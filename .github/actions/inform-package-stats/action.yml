name: Inform package stats
description: "Post comment to a pull request page about package stats"
inputs:
  pr-number:
    required: false
    description: "The PR number to inform. If not provided, the action will infer the PR number from the event type."
  stats-file-prefix:
    default: "package-stats."
    description: stats file name prefix
  size-diff-warning-threshold-kib:
    default: "128"
    description: file size warning threshold in KiB

runs:
  using: "composite"
  steps:
    - name: Set up the working directory
      shell: bash
      run: |
        working_dir=${{ runner.temp }}/stats-artifacts/
        mkdir -p $working_dir
        echo "PACKAGE_STATS_WORKING_DIR=$working_dir" >> "$GITHUB_ENV"

    - name: Get the base run_id for diff
      run: |
        diff_base_branch='${{ github.event.repository.default_branch }}'
        current_workflow='${{ github.event_name == 'workflow_run' && github.event.workflow_run.name || github.workflow }}'
        run_info=$(gh run list --branch "$diff_base_branch" --workflow "$current_workflow" --status success --limit 1 --json=databaseId,headSha --jq ".[0]")
        run_id=$(echo $run_info | jq -r ".databaseId")
        commit_sha=$(echo $run_info | jq -r ".headSha")
        echo "PACKAGE_STATS_DIFF_BASE_RUN_ID=$run_id" >> $GITHUB_ENV
        echo "PACKAGE_STATS_DIFF_BASE_COMMIT_SHA=$commit_sha" >> $GITHUB_ENV
        echo "PACKAGE_STATS_DIFF_BASE_BRANCH=$diff_base_branch" >> $GITHUB_ENV
      env:
        GH_TOKEN: ${{ github.token }}
      shell: bash

    - run: |
        cd "$PACKAGE_STATS_WORKING_DIR"
        npm install jszip
      shell: bash
    - name: Gather JSON files for this commit and generate a comment body
      uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b # v7.1.0
      env:
        RUN_ID: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.id || github.run_id }}
      with:
        result-encoding: string
        script: |
          process.chdir(process.env.PACKAGE_STATS_WORKING_DIR);

          const fs = require("fs");
          const jszip = require('jszip');
          const { spawn } = require('child_process');

          function escapeRegex(string) {
            // https://stackoverflow.com/a/3561711/13103190
            return string.replace(/[/\-\\^$*+?.()|[\]{}]/g, '\\$&');
          }

          async function loadStatArtifactContents(runId) {
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: runId,
            });

            const filteredArtifacts = artifacts.data.artifacts
              .map(artifact => {
                const match = artifact.name.match(new RegExp(`^(?<prefix>${escapeRegex("${{ inputs.stats-file-prefix }}")})(?<key>.+)\.json`));
                if (match == null) {
                  return null;
                }
                return { key: match.groups["key"], artifact };
              })
              .filter(a => a != null);

            const artifactContents = await Promise.all(
              filteredArtifacts.map(async ({ key, artifact }) => {
                const downloadResponse = await github.rest.actions.downloadArtifact({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  artifact_id: artifact.id,
                  archive_format: 'zip',
                });

                const artifactZip = await downloadResponse.data;
                const zip = await jszip.loadAsync(artifactZip);
                const artifactFile = Object.values(zip.files)[0];
                const artifactContent = await artifactFile.async('string');

                return { key, content: JSON.parse(artifactContent) };
              })
            );

            return artifactContents;
          }

          const artifactContents = await loadStatArtifactContents(process.env.RUN_ID)
          core.startGroup('Artifact contents preview')
          console.log(JSON.stringify(artifactContents, null, 2));
          core.endGroup()

          const baseArtifactContents = await loadStatArtifactContents(process.env.PACKAGE_STATS_DIFF_BASE_RUN_ID)
          core.startGroup('Base artifact contents preview')
          console.log(JSON.stringify(baseArtifactContents, null, 2));
          core.endGroup()

          const sortedContents = artifactContents.sort((a, b) => a.content.name.localeCompare(b.content.name));

          function compareStrings(str1, str2) {
            fs.writeFileSync('temp1.txt', str1);
            fs.writeFileSync('temp2.txt', str2);

            const diff = spawn(
              'diff',
              [
                // Ref: https://stackoverflow.com/a/354590/13103190
                '--new-line-format', '+%L',
                '--old-line-format', '-%L',
                '--unchanged-line-format', ' %L',
                'temp1.txt',
                'temp2.txt'
              ]
            );

            let output = '';
            diff.stdout.on('data', (data) => {
              output += data.toString();
            });

            return new Promise((resolve, reject) => {
              diff.on('close', (code) => {
                fs.unlinkSync('temp1.txt');
                fs.unlinkSync('temp2.txt');

                resolve({ isDiff: code === 0, diff: output });
              });
            });
          }

          let comment = "";
          comment +=
            `Diffs are from [\`${process.env.PACKAGE_STATS_DIFF_BASE_COMMIT_SHA.slice(0, 7)}\`](https://github.com/${{ github.repository }}/commit/${process.env.PACKAGE_STATS_DIFF_BASE_COMMIT_SHA}) ` +
            `on [\`${process.env.PACKAGE_STATS_DIFF_BASE_BRANCH}\`](https://github.com/whitphx/stlite/tree/${process.env.PACKAGE_STATS_DIFF_BASE_BRANCH})  ` +
            `(workflow run: [\`${process.env.PACKAGE_STATS_DIFF_BASE_RUN_ID}\`](https://github.com/${{ github.repository }}/actions/runs/${process.env.PACKAGE_STATS_DIFF_BASE_RUN_ID}))\n\n`;

          for (const artifactContent of sortedContents) {
            const { key, content } = artifactContent;

            const baseContent = baseArtifactContents.find(b => b.key === key)?.content;

            const sizeKiB = content.package.sizeKib;
            const baseSizeKiB = baseContent?.package?.sizeKib;
            const sizeDiffKiB = sizeKiB - baseSizeKiB;
            const shouldWarn = Math.abs(sizeDiffKiB) >= ${{ inputs.size-diff-warning-threshold-kib }};
            const sizeDiffFormatter = new Intl.NumberFormat("en-US", { signDisplay: "always" });
            const sizeDiffStr = baseSizeKiB ? `(${baseSizeKiB} kiB ${shouldWarn ? '⚠️ ' : ''}**${sizeDiffFormatter.format(sizeDiffKiB)} kiB**)` : "";

            const fileSizesCmp = await compareStrings(baseContent?.filelist?.sizes ?? "", content.filelist.sizes)

            comment += `### ${content.name}
          \`${content.package.filename}\`: ${sizeKiB} kiB ${sizeDiffStr}

          <details>
          <summary>File Tree</summary>

          \`\`\`\n${content.filelist.tree}\n\`\`\`

          </details>

          <details>
          <summary>File Sizes</summary>

          \`\`\`diff\n${fileSizesCmp.diff}\n\`\`\`

          </details>

          `;
          }
          core.startGroup('Comment preview')
          core.info(comment);
          core.endGroup()

          fs.writeFileSync('comment.txt', comment);

    - name: Get target PR numbers
      id: get-pr-numbers
      uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b # v7.1.0
      env:
        PR_NUMBER: ${{ inputs.pr-number }}
        # When the event is `pull_request`, `github.sha` points to a temporary merge commit, so we use `github.event.pull_request.head.sha` instead. Ref: https://github.com/orgs/community/discussions/47804#discussioncomment-5026092
        COMMIT_SHA: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_sha || github.event_name == 'pull_request' && github.event.pull_request.head.sha || github.sha }}
      with:
        result-encoding: string
        script: |
          // Returns a JSON array of PR numbers
          if (process.env.PR_NUMBER) {
            return JSON.stringify([parseInt(process.env.PR_NUMBER)]);
          }
          if (context.eventName === "pull_request") {
            return JSON.stringify([context.payload.pull_request.number]);
          }
          if (context.eventName === "push" || context.eventName === "workflow_run") {
            const pullRequests = (
              await github.rest.repos.listPullRequestsAssociatedWithCommit({
                owner: context.repo.owner,
                repo: context.repo.repo,
                commit_sha: process.env.COMMIT_SHA,
              })
            ).data;
            const openPullRequests = pullRequests.filter(pr => pr.state === "open");
            if (openPullRequests.length > 0) {
              return JSON.stringify(openPullRequests.map(pr => pr.number));
            }
          }
          return "[]";

    - name: Read comment content
      id: read-comment
      shell: bash
      run: |
        cd "$PACKAGE_STATS_WORKING_DIR"
        {
          echo 'CONTENT<<EOF'
          cat comment.txt
          echo 'EOF'
        } >> "$GITHUB_OUTPUT"

    - name: Add package stats section to sticky comment for all PRs
      if: steps.get-pr-numbers.outputs.result != '[]'
      uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b # v7.1.0
      env:
        PR_NUMBERS: ${{ steps.get-pr-numbers.outputs.result }}
        SECTION_CONTENT: ${{ steps.read-comment.outputs.CONTENT }}
      with:
        script: |
          const prNumbers = JSON.parse(process.env.PR_NUMBERS);
          const sectionContent = process.env.SECTION_CONTENT;
          const sectionId = "package-stats";
          // Validate sectionId to match the same constraints used by the parser and sticky-comment actions
          if (!/^[A-Za-z0-9_-]+$/.test(sectionId)) {
            throw new Error(`Invalid sectionId "${sectionId}". It must match /^[A-Za-z0-9_-]+$/ to be compatible with sticky comment parsing.`);
          }
          const sectionTitle = "## Package Stats";
          const sectionOrder = 10;

          if (prNumbers.length === 0) {
            core.info("No PRs to update.");
            return;
          }

          const COMMENT_HEADER = "<!-- Unified CI Report -->";
          const SECTION_START_MARKER = (id) => `<!-- section:${id}:start -->`;
          const SECTION_END_MARKER = (id) => `<!-- section:${id}:end -->`;
          const SECTION_ORDER_MARKER = (id, order) => `<!-- section:${id}:order:${order} -->`;

          function parseSections(body) {
            const sections = [];
            const sectionRegex = /<!-- section:([A-Za-z0-9_-]+):start -->\s*<!-- section:\1:order:(\d+) -->\s*([\s\S]*?)<!-- section:\1:end -->/g;
            let match;
            while ((match = sectionRegex.exec(body)) !== null) {
              sections.push({
                id: match[1],
                order: parseInt(match[2]),
                content: match[3].trim(),
              });
            }
            return sections;
          }

          function buildCommentBody(sections) {
            const title = "# CI Report\n\n";
            const sectionsContent = sections
              .map((section) => {
                return `${SECTION_START_MARKER(section.id)}\n${SECTION_ORDER_MARKER(section.id, section.order)}\n${section.content}\n${SECTION_END_MARKER(section.id)}`;
              })
              .join("\n\n---\n\n");
            return `${COMMENT_HEADER}\n${title}${sectionsContent}`;
          }

          for (const prNumber of prNumbers) {
            core.info(`Updating PR #${prNumber}...`);

            // Retry logic to handle race conditions when multiple jobs update concurrently.
            // This handles:
            // - 409 Conflict: Comment was modified between read and update
            // - 422 Unprocessable Entity: Validation failed due to stale data
            // - 403 Forbidden: Rate limiting (secondary rate limit)
            // Note: If two jobs simultaneously find no existing comment and both create one,
            // both creates will succeed (no error), potentially resulting in duplicate comments.
            // This is a rare edge case that would require manual cleanup.
            const MAX_RETRIES = 3;
            const RETRY_DELAY_MS = 1000;

            for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
              try {
                // Fetch comment inside the loop so retries get fresh data
                const comments = await github.paginate(
                  github.rest.issues.listComments,
                  {
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber,
                  }
                );

                const existingComment = comments.find(
                  (comment) =>
                    comment.body?.startsWith(COMMENT_HEADER) &&
                    comment.user?.login === "github-actions[bot]"
                );

                // Get existing sections
                let sections = existingComment ? parseSections(existingComment.body) : [];

                // Create new section content
                const newSectionContent = `${sectionTitle}\n\n${sectionContent}`;

                // Update or add section
                const existingIndex = sections.findIndex((s) => s.id === sectionId);
                if (existingIndex >= 0) {
                  sections[existingIndex] = {
                    id: sectionId,
                    order: sectionOrder,
                    content: newSectionContent,
                  };
                } else {
                  sections.push({
                    id: sectionId,
                    order: sectionOrder,
                    content: newSectionContent,
                  });
                }

                // Sort sections by order
                sections.sort((a, b) => a.order - b.order);

                const commentBody = buildCommentBody(sections);

                // Create or update comment
                if (existingComment) {
                  await github.rest.issues.updateComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    comment_id: existingComment.id,
                    body: commentBody,
                  });
                  core.info(`Updated unified comment on PR #${prNumber}`);
                } else {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber,
                    body: commentBody,
                  });
                  core.info(`Created unified comment on PR #${prNumber}`);
                }

                // Success - exit retry loop
                break;
              } catch (error) {
                // Check if it's a retryable error
                const isRetryable = error.status === 409 || error.status === 422 || error.status === 403;

                if (isRetryable && attempt < MAX_RETRIES) {
                  core.warning(`Attempt ${attempt} for PR #${prNumber} failed with status ${error.status}, retrying...`);
                  await new Promise(resolve => setTimeout(resolve, RETRY_DELAY_MS));
                  continue;
                }

                throw error;
              }
            }
          }

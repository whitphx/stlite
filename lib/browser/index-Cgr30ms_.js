import { r as Dt, bN as Br, c1 as vt, a3 as dh, c2 as CN, aB as Uu, _ as q4, c3 as SN, j as Jl, s as X4, h as Z4, c4 as IN, c5 as PN, J as Y4, c6 as mb, c7 as lE, aV as MN, L as RN, u as BN, bo as ON, c8 as cE } from "./index-COqA-032.js";
import { _ as gs, C as DN } from "./slicedToArray-CHnELQWR.js";
import { d as Ju, c as ef, b as X2, _ as gp, a as Z2 } from "./inherits-DZBdSoid.js";
import { E as K4, w as LN } from "./withFullScreenWrapper-Bd7ZpoRc.js";
import { T as kN, a as FN } from "./Toolbar-DRAqg1o6.js";
import { a as NN } from "./useBasicWidgetState-Hu_BQk7V.js";
function UN(r, e) {
  for (var t = 0; t < e.length; t++) {
    const n = e[t];
    if (typeof n != "string" && !Array.isArray(n)) {
      for (const i in n)
        if (i !== "default" && !(i in r)) {
          const s = Object.getOwnPropertyDescriptor(n, i);
          s && Object.defineProperty(r, i, s.get ? s : {
            enumerable: !0,
            get: () => n[i]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(r, Symbol.toStringTag, { value: "Module" }));
}
async function g0(r, e, t, n) {
  return n._parse(r, e, t, n);
}
function _i(r, e) {
  if (!r)
    throw new Error(e || "loader assertion failed.");
}
const M_ = (
  // @ts-ignore process does not exist on browser
  !!(typeof process != "object" || String(process) !== "[object process]" || process.browser)
), uE = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version);
uE && parseFloat(uE[1]);
const fE = globalThis, hE = globalThis.process || {}, zN = globalThis.navigator || {};
function Q4(r) {
  if (typeof window < "u" && window.process?.type === "renderer" || typeof process < "u" && process.versions?.electron)
    return !0;
  const t = typeof navigator < "u" && navigator.userAgent;
  return !!(t && t.indexOf("Electron") >= 0);
}
function ph() {
  return !// @ts-expect-error
  (typeof process == "object" && String(process) === "[object process]" && !process?.browser) || Q4();
}
function VN(r) {
  return ph() ? Q4() ? "Electron" : (zN.userAgent || "").indexOf("Edge") > -1 ? "Edge" : globalThis.chrome ? "Chrome" : globalThis.safari ? "Safari" : globalThis.mozInnerScreenX ? "Firefox" : "Unknown" : "Node";
}
const J4 = "4.1.0";
function jN(r) {
  try {
    const e = window[r], t = "__storage_test__";
    return e.setItem(t, t), e.removeItem(t), e;
  } catch {
    return null;
  }
}
class HN {
  constructor(e, t, n = "sessionStorage") {
    this.storage = jN(n), this.id = e, this.config = t, this._loadConfiguration();
  }
  getConfiguration() {
    return this.config;
  }
  setConfiguration(e) {
    if (Object.assign(this.config, e), this.storage) {
      const t = JSON.stringify(this.config);
      this.storage.setItem(this.id, t);
    }
  }
  // Get config from persistent store, if available
  _loadConfiguration() {
    let e = {};
    if (this.storage) {
      const t = this.storage.getItem(this.id);
      e = t ? JSON.parse(t) : {};
    }
    return Object.assign(this.config, e), this;
  }
}
function GN(r) {
  let e;
  return r < 10 ? e = `${r.toFixed(2)}ms` : r < 100 ? e = `${r.toFixed(1)}ms` : r < 1e3 ? e = `${r.toFixed(0)}ms` : e = `${(r / 1e3).toFixed(2)}s`, e;
}
function WN(r, e = 8) {
  const t = Math.max(e - r.length, 0);
  return `${" ".repeat(t)}${r}`;
}
var Vm;
(function(r) {
  r[r.BLACK = 30] = "BLACK", r[r.RED = 31] = "RED", r[r.GREEN = 32] = "GREEN", r[r.YELLOW = 33] = "YELLOW", r[r.BLUE = 34] = "BLUE", r[r.MAGENTA = 35] = "MAGENTA", r[r.CYAN = 36] = "CYAN", r[r.WHITE = 37] = "WHITE", r[r.BRIGHT_BLACK = 90] = "BRIGHT_BLACK", r[r.BRIGHT_RED = 91] = "BRIGHT_RED", r[r.BRIGHT_GREEN = 92] = "BRIGHT_GREEN", r[r.BRIGHT_YELLOW = 93] = "BRIGHT_YELLOW", r[r.BRIGHT_BLUE = 94] = "BRIGHT_BLUE", r[r.BRIGHT_MAGENTA = 95] = "BRIGHT_MAGENTA", r[r.BRIGHT_CYAN = 96] = "BRIGHT_CYAN", r[r.BRIGHT_WHITE = 97] = "BRIGHT_WHITE";
})(Vm || (Vm = {}));
const $N = 10;
function dE(r) {
  return typeof r != "string" ? r : (r = r.toUpperCase(), Vm[r] || Vm.WHITE);
}
function qN(r, e, t) {
  return !ph && typeof r == "string" && (e && (r = `\x1B[${dE(e)}m${r}\x1B[39m`), t && (r = `\x1B[${dE(t) + $N}m${r}\x1B[49m`)), r;
}
function XN(r, e = ["constructor"]) {
  const t = Object.getPrototypeOf(r), n = Object.getOwnPropertyNames(t), i = r;
  for (const s of n) {
    const o = i[s];
    typeof o == "function" && (e.find((l) => s === l) || (i[s] = o.bind(r)));
  }
}
function Y2(r, e) {
  if (!r)
    throw new Error("Assertion failed");
}
function gd() {
  let r;
  if (ph() && fE.performance)
    r = fE?.performance?.now?.();
  else if ("hrtime" in hE) {
    const e = hE?.hrtime?.();
    r = e[0] * 1e3 + e[1] / 1e6;
  } else
    r = Date.now();
  return r;
}
const md = {
  debug: ph() && console.debug || console.log,
  log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error
}, ZN = {
  enabled: !0,
  level: 0
};
function _d() {
}
const pE = {}, AE = { once: !0 };
class Rp {
  constructor({ id: e } = { id: "" }) {
    this.VERSION = J4, this._startTs = gd(), this._deltaTs = gd(), this.userData = {}, this.LOG_THROTTLE_TIMEOUT = 0, this.id = e, this.userData = {}, this._storage = new HN(`__probe-${this.id}__`, ZN), this.timeStamp(`${this.id} started`), XN(this), Object.seal(this);
  }
  set level(e) {
    this.setLevel(e);
  }
  get level() {
    return this.getLevel();
  }
  isEnabled() {
    return this._storage.config.enabled;
  }
  getLevel() {
    return this._storage.config.level;
  }
  /** @return milliseconds, with fractions */
  getTotal() {
    return Number((gd() - this._startTs).toPrecision(10));
  }
  /** @return milliseconds, with fractions */
  getDelta() {
    return Number((gd() - this._deltaTs).toPrecision(10));
  }
  /** @deprecated use logLevel */
  set priority(e) {
    this.level = e;
  }
  /** @deprecated use logLevel */
  get priority() {
    return this.level;
  }
  /** @deprecated use logLevel */
  getPriority() {
    return this.level;
  }
  // Configure
  enable(e = !0) {
    return this._storage.setConfiguration({ enabled: e }), this;
  }
  setLevel(e) {
    return this._storage.setConfiguration({ level: e }), this;
  }
  /** return the current status of the setting */
  get(e) {
    return this._storage.config[e];
  }
  // update the status of the setting
  set(e, t) {
    this._storage.setConfiguration({ [e]: t });
  }
  /** Logs the current settings as a table */
  settings() {
    console.table ? console.table(this._storage.config) : console.log(this._storage.config);
  }
  // Unconditional logging
  assert(e, t) {
    if (!e)
      throw new Error(t || "Assertion failed");
  }
  warn(e) {
    return this._getLogFunction(0, e, md.warn, arguments, AE);
  }
  error(e) {
    return this._getLogFunction(0, e, md.error, arguments);
  }
  /** Print a deprecation warning */
  deprecated(e, t) {
    return this.warn(`\`${e}\` is deprecated and will be removed in a later version. Use \`${t}\` instead`);
  }
  /** Print a removal warning */
  removed(e, t) {
    return this.error(`\`${e}\` has been removed. Use \`${t}\` instead`);
  }
  probe(e, t) {
    return this._getLogFunction(e, t, md.log, arguments, {
      time: !0,
      once: !0
    });
  }
  log(e, t) {
    return this._getLogFunction(e, t, md.debug, arguments);
  }
  info(e, t) {
    return this._getLogFunction(e, t, console.info, arguments);
  }
  once(e, t) {
    return this._getLogFunction(e, t, md.debug || md.info, arguments, AE);
  }
  /** Logs an object as a table */
  table(e, t, n) {
    return t ? this._getLogFunction(e, t, console.table || _d, n && [n], {
      tag: KN(t)
    }) : _d;
  }
  time(e, t) {
    return this._getLogFunction(e, t, console.time ? console.time : console.info);
  }
  timeEnd(e, t) {
    return this._getLogFunction(e, t, console.timeEnd ? console.timeEnd : console.info);
  }
  timeStamp(e, t) {
    return this._getLogFunction(e, t, console.timeStamp || _d);
  }
  group(e, t, n = { collapsed: !1 }) {
    const i = gE({ logLevel: e, message: t, opts: n }), { collapsed: s } = n;
    return i.method = (s ? console.groupCollapsed : console.group) || console.info, this._getLogFunction(i);
  }
  groupCollapsed(e, t, n = {}) {
    return this.group(e, t, Object.assign({}, n, { collapsed: !0 }));
  }
  groupEnd(e) {
    return this._getLogFunction(e, "", console.groupEnd || _d);
  }
  // EXPERIMENTAL
  withGroup(e, t, n) {
    this.group(e, t)();
    try {
      n();
    } finally {
      this.groupEnd(e)();
    }
  }
  trace() {
    console.trace && console.trace();
  }
  // PRIVATE METHODS
  /** Deduces log level from a variety of arguments */
  _shouldLog(e) {
    return this.isEnabled() && this.getLevel() >= eB(e);
  }
  _getLogFunction(e, t, n, i, s) {
    if (this._shouldLog(e)) {
      s = gE({ logLevel: e, message: t, args: i, opts: s }), n = n || s.method, Y2(n), s.total = this.getTotal(), s.delta = this.getDelta(), this._deltaTs = gd();
      const o = s.tag || s.message;
      if (s.once && o)
        if (!pE[o])
          pE[o] = gd();
        else
          return _d;
      return t = YN(this.id, s.message, s), n.bind(console, t, ...s.args);
    }
    return _d;
  }
}
Rp.VERSION = J4;
function eB(r) {
  if (!r)
    return 0;
  let e;
  switch (typeof r) {
    case "number":
      e = r;
      break;
    case "object":
      e = r.logLevel || r.priority || 0;
      break;
    default:
      return 0;
  }
  return Y2(Number.isFinite(e) && e >= 0), e;
}
function gE(r) {
  const { logLevel: e, message: t } = r;
  r.logLevel = eB(e);
  const n = r.args ? Array.from(r.args) : [];
  for (; n.length && n.shift() !== t; )
    ;
  switch (typeof e) {
    case "string":
    case "function":
      t !== void 0 && n.unshift(t), r.message = e;
      break;
    case "object":
      Object.assign(r, e);
      break;
  }
  typeof r.message == "function" && (r.message = r.message());
  const i = typeof r.message;
  return Y2(i === "string" || i === "object"), Object.assign(r, { args: n }, r.opts);
}
function YN(r, e, t) {
  if (typeof e == "string") {
    const n = t.time ? WN(GN(t.total)) : "";
    e = t.time ? `${r}: ${n}  ${e}` : `${r}: ${e}`, e = qN(e, t.color, t.background);
  }
  return e;
}
function KN(r) {
  for (const e in r)
    for (const t in r[e])
      return t || "untitled";
  return "empty";
}
globalThis.probe = {};
const tB = new Rp({ id: "@probe.gl/log" }), cv = "4.3.3", QN = cv[0] >= "0" && cv[0] <= "9" ? `v${cv}` : "";
function JN() {
  const r = new Rp({ id: "loaders.gl" });
  return globalThis.loaders = globalThis.loaders || {}, globalThis.loaders.log = r, globalThis.loaders.version = QN, globalThis.probe = globalThis.probe || {}, globalThis.probe.loaders = r, r;
}
const e5 = JN();
function rB(r, e) {
  return nB(r || {}, e);
}
function nB(r, e, t = 0) {
  if (t > 3)
    return e;
  const n = { ...r };
  for (const [i, s] of Object.entries(e))
    s && typeof s == "object" && !Array.isArray(s) ? n[i] = nB(n[i] || {}, e[i], t + 1) : n[i] = e[i];
  return n;
}
function t5(r) {
  globalThis.loaders ||= {}, globalThis.loaders.modules ||= {}, Object.assign(globalThis.loaders.modules, r);
}
function r5(r) {
  return globalThis.loaders?.modules?.[r] || null;
}
const n5 = "latest";
function i5() {
  return globalThis._loadersgl_?.version || (globalThis._loadersgl_ = globalThis._loadersgl_ || {}, globalThis._loadersgl_.version = "4.3.3"), globalThis._loadersgl_.version;
}
const iB = i5();
function Yc(r, e) {
  if (!r)
    throw new Error(e || "loaders.gl assertion failed.");
}
const ka = (
  // @ts-ignore process.browser
  typeof process != "object" || String(process) !== "[object process]" || process.browser
), K2 = typeof importScripts == "function", s5 = typeof window < "u" && typeof window.orientation < "u", mE = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version);
mE && parseFloat(mE[1]);
class o5 {
  name;
  workerThread;
  isRunning = !0;
  /** Promise that resolves when Job is done */
  result;
  _resolve = () => {
  };
  _reject = () => {
  };
  constructor(e, t) {
    this.name = e, this.workerThread = t, this.result = new Promise((n, i) => {
      this._resolve = n, this._reject = i;
    });
  }
  /**
   * Send a message to the job's worker thread
   * @param data any data structure, ideally consisting mostly of transferrable objects
   */
  postMessage(e, t) {
    this.workerThread.postMessage({
      source: "loaders.gl",
      // Lets worker ignore unrelated messages
      type: e,
      payload: t
    });
  }
  /**
   * Call to resolve the `result` Promise with the supplied value
   */
  done(e) {
    Yc(this.isRunning), this.isRunning = !1, this._resolve(e);
  }
  /**
   * Call to reject the `result` Promise with the supplied error
   */
  error(e) {
    Yc(this.isRunning), this.isRunning = !1, this._reject(e);
  }
}
class uv {
  terminate() {
  }
}
const fv = /* @__PURE__ */ new Map();
function a5(r) {
  Yc(r.source && !r.url || !r.source && r.url);
  let e = fv.get(r.source || r.url);
  return e || (r.url && (e = l5(r.url), fv.set(r.url, e)), r.source && (e = sB(r.source), fv.set(r.source, e))), Yc(e), e;
}
function l5(r) {
  if (!r.startsWith("http"))
    return r;
  const e = c5(r);
  return sB(e);
}
function sB(r) {
  const e = new Blob([r], { type: "application/javascript" });
  return URL.createObjectURL(e);
}
function c5(r) {
  return `try {
  importScripts('${r}');
} catch (error) {
  console.error(error);
  throw error;
}`;
}
function oB(r, e = !0, t) {
  const n = t || /* @__PURE__ */ new Set();
  if (r) {
    if (_E(r))
      n.add(r);
    else if (_E(r.buffer))
      n.add(r.buffer);
    else if (!ArrayBuffer.isView(r)) {
      if (e && typeof r == "object")
        for (const i in r)
          oB(r[i], e, n);
    }
  }
  return t === void 0 ? Array.from(n) : [];
}
function _E(r) {
  return r ? r instanceof ArrayBuffer || typeof MessagePort < "u" && r instanceof MessagePort || typeof ImageBitmap < "u" && r instanceof ImageBitmap || typeof OffscreenCanvas < "u" && r instanceof OffscreenCanvas : !1;
}
const hv = () => {
};
class _b {
  name;
  source;
  url;
  terminated = !1;
  worker;
  onMessage;
  onError;
  _loadableURL = "";
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return typeof Worker < "u" && ka || typeof uv < "u" && !ka;
  }
  constructor(e) {
    const { name: t, source: n, url: i } = e;
    Yc(n || i), this.name = t, this.source = n, this.url = i, this.onMessage = hv, this.onError = (s) => console.log(s), this.worker = ka ? this._createBrowserWorker() : this._createNodeWorker();
  }
  /**
   * Terminate this worker thread
   * @note Can free up significant memory
   */
  destroy() {
    this.onMessage = hv, this.onError = hv, this.worker.terminate(), this.terminated = !0;
  }
  get isRunning() {
    return !!this.onMessage;
  }
  /**
   * Send a message to this worker thread
   * @param data any data structure, ideally consisting mostly of transferrable objects
   * @param transferList If not supplied, calculated automatically by traversing data
   */
  postMessage(e, t) {
    t = t || oB(e), this.worker.postMessage(e, t);
  }
  // PRIVATE
  /**
   * Generate a standard Error from an ErrorEvent
   * @param event
   */
  _getErrorFromErrorEvent(e) {
    let t = "Failed to load ";
    return t += `worker ${this.name} from ${this.url}. `, e.message && (t += `${e.message} in `), e.lineno && (t += `:${e.lineno}:${e.colno}`), new Error(t);
  }
  /**
   * Creates a worker thread on the browser
   */
  _createBrowserWorker() {
    this._loadableURL = a5({ source: this.source, url: this.url });
    const e = new Worker(this._loadableURL, { name: this.name });
    return e.onmessage = (t) => {
      t.data ? this.onMessage(t.data) : this.onError(new Error("No data received"));
    }, e.onerror = (t) => {
      this.onError(this._getErrorFromErrorEvent(t)), this.terminated = !0;
    }, e.onmessageerror = (t) => console.error(t), e;
  }
  /**
   * Creates a worker thread in node.js
   * @todo https://nodejs.org/api/async_hooks.html#async-resource-worker-pool
   */
  _createNodeWorker() {
    let e;
    if (this.url) {
      const n = this.url.includes(":/") || this.url.startsWith("/") ? this.url : `./${this.url}`;
      e = new uv(n, { eval: !1 });
    } else if (this.source)
      e = new uv(this.source, { eval: !0 });
    else
      throw new Error("no worker");
    return e.on("message", (t) => {
      this.onMessage(t);
    }), e.on("error", (t) => {
      this.onError(t);
    }), e.on("exit", (t) => {
    }), e;
  }
}
class u5 {
  name = "unnamed";
  source;
  // | Function;
  url;
  maxConcurrency = 1;
  maxMobileConcurrency = 1;
  onDebug = () => {
  };
  reuseWorkers = !0;
  props = {};
  jobQueue = [];
  idleQueue = [];
  count = 0;
  isDestroyed = !1;
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return _b.isSupported();
  }
  /**
   * @param processor - worker function
   * @param maxConcurrency - max count of workers
   */
  constructor(e) {
    this.source = e.source, this.url = e.url, this.setProps(e);
  }
  /**
   * Terminates all workers in the pool
   * @note Can free up significant memory
   */
  destroy() {
    this.idleQueue.forEach((e) => e.destroy()), this.isDestroyed = !0;
  }
  setProps(e) {
    this.props = { ...this.props, ...e }, e.name !== void 0 && (this.name = e.name), e.maxConcurrency !== void 0 && (this.maxConcurrency = e.maxConcurrency), e.maxMobileConcurrency !== void 0 && (this.maxMobileConcurrency = e.maxMobileConcurrency), e.reuseWorkers !== void 0 && (this.reuseWorkers = e.reuseWorkers), e.onDebug !== void 0 && (this.onDebug = e.onDebug);
  }
  async startJob(e, t = (i, s, o) => i.done(o), n = (i, s) => i.error(s)) {
    const i = new Promise((s) => (this.jobQueue.push({ name: e, onMessage: t, onError: n, onStart: s }), this));
    return this._startQueuedJob(), await i;
  }
  // PRIVATE
  /**
   * Starts first queued job if worker is available or can be created
   * Called when job is started and whenever a worker returns to the idleQueue
   */
  async _startQueuedJob() {
    if (!this.jobQueue.length)
      return;
    const e = this._getAvailableWorker();
    if (!e)
      return;
    const t = this.jobQueue.shift();
    if (t) {
      this.onDebug({
        message: "Starting job",
        name: t.name,
        workerThread: e,
        backlog: this.jobQueue.length
      });
      const n = new o5(t.name, e);
      e.onMessage = (i) => t.onMessage(n, i.type, i.payload), e.onError = (i) => t.onError(n, i), t.onStart(n);
      try {
        await n.result;
      } catch (i) {
        console.error(`Worker exception: ${i}`);
      } finally {
        this.returnWorkerToQueue(e);
      }
    }
  }
  /**
   * Returns a worker to the idle queue
   * Destroys the worker if
   *  - pool is destroyed
   *  - if this pool doesn't reuse workers
   *  - if maxConcurrency has been lowered
   * @param worker
   */
  returnWorkerToQueue(e) {
    // Workers on Node.js prevent the process from exiting.
    // Until we figure out how to close them before exit, we always destroy them
    !ka || // If the pool is destroyed, there is no reason to keep the worker around
    this.isDestroyed || // If the app has disabled worker reuse, any completed workers should be destroyed
    !this.reuseWorkers || // If concurrency has been lowered, this worker might be surplus to requirements
    this.count > this._getMaxConcurrency() ? (e.destroy(), this.count--) : this.idleQueue.push(e), this.isDestroyed || this._startQueuedJob();
  }
  /**
   * Returns idle worker or creates new worker if maxConcurrency has not been reached
   */
  _getAvailableWorker() {
    if (this.idleQueue.length > 0)
      return this.idleQueue.shift() || null;
    if (this.count < this._getMaxConcurrency()) {
      this.count++;
      const e = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;
      return new _b({ name: e, source: this.source, url: this.url });
    }
    return null;
  }
  _getMaxConcurrency() {
    return s5 ? this.maxMobileConcurrency : this.maxConcurrency;
  }
}
const f5 = {
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: !0,
  onDebug: () => {
  }
};
class Vu {
  props;
  workerPools = /* @__PURE__ */ new Map();
  // singleton
  static _workerFarm;
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return _b.isSupported();
  }
  /** Get the singleton instance of the global worker farm */
  static getWorkerFarm(e = {}) {
    return Vu._workerFarm = Vu._workerFarm || new Vu({}), Vu._workerFarm.setProps(e), Vu._workerFarm;
  }
  /** get global instance with WorkerFarm.getWorkerFarm() */
  constructor(e) {
    this.props = { ...f5 }, this.setProps(e), this.workerPools = /* @__PURE__ */ new Map();
  }
  /**
   * Terminate all workers in the farm
   * @note Can free up significant memory
   */
  destroy() {
    for (const e of this.workerPools.values())
      e.destroy();
    this.workerPools = /* @__PURE__ */ new Map();
  }
  /**
   * Set props used when initializing worker pools
   * @param props
   */
  setProps(e) {
    this.props = { ...this.props, ...e };
    for (const t of this.workerPools.values())
      t.setProps(this._getWorkerPoolProps());
  }
  /**
   * Returns a worker pool for the specified worker
   * @param options - only used first time for a specific worker name
   * @param options.name - the name of the worker - used to identify worker pool
   * @param options.url -
   * @param options.source -
   * @example
   *   const job = WorkerFarm.getWorkerFarm().getWorkerPool({name, url}).startJob(...);
   */
  getWorkerPool(e) {
    const { name: t, source: n, url: i } = e;
    let s = this.workerPools.get(t);
    return s || (s = new u5({
      name: t,
      source: n,
      url: i
    }), s.setProps(this._getWorkerPoolProps()), this.workerPools.set(t, s)), s;
  }
  _getWorkerPoolProps() {
    return {
      maxConcurrency: this.props.maxConcurrency,
      maxMobileConcurrency: this.props.maxMobileConcurrency,
      reuseWorkers: this.props.reuseWorkers,
      onDebug: this.props.onDebug
    };
  }
}
function h5(r, e = {}) {
  const t = e[r.id] || {}, n = ka ? `${r.id}-worker.js` : `${r.id}-worker-node.js`;
  let i = t.workerUrl;
  if (!i && r.id === "compression" && (i = e.workerUrl), e._workerType === "test" && (ka ? i = `modules/${r.module}/dist/${n}` : i = `modules/${r.module}/src/workers/${r.id}-worker-node.ts`), !i) {
    let s = r.version;
    s === "latest" && (s = n5);
    const o = s ? `@${s}` : "";
    i = `https://unpkg.com/@loaders.gl/${r.module}${o}/dist/${n}`;
  }
  return Yc(i), i;
}
function d5(r, e = iB) {
  Yc(r, "no worker provided");
  const t = r.version;
  return !(!e || !t);
}
const dv = {};
async function Xf(r, e = null, t = {}, n = null) {
  return e && (r = p5(r, e, t, n)), dv[r] = // eslint-disable-next-line @typescript-eslint/no-misused-promises
  dv[r] || A5(r), await dv[r];
}
function p5(r, e, t = {}, n = null) {
  if (!t.useLocalLibraries && r.startsWith("http"))
    return r;
  n = n || r;
  const i = t.modules || {};
  return i[n] ? i[n] : ka ? t.CDN ? (Yc(t.CDN.startsWith("http")), `${t.CDN}/${e}@${iB}/dist/libs/${n}`) : K2 ? `../src/libs/${n}` : `modules/${e}/src/libs/${n}` : `modules/${e}/dist/libs/${n}`;
}
async function A5(r) {
  if (r.endsWith("wasm"))
    return await m5(r);
  if (!ka)
    try {
      const { requireFromFile: t } = globalThis.loaders || {};
      return await t?.(r);
    } catch (t) {
      return console.error(t), null;
    }
  if (K2)
    return importScripts(r);
  const e = await _5(r);
  return g5(e, r);
}
function g5(r, e) {
  if (!ka) {
    const { requireFromString: n } = globalThis.loaders || {};
    return n?.(r, e);
  }
  if (K2)
    return eval.call(globalThis, r), null;
  const t = document.createElement("script");
  t.id = e;
  try {
    t.appendChild(document.createTextNode(r));
  } catch {
    t.text = r;
  }
  return document.body.appendChild(t), null;
}
async function m5(r) {
  const { readFileAsArrayBuffer: e } = globalThis.loaders || {};
  return ka || !e || r.startsWith("http") ? await (await fetch(r)).arrayBuffer() : await e(r);
}
async function _5(r) {
  const { readFileAsText: e } = globalThis.loaders || {};
  return ka || !e || r.startsWith("http") ? await (await fetch(r)).text() : await e(r);
}
const Ou = {};
function y5(r, e) {
  return !Vu.isSupported() || !ka && !e?._nodeWorkers ? !1 : r.worker && e?.worker;
}
async function v5(r, e, t, n, i) {
  const s = r.id, o = h5(r, t), u = Vu.getWorkerFarm(t).getWorkerPool({ name: s, url: o });
  t = JSON.parse(JSON.stringify(t)), n = JSON.parse(JSON.stringify(n || {}));
  const m = await u.startJob(
    "process-on-worker",
    // @ts-expect-error
    b5.bind(null, i)
    // eslint-disable-line @typescript-eslint/no-misused-promises
  );
  return m.postMessage("process", {
    // @ts-ignore
    input: e,
    options: t,
    context: n
  }), await (await m.result).result;
}
async function b5(r, e, t, n) {
  switch (t) {
    case "done":
      e.done(n);
      break;
    case "error":
      e.error(new Error(n.error));
      break;
    case "process":
      const { id: i, input: s, options: o } = n;
      try {
        const l = await r(s, o);
        e.postMessage("done", { id: i, result: l });
      } catch (l) {
        const u = l instanceof Error ? l.message : "unknown error";
        e.postMessage("error", { id: i, error: u });
      }
      break;
    default:
      console.warn(`parse-with-worker unknown message ${t}`);
  }
}
function x5(r, e = 5) {
  return typeof r == "string" ? r.slice(0, e) : ArrayBuffer.isView(r) ? yE(r.buffer, r.byteOffset, e) : r instanceof ArrayBuffer ? yE(r, 0, e) : "";
}
function yE(r, e, t) {
  if (r.byteLength <= e + t)
    return "";
  const n = new DataView(r);
  let i = "";
  for (let s = 0; s < t; s++)
    i += String.fromCharCode(n.getUint8(e + s));
  return i;
}
function w5(r) {
  try {
    return JSON.parse(r);
  } catch {
    throw new Error(`Failed to parse JSON from data starting with "${x5(r)}"`);
  }
}
function T5(r, e, t) {
  if (t = t || r.byteLength, r.byteLength < t || e.byteLength < t)
    return !1;
  const n = new Uint8Array(r), i = new Uint8Array(e);
  for (let s = 0; s < n.length; ++s)
    if (n[s] !== i[s])
      return !1;
  return !0;
}
function E5(...r) {
  return C5(r);
}
function C5(r) {
  const e = r.map((s) => s instanceof ArrayBuffer ? new Uint8Array(s) : s), t = e.reduce((s, o) => s + o.byteLength, 0), n = new Uint8Array(t);
  let i = 0;
  for (const s of e)
    n.set(s, i), i += s.byteLength;
  return n.buffer;
}
function Q2(r, e, t) {
  const n = t !== void 0 ? new Uint8Array(r).subarray(e, e + t) : new Uint8Array(r).subarray(e);
  return new Uint8Array(n).buffer;
}
function m0(r, e) {
  return _i(r >= 0), _i(e > 0), r + (e - 1) & -4;
}
function S5(r, e, t) {
  let n;
  if (r instanceof ArrayBuffer)
    n = new Uint8Array(r);
  else {
    const i = r.byteOffset, s = r.byteLength;
    n = new Uint8Array(r.buffer || r.arrayBuffer, i, s);
  }
  return e.set(n, t), t + m0(n.byteLength, 4);
}
async function I5(r) {
  const e = [];
  for await (const t of r)
    e.push(t);
  return E5(...e);
}
function vE() {
  let r;
  if (typeof window < "u" && window.performance)
    r = window.performance.now();
  else if (typeof process < "u" && process.hrtime) {
    const e = process.hrtime();
    r = e[0] * 1e3 + e[1] / 1e6;
  } else
    r = Date.now();
  return r;
}
class bE {
  constructor(e, t) {
    this.sampleSize = 1, this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this.name = e, this.type = t, this.reset();
  }
  reset() {
    return this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this;
  }
  setSampleSize(e) {
    return this.sampleSize = e, this;
  }
  /** Call to increment count (+1) */
  incrementCount() {
    return this.addCount(1), this;
  }
  /** Call to decrement count (-1) */
  decrementCount() {
    return this.subtractCount(1), this;
  }
  /** Increase count */
  addCount(e) {
    return this._count += e, this._samples++, this._checkSampling(), this;
  }
  /** Decrease count */
  subtractCount(e) {
    return this._count -= e, this._samples++, this._checkSampling(), this;
  }
  /** Add an arbitrary timing and bump the count */
  addTime(e) {
    return this._time += e, this.lastTiming = e, this._samples++, this._checkSampling(), this;
  }
  /** Start a timer */
  timeStart() {
    return this._startTime = vE(), this._timerPending = !0, this;
  }
  /** End a timer. Adds to time and bumps the timing count. */
  timeEnd() {
    return this._timerPending ? (this.addTime(vE() - this._startTime), this._timerPending = !1, this._checkSampling(), this) : this;
  }
  getSampleAverageCount() {
    return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
  }
  /** Calculate average time / count for the previous window */
  getSampleAverageTime() {
    return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
  }
  /** Calculate counts per second for the previous window */
  getSampleHz() {
    return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;
  }
  getAverageCount() {
    return this.samples > 0 ? this.count / this.samples : 0;
  }
  /** Calculate average time / count */
  getAverageTime() {
    return this.samples > 0 ? this.time / this.samples : 0;
  }
  /** Calculate counts per second */
  getHz() {
    return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
  }
  _checkSampling() {
    this._samples === this.sampleSize && (this.lastSampleTime = this._time, this.lastSampleCount = this._count, this.count += this._count, this.time += this._time, this.samples += this._samples, this._time = 0, this._count = 0, this._samples = 0);
  }
}
class Bp {
  constructor(e) {
    this.stats = {}, this.id = e.id, this.stats = {}, this._initializeStats(e.stats), Object.seal(this);
  }
  /** Acquire a stat. Create if it doesn't exist. */
  get(e, t = "count") {
    return this._getOrCreate({ name: e, type: t });
  }
  get size() {
    return Object.keys(this.stats).length;
  }
  /** Reset all stats */
  reset() {
    for (const e of Object.values(this.stats))
      e.reset();
    return this;
  }
  forEach(e) {
    for (const t of Object.values(this.stats))
      e(t);
  }
  getTable() {
    const e = {};
    return this.forEach((t) => {
      e[t.name] = {
        time: t.time || 0,
        count: t.count || 0,
        average: t.getAverageTime() || 0,
        hz: t.getHz() || 0
      };
    }), e;
  }
  _initializeStats(e = []) {
    e.forEach((t) => this._getOrCreate(t));
  }
  _getOrCreate(e) {
    const { name: t, type: n } = e;
    let i = this.stats[t];
    return i || (e instanceof bE ? i = e : i = new bE(t, n), this.stats[t] = i), i;
  }
}
const P5 = "Queued Requests", M5 = "Active Requests", R5 = "Cancelled Requests", B5 = "Queued Requests Ever", O5 = "Active Requests Ever", D5 = {
  id: "request-scheduler",
  /** Specifies if the request scheduler should throttle incoming requests, mainly for comparative testing. */
  throttleRequests: !0,
  /** The maximum number of simultaneous active requests. Un-throttled requests do not observe this limit. */
  maxRequests: 6,
  /**
   * Specifies a debounce time, in milliseconds. All requests are queued, until no new requests have
   * been added to the queue for this amount of time.
   */
  debounceTime: 0
};
class aB {
  props;
  stats;
  activeRequestCount = 0;
  /** Tracks the number of active requests and prioritizes/cancels queued requests. */
  requestQueue = [];
  requestMap = /* @__PURE__ */ new Map();
  updateTimer = null;
  constructor(e = {}) {
    this.props = { ...D5, ...e }, this.stats = new Bp({ id: this.props.id }), this.stats.get(P5), this.stats.get(M5), this.stats.get(R5), this.stats.get(B5), this.stats.get(O5);
  }
  /**
   * Called by an application that wants to issue a request, without having it deeply queued by the browser
   *
   * When the returned promise resolved, it is OK for the application to issue a request.
   * The promise resolves to an object that contains a `done` method.
   * When the application's request has completed (or failed), the application must call the `done` function
   *
   * @param handle
   * @param getPriority will be called when request "slots" open up,
   *    allowing the caller to update priority or cancel the request
   *    Highest priority executes first, priority < 0 cancels the request
   * @returns a promise
   *   - resolves to a object (with a `done` field) when the request can be issued without queueing,
   *   - resolves to `null` if the request has been cancelled (by the callback return < 0).
   *     In this case the application should not issue the request
   */
  scheduleRequest(e, t = () => 0) {
    if (!this.props.throttleRequests)
      return Promise.resolve({ done: () => {
      } });
    if (this.requestMap.has(e))
      return this.requestMap.get(e);
    const n = { handle: e, priority: 0, getPriority: t }, i = new Promise((s) => (n.resolve = s, n));
    return this.requestQueue.push(n), this.requestMap.set(e, i), this._issueNewRequests(), i;
  }
  // PRIVATE
  _issueRequest(e) {
    const { handle: t, resolve: n } = e;
    let i = !1;
    const s = () => {
      i || (i = !0, this.requestMap.delete(t), this.activeRequestCount--, this._issueNewRequests());
    };
    return this.activeRequestCount++, n ? n({ done: s }) : Promise.resolve({ done: s });
  }
  /** We check requests asynchronously, to prevent multiple updates */
  _issueNewRequests() {
    this.updateTimer !== null && clearTimeout(this.updateTimer), this.updateTimer = setTimeout(() => this._issueNewRequestsAsync(), this.props.debounceTime);
  }
  /** Refresh all requests  */
  _issueNewRequestsAsync() {
    this.updateTimer !== null && clearTimeout(this.updateTimer), this.updateTimer = null;
    const e = Math.max(this.props.maxRequests - this.activeRequestCount, 0);
    if (e !== 0) {
      this._updateAllRequests();
      for (let t = 0; t < e; ++t) {
        const n = this.requestQueue.shift();
        n && this._issueRequest(n);
      }
    }
  }
  /** Ensure all requests have updated priorities, and that no longer valid requests are cancelled */
  _updateAllRequests() {
    const e = this.requestQueue;
    for (let t = 0; t < e.length; ++t) {
      const n = e[t];
      this._updateRequest(n) || (e.splice(t, 1), this.requestMap.delete(n.handle), t--);
    }
    e.sort((t, n) => t.priority - n.priority);
  }
  /** Update a single request by calling the callback */
  _updateRequest(e) {
    return e.priority = e.getPriority(e.handle), e.priority < 0 ? (e.resolve(null), !1) : !0;
  }
}
let L5 = "";
const xE = {};
function k5(r) {
  for (const e in xE)
    if (r.startsWith(e)) {
      const t = xE[e];
      r = r.replace(e, t);
    }
  return !r.startsWith("http://") && !r.startsWith("https://") && (r = `${L5}${r}`), r;
}
function F5(r) {
  return r && typeof r == "object" && r.isBuffer;
}
function lB(r) {
  if (F5(r))
    return r;
  if (r instanceof ArrayBuffer)
    return r;
  if (ArrayBuffer.isView(r))
    return r.byteOffset === 0 && r.byteLength === r.buffer.byteLength ? r.buffer : r.buffer.slice(r.byteOffset, r.byteOffset + r.byteLength);
  if (typeof r == "string") {
    const e = r;
    return new TextEncoder().encode(e).buffer;
  }
  if (r && typeof r == "object" && r._toArrayBuffer)
    return r._toArrayBuffer();
  throw new Error("toArrayBuffer");
}
function N5() {
  if (typeof process < "u" && typeof process.cwd < "u")
    return process.cwd();
  const r = window.location?.pathname;
  return r?.slice(0, r.lastIndexOf("/") + 1) || "";
}
function cB(r) {
  const e = r ? r.lastIndexOf("/") : -1;
  return e >= 0 ? r.substr(e + 1) : "";
}
function J2(r) {
  const e = r ? r.lastIndexOf("/") : -1;
  return e >= 0 ? r.substr(0, e) : "";
}
function U5(...r) {
  const e = [];
  for (let s = 0; s < r.length; s++)
    e[s] = r[s];
  let t = "", n = !1, i;
  for (let s = e.length - 1; s >= -1 && !n; s--) {
    let o;
    s >= 0 ? o = e[s] : (i === void 0 && (i = N5()), o = i), o.length !== 0 && (t = `${o}/${t}`, n = o.charCodeAt(0) === IA);
  }
  return t = z5(t, !n), n ? `/${t}` : t.length > 0 ? t : ".";
}
const IA = 47, pv = 46;
function z5(r, e) {
  let t = "", n = -1, i = 0, s, o = !1;
  for (let l = 0; l <= r.length; ++l) {
    if (l < r.length)
      s = r.charCodeAt(l);
    else {
      if (s === IA)
        break;
      s = IA;
    }
    if (s === IA) {
      if (!(n === l - 1 || i === 1)) if (n !== l - 1 && i === 2) {
        if (t.length < 2 || !o || t.charCodeAt(t.length - 1) !== pv || t.charCodeAt(t.length - 2) !== pv) {
          if (t.length > 2) {
            const u = t.length - 1;
            let m = u;
            for (; m >= 0 && t.charCodeAt(m) !== IA; --m)
              ;
            if (m !== u) {
              t = m === -1 ? "" : t.slice(0, m), n = l, i = 0, o = !1;
              continue;
            }
          } else if (t.length === 2 || t.length === 1) {
            t = "", n = l, i = 0, o = !1;
            continue;
          }
        }
        e && (t.length > 0 ? t += "/.." : t = "..", o = !0);
      } else {
        const u = r.slice(n + 1, l);
        t.length > 0 ? t += `/${u}` : t = u, o = !1;
      }
      n = l, i = 0;
    } else s === pv && i !== -1 ? ++i : i = -1;
  }
  return t;
}
class V5 {
  /** A resolved fetch function extracted from loadOptions prop */
  fetch;
  /** The actual load options, if calling a loaders.gl loader */
  loadOptions;
  _needsRefresh = !0;
  props;
  constructor(e) {
    this.props = { ...e }, this.loadOptions = { ...e.loadOptions }, this.fetch = j5(this.loadOptions);
  }
  setProps(e) {
    this.props = Object.assign(this.props, e), this.setNeedsRefresh();
  }
  /** Mark this data source as needing a refresh (redraw) */
  setNeedsRefresh() {
    this._needsRefresh = !0;
  }
  /**
   * Does this data source need refreshing?
   * @note The specifics of the refresh mechanism depends on type of data source
   */
  getNeedsRefresh(e = !0) {
    const t = this._needsRefresh;
    return e && (this._needsRefresh = !1), t;
  }
}
function j5(r) {
  const e = r?.fetch;
  if (e && typeof e == "function")
    return (n, i) => e(n, i);
  const t = r?.fetch;
  return t && typeof t != "function" ? (n) => fetch(n, t) : (n) => fetch(n);
}
class ex extends V5 {
  static type = "template";
  static testURL = (e) => !1;
}
const H5 = (r) => typeof r == "boolean", FA = (r) => typeof r == "function", _0 = (r) => r !== null && typeof r == "object", wE = (r) => _0(r) && r.constructor === {}.constructor, G5 = (r) => !!r && typeof r[Symbol.iterator] == "function", W5 = (r) => r && typeof r[Symbol.asyncIterator] == "function", Ah = (r) => typeof Response < "u" && r instanceof Response || r && r.arrayBuffer && r.text && r.json, gh = (r) => typeof Blob < "u" && r instanceof Blob, $5 = (r) => r && typeof r == "object" && r.isBuffer, q5 = (r) => typeof ReadableStream < "u" && r instanceof ReadableStream || _0(r) && FA(r.tee) && FA(r.cancel) && FA(r.getReader), X5 = (r) => _0(r) && FA(r.read) && FA(r.pipe) && H5(r.readable), uB = (r) => q5(r) || X5(r);
class Z5 extends Error {
  constructor(e, t) {
    super(e), this.reason = t.reason, this.url = t.url, this.response = t.response;
  }
  /** A best effort reason for why the fetch failed */
  reason;
  /** The URL that failed to load. Empty string if not available. */
  url;
  /** The Response object, if any. */
  response;
}
const Y5 = /^data:([-\w.]+\/[-\w.+]+)(;|,)/, K5 = /^([-\w.]+\/[-\w.+]+)/;
function TE(r, e) {
  return r.toLowerCase() === e.toLowerCase();
}
function Q5(r) {
  const e = K5.exec(r);
  return e ? e[1] : r;
}
function EE(r) {
  const e = Y5.exec(r);
  return e ? e[1] : "";
}
const fB = /\?.*/;
function J5(r) {
  const e = r.match(fB);
  return e && e[0];
}
function tx(r) {
  return r.replace(fB, "");
}
function eU(r) {
  if (r.length < 50)
    return r;
  const e = r.slice(r.length - 15);
  return `${r.substr(0, 32)}...${e}`;
}
function R_(r) {
  return Ah(r) ? r.url : gh(r) ? r.name || "" : typeof r == "string" ? r : "";
}
function rx(r) {
  if (Ah(r)) {
    const e = r, t = e.headers.get("content-type") || "", n = tx(e.url);
    return Q5(t) || EE(n);
  }
  return gh(r) ? r.type || "" : typeof r == "string" ? EE(r) : "";
}
function tU(r) {
  return Ah(r) ? r.headers["content-length"] || -1 : gh(r) ? r.size : typeof r == "string" ? r.length : r instanceof ArrayBuffer || ArrayBuffer.isView(r) ? r.byteLength : -1;
}
async function hB(r) {
  if (Ah(r))
    return r;
  const e = {}, t = tU(r);
  t >= 0 && (e["content-length"] = String(t));
  const n = R_(r), i = rx(r);
  i && (e["content-type"] = i);
  const s = await iU(r);
  s && (e["x-first-bytes"] = s), typeof r == "string" && (r = new TextEncoder().encode(r));
  const o = new Response(r, { headers: e });
  return Object.defineProperty(o, "url", { value: n }), o;
}
async function rU(r) {
  if (!r.ok)
    throw await nU(r);
}
async function nU(r) {
  const e = eU(r.url);
  let t = `Failed to fetch resource (${r.status}) ${r.statusText}: ${e}`;
  t = t.length > 100 ? `${t.slice(0, 100)}...` : t;
  const n = {
    reason: r.statusText,
    url: r.url,
    response: r
  };
  try {
    const i = r.headers.get("Content-Type");
    n.reason = !r.bodyUsed && i?.includes("application/json") ? await r.json() : await r.text();
  } catch {
  }
  return new Z5(t, n);
}
async function iU(r) {
  if (typeof r == "string")
    return `data:,${r.slice(0, 5)}`;
  if (r instanceof Blob) {
    const t = r.slice(0, 5);
    return await new Promise((n) => {
      const i = new FileReader();
      i.onload = (s) => n(s?.target?.result), i.readAsDataURL(t);
    });
  }
  if (r instanceof ArrayBuffer) {
    const t = r.slice(0, 5);
    return `data:base64,${sU(t)}`;
  }
  return null;
}
function sU(r) {
  let e = "";
  const t = new Uint8Array(r);
  for (let n = 0; n < t.byteLength; n++)
    e += String.fromCharCode(t[n]);
  return btoa(e);
}
function oU(r) {
  return !aU(r) && !lU(r);
}
function aU(r) {
  return r.startsWith("http:") || r.startsWith("https:");
}
function lU(r) {
  return r.startsWith("data:");
}
async function CE(r, e) {
  if (typeof r == "string") {
    const t = k5(r);
    return oU(t) && globalThis.loaders?.fetchNode ? globalThis.loaders?.fetchNode(t, e) : await fetch(t, e);
  }
  return await hB(r);
}
const SE = new Rp({ id: "loaders.gl" });
class cU {
  log() {
    return () => {
    };
  }
  info() {
    return () => {
    };
  }
  warn() {
    return () => {
    };
  }
  error() {
    return () => {
    };
  }
}
class uU {
  console;
  constructor() {
    this.console = console;
  }
  log(...e) {
    return this.console.log.bind(this.console, ...e);
  }
  info(...e) {
    return this.console.info.bind(this.console, ...e);
  }
  warn(...e) {
    return this.console.warn.bind(this.console, ...e);
  }
  error(...e) {
    return this.console.error.bind(this.console, ...e);
  }
}
const dB = {
  // baseUri
  fetch: null,
  mimeType: void 0,
  nothrow: !1,
  log: new uU(),
  // A probe.gl compatible (`log.log()()` syntax) that just logs to console
  useLocalLibraries: !1,
  CDN: "https://unpkg.com/@loaders.gl",
  worker: !0,
  // By default, use worker if provided by loader.
  maxConcurrency: 3,
  // How many worker instances should be created for each loader.
  maxMobileConcurrency: 1,
  // How many worker instances should be created for each loader on mobile devices.
  reuseWorkers: M_,
  // By default reuse workers in browser (Node.js refuses to terminate if browsers are running)
  _nodeWorkers: !1,
  // By default do not support node workers
  _workerType: "",
  // 'test' to use locally generated workers
  limit: 0,
  _limitMB: 0,
  batchSize: "auto",
  batchDebounceMs: 0,
  metadata: !1,
  // TODO - currently only implemented for parseInBatches, adds initial metadata batch,
  transforms: []
}, fU = {
  throws: "nothrow",
  dataType: "(no longer used)",
  uri: "baseUri",
  // Warn if fetch options are used on top-level
  method: "fetch.method",
  headers: "fetch.headers",
  body: "fetch.body",
  mode: "fetch.mode",
  credentials: "fetch.credentials",
  cache: "fetch.cache",
  redirect: "fetch.redirect",
  referrer: "fetch.referrer",
  referrerPolicy: "fetch.referrerPolicy",
  integrity: "fetch.integrity",
  keepalive: "fetch.keepalive",
  signal: "fetch.signal"
};
function pB() {
  globalThis.loaders = globalThis.loaders || {};
  const { loaders: r } = globalThis;
  return r._state || (r._state = {}), r._state;
}
function AB() {
  const r = pB();
  return r.globalOptions = r.globalOptions || { ...dB }, r.globalOptions;
}
function hU(r, e, t, n) {
  return t = t || [], t = Array.isArray(t) ? t : [t], dU(r, t), AU(e, r, n);
}
function dU(r, e) {
  IE(r, null, dB, fU, e);
  for (const t of e) {
    const n = r && r[t.id] || {}, i = t.options && t.options[t.id] || {}, s = t.deprecatedOptions && t.deprecatedOptions[t.id] || {};
    IE(n, t.id, i, s, e);
  }
}
function IE(r, e, t, n, i) {
  const s = e || "Top level", o = e ? `${e}.` : "";
  for (const l in r) {
    const u = !e && _0(r[l]), m = l === "baseUri" && !e, y = l === "workerUrl" && e;
    if (!(l in t) && !m && !y) {
      if (l in n)
        SE.warn(`${s} loader option '${o}${l}' no longer supported, use '${n[l]}'`)();
      else if (!u) {
        const E = pU(l, i);
        SE.warn(`${s} loader option '${o}${l}' not recognized. ${E}`)();
      }
    }
  }
}
function pU(r, e) {
  const t = r.toLowerCase();
  let n = "";
  for (const i of e)
    for (const s in i.options) {
      if (r === s)
        return `Did you mean '${i.id}.${s}'?`;
      const o = s.toLowerCase();
      (t.startsWith(o) || o.startsWith(t)) && (n = n || `Did you mean '${i.id}.${s}'?`);
    }
  return n;
}
function AU(r, e, t) {
  const i = { ...r.options || {} };
  return gU(i, t), i.log === null && (i.log = new cU()), PE(i, AB()), PE(i, e), i;
}
function PE(r, e) {
  for (const t in e)
    if (t in e) {
      const n = e[t];
      wE(n) && wE(r[t]) ? r[t] = {
        ...r[t],
        ...e[t]
      } : r[t] = e[t];
    }
}
function gU(r, e) {
  e && !("baseUri" in r) && (r.baseUri = e);
}
function nx(r) {
  return r ? (Array.isArray(r) && (r = r[0]), Array.isArray(r?.extensions)) : !1;
}
function ix(r) {
  _i(r, "null loader"), _i(nx(r), "invalid loader");
  let e;
  return Array.isArray(r) && (e = r[1], r = r[0], r = {
    ...r,
    options: { ...r.options, ...e }
  }), (r?.parseTextSync || r?.parseText) && (r.text = !0), r.text || (r.binary = !0), r;
}
const gB = () => {
  const r = pB();
  return r.loaderRegistry = r.loaderRegistry || [], r.loaderRegistry;
};
function Op(r) {
  const e = gB();
  r = Array.isArray(r) ? r : [r];
  for (const t of r) {
    const n = ix(t);
    e.find((i) => n === i) || e.unshift(n);
  }
}
function mU() {
  return gB();
}
const _U = /\.([^.]+)$/;
async function yU(r, e = [], t, n) {
  if (!mB(r))
    return null;
  let i = ME(r, e, { ...t, nothrow: !0 }, n);
  if (i)
    return i;
  if (gh(r) && (r = await r.slice(0, 10).arrayBuffer(), i = ME(r, e, t, n)), !i && !t?.nothrow)
    throw new Error(_B(r));
  return i;
}
function ME(r, e = [], t, n) {
  if (!mB(r))
    return null;
  if (e && !Array.isArray(e))
    return ix(e);
  let i = [];
  e && (i = i.concat(e)), t?.ignoreRegisteredLoaders || i.push(...mU()), bU(i);
  const s = vU(r, i, t, n);
  if (!s && !t?.nothrow)
    throw new Error(_B(r));
  return s;
}
function vU(r, e, t, n) {
  const i = R_(r), s = rx(r), o = tx(i) || n?.url;
  let l = null, u = "";
  return t?.mimeType && (l = Av(e, t?.mimeType), u = `match forced by supplied MIME type ${t?.mimeType}`), l = l || xU(e, o), u = u || (l ? `matched url ${o}` : ""), l = l || Av(e, s), u = u || (l ? `matched MIME type ${s}` : ""), l = l || TU(e, r), u = u || (l ? `matched initial data ${yB(r)}` : ""), t?.fallbackMimeType && (l = l || Av(e, t?.fallbackMimeType), u = u || (l ? `matched fallback MIME type ${s}` : "")), u && e5.log(1, `selectLoader selected ${l?.name}: ${u}.`), l;
}
function mB(r) {
  return !(r instanceof Response && r.status === 204);
}
function _B(r) {
  const e = R_(r), t = rx(r);
  let n = "No valid loader found (";
  n += e ? `${cB(e)}, ` : "no url provided, ", n += `MIME type: ${t ? `"${t}"` : "not provided"}, `;
  const i = r ? yB(r) : "";
  return n += i ? ` first bytes: "${i}"` : "first bytes: not available", n += ")", n;
}
function bU(r) {
  for (const e of r)
    ix(e);
}
function xU(r, e) {
  const t = e && _U.exec(e), n = t && t[1];
  return n ? wU(r, n) : null;
}
function wU(r, e) {
  e = e.toLowerCase();
  for (const t of r)
    for (const n of t.extensions)
      if (n.toLowerCase() === e)
        return t;
  return null;
}
function Av(r, e) {
  for (const t of r)
    if (t.mimeTypes?.some((n) => TE(e, n)) || TE(e, `application/x.${t.id}`))
      return t;
  return null;
}
function TU(r, e) {
  if (!e)
    return null;
  for (const t of r)
    if (typeof e == "string") {
      if (EU(e, t))
        return t;
    } else if (ArrayBuffer.isView(e)) {
      if (RE(e.buffer, e.byteOffset, t))
        return t;
    } else if (e instanceof ArrayBuffer && RE(e, 0, t))
      return t;
  return null;
}
function EU(r, e) {
  return e.testText ? e.testText(r) : (Array.isArray(e.tests) ? e.tests : [e.tests]).some((n) => r.startsWith(n));
}
function RE(r, e, t) {
  return (Array.isArray(t.tests) ? t.tests : [t.tests]).some((i) => CU(r, e, t, i));
}
function CU(r, e, t, n) {
  if (n instanceof ArrayBuffer)
    return T5(n, r, n.byteLength);
  switch (typeof n) {
    case "function":
      return n(r);
    case "string":
      const i = yb(r, e, n.length);
      return n === i;
    default:
      return !1;
  }
}
function yB(r, e = 5) {
  return typeof r == "string" ? r.slice(0, e) : ArrayBuffer.isView(r) ? yb(r.buffer, r.byteOffset, e) : r instanceof ArrayBuffer ? yb(r, 0, e) : "";
}
function yb(r, e, t) {
  if (r.byteLength < e + t)
    return "";
  const n = new DataView(r);
  let i = "";
  for (let s = 0; s < t; s++)
    i += String.fromCharCode(n.getUint8(e + s));
  return i;
}
const SU = 256 * 1024;
function* IU(r, e) {
  const t = e?.chunkSize || SU;
  let n = 0;
  const i = new TextEncoder();
  for (; n < r.length; ) {
    const s = Math.min(r.length - n, t), o = r.slice(n, n + s);
    n += s, yield i.encode(o);
  }
}
const PU = 256 * 1024;
function* MU(r, e = {}) {
  const { chunkSize: t = PU } = e;
  let n = 0;
  for (; n < r.byteLength; ) {
    const i = Math.min(r.byteLength - n, t), s = new ArrayBuffer(i), o = new Uint8Array(r, n, i);
    new Uint8Array(s).set(o), n += i, yield s;
  }
}
const RU = 1024 * 1024;
async function* BU(r, e) {
  const t = e?.chunkSize || RU;
  let n = 0;
  for (; n < r.size; ) {
    const i = n + t, s = await r.slice(n, i).arrayBuffer();
    n = i, yield s;
  }
}
function BE(r, e) {
  return M_ ? OU(r, e) : DU(r);
}
async function* OU(r, e) {
  const t = r.getReader();
  let n;
  try {
    for (; ; ) {
      const i = n || t.read();
      e?._streamReadAhead && (n = t.read());
      const { done: s, value: o } = await i;
      if (s)
        return;
      yield lB(o);
    }
  } catch {
    t.releaseLock();
  }
}
async function* DU(r, e) {
  for await (const t of r)
    yield lB(t);
}
function LU(r, e) {
  if (typeof r == "string")
    return IU(r, e);
  if (r instanceof ArrayBuffer)
    return MU(r, e);
  if (gh(r))
    return BU(r, e);
  if (uB(r))
    return BE(r, e);
  if (Ah(r))
    return BE(r.body, e);
  throw new Error("makeIterator");
}
const vB = "Cannot convert supplied data type";
function kU(r, e, t) {
  if (e.text && typeof r == "string")
    return r;
  if ($5(r) && (r = r.buffer), r instanceof ArrayBuffer) {
    const n = r;
    return e.text && !e.binary ? new TextDecoder("utf8").decode(n) : n;
  }
  if (ArrayBuffer.isView(r)) {
    if (e.text && !e.binary)
      return new TextDecoder("utf8").decode(r);
    let n = r.buffer;
    const i = r.byteLength || r.length;
    return (r.byteOffset !== 0 || i !== n.byteLength) && (n = n.slice(r.byteOffset, r.byteOffset + i)), n;
  }
  throw new Error(vB);
}
async function FU(r, e, t) {
  const n = r instanceof ArrayBuffer || ArrayBuffer.isView(r);
  if (typeof r == "string" || n)
    return kU(r, e);
  if (gh(r) && (r = await hB(r)), Ah(r)) {
    const i = r;
    return await rU(i), e.binary ? await i.arrayBuffer() : await i.text();
  }
  if (uB(r) && (r = LU(r, t)), G5(r) || W5(r))
    return I5(r);
  throw new Error(vB);
}
function bB(r, e) {
  const t = AB(), n = r || t;
  return typeof n.fetch == "function" ? n.fetch : _0(n.fetch) ? (i) => CE(i, n.fetch) : e?.fetch ? e?.fetch : CE;
}
function NU(r, e, t) {
  if (t)
    return t;
  const n = {
    fetch: bB(e, r),
    ...r
  };
  if (n.url) {
    const i = tx(n.url);
    n.baseUrl = i, n.queryString = J5(n.url), n.filename = cB(i), n.baseUrl = J2(i);
  }
  return Array.isArray(n.loaders) || (n.loaders = null), n;
}
function UU(r, e) {
  if (r && !Array.isArray(r))
    return r;
  let t;
  if (r && (t = Array.isArray(r) ? r : [r]), e && e.loaders) {
    const n = Array.isArray(e.loaders) ? e.loaders : [e.loaders];
    t = t ? [...t, ...n] : n;
  }
  return t && t.length ? t : void 0;
}
async function jm(r, e, t, n) {
  e && !Array.isArray(e) && !nx(e) && (n = void 0, t = e, e = void 0), r = await r, t = t || {};
  const i = R_(r), o = UU(e, n), l = await yU(r, o, t);
  return l ? (t = hU(t, l, o, i), n = NU(
    // @ts-expect-error
    { url: i, _parse: jm, loaders: o },
    t,
    n || null
  ), await zU(l, r, t, n)) : null;
}
async function zU(r, e, t, n) {
  if (d5(r), t = rB(r.options, t), Ah(e)) {
    const s = e, { ok: o, redirected: l, status: u, statusText: m, type: y, url: E } = s, P = Object.fromEntries(s.headers.entries());
    n.response = { headers: P, ok: o, redirected: l, status: u, statusText: m, type: y, url: E };
  }
  e = await FU(e, r, t);
  const i = r;
  if (i.parseTextSync && typeof e == "string")
    return i.parseTextSync(e, t, n);
  if (y5(r, t))
    return await v5(r, e, t, n, jm);
  if (i.parseText && typeof e == "string")
    return await i.parseText(e, t, n);
  if (i.parse)
    return await i.parse(e, t, n);
  throw Yc(!i.parseSync), new Error(`${r.id} loader - no parser found and worker is disabled`);
}
function VU(r) {
  switch (r.constructor) {
    case Int8Array:
      return "int8";
    case Uint8Array:
    case Uint8ClampedArray:
      return "uint8";
    case Int16Array:
      return "int16";
    case Uint16Array:
      return "uint16";
    case Int32Array:
      return "int32";
    case Uint32Array:
      return "uint32";
    case Float32Array:
      return "float32";
    case Float64Array:
      return "float64";
    default:
      return "null";
  }
}
const OE = 100;
class jU {
  schema;
  options;
  shape;
  length = 0;
  rows = null;
  cursor = 0;
  _headers = [];
  constructor(e, t) {
    if (this.options = t, this.schema = e, !Array.isArray(e)) {
      this._headers = [];
      for (const n in e)
        this._headers[e[n].index] = e[n].name;
    }
  }
  rowCount() {
    return this.length;
  }
  addArrayRow(e, t) {
    Number.isFinite(t) && (this.cursor = t), this.shape = "array-row-table", this.rows = this.rows || new Array(OE), this.rows[this.length] = e, this.length++;
  }
  addObjectRow(e, t) {
    Number.isFinite(t) && (this.cursor = t), this.shape = "object-row-table", this.rows = this.rows || new Array(OE), this.rows[this.length] = e, this.length++;
  }
  getBatch() {
    let e = this.rows;
    return e ? (e = e.slice(0, this.length), this.rows = null, {
      shape: this.shape || "array-row-table",
      batchType: "data",
      data: e,
      length: this.length,
      schema: this.schema,
      cursor: this.cursor
    }) : null;
  }
}
function xB(r, e) {
  if (!r)
    throw new Error("null row");
  const t = {};
  if (e)
    for (let n = 0; n < e.length; n++)
      t[e[n]] = r[n];
  else
    for (let n = 0; n < r.length; n++) {
      const i = `column-${n}`;
      t[i] = r[n];
    }
  return t;
}
function wB(r, e) {
  if (!r)
    throw new Error("null row");
  if (e) {
    const t = new Array(e.length);
    for (let n = 0; n < e.length; n++)
      t[n] = r[e[n]];
    return t;
  }
  return Object.values(r);
}
function HU(r) {
  const e = [];
  for (let t = 0; t < r.length; t++) {
    const n = `column-${t}`;
    e.push(n);
  }
  return e;
}
function GU(r) {
  return Object.keys(r);
}
const DE = 100;
class WU {
  schema;
  options;
  length = 0;
  objectRows = null;
  arrayRows = null;
  cursor = 0;
  _headers = null;
  constructor(e, t) {
    if (this.options = t, this.schema = e, e) {
      this._headers = [];
      for (const n in e)
        this._headers[e[n].index] = e[n].name;
    }
  }
  rowCount() {
    return this.length;
  }
  addArrayRow(e, t) {
    switch (Number.isFinite(t) && (this.cursor = t), this._headers ||= HU(e), this.options.shape) {
      case "object-row-table":
        const n = xB(e, this._headers);
        this.addObjectRow(n, t);
        break;
      case "array-row-table":
        this.arrayRows = this.arrayRows || new Array(DE), this.arrayRows[this.length] = e, this.length++;
        break;
    }
  }
  addObjectRow(e, t) {
    switch (Number.isFinite(t) && (this.cursor = t), this._headers ||= GU(e), this.options.shape) {
      case "array-row-table":
        const n = wB(e, this._headers);
        this.addArrayRow(n, t);
        break;
      case "object-row-table":
        this.objectRows = this.objectRows || new Array(DE), this.objectRows[this.length] = e, this.length++;
        break;
    }
  }
  getBatch() {
    let e = this.arrayRows || this.objectRows;
    return e ? (e = e.slice(0, this.length), this.arrayRows = null, this.objectRows = null, {
      shape: this.options.shape,
      batchType: "data",
      data: e,
      length: this.length,
      // @ts-expect-error we should infer a schema
      schema: this.schema,
      cursor: this.cursor
    }) : null;
  }
}
const $U = 100;
class qU {
  schema;
  length = 0;
  allocated = 0;
  columns = {};
  constructor(e, t) {
    this.schema = e, this._reallocateColumns();
  }
  rowCount() {
    return this.length;
  }
  addArrayRow(e) {
    this._reallocateColumns();
    let t = 0;
    for (const n in this.columns)
      this.columns[n][this.length] = e[t++];
    this.length++;
  }
  addObjectRow(e) {
    this._reallocateColumns();
    for (const t in e)
      this.columns[t][this.length] = e[t];
    this.length++;
  }
  getBatch() {
    this._pruneColumns();
    const e = Array.isArray(this.schema) ? this.columns : {};
    if (!Array.isArray(this.schema))
      for (const n in this.schema) {
        const i = this.schema[n];
        e[i.name] = this.columns[i.index];
      }
    return this.columns = {}, {
      shape: "columnar-table",
      batchType: "data",
      data: e,
      schema: this.schema,
      length: this.length
    };
  }
  // HELPERS
  _reallocateColumns() {
    if (!(this.length < this.allocated)) {
      this.allocated = this.allocated > 0 ? this.allocated *= 2 : $U, this.columns = {};
      for (const e in this.schema) {
        const t = this.schema[e], n = t.type || Float32Array, i = this.columns[t.index];
        if (i && ArrayBuffer.isView(i)) {
          const s = new n(this.allocated);
          s.set(i), this.columns[t.index] = s;
        } else i ? (i.length = this.allocated, this.columns[t.index] = i) : this.columns[t.index] = new n(this.allocated);
      }
    }
  }
  _pruneColumns() {
    for (const [e, t] of Object.entries(this.columns))
      this.columns[e] = t.slice(0, this.length);
  }
}
const XU = {
  shape: void 0,
  batchSize: "auto",
  batchDebounceMs: 0,
  limit: 0,
  _limitMB: 0
}, ZU = "TableBatchBuilder";
class Hm {
  schema;
  options;
  aggregator = null;
  batchCount = 0;
  bytesUsed = 0;
  isChunkComplete = !1;
  lastBatchEmittedMs = Date.now();
  totalLength = 0;
  totalBytes = 0;
  rowBytes = 0;
  static ArrowBatch;
  constructor(e, t) {
    this.schema = e, this.options = { ...XU, ...t };
  }
  limitReached() {
    return !!(this.options?.limit && this.totalLength >= this.options.limit || this.options?._limitMB && this.totalBytes / 1e6 >= this.options._limitMB);
  }
  /** @deprecated Use addArrayRow or addObjectRow */
  addRow(e) {
    this.limitReached() || (this.totalLength++, this.rowBytes = this.rowBytes || this._estimateRowMB(e), this.totalBytes += this.rowBytes, Array.isArray(e) ? this.addArrayRow(e) : this.addObjectRow(e));
  }
  /** Add one row to the batch */
  addArrayRow(e) {
    if (!this.aggregator) {
      const t = this._getTableBatchType();
      this.aggregator = new t(this.schema, this.options);
    }
    this.aggregator.addArrayRow(e);
  }
  /** Add one row to the batch */
  addObjectRow(e) {
    if (!this.aggregator) {
      const t = this._getTableBatchType();
      this.aggregator = new t(this.schema, this.options);
    }
    this.aggregator.addObjectRow(e);
  }
  /** Mark an incoming raw memory chunk has completed */
  chunkComplete(e) {
    e instanceof ArrayBuffer && (this.bytesUsed += e.byteLength), typeof e == "string" && (this.bytesUsed += e.length), this.isChunkComplete = !0;
  }
  getFullBatch(e) {
    return this._isFull() ? this._getBatch(e) : null;
  }
  getFinalBatch(e) {
    return this._getBatch(e);
  }
  // INTERNAL
  _estimateRowMB(e) {
    return Array.isArray(e) ? e.length * 8 : Object.keys(e).length * 8;
  }
  _isFull() {
    if (!this.aggregator || this.aggregator.rowCount() === 0)
      return !1;
    if (this.options.batchSize === "auto") {
      if (!this.isChunkComplete)
        return !1;
    } else if (this.options.batchSize > this.aggregator.rowCount())
      return !1;
    return this.options.batchDebounceMs > Date.now() - this.lastBatchEmittedMs ? !1 : (this.isChunkComplete = !1, this.lastBatchEmittedMs = Date.now(), !0);
  }
  /**
   * bytesUsed can be set via chunkComplete or via getBatch*
   */
  _getBatch(e) {
    if (!this.aggregator)
      return null;
    e?.bytesUsed && (this.bytesUsed = e.bytesUsed);
    const t = this.aggregator.getBatch();
    return t.count = this.batchCount, t.bytesUsed = this.bytesUsed, Object.assign(t, e), this.batchCount++, this.aggregator = null, t;
  }
  _getTableBatchType() {
    switch (this.options.shape) {
      case "array-row-table":
      case "object-row-table":
        return WU;
      case "columnar-table":
        return qU;
      case "arrow-table":
        if (!Hm.ArrowBatch)
          throw new Error(ZU);
        return Hm.ArrowBatch;
      default:
        return jU;
    }
  }
}
function TB(r) {
  let e = 1 / 0, t = 1 / 0, n = 1 / 0, i = -1 / 0, s = -1 / 0, o = -1 / 0;
  const l = r.POSITION ? r.POSITION.value : [], u = l && l.length;
  for (let m = 0; m < u; m += 3) {
    const y = l[m], E = l[m + 1], P = l[m + 2];
    e = y < e ? y : e, t = E < t ? E : t, n = P < n ? P : n, i = y > i ? y : i, s = E > s ? E : s, o = P > o ? P : o;
  }
  return [
    [e, t, n],
    [i, s, o]
  ];
}
function YU(r, e, t) {
  const n = VU(e.value), i = t || KU(e);
  return {
    name: r,
    type: { type: "fixed-size-list", listSize: e.size, children: [{ name: "value", type: n }] },
    nullable: !1,
    metadata: i
  };
}
function KU(r) {
  const e = {};
  return "byteOffset" in r && (e.byteOffset = r.byteOffset.toString(10)), "byteStride" in r && (e.byteStride = r.byteStride.toString(10)), "normalized" in r && (e.normalized = r.normalized.toString()), e;
}
class LE extends Array {
  enqueue(e) {
    return this.push(e);
  }
  dequeue() {
    return this.shift();
  }
}
class QU {
  _values;
  _settlers;
  _closed;
  constructor() {
    this._values = new LE(), this._settlers = new LE(), this._closed = !1;
  }
  close() {
    for (; this._settlers.length > 0; )
      this._settlers.dequeue().resolve({ done: !0 });
    this._closed = !0;
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  enqueue(e) {
    if (this._closed)
      throw new Error("Closed");
    if (this._settlers.length > 0) {
      if (this._values.length > 0)
        throw new Error("Illegal internal state");
      const t = this._settlers.dequeue();
      e instanceof Error ? t.reject(e) : t.resolve({ value: e });
    } else
      this._values.enqueue(e);
  }
  /**
   * @returns a Promise for an IteratorResult
   */
  next() {
    if (this._values.length > 0) {
      const e = this._values.dequeue();
      return e instanceof Error ? Promise.reject(e) : Promise.resolve({ value: e });
    }
    if (this._closed) {
      if (this._settlers.length > 0)
        throw new Error("Illegal internal state");
      return Promise.resolve({ done: !0 });
    }
    return new Promise((e, t) => {
      this._settlers.enqueue({ resolve: e, reject: t });
    });
  }
}
async function Kc(r, e, t, n) {
  let i, s;
  !Array.isArray(e) && !nx(e) ? (i = [], s = e) : (i = e, s = t);
  const o = bB(s);
  let l = r;
  return typeof r == "string" && (l = await o(r)), gh(r) && (l = await o(r)), Array.isArray(i) ? await jm(l, i, s) : await jm(l, i, s);
}
const JU = "4.3.3", ez = globalThis.loaders?.parseImageNode, vb = typeof Image < "u", bb = typeof ImageBitmap < "u", tz = !!ez, xb = M_ ? !0 : tz;
function rz(r) {
  switch (r) {
    case "auto":
      return bb || vb || xb;
    case "imagebitmap":
      return bb;
    case "image":
      return vb;
    case "data":
      return xb;
    default:
      throw new Error(`@loaders.gl/images: image ${r} not supported in this environment`);
  }
}
function nz() {
  if (bb)
    return "imagebitmap";
  if (vb)
    return "image";
  if (xb)
    return "data";
  throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
}
function iz(r) {
  const e = sz(r);
  if (!e)
    throw new Error("Not an image");
  return e;
}
function EB(r) {
  switch (iz(r)) {
    case "data":
      return r;
    case "image":
    case "imagebitmap":
      const e = document.createElement("canvas"), t = e.getContext("2d");
      if (!t)
        throw new Error("getImageData");
      return e.width = r.width, e.height = r.height, t.drawImage(r, 0, 0), t.getImageData(0, 0, r.width, r.height);
    default:
      throw new Error("getImageData");
  }
}
function sz(r) {
  return typeof ImageBitmap < "u" && r instanceof ImageBitmap ? "imagebitmap" : typeof Image < "u" && r instanceof Image ? "image" : r && typeof r == "object" && r.data && r.width && r.height ? "data" : null;
}
const oz = /^data:image\/svg\+xml/, az = /\.svg((\?|#).*)?$/;
function sx(r) {
  return r && (oz.test(r) || az.test(r));
}
function lz(r, e) {
  if (sx(e)) {
    let n = new TextDecoder().decode(r);
    try {
      typeof unescape == "function" && typeof encodeURIComponent == "function" && (n = unescape(encodeURIComponent(n)));
    } catch (s) {
      throw new Error(s.message);
    }
    return `data:image/svg+xml;base64,${btoa(n)}`;
  }
  return CB(r, e);
}
function CB(r, e) {
  if (sx(e))
    throw new Error("SVG cannot be parsed directly to imagebitmap");
  return new Blob([new Uint8Array(r)]);
}
async function SB(r, e, t) {
  const n = lz(r, t), i = self.URL || self.webkitURL, s = typeof n != "string" && i.createObjectURL(n);
  try {
    return await cz(s || n, e);
  } finally {
    s && i.revokeObjectURL(s);
  }
}
async function cz(r, e) {
  const t = new Image();
  return t.src = r, e.image && e.image.decode && t.decode ? (await t.decode(), t) : await new Promise((n, i) => {
    try {
      t.onload = () => n(t), t.onerror = (s) => {
        const o = s instanceof Error ? s.message : "error";
        i(new Error(o));
      };
    } catch (s) {
      i(s);
    }
  });
}
const uz = {};
let kE = !0;
async function fz(r, e, t) {
  let n;
  sx(t) ? n = await SB(r, e, t) : n = CB(r, t);
  const i = e && e.imagebitmap;
  return await hz(n, i);
}
async function hz(r, e = null) {
  if ((dz(e) || !kE) && (e = null), e)
    try {
      return await createImageBitmap(r, e);
    } catch (t) {
      console.warn(t), kE = !1;
    }
  return await createImageBitmap(r);
}
function dz(r) {
  for (const e in r || uz)
    return !1;
  return !0;
}
function pz(r) {
  return !_z(r, "ftyp", 4) || (r[8] & 96) === 0 ? null : Az(r);
}
function Az(r) {
  switch (gz(r, 8, 12).replace("\0", " ").trim()) {
    case "avif":
    case "avis":
      return { extension: "avif", mimeType: "image/avif" };
    default:
      return null;
  }
}
function gz(r, e, t) {
  return String.fromCharCode(...r.slice(e, t));
}
function mz(r) {
  return [...r].map((e) => e.charCodeAt(0));
}
function _z(r, e, t = 0) {
  const n = mz(e);
  for (let i = 0; i < n.length; ++i)
    if (n[i] !== r[i + t])
      return !1;
  return !0;
}
const tc = !1, NA = !0;
function ox(r) {
  const e = y0(r);
  return vz(e) || wz(e) || bz(e) || xz(e) || yz(e);
}
function yz(r) {
  const e = new Uint8Array(r instanceof DataView ? r.buffer : r), t = pz(e);
  return t ? {
    mimeType: t.mimeType,
    // TODO - decode width and height
    width: 0,
    height: 0
  } : null;
}
function vz(r) {
  const e = y0(r);
  return e.byteLength >= 24 && e.getUint32(0, tc) === 2303741511 ? {
    mimeType: "image/png",
    width: e.getUint32(16, tc),
    height: e.getUint32(20, tc)
  } : null;
}
function bz(r) {
  const e = y0(r);
  return e.byteLength >= 10 && e.getUint32(0, tc) === 1195984440 ? {
    mimeType: "image/gif",
    width: e.getUint16(6, NA),
    height: e.getUint16(8, NA)
  } : null;
}
function xz(r) {
  const e = y0(r);
  return e.byteLength >= 14 && e.getUint16(0, tc) === 16973 && e.getUint32(2, NA) === e.byteLength ? {
    mimeType: "image/bmp",
    width: e.getUint32(18, NA),
    height: e.getUint32(22, NA)
  } : null;
}
function wz(r) {
  const e = y0(r);
  if (!(e.byteLength >= 3 && e.getUint16(0, tc) === 65496 && e.getUint8(2) === 255))
    return null;
  const { tableMarkers: n, sofMarkers: i } = Tz();
  let s = 2;
  for (; s + 9 < e.byteLength; ) {
    const o = e.getUint16(s, tc);
    if (i.has(o))
      return {
        mimeType: "image/jpeg",
        height: e.getUint16(s + 5, tc),
        // Number of lines
        width: e.getUint16(s + 7, tc)
        // Number of pixels per line
      };
    if (!n.has(o))
      return null;
    s += 2, s += e.getUint16(s, tc);
  }
  return null;
}
function Tz() {
  const r = /* @__PURE__ */ new Set([65499, 65476, 65484, 65501, 65534]);
  for (let t = 65504; t < 65520; ++t)
    r.add(t);
  return { tableMarkers: r, sofMarkers: /* @__PURE__ */ new Set([
    65472,
    65473,
    65474,
    65475,
    65477,
    65478,
    65479,
    65481,
    65482,
    65483,
    65485,
    65486,
    65487,
    65502
  ]) };
}
function y0(r) {
  if (r instanceof DataView)
    return r;
  if (ArrayBuffer.isView(r))
    return new DataView(r.buffer);
  if (r instanceof ArrayBuffer)
    return new DataView(r);
  throw new Error("toDataView");
}
async function Ez(r, e) {
  const { mimeType: t } = ox(r) || {}, n = globalThis.loaders?.parseImageNode;
  return _i(n), await n(r, t);
}
async function Cz(r, e, t) {
  e = e || {};
  const i = (e.image || {}).type || "auto", { url: s } = t || {}, o = Sz(i);
  let l;
  switch (o) {
    case "imagebitmap":
      l = await fz(r, e, s);
      break;
    case "image":
      l = await SB(r, e, s);
      break;
    case "data":
      l = await Ez(r);
      break;
    default:
      _i(!1);
  }
  return i === "data" && (l = EB(l)), l;
}
function Sz(r) {
  switch (r) {
    case "auto":
    case "data":
      return nz();
    default:
      return rz(r), r;
  }
}
const Iz = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg", "avif"], Pz = [
  "image/png",
  "image/jpeg",
  "image/gif",
  "image/webp",
  "image/avif",
  "image/bmp",
  "image/vnd.microsoft.icon",
  "image/svg+xml"
], Mz = {
  image: {
    type: "auto",
    decode: !0
    // if format is HTML
  }
  // imagebitmap: {} - passes (platform dependent) parameters to ImageBitmap constructor
}, Gm = {
  dataType: null,
  batchType: null,
  id: "image",
  module: "images",
  name: "Images",
  version: JU,
  mimeTypes: Pz,
  extensions: Iz,
  parse: Cz,
  // TODO: byteOffset, byteLength;
  tests: [(r) => !!ox(new DataView(r))],
  options: Mz
}, gv = {};
function Rz(r) {
  if (gv[r] === void 0) {
    const e = M_ ? Oz(r) : Bz(r);
    gv[r] = e;
  }
  return gv[r];
}
function Bz(r) {
  const e = ["image/png", "image/jpeg", "image/gif"], t = globalThis.loaders?.imageFormatsNode || e;
  return !!globalThis.loaders?.parseImageNode && t.includes(r);
}
function Oz(r) {
  switch (r) {
    case "image/avif":
    // Will fail
    case "image/webp":
      return Dz(r);
    default:
      return !0;
  }
}
function Dz(r) {
  try {
    return document.createElement("canvas").toDataURL(r).indexOf(`data:${r}`) === 0;
  } catch {
    return !1;
  }
}
const Jr = new Rp({ id: "deck" });
let wb = {};
function Lz(r) {
  wb = r;
}
function go(r, e, t, n) {
  Jr.level > 0 && wb[r] && wb[r].call(null, e, t, n);
}
function kz(r) {
  const e = r[0], t = r[r.length - 1];
  return e === "{" && t === "}" || e === "[" && t === "]";
}
const Fz = {
  dataType: null,
  batchType: null,
  id: "JSON",
  name: "JSON",
  module: "",
  version: "",
  options: {},
  extensions: ["json", "geojson"],
  mimeTypes: ["application/json", "application/geo+json"],
  testText: kz,
  parseTextSync: JSON.parse
};
function Nz() {
  const r = "9.2.2", e = globalThis.deck && globalThis.deck.VERSION;
  if (e && e !== r)
    throw new Error(`deck.gl - multiple versions detected: ${e} vs ${r}`);
  return e || (Jr.log(1, `deck.gl ${r}`)(), globalThis.deck = {
    ...globalThis.deck,
    VERSION: r,
    version: r,
    log: Jr,
    // experimental
    _registerLoggers: Lz
  }, Op([
    Fz,
    // @ts-expect-error non-standard Loader format
    [Gm, { imagebitmap: { premultiplyAlpha: "none" } }]
  ])), r;
}
const Uz = Nz();
function ax(r, e) {
  if (!r)
    throw new Error(e || "shadertools: assertion failed.");
}
const mv = {
  number: {
    type: "number",
    validate(r, e) {
      return Number.isFinite(r) && typeof e == "object" && (e.max === void 0 || r <= e.max) && (e.min === void 0 || r >= e.min);
    }
  },
  array: {
    type: "array",
    validate(r, e) {
      return Array.isArray(r) || ArrayBuffer.isView(r);
    }
  }
};
function zz(r) {
  const e = {};
  for (const [t, n] of Object.entries(r))
    e[t] = Vz(n);
  return e;
}
function Vz(r) {
  let e = FE(r);
  if (e !== "object")
    return { value: r, ...mv[e], type: e };
  if (typeof r == "object")
    return r ? r.type !== void 0 ? { ...r, ...mv[r.type], type: r.type } : r.value === void 0 ? { type: "object", value: r } : (e = FE(r.value), { ...r, ...mv[e], type: e }) : { type: "object", value: null };
  throw new Error("props");
}
function FE(r) {
  return Array.isArray(r) || ArrayBuffer.isView(r) ? "array" : typeof r;
}
const jz = (
  /* glsl */
  `#ifdef MODULE_LOGDEPTH
  logdepth_adjustPosition(gl_Position);
#endif
`
), Hz = (
  /* glsl */
  `#ifdef MODULE_MATERIAL
  fragColor = material_filterColor(fragColor);
#endif

#ifdef MODULE_LIGHTING
  fragColor = lighting_filterColor(fragColor);
#endif

#ifdef MODULE_FOG
  fragColor = fog_filterColor(fragColor);
#endif

#ifdef MODULE_PICKING
  fragColor = picking_filterHighlightColor(fragColor);
  fragColor = picking_filterPickingColor(fragColor);
#endif

#ifdef MODULE_LOGDEPTH
  logdepth_setFragDepth();
#endif
`
), Gz = {
  vertex: jz,
  fragment: Hz
}, NE = /void\s+main\s*\([^)]*\)\s*\{\n?/, UE = /}\n?[^{}]*$/, _v = [], gm = "__LUMA_INJECT_DECLARATIONS__";
function Wz(r) {
  const e = { vertex: {}, fragment: {} };
  for (const t in r) {
    let n = r[t];
    const i = $z(t);
    typeof n == "string" && (n = {
      order: 0,
      injection: n
    }), e[i][t] = n;
  }
  return e;
}
function $z(r) {
  const e = r.slice(0, 2);
  switch (e) {
    case "vs":
      return "vertex";
    case "fs":
      return "fragment";
    default:
      throw new Error(e);
  }
}
function Wm(r, e, t, n = !1) {
  const i = e === "vertex";
  for (const s in t) {
    const o = t[s];
    o.sort((u, m) => u.order - m.order), _v.length = o.length;
    for (let u = 0, m = o.length; u < m; ++u)
      _v[u] = o[u].injection;
    const l = `${_v.join(`
`)}
`;
    switch (s) {
      // declarations are injected before the main function
      case "vs:#decl":
        i && (r = r.replace(gm, l));
        break;
      // inject code at the beginning of the main function
      case "vs:#main-start":
        i && (r = r.replace(NE, (u) => u + l));
        break;
      // inject code at the end of main function
      case "vs:#main-end":
        i && (r = r.replace(UE, (u) => l + u));
        break;
      // declarations are injected before the main function
      case "fs:#decl":
        i || (r = r.replace(gm, l));
        break;
      // inject code at the beginning of the main function
      case "fs:#main-start":
        i || (r = r.replace(NE, (u) => u + l));
        break;
      // inject code at the end of main function
      case "fs:#main-end":
        i || (r = r.replace(UE, (u) => l + u));
        break;
      default:
        r = r.replace(s, (u) => u + l);
    }
  }
  return r = r.replace(gm, ""), n && (r = r.replace(/\}\s*$/, (s) => s + Gz[e])), r;
}
function $m(r) {
  r.map((e) => IB(e));
}
function IB(r) {
  if (r.instance)
    return;
  $m(r.dependencies || []);
  const {
    propTypes: e = {},
    deprecations: t = [],
    // defines = {},
    inject: n = {}
  } = r, i = {
    normalizedInjections: Wz(n),
    parsedDeprecations: qz(t)
  };
  e && (i.propValidators = zz(e)), r.instance = i;
  let s = {};
  e && (s = Object.entries(e).reduce((o, [l, u]) => {
    const m = u?.value;
    return m && (o[l] = m), o;
  }, {})), r.defaultUniforms = { ...r.defaultUniforms, ...s };
}
function PB(r, e, t) {
  r.deprecations?.forEach((n) => {
    n.regex?.test(e) && (n.deprecated ? t.deprecated(n.old, n.new)() : t.removed(n.old, n.new)());
  });
}
function qz(r) {
  return r.forEach((e) => {
    switch (e.type) {
      case "function":
        e.regex = new RegExp(`\\b${e.old}\\(`);
        break;
      default:
        e.regex = new RegExp(`${e.type} ${e.old};`);
    }
  }), r;
}
function lx(r) {
  $m(r);
  const e = {}, t = {};
  MB({ modules: r, level: 0, moduleMap: e, moduleDepth: t });
  const n = Object.keys(t).sort((i, s) => t[s] - t[i]).map((i) => e[i]);
  return $m(n), n;
}
function MB(r) {
  const { modules: e, level: t, moduleMap: n, moduleDepth: i } = r;
  if (t >= 5)
    throw new Error("Possible loop in shader dependency graph");
  for (const s of e)
    n[s.name] = s, (i[s.name] === void 0 || i[s.name] < t) && (i[s.name] = t);
  for (const s of e)
    s.dependencies && MB({ modules: s.dependencies, level: t + 1, moduleMap: n, moduleDepth: i });
}
function Xz(r) {
  switch (r?.gpu.toLowerCase()) {
    case "apple":
      return (
        /* glsl */
        `#define APPLE_GPU
// Apple optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`
      );
    case "nvidia":
      return (
        /* glsl */
        `#define NVIDIA_GPU
// Nvidia optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
`
      );
    case "intel":
      return (
        /* glsl */
        `#define INTEL_GPU
// Intel optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Intel's built-in 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`
      );
    case "amd":
      return (
        /* glsl */
        `#define AMD_GPU
`
      );
    default:
      return (
        /* glsl */
        `#define DEFAULT_GPU
// Prevent driver from optimizing away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Headless Chrome's software shader 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// If the GPU doesn't have full 32 bits precision, will causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`
      );
  }
}
function Zz(r, e) {
  if (Number(r.match(/^#version[ \t]+(\d+)/m)?.[1] || 100) !== 300)
    throw new Error("luma.gl v9 only supports GLSL 3.00 shader sources");
  switch (e) {
    case "vertex":
      return r = zE(r, Yz), r;
    case "fragment":
      return r = zE(r, Kz), r;
    default:
      throw new Error(e);
  }
}
const RB = [
  // Fix poorly formatted version directive
  [/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/, `#version 300 es
`],
  // The individual `texture...()` functions were replaced with `texture()` overloads
  [/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, "textureLod("],
  [/\btexture(2D|2DProj|Cube)(EXT)?\(/g, "texture("]
], Yz = [
  ...RB,
  // `attribute` keyword replaced with `in`
  [Tb("attribute"), "in $1"],
  // `varying` keyword replaced with `out`
  [Tb("varying"), "out $1"]
], Kz = [
  ...RB,
  // `varying` keyword replaced with `in`
  [Tb("varying"), "in $1"]
];
function zE(r, e) {
  for (const [t, n] of e)
    r = r.replace(t, n);
  return r;
}
function Tb(r) {
  return new RegExp(`\\b${r}[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)`, "g");
}
function BB(r, e) {
  let t = "";
  for (const n in r) {
    const i = r[n];
    if (t += `void ${i.signature} {
`, i.header && (t += `  ${i.header}`), e[n]) {
      const s = e[n];
      s.sort((o, l) => o.order - l.order);
      for (const o of s)
        t += `  ${o.injection}
`;
    }
    i.footer && (t += `  ${i.footer}`), t += `}
`;
  }
  return t;
}
function OB(r) {
  const e = { vertex: {}, fragment: {} };
  for (const t of r) {
    let n, i;
    typeof t != "string" ? (n = t, i = n.hook) : (n = {}, i = t), i = i.trim();
    const [s, o] = i.split(":"), l = i.replace(/\(.+/, ""), u = Object.assign(n, { signature: o });
    switch (s) {
      case "vs":
        e.vertex[l] = u;
        break;
      case "fs":
        e.fragment[l] = u;
        break;
      default:
        throw new Error(s);
    }
  }
  return e;
}
function Qz(r, e) {
  return {
    name: Jz(r, e),
    language: "glsl",
    version: e9(r)
  };
}
function Jz(r, e = "unnamed") {
  const n = /#define[^\S\r\n]*SHADER_NAME[^\S\r\n]*([A-Za-z0-9_-]+)\s*/.exec(r);
  return n ? n[1] : e;
}
function e9(r) {
  let e = 100;
  const t = r.match(/[^\s]+/g);
  if (t && t.length >= 2 && t[0] === "#version") {
    const n = parseInt(t[1], 10);
    Number.isFinite(n) && (e = n);
  }
  if (e !== 100 && e !== 300)
    throw new Error(`Invalid GLSL version ${e}`);
  return e;
}
const DB = `

${gm}
`, t9 = (
  /* glsl */
  `precision highp float;
`
);
function r9(r) {
  const e = lx(r.modules || []);
  return {
    source: i9(r.platformInfo, {
      ...r,
      source: r.source,
      stage: "vertex",
      modules: e
    }),
    getUniforms: LB(e)
  };
}
function n9(r) {
  const { vs: e, fs: t } = r, n = lx(r.modules || []);
  return {
    vs: VE(r.platformInfo, {
      ...r,
      source: e,
      stage: "vertex",
      modules: n
    }),
    fs: VE(r.platformInfo, {
      ...r,
      // @ts-expect-error
      source: t,
      stage: "fragment",
      modules: n
    }),
    getUniforms: LB(n)
  };
}
function i9(r, e) {
  const {
    // id,
    source: t,
    stage: n,
    modules: i,
    // defines = {},
    hookFunctions: s = [],
    inject: o = {},
    log: l
  } = e;
  ax(typeof t == "string", "shader source must be a string");
  const u = t;
  let m = "";
  const y = OB(s), E = {}, P = {}, L = {};
  for (const V in o) {
    const q = typeof o[V] == "string" ? { injection: o[V], order: 0 } : o[V], j = /^(v|f)s:(#)?([\w-]+)$/.exec(V);
    if (j) {
      const K = j[2], Y = j[3];
      K ? Y === "decl" ? P[V] = [q] : L[V] = [q] : E[V] = [q];
    } else
      L[V] = [q];
  }
  const U = i;
  for (const V of U) {
    l && PB(V, u, l);
    const q = kB(V, "wgsl");
    m += q;
    const j = V.injections?.[n] || {};
    for (const K in j) {
      const Y = /^(v|f)s:#([\w-]+)$/.exec(K);
      if (Y) {
        const ne = Y[2] === "decl" ? P : L;
        ne[K] = ne[K] || [], ne[K].push(j[K]);
      } else
        E[K] = E[K] || [], E[K].push(j[K]);
    }
  }
  return m += DB, m = Wm(m, n, P), m += BB(y[n], E), m += u, m = Wm(m, n, L), m;
}
function VE(r, e) {
  const { source: t, stage: n, language: i = "glsl", modules: s, defines: o = {}, hookFunctions: l = [], inject: u = {}, prologue: m = !0, log: y } = e;
  ax(typeof t == "string", "shader source must be a string");
  const E = i === "glsl" ? Qz(t).version : -1, P = r.shaderLanguageVersion, L = E === 100 ? "#version 100" : "#version 300 es", V = t.split(`
`).slice(1).join(`
`), q = {};
  s.forEach((ae) => {
    Object.assign(q, ae.defines);
  }), Object.assign(q, o);
  let j = "";
  switch (i) {
    case "wgsl":
      break;
    case "glsl":
      j = m ? `${L}

// ----- PROLOGUE -------------------------
${`#define SHADER_TYPE_${n.toUpperCase()}`}

${Xz(r)}
${n === "fragment" ? t9 : ""}

// ----- APPLICATION DEFINES -------------------------

${s9(q)}

` : `${L}
`;
      break;
  }
  const K = OB(l), Y = {}, de = {}, ne = {};
  for (const ae in u) {
    const De = typeof u[ae] == "string" ? { injection: u[ae], order: 0 } : u[ae], Ge = /^(v|f)s:(#)?([\w-]+)$/.exec(ae);
    if (Ge) {
      const fe = Ge[2], ve = Ge[3];
      fe ? ve === "decl" ? de[ae] = [De] : ne[ae] = [De] : Y[ae] = [De];
    } else
      ne[ae] = [De];
  }
  for (const ae of s) {
    y && PB(ae, V, y);
    const De = kB(ae, n);
    j += De;
    const Ge = ae.instance?.normalizedInjections[n] || {};
    for (const fe in Ge) {
      const ve = /^(v|f)s:#([\w-]+)$/.exec(fe);
      if (ve) {
        const X = ve[2] === "decl" ? de : ne;
        X[fe] = X[fe] || [], X[fe].push(Ge[fe]);
      } else
        Y[fe] = Y[fe] || [], Y[fe].push(Ge[fe]);
    }
  }
  return j += "// ----- MAIN SHADER SOURCE -------------------------", j += DB, j = Wm(j, n, de), j += BB(K[n], Y), j += V, j = Wm(j, n, ne), i === "glsl" && E !== P && (j = Zz(j, n)), j.trim();
}
function LB(r) {
  return function(t) {
    const n = {};
    for (const i of r) {
      const s = i.getUniforms?.(t, n);
      Object.assign(n, s);
    }
    return n;
  };
}
function s9(r = {}) {
  let e = "";
  for (const t in r) {
    const n = r[t];
    (n || Number.isFinite(n)) && (e += `#define ${t.toUpperCase()} ${r[t]}
`);
  }
  return e;
}
function kB(r, e) {
  let t;
  switch (e) {
    case "vertex":
      t = r.vs || "";
      break;
    case "fragment":
      t = r.fs || "";
      break;
    case "wgsl":
      t = r.source || "";
      break;
    default:
      ax(!1);
  }
  if (!r.name)
    throw new Error("Shader module must have a name");
  const n = r.name.toUpperCase().replace(/[^0-9a-z]/gi, "_");
  let i = `// ----- MODULE ${r.name} ---------------

`;
  return e !== "wgsl" && (i += `#define MODULE_${n}
`), i += `${t}
`, i;
}
const o9 = /^\s*\#\s*ifdef\s*([a-zA-Z_]+)\s*$/, a9 = /^\s*\#\s*endif\s*$/;
function l9(r, e) {
  const t = r.split(`
`), n = [];
  let i = !0, s = null;
  for (const o of t) {
    const l = o.match(o9), u = o.match(a9);
    l ? (s = l[1], i = !!e?.defines?.[s]) : u ? i = !0 : i && n.push(o);
  }
  return n.join(`
`);
}
class Hf {
  /** Default ShaderAssembler instance */
  static defaultShaderAssembler;
  /** Hook functions */
  _hookFunctions = [];
  /** Shader modules */
  _defaultModules = [];
  /**
   * A default shader assembler instance - the natural place to register default modules and hooks
   * @returns
   */
  static getDefaultShaderAssembler() {
    return Hf.defaultShaderAssembler = Hf.defaultShaderAssembler || new Hf(), Hf.defaultShaderAssembler;
  }
  /**
   * Add a default module that does not have to be provided with every call to assembleShaders()
   */
  addDefaultModule(e) {
    this._defaultModules.find((t) => t.name === (typeof e == "string" ? e : e.name)) || this._defaultModules.push(e);
  }
  /**
   * Remove a default module
   */
  removeDefaultModule(e) {
    const t = typeof e == "string" ? e : e.name;
    this._defaultModules = this._defaultModules.filter((n) => n.name !== t);
  }
  /**
   * Register a shader hook
   * @param hook
   * @param opts
   */
  addShaderHook(e, t) {
    t && (e = Object.assign(t, { hook: e })), this._hookFunctions.push(e);
  }
  /**
   * Assemble a WGSL unified shader
   * @param platformInfo
   * @param props
   * @returns
   */
  assembleWGSLShader(e) {
    const t = this._getModuleList(e.modules), n = this._hookFunctions, { source: i, getUniforms: s } = r9({
      ...e,
      // @ts-expect-error
      source: e.source,
      modules: t,
      hookFunctions: n
    });
    return { source: e.platformInfo.shaderLanguage === "wgsl" ? l9(i) : i, getUniforms: s, modules: t };
  }
  /**
   * Assemble a pair of shaders into a single shader program
   * @param platformInfo
   * @param props
   * @returns
   */
  assembleGLSLShaderPair(e) {
    const t = this._getModuleList(e.modules), n = this._hookFunctions;
    return { ...n9({
      ...e,
      // @ts-expect-error
      vs: e.vs,
      // @ts-expect-error
      fs: e.fs,
      modules: t,
      hookFunctions: n
    }), modules: t };
  }
  /**
   * Dedupe and combine with default modules
   */
  _getModuleList(e = []) {
    const t = new Array(this._defaultModules.length + e.length), n = {};
    let i = 0;
    for (let s = 0, o = this._defaultModules.length; s < o; ++s) {
      const l = this._defaultModules[s], u = l.name;
      t[i++] = l, n[u] = !0;
    }
    for (let s = 0, o = e.length; s < o; ++s) {
      const l = e[s], u = l.name;
      n[u] || (t[i++] = l, n[u] = !0);
    }
    return t.length = i, $m(t), t;
  }
}
const c9 = (
  /* glsl */
  `out vec4 transform_output;
void main() {
  transform_output = vec4(0);
}`
), u9 = `#version 300 es
${c9}`;
function FB(r) {
  const { input: e, inputChannels: t, output: n } = r || {};
  if (!e)
    return u9;
  if (!t)
    throw new Error("inputChannels");
  const i = f9(t), s = h9(e, t);
  return `#version 300 es
in ${i} ${e};
out vec4 ${n};
void main() {
  ${n} = ${s};
}`;
}
function f9(r) {
  switch (r) {
    case 1:
      return "float";
    case 2:
      return "vec2";
    case 3:
      return "vec3";
    case 4:
      return "vec4";
    default:
      throw new Error(`invalid channels: ${r}`);
  }
}
function h9(r, e) {
  switch (e) {
    case 1:
      return `vec4(${r}, 0.0, 0.0, 1.0)`;
    case 2:
      return `vec4(${r}, 0.0, 1.0)`;
    case 3:
      return `vec4(${r}, 1.0)`;
    case 4:
      return r;
    default:
      throw new Error(`invalid channels: ${e}`);
  }
}
class d9 {
  stats = /* @__PURE__ */ new Map();
  getStats(e) {
    return this.get(e);
  }
  get(e) {
    return this.stats.has(e) || this.stats.set(e, new Bp({ id: e })), this.stats.get(e);
  }
}
const NB = new d9(), qt = new Rp({ id: "luma.gl" }), yv = {};
function B_(r = "id") {
  yv[r] = yv[r] || 1;
  const e = yv[r]++;
  return `${r}-${e}`;
}
let di = class {
  /** Default properties for resource */
  static defaultProps = {
    id: "undefined",
    handle: void 0,
    userData: void 0
  };
  toString() {
    return `${this[Symbol.toStringTag] || this.constructor.name}:"${this.id}"`;
  }
  /** props.id, for debugging. */
  id;
  props;
  userData = {};
  _device;
  /** Whether this resource has been destroyed */
  destroyed = !1;
  /** For resources that allocate GPU memory */
  allocatedBytes = 0;
  /** Attached resources will be destroyed when this resource is destroyed. Tracks auto-created "sub" resources. */
  _attachedResources = /* @__PURE__ */ new Set();
  /**
   * Create a new Resource. Called from Subclass
   */
  constructor(e, t, n) {
    if (!e)
      throw new Error("no device");
    this._device = e, this.props = p9(t, n);
    const i = this.props.id !== "undefined" ? this.props.id : B_(this[Symbol.toStringTag]);
    this.props.id = i, this.id = i, this.userData = this.props.userData || {}, this.addStats();
  }
  /**
   * destroy can be called on any resource to release it before it is garbage collected.
   */
  destroy() {
    this.destroyResource();
  }
  /** @deprecated Use destroy() */
  delete() {
    return this.destroy(), this;
  }
  /**
   * Combines a map of user props and default props, only including props from defaultProps
   * @returns returns a map of overridden default props
   */
  getProps() {
    return this.props;
  }
  // ATTACHED RESOURCES
  /**
   * Attaches a resource. Attached resources are auto destroyed when this resource is destroyed
   * Called automatically when sub resources are auto created but can be called by application
   */
  attachResource(e) {
    this._attachedResources.add(e);
  }
  /**
   * Detach an attached resource. The resource will no longer be auto-destroyed when this resource is destroyed.
   */
  detachResource(e) {
    this._attachedResources.delete(e);
  }
  /**
   * Destroys a resource (only if owned), and removes from the owned (auto-destroy) list for this resource.
   */
  destroyAttachedResource(e) {
    this._attachedResources.delete(e) && e.destroy();
  }
  /** Destroy all owned resources. Make sure the resources are no longer needed before calling. */
  destroyAttachedResources() {
    for (const e of Object.values(this._attachedResources))
      e.destroy();
    this._attachedResources = /* @__PURE__ */ new Set();
  }
  // PROTECTED METHODS
  /** Perform all destroy steps. Can be called by derived resources when overriding destroy() */
  destroyResource() {
    this.destroyAttachedResources(), this.removeStats(), this.destroyed = !0;
  }
  /** Called by .destroy() to track object destruction. Subclass must call if overriding destroy() */
  removeStats() {
    const e = this._device.statsManager.getStats("Resource Counts"), t = this[Symbol.toStringTag];
    e.get(`${t}s Active`).decrementCount();
  }
  /** Called by subclass to track memory allocations */
  trackAllocatedMemory(e, t = this[Symbol.toStringTag]) {
    const n = this._device.statsManager.getStats("Resource Counts");
    n.get("GPU Memory").addCount(e), n.get(`${t} Memory`).addCount(e), this.allocatedBytes = e;
  }
  /** Called by subclass to track memory deallocations */
  trackDeallocatedMemory(e = this[Symbol.toStringTag]) {
    const t = this._device.statsManager.getStats("Resource Counts");
    t.get("GPU Memory").subtractCount(this.allocatedBytes), t.get(`${e} Memory`).subtractCount(this.allocatedBytes), this.allocatedBytes = 0;
  }
  /** Called by resource constructor to track object creation */
  addStats() {
    const e = this._device.statsManager.getStats("Resource Counts"), t = this[Symbol.toStringTag];
    e.get("Resources Created").incrementCount(), e.get(`${t}s Created`).incrementCount(), e.get(`${t}s Active`).incrementCount();
  }
};
function p9(r, e) {
  const t = { ...e };
  for (const n in r)
    r[n] !== void 0 && (t[n] = r[n]);
  return t;
}
class vi extends di {
  /** Index buffer */
  static INDEX = 16;
  /** Vertex buffer */
  static VERTEX = 32;
  /** Uniform buffer */
  static UNIFORM = 64;
  /** Storage buffer */
  static STORAGE = 128;
  static INDIRECT = 256;
  static QUERY_RESOLVE = 512;
  // Usage Flags
  static MAP_READ = 1;
  static MAP_WRITE = 2;
  static COPY_SRC = 4;
  static COPY_DST = 8;
  get [Symbol.toStringTag]() {
    return "Buffer";
  }
  /** The usage with which this buffer was created */
  usage;
  /** For index buffers, whether indices are 16 or 32 bit */
  indexType;
  /** "Time" of last update, can be used to check if redraw is needed */
  updateTimestamp;
  constructor(e, t) {
    const n = { ...t };
    (t.usage || 0) & vi.INDEX && !t.indexType && (t.data instanceof Uint32Array ? n.indexType = "uint32" : t.data instanceof Uint16Array && (n.indexType = "uint16")), delete n.data, super(e, n, vi.defaultProps), this.usage = n.usage || 0, this.indexType = n.indexType, this.updateTimestamp = e.incrementTimestamp();
  }
  /**
   * Create a copy of this Buffer with new byteLength, with same props but of the specified size.
   * @note Does not copy contents of the cloned Buffer.
   */
  clone(e) {
    return this.device.createBuffer({ ...this.props, ...e });
  }
  // PROTECTED METHODS (INTENDED FOR USE BY OTHER FRAMEWORK CODE ONLY)
  /** Max amount of debug data saved. Two vec4's */
  static DEBUG_DATA_MAX_LENGTH = 32;
  /** A partial CPU-side copy of the data in this buffer, for debugging purposes */
  debugData = new ArrayBuffer(0);
  /** This doesn't handle partial non-zero offset updates correctly */
  _setDebugData(e, t, n) {
    const i = ArrayBuffer.isView(e) ? e.buffer : e, s = Math.min(e ? e.byteLength : n, vi.DEBUG_DATA_MAX_LENGTH);
    i === null ? this.debugData = new ArrayBuffer(s) : t === 0 && n === i.byteLength ? this.debugData = i.slice(0, s) : this.debugData = i.slice(t, t + s);
  }
  static defaultProps = {
    ...di.defaultProps,
    usage: 0,
    // Buffer.COPY_DST | Buffer.COPY_SRC
    byteLength: 0,
    byteOffset: 0,
    data: null,
    indexType: "uint16",
    onMapped: void 0
  };
}
function UB(r) {
  const [e, t, n] = fx[r], i = r.includes("norm"), s = !i && !r.startsWith("float"), o = r.startsWith("s");
  return {
    signedType: e,
    primitiveType: t,
    byteLength: n,
    normalized: i,
    integer: s,
    signed: o
  };
}
function A9(r) {
  const e = r;
  switch (e) {
    case "uint8":
      return "unorm8";
    case "sint8":
      return "snorm8";
    case "uint16":
      return "unorm16";
    case "sint16":
      return "snorm16";
    default:
      return e;
  }
}
function g9(r, e) {
  switch (e) {
    case 1:
      return r;
    // Pad upwards to even multiple of 2
    case 2:
      return r + r % 2;
    // Pad upwards to even multiple of 2
    default:
      return r + (4 - r % 4) % 4;
  }
}
function cx(r) {
  const e = ArrayBuffer.isView(r) ? r.constructor : r;
  if (e === Uint8ClampedArray)
    return "uint8";
  const t = Object.values(fx).find((n) => e === n[4]);
  if (!t)
    throw new Error(e.name);
  return t[0];
}
function ux(r) {
  const [, , , , e] = fx[r];
  return e;
}
const fx = {
  uint8: ["uint8", "u32", 1, !1, Uint8Array],
  sint8: ["sint8", "i32", 1, !1, Int8Array],
  unorm8: ["uint8", "f32", 1, !0, Uint8Array],
  snorm8: ["sint8", "f32", 1, !0, Int8Array],
  uint16: ["uint16", "u32", 2, !1, Uint16Array],
  sint16: ["sint16", "i32", 2, !1, Int16Array],
  unorm16: ["uint16", "u32", 2, !0, Uint16Array],
  snorm16: ["sint16", "i32", 2, !0, Int16Array],
  float16: ["float16", "f16", 2, !1, Uint16Array],
  float32: ["float32", "f32", 4, !1, Float32Array],
  uint32: ["uint32", "u32", 4, !1, Uint32Array],
  sint32: ["sint32", "i32", 4, !1, Int32Array]
};
function hx(r) {
  let e;
  r.endsWith("-webgl") && (r.replace("-webgl", ""), e = !0);
  const [t, n] = r.split("x"), i = t, s = n ? parseInt(n) : 1, o = UB(i), l = {
    type: i,
    components: s,
    byteLength: o.byteLength * s,
    integer: o.integer,
    signed: o.signed,
    normalized: o.normalized
  };
  return e && (l.webglOnly = !0), l;
}
function m9(r, e, t) {
  const n = t ? A9(r) : r;
  switch (n) {
    // TODO - Special cases for WebGL (not supported on WebGPU), overrides the check below
    case "unorm8":
      return e === 1 ? "unorm8" : e === 3 ? "unorm8x3-webgl" : `${n}x${e}`;
    case "snorm8":
    case "uint8":
    case "sint8":
    // WebGPU 8 bit formats must be aligned to 16 bit boundaries');
    // fall through
    case "uint16":
    case "sint16":
    case "unorm16":
    case "snorm16":
    case "float16":
      if (e === 1 || e === 3)
        throw new Error(`size: ${e}`);
      return `${n}x${e}`;
    default:
      return e === 1 ? n : `${n}x${e}`;
  }
}
function _9(r, e, t) {
  if (!e || e > 4)
    throw new Error(`size ${e}`);
  const n = e, i = cx(r);
  return m9(i, n, t);
}
function y9(r) {
  let e;
  switch (r.primitiveType) {
    case "f32":
      e = "float32";
      break;
    case "i32":
      e = "sint32";
      break;
    case "u32":
      e = "uint32";
      break;
    case "f16":
      return r.components <= 2 ? "float16x2" : "float16x4";
  }
  return r.components === 1 ? e : `${e}x${r.components}`;
}
const fo = "texture-compression-bc", hi = "texture-compression-astc", Zl = "texture-compression-etc2", v9 = "texture-compression-etc1-webgl", fg = "texture-compression-pvrtc-webgl", vv = "texture-compression-atc-webgl", hg = "float32-renderable-webgl", bv = "float16-renderable-webgl", b9 = "rgb9e5ufloat-renderable-webgl", xv = "snorm8-renderable-webgl", mA = "norm16-renderable-webgl", wv = "snorm16-renderable-webgl", dg = "float32-filterable", jE = "float16-filterable-webgl";
function zB(r) {
  const e = T9[r];
  if (!e)
    throw new Error(`Unsupported texture format ${r}`);
  return e;
}
const x9 = {
  // 8-bit formats
  r8unorm: {},
  rg8unorm: {},
  "rgb8unorm-webgl": {},
  rgba8unorm: {},
  "rgba8unorm-srgb": {},
  r8snorm: { render: xv },
  rg8snorm: { render: xv },
  "rgb8snorm-webgl": {},
  rgba8snorm: { render: xv },
  r8uint: {},
  rg8uint: {},
  rgba8uint: {},
  r8sint: {},
  rg8sint: {},
  rgba8sint: {},
  bgra8unorm: {},
  "bgra8unorm-srgb": {},
  r16unorm: { f: mA },
  rg16unorm: { render: mA },
  "rgb16unorm-webgl": { f: mA },
  // rgb not renderable
  rgba16unorm: { render: mA },
  r16snorm: { f: wv },
  rg16snorm: { render: wv },
  "rgb16snorm-webgl": { f: mA },
  // rgb not renderable
  rgba16snorm: { render: wv },
  r16uint: {},
  rg16uint: {},
  rgba16uint: {},
  r16sint: {},
  rg16sint: {},
  rgba16sint: {},
  r16float: { render: bv, filter: "float16-filterable-webgl" },
  rg16float: { render: bv, filter: jE },
  rgba16float: { render: bv, filter: jE },
  r32uint: {},
  rg32uint: {},
  rgba32uint: {},
  r32sint: {},
  rg32sint: {},
  rgba32sint: {},
  r32float: { render: hg, filter: dg },
  rg32float: { render: !1, filter: dg },
  "rgb32float-webgl": { render: hg, filter: dg },
  rgba32float: { render: hg, filter: dg },
  // Packed 16-bit formats
  "rgba4unorm-webgl": { channels: "rgba", bitsPerChannel: [4, 4, 4, 4], packed: !0 },
  "rgb565unorm-webgl": { channels: "rgb", bitsPerChannel: [5, 6, 5, 0], packed: !0 },
  "rgb5a1unorm-webgl": { channels: "rgba", bitsPerChannel: [5, 5, 5, 1], packed: !0 },
  // Packed 32 bit formats
  rgb9e5ufloat: { channels: "rgb", packed: !0, render: b9 },
  // , filter: true},
  rg11b10ufloat: { channels: "rgb", bitsPerChannel: [11, 11, 10, 0], packed: !0, p: 1, render: hg },
  rgb10a2unorm: { channels: "rgba", bitsPerChannel: [10, 10, 10, 2], packed: !0, p: 1 },
  rgb10a2uint: { channels: "rgba", bitsPerChannel: [10, 10, 10, 2], packed: !0, p: 1 },
  // Depth/stencil Formats
  // Depth and stencil formats
  stencil8: { attachment: "stencil", bitsPerChannel: [8, 0, 0, 0], dataType: "uint8" },
  depth16unorm: { attachment: "depth", bitsPerChannel: [16, 0, 0, 0], dataType: "uint16" },
  depth24plus: { attachment: "depth", bitsPerChannel: [24, 0, 0, 0], dataType: "uint32" },
  depth32float: { attachment: "depth", bitsPerChannel: [32, 0, 0, 0], dataType: "float32" },
  // The depth component of the "depth24plus" and "depth24plus-stencil8" formats may be implemented as either a 24-bit depth value or a "depth32float" value.
  "depth24plus-stencil8": { attachment: "depth-stencil", bitsPerChannel: [24, 8, 0, 0], packed: !0 },
  // "depth32float-stencil8" feature
  "depth32float-stencil8": { attachment: "depth-stencil", bitsPerChannel: [32, 8, 0, 0], packed: !0 }
}, w9 = {
  // BC compressed formats: check device.features.has("texture-compression-bc");
  "bc1-rgb-unorm-webgl": { f: fo },
  "bc1-rgb-unorm-srgb-webgl": { f: fo },
  "bc1-rgba-unorm": { f: fo },
  "bc1-rgba-unorm-srgb": { f: fo },
  "bc2-rgba-unorm": { f: fo },
  "bc2-rgba-unorm-srgb": { f: fo },
  "bc3-rgba-unorm": { f: fo },
  "bc3-rgba-unorm-srgb": { f: fo },
  "bc4-r-unorm": { f: fo },
  "bc4-r-snorm": { f: fo },
  "bc5-rg-unorm": { f: fo },
  "bc5-rg-snorm": { f: fo },
  "bc6h-rgb-ufloat": { f: fo },
  "bc6h-rgb-float": { f: fo },
  "bc7-rgba-unorm": { f: fo },
  "bc7-rgba-unorm-srgb": { f: fo },
  // WEBGL_compressed_texture_etc: device.features.has("texture-compression-etc2")
  // Note: Supposedly guaranteed availability compressed formats in WebGL2, but through CPU decompression
  "etc2-rgb8unorm": { f: Zl },
  "etc2-rgb8unorm-srgb": { f: Zl },
  "etc2-rgb8a1unorm": { f: Zl },
  "etc2-rgb8a1unorm-srgb": { f: Zl },
  "etc2-rgba8unorm": { f: Zl },
  "etc2-rgba8unorm-srgb": { f: Zl },
  "eac-r11unorm": { f: Zl },
  "eac-r11snorm": { f: Zl },
  "eac-rg11unorm": { f: Zl },
  "eac-rg11snorm": { f: Zl },
  // X_ASTC compressed formats: device.features.has("texture-compression-astc")
  "astc-4x4-unorm": { f: hi },
  "astc-4x4-unorm-srgb": { f: hi },
  "astc-5x4-unorm": { f: hi },
  "astc-5x4-unorm-srgb": { f: hi },
  "astc-5x5-unorm": { f: hi },
  "astc-5x5-unorm-srgb": { f: hi },
  "astc-6x5-unorm": { f: hi },
  "astc-6x5-unorm-srgb": { f: hi },
  "astc-6x6-unorm": { f: hi },
  "astc-6x6-unorm-srgb": { f: hi },
  "astc-8x5-unorm": { f: hi },
  "astc-8x5-unorm-srgb": { f: hi },
  "astc-8x6-unorm": { f: hi },
  "astc-8x6-unorm-srgb": { f: hi },
  "astc-8x8-unorm": { f: hi },
  "astc-8x8-unorm-srgb": { f: hi },
  "astc-10x5-unorm": { f: hi },
  "astc-10x5-unorm-srgb": { f: hi },
  "astc-10x6-unorm": { f: hi },
  "astc-10x6-unorm-srgb": { f: hi },
  "astc-10x8-unorm": { f: hi },
  "astc-10x8-unorm-srgb": { f: hi },
  "astc-10x10-unorm": { f: hi },
  "astc-10x10-unorm-srgb": { f: hi },
  "astc-12x10-unorm": { f: hi },
  "astc-12x10-unorm-srgb": { f: hi },
  "astc-12x12-unorm": { f: hi },
  "astc-12x12-unorm-srgb": { f: hi },
  // WEBGL_compressed_texture_pvrtc
  "pvrtc-rgb4unorm-webgl": { f: fg },
  "pvrtc-rgba4unorm-webgl": { f: fg },
  "pvrtc-rbg2unorm-webgl": { f: fg },
  "pvrtc-rgba2unorm-webgl": { f: fg },
  // WEBGL_compressed_texture_etc1
  "etc1-rbg-unorm-webgl": { f: v9 },
  // WEBGL_compressed_texture_atc
  "atc-rgb-unorm-webgl": { f: vv },
  "atc-rgba-unorm-webgl": { f: vv },
  "atc-rgbai-unorm-webgl": { f: vv }
}, T9 = {
  ...x9,
  ...w9
}, E9 = [
  "bc1",
  "bc2",
  "bc3",
  "bc4",
  "bc5",
  "bc6",
  "bc7",
  "etc1",
  "etc2",
  "eac",
  "atc",
  "astc",
  "pvrtc"
], C9 = /^(r|rg|rgb|rgba|bgra)([0-9]*)([a-z]*)(-srgb)?(-webgl)?$/;
class S9 {
  /** Returns information about a texture format, e.g. attatchment type, components, byte length and flags (integer, signed, normalized) */
  getInfo(e) {
    return HE(e);
  }
  /** Checks if a texture format is color */
  isColor(e) {
    return e.startsWith("rgba") || e.startsWith("bgra") || e.startsWith("rgb");
  }
  /** Checks if a texture format is depth or stencil */
  isDepthStencil(e) {
    return e.startsWith("depth") || e.startsWith("stencil");
  }
  /** Checks if a texture format is compressed */
  isCompressed(e) {
    return E9.some((t) => e.startsWith(t));
  }
  /**
   * Returns the "static" capabilities of a texture format.
   * @note Needs to be checked against current device
   */
  getCapabilities(e) {
    const t = zB(e), n = {
      format: e,
      create: t.f ?? !0,
      render: t.render ?? !0,
      filter: t.filter ?? !0,
      blend: t.blend ?? !0,
      store: t.store ?? !0
    }, i = HE(e), s = e.startsWith("depth") || e.startsWith("stencil"), o = i?.signed, l = i?.integer, u = i?.webgl;
    return n.render &&= !o, n.filter &&= !s && !o && !l && !u, n;
  }
}
const ip = new S9();
function HE(r) {
  let e = I9(r);
  if (ip.isCompressed(r)) {
    e.channels = "rgb", e.components = 3, e.bytesPerPixel = 1, e.srgb = !1, e.compressed = !0;
    const n = P9(r);
    n && (e.blockWidth = n.blockWidth, e.blockHeight = n.blockHeight);
  }
  const t = C9.exec(r);
  if (t) {
    const [, n, i, s, o, l] = t, u = `${s}${i}`, m = UB(u), y = m.byteLength * 8, E = n.length, P = [
      y,
      E >= 2 ? y : 0,
      E >= 3 ? y : 0,
      E >= 4 ? y : 0
    ];
    e = {
      format: r,
      attachment: e.attachment,
      dataType: m.signedType,
      components: E,
      channels: n,
      integer: m.integer,
      signed: m.signed,
      normalized: m.normalized,
      bitsPerChannel: P,
      bytesPerPixel: m.byteLength * n.length,
      packed: e.packed,
      srgb: e.srgb
    }, l === "-webgl" && (e.webgl = !0), o === "-srgb" && (e.srgb = !0);
  }
  return r.endsWith("-webgl") && (e.webgl = !0), r.endsWith("-srgb") && (e.srgb = !0), e;
}
function I9(r) {
  const e = zB(r), t = e.bytesPerPixel || 1, n = e.bitsPerChannel || [8, 8, 8, 8];
  return delete e.bitsPerChannel, delete e.bytesPerPixel, delete e.f, delete e.render, delete e.filter, delete e.blend, delete e.store, {
    ...e,
    format: r,
    attachment: e.attachment || "color",
    channels: e.channels || "r",
    components: e.components || e.channels?.length || 1,
    bytesPerPixel: t,
    bitsPerChannel: n,
    dataType: e.dataType || "uint8",
    srgb: e.srgb ?? !1,
    packed: e.packed ?? !1,
    webgl: e.webgl ?? !1,
    integer: e.integer ?? !1,
    signed: e.signed ?? !1,
    normalized: e.normalized ?? !1,
    compressed: e.compressed ?? !1
  };
}
function P9(r) {
  const t = /.*-(\d+)x(\d+)-.*/.exec(r);
  if (t) {
    const [, n, i] = t;
    return { blockWidth: Number(n), blockHeight: Number(i) };
  }
  return null;
}
function M9(r) {
  return typeof ImageData < "u" && r instanceof ImageData || typeof ImageBitmap < "u" && r instanceof ImageBitmap || typeof HTMLImageElement < "u" && r instanceof HTMLImageElement || typeof HTMLVideoElement < "u" && r instanceof HTMLVideoElement || typeof VideoFrame < "u" && r instanceof VideoFrame || typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement || typeof OffscreenCanvas < "u" && r instanceof OffscreenCanvas;
}
function R9(r) {
  if (typeof ImageData < "u" && r instanceof ImageData || typeof ImageBitmap < "u" && r instanceof ImageBitmap || typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement || typeof OffscreenCanvas < "u" && r instanceof OffscreenCanvas)
    return { width: r.width, height: r.height };
  if (typeof HTMLImageElement < "u" && r instanceof HTMLImageElement)
    return { width: r.naturalWidth, height: r.naturalHeight };
  if (typeof HTMLVideoElement < "u" && r instanceof HTMLVideoElement)
    return { width: r.videoWidth, height: r.videoHeight };
  if (typeof VideoFrame < "u" && r instanceof VideoFrame)
    return { width: r.displayWidth, height: r.displayHeight };
  throw new Error("Unknown image type");
}
class B9 {
}
class O9 {
  features;
  disabledFeatures;
  constructor(e = [], t) {
    this.features = new Set(e), this.disabledFeatures = t || {};
  }
  *[Symbol.iterator]() {
    yield* this.features;
  }
  has(e) {
    return !this.disabledFeatures?.[e] && this.features.has(e);
  }
}
class eh {
  static defaultProps = {
    id: null,
    powerPreference: "high-performance",
    failIfMajorPerformanceCaveat: !1,
    createCanvasContext: void 0,
    // WebGL specific
    webgl: {},
    // Callbacks
    // eslint-disable-next-line handle-callback-err
    onError: (e, t) => {
    },
    onResize: (e, t) => {
      const [n, i] = e.getDevicePixelSize();
      qt.log(1, `${e} resized => ${n}x${i}px`)();
    },
    onPositionChange: (e, t) => {
      const [n, i] = e.getPosition();
      qt.log(1, `${e} repositioned => ${n},${i}`)();
    },
    onVisibilityChange: (e) => qt.log(1, `${e} Visibility changed ${e.isVisible}`)(),
    onDevicePixelRatioChange: (e, t) => qt.log(1, `${e} DPR changed ${t.oldRatio} => ${e.devicePixelRatio}`)(),
    // Debug flags
    debug: qt.get("debug") || void 0,
    debugShaders: qt.get("debug-shaders") || void 0,
    debugFramebuffers: !!qt.get("debug-framebuffers"),
    debugFactories: !!qt.get("debug-factories"),
    debugWebGL: !!qt.get("debug-webgl"),
    debugSpectorJS: void 0,
    // Note: log setting is queried by the spector.js code
    debugSpectorJSUrl: void 0,
    // Experimental
    _reuseDevices: !1,
    _requestMaxLimits: !0,
    _cacheShaders: !1,
    _cachePipelines: !1,
    _cacheDestroyPolicy: "unused",
    // TODO - Change these after confirming things work as expected
    _initializeFeatures: !0,
    _disabledFeatures: {
      "compilation-status-async-webgl": !0
    },
    // INTERNAL
    _handle: void 0
  };
  get [Symbol.toStringTag]() {
    return "Device";
  }
  toString() {
    return `Device(${this.id})`;
  }
  /** id of this device, primarily for debugging */
  id;
  /** A copy of the device props  */
  props;
  /** Available for the application to store data on the device */
  userData = {};
  /** stats */
  statsManager = NB;
  /** An abstract timestamp used for change tracking */
  timestamp = 0;
  /** True if this device has been reused during device creation (app has multiple references) */
  _reused = !1;
  /** Used by other luma.gl modules to store data on the device */
  _lumaData = {};
  _textureCaps = {};
  constructor(e) {
    this.props = { ...eh.defaultProps, ...e }, this.id = this.props.id || B_(this[Symbol.toStringTag].toLowerCase());
  }
  getVertexFormatInfo(e) {
    return hx(e);
  }
  isVertexFormatSupported(e) {
    return !0;
  }
  /** Returns information about a texture format, such as data type, channels, bits per channel, compression etc */
  getTextureFormatInfo(e) {
    return ip.getInfo(e);
  }
  /** Determines what operations are supported on a texture format on this particular device (checks against supported device features) */
  getTextureFormatCapabilities(e) {
    let t = this._textureCaps[e];
    if (!t) {
      const n = this._getDeviceTextureFormatCapabilities(e);
      t = this._getDeviceSpecificTextureFormatCapabilities(n), this._textureCaps[e] = t;
    }
    return t;
  }
  /** Calculates the number of mip levels for a texture of width, height and in case of 3d textures only, depth */
  getMipLevelCount(e, t, n = 1) {
    const i = Math.max(e, t, n);
    return 1 + Math.floor(Math.log2(i));
  }
  /** Check if data is an external image */
  isExternalImage(e) {
    return M9(e);
  }
  /** Get the size of an external image */
  getExternalImageSize(e) {
    return R9(e);
  }
  /** Check if device supports a specific texture format (creation and `nearest` sampling) */
  isTextureFormatSupported(e) {
    return this.getTextureFormatCapabilities(e).create;
  }
  /** Check if linear filtering (sampler interpolation) is supported for a specific texture format */
  isTextureFormatFilterable(e) {
    return this.getTextureFormatCapabilities(e).filter;
  }
  /** Check if device supports rendering to a framebuffer color attachment of a specific texture format */
  isTextureFormatRenderable(e) {
    return this.getTextureFormatCapabilities(e).render;
  }
  /** Check if a specific texture format is GPU compressed */
  isTextureFormatCompressed(e) {
    return ip.isCompressed(e);
  }
  // DEBUG METHODS
  pushDebugGroup(e) {
    this.commandEncoder.pushDebugGroup(e);
  }
  popDebugGroup() {
    this.commandEncoder?.popDebugGroup();
  }
  insertDebugMarker(e) {
    this.commandEncoder?.insertDebugMarker(e);
  }
  /**
   * Trigger device loss.
   * @returns `true` if context loss could actually be triggered.
   * @note primarily intended for testing how application reacts to device loss
   */
  loseDevice() {
    return !1;
  }
  /** A monotonic counter for tracking buffer and texture updates */
  incrementTimestamp() {
    return this.timestamp++;
  }
  /**
   * Reports Device errors in a way that optimizes for developer experience / debugging.
   * - Logs so that the console error links directly to the source code that generated the error.
   * - Includes the object that reported the error in the log message, even if the error is asynchronous.
   *
   * Conventions when calling reportError():
   * - Always call the returned function - to ensure error is logged, at the error site
   * - Follow with a call to device.debug() - to ensure that the debugger breaks at the error site
   *
   * @param error - the error to report. If needed, just create a new Error object with the appropriate message.
   * @param context - pass `this` as context, otherwise it may not be available in the debugger for async errors.
   * @returns the logger function returned by device.props.onError() so that it can be called from the error site.
   *
   * @example
   *   device.reportError(new Error(...), this)();
   *   device.debug();
   */
  reportError(e, t, ...n) {
    return this.props.onError(e, t) ? () => {
    } : qt.error(e.message, t, ...n);
  }
  /** Break in the debugger - if device.props.debug is true */
  debug() {
    if (this.props.debug)
      debugger;
    else
      qt.once(0, `'Type luma.log.set({debug: true}) in console to enable debug breakpoints',
or create a device with the 'debug: true' prop.`)();
  }
  /** Returns the default / primary canvas context. Throws an error if no canvas context is available (a WebGPU compute device) */
  getDefaultCanvasContext() {
    if (!this.canvasContext)
      throw new Error("Device has no default CanvasContext. See props.createCanvasContext");
    return this.canvasContext;
  }
  /** Create a RenderPass using the default CommandEncoder */
  beginRenderPass(e) {
    return this.commandEncoder.beginRenderPass(e);
  }
  /** Create a ComputePass using the default CommandEncoder*/
  beginComputePass(e) {
    return this.commandEncoder.beginComputePass(e);
  }
  // DEPRECATED METHODS
  /** @deprecated Use getDefaultCanvasContext() */
  getCanvasContext() {
    return this.getDefaultCanvasContext();
  }
  // WebGL specific HACKS - enables app to remove webgl import
  // Use until we have a better way to handle these
  /** @deprecated - will be removed - should use command encoder */
  readPixelsToArrayWebGL(e, t) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use command encoder */
  readPixelsToBufferWebGL(e, t) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
  setParametersWebGL(e) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
  getParametersWebGL(e) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
  withParametersWebGL(e, t) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use clear arguments in RenderPass */
  clearWebGL(e) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use for debugging only */
  resetWebGL() {
    throw new Error("not implemented");
  }
  // IMPLEMENTATION
  /** Helper to get the canvas context props */
  static _getCanvasContextProps(e) {
    return e.createCanvasContext === !0 ? {} : e.createCanvasContext;
  }
  _getDeviceTextureFormatCapabilities(e) {
    const t = ip.getCapabilities(e), n = (s) => (typeof s == "string" ? this.features.has(s) : s) ?? !0, i = n(t.create);
    return {
      format: e,
      create: i,
      render: i && n(t.render),
      filter: i && n(t.filter),
      blend: i && n(t.blend),
      store: i && n(t.store)
    };
  }
  /** Subclasses use this to support .createBuffer() overloads */
  _normalizeBufferProps(e) {
    (e instanceof ArrayBuffer || ArrayBuffer.isView(e)) && (e = { data: e });
    const t = { ...e };
    if ((e.usage || 0) & vi.INDEX && (e.indexType || (e.data instanceof Uint32Array ? t.indexType = "uint32" : e.data instanceof Uint16Array && (t.indexType = "uint16")), !t.indexType))
      throw new Error("indices buffer content must be of type uint16 or uint32");
    return t;
  }
}
const D9 = "set luma.log.level=1 (or higher) to trace rendering", GE = "No matching device found. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.";
class qm {
  static defaultProps = {
    ...eh.defaultProps,
    type: "best-available",
    adapters: void 0,
    waitForPageLoad: !0
  };
  /** Global stats for all devices */
  stats = NB;
  /**
   * Global log
   *
   * Assign luma.log.level in console to control logging: \
   * 0: none, 1: minimal, 2: verbose, 3: attribute/uniforms, 4: gl logs
   * luma.log.break[], set to gl funcs, luma.log.profile[] set to model names`;
   */
  log = qt;
  /** Version of luma.gl */
  VERSION = (
    // Version detection using build plugin
    // @ts-expect-error no-undef
    "9.2.4"
  );
  spector;
  preregisteredAdapters = /* @__PURE__ */ new Map();
  constructor() {
    if (globalThis.luma) {
      if (globalThis.luma.VERSION !== this.VERSION)
        throw qt.error(`Found luma.gl ${globalThis.luma.VERSION} while initialzing ${this.VERSION}`)(), qt.error("'yarn why @luma.gl/core' can help identify the source of the conflict")(), new Error("luma.gl - multiple versions detected: see console log");
      qt.error("This version of luma.gl has already been initialized")();
    }
    qt.log(1, `${this.VERSION} - ${D9}`)(), globalThis.luma = this;
  }
  /** Creates a device. Asynchronously. */
  async createDevice(e = {}) {
    const t = { ...qm.defaultProps, ...e }, n = this.selectAdapter(t.type, t.adapters);
    if (!n)
      throw new Error(GE);
    return t.waitForPageLoad && await n.pageLoaded, await n.create(t);
  }
  /**
   * Attach to an existing GPU API handle (WebGL2RenderingContext or GPUDevice).
   * @param handle Externally created WebGL context or WebGPU device
   */
  async attachDevice(e, t) {
    const n = this._getTypeFromHandle(e, t.adapters), i = n && this.selectAdapter(n, t.adapters);
    if (!i)
      throw new Error(GE);
    return await i?.attach?.(e, t);
  }
  /**
   * Global adapter registration.
   * @deprecated Use props.adapters instead
   */
  registerAdapters(e) {
    for (const t of e)
      this.preregisteredAdapters.set(t.type, t);
  }
  /** Get type strings for supported Devices */
  getSupportedAdapters(e = []) {
    const t = this._getAdapterMap(e);
    return Array.from(t).map(([, n]) => n).filter((n) => n.isSupported?.()).map((n) => n.type);
  }
  /** Get type strings for best available Device */
  getBestAvailableAdapterType(e = []) {
    const t = ["webgpu", "webgl", "null"], n = this._getAdapterMap(e);
    for (const i of t)
      if (n.get(i)?.isSupported?.())
        return i;
    return null;
  }
  /** Select adapter of type from registered adapters */
  selectAdapter(e, t = []) {
    let n = e;
    e === "best-available" && (n = this.getBestAvailableAdapterType(t));
    const i = this._getAdapterMap(t);
    return n && i.get(n) || null;
  }
  /**
   * Override `HTMLCanvasContext.getCanvas()` to always create WebGL2 contexts with additional WebGL1 compatibility.
   * Useful when attaching luma to a context from an external library does not support creating WebGL2 contexts.
   */
  enforceWebGL2(e = !0, t = []) {
    const i = this._getAdapterMap(t).get("webgl");
    i || qt.warn("enforceWebGL2: webgl adapter not found")(), i?.enforceWebGL2?.(e);
  }
  // DEPRECATED
  /** @deprecated */
  setDefaultDeviceProps(e) {
    Object.assign(qm.defaultProps, e);
  }
  // HELPERS
  /** Convert a list of adapters to a map */
  _getAdapterMap(e = []) {
    const t = new Map(this.preregisteredAdapters);
    for (const n of e)
      t.set(n.type, n);
    return t;
  }
  /** Get type of a handle (for attachDevice) */
  _getTypeFromHandle(e, t = []) {
    return e instanceof WebGL2RenderingContext ? "webgl" : typeof GPUDevice < "u" && e instanceof GPUDevice || e?.queue ? "webgpu" : e === null ? "null" : (e instanceof WebGLRenderingContext ? qt.warn("WebGL1 is not supported", e)() : qt.warn("Unknown handle type", e)(), null);
  }
}
const Eb = new qm();
class L9 {
  /**
   * Page load promise
   * Resolves when the DOM is loaded.
   * @note Since are be limitations on number of `load` event listeners,
   * it is recommended avoid calling this accessor until actually needed.
   * I.e. we don't call it unless you know that you will be looking up a string in the DOM.
   */
  get pageLoaded() {
    return N9();
  }
}
const k9 = ph() && typeof document < "u", F9 = () => k9 && document.readyState === "complete";
let pg = null;
function N9() {
  return pg || (F9() || typeof window > "u" ? pg = Promise.resolve() : pg = new Promise((r) => window.addEventListener("load", () => r()))), pg;
}
function U9() {
  let r, e;
  return { promise: new Promise((n, i) => {
    r = n, e = i;
  }), resolve: r, reject: e };
}
class Gf {
  static isHTMLCanvas(e) {
    return typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement;
  }
  static isOffscreenCanvas(e) {
    return typeof OffscreenCanvas < "u" && e instanceof OffscreenCanvas;
  }
  static defaultProps = {
    id: void 0,
    canvas: null,
    width: 800,
    height: 600,
    useDevicePixels: !0,
    autoResize: !0,
    container: null,
    visible: !0,
    alphaMode: "opaque",
    colorSpace: "srgb",
    trackPosition: !1
  };
  id;
  props;
  canvas;
  /** Handle to HTML canvas */
  htmlCanvas;
  /** Handle to wrapped OffScreenCanvas */
  offscreenCanvas;
  type;
  /** Promise that resolved once the resize observer has updated the pixel size */
  initialized;
  isInitialized = !1;
  /** Visibility is automatically updated (via an IntersectionObserver) */
  isVisible = !0;
  /** Width of canvas in CSS units (tracked by a ResizeObserver) */
  cssWidth;
  /** Height of canvas in CSS units (tracked by a ResizeObserver) */
  cssHeight;
  /** Device pixel ratio. Automatically updated via media queries */
  devicePixelRatio;
  /** Exact width of canvas in physical pixels (tracked by a ResizeObserver) */
  devicePixelWidth;
  /** Exact height of canvas in physical pixels (tracked by a ResizeObserver) */
  devicePixelHeight;
  /** Width of drawing buffer: automatically tracks this.pixelWidth if props.autoResize is true */
  drawingBufferWidth;
  /** Height of drawing buffer: automatically tracks this.pixelHeight if props.autoResize is true */
  drawingBufferHeight;
  _initializedResolvers = U9();
  _resizeObserver;
  _intersectionObserver;
  _position;
  destroyed = !1;
  toString() {
    return `${this[Symbol.toStringTag]}(${this.id})`;
  }
  constructor(e) {
    if (this.props = { ...Gf.defaultProps, ...e }, e = this.props, this.initialized = this._initializedResolvers.promise, ph() ? e.canvas ? typeof e.canvas == "string" ? this.canvas = V9(e.canvas) : this.canvas = e.canvas : this.canvas = j9(e) : this.canvas = { width: e.width || 1, height: e.height || 1 }, Gf.isHTMLCanvas(this.canvas) ? (this.id = e.id || this.canvas.id, this.type = "html-canvas", this.htmlCanvas = this.canvas) : Gf.isOffscreenCanvas(this.canvas) ? (this.id = e.id || "offscreen-canvas", this.type = "offscreen-canvas", this.offscreenCanvas = this.canvas) : (this.id = e.id || "node-canvas-context", this.type = "node"), this.cssWidth = this.htmlCanvas?.clientWidth || this.canvas.width, this.cssHeight = this.htmlCanvas?.clientHeight || this.canvas.height, this.devicePixelWidth = this.canvas.width, this.devicePixelHeight = this.canvas.height, this.drawingBufferWidth = this.canvas.width, this.drawingBufferHeight = this.canvas.height, this.devicePixelRatio = globalThis.devicePixelRatio || 1, this._position = [0, 0], Gf.isHTMLCanvas(this.canvas)) {
      this._intersectionObserver = new IntersectionObserver((t) => this._handleIntersection(t)), this._intersectionObserver.observe(this.canvas), this._resizeObserver = new ResizeObserver((t) => this._handleResize(t));
      try {
        this._resizeObserver.observe(this.canvas, { box: "device-pixel-content-box" });
      } catch {
        this._resizeObserver.observe(this.canvas, { box: "content-box" });
      }
      setTimeout(() => this._observeDevicePixelRatio(), 0), this.props.trackPosition && this._trackPosition();
    }
  }
  destroy() {
    this.destroyed = !0;
  }
  setProps(e) {
    return "useDevicePixels" in e && (this.props.useDevicePixels = e.useDevicePixels || !1, this._updateDrawingBufferSize()), this;
  }
  // SIZE METHODS
  /**
   * Returns the size covered by the canvas in CSS pixels
   * @note This can be different from the actual device pixel size of a canvas due to DPR scaling, and rounding to integer pixels
   * @note This is independent of the canvas' internal drawing buffer size (.width, .height).
   */
  getCSSSize() {
    return [this.cssWidth, this.cssHeight];
  }
  getPosition() {
    return this._position;
  }
  /**
   * Returns the size covered by the canvas in actual device pixels.
   * @note This can be different from the 'CSS' size of a canvas due to DPR scaling, and rounding to integer pixels
   * @note This is independent of the canvas' internal drawing buffer size (.width, .height).
   */
  getDevicePixelSize() {
    return [this.devicePixelWidth, this.devicePixelHeight];
  }
  /** Get the drawing buffer size (number of pixels GPU is rendering into, can be different from CSS size) */
  getDrawingBufferSize() {
    return [this.drawingBufferWidth, this.drawingBufferHeight];
  }
  /** Returns the biggest allowed framebuffer size. @todo Allow the application to limit this? */
  getMaxDrawingBufferSize() {
    const e = this.device.limits.maxTextureDimension2D;
    return [e, e];
  }
  /** Update the canvas drawing buffer size. Called automatically if props.autoResize is true. */
  setDrawingBufferSize(e, t) {
    this.canvas.width = e, this.canvas.height = t, this.drawingBufferWidth = e, this.drawingBufferHeight = t;
  }
  /**
   * Returns the current DPR (number of physical pixels per CSS pixel), if props.useDevicePixels is true
   * @note This can be a fractional (non-integer) number, e.g. when the user zooms in the browser.
   * @note This function handles the non-HTML canvas cases
   */
  getDevicePixelRatio() {
    return typeof window < "u" && window.devicePixelRatio || 1;
  }
  // DEPRECATED METHODS
  /**
   * Maps CSS pixel position to device pixel position
   */
  cssToDevicePixels(e, t = !0) {
    const n = this.cssToDeviceRatio(), [i, s] = this.getDrawingBufferSize();
    return H9(e, n, i, s, t);
  }
  /** @deprecated - use .getDevicePixelSize() */
  getPixelSize() {
    return this.getDevicePixelSize();
  }
  /** @deprecated - TODO which values should we use for aspect */
  getAspect() {
    const [e, t] = this.getDevicePixelSize();
    return e / t;
  }
  /** @deprecated Returns multiplier need to convert CSS size to Device size */
  cssToDeviceRatio() {
    try {
      const [e] = this.getDrawingBufferSize(), [t] = this.getCSSSize();
      return t ? e / t : 1;
    } catch {
      return 1;
    }
  }
  /** @deprecated Use canvasContext.setDrawingBufferSize() */
  resize(e) {
    this.setDrawingBufferSize(e.width, e.height);
  }
  // IMPLEMENTATION
  /**
   * Allows subclass constructor to override the canvas id for auto created canvases.
   * This can really help when debugging DOM in apps that create multiple devices
   */
  _setAutoCreatedCanvasId(e) {
    this.htmlCanvas?.id === "lumagl-auto-created-canvas" && (this.htmlCanvas.id = e);
  }
  /** reacts to an observed intersection */
  _handleIntersection(e) {
    const t = e.find((i) => i.target === this.canvas);
    if (!t)
      return;
    const n = t.isIntersecting;
    this.isVisible !== n && (this.isVisible = n, this.device.props.onVisibilityChange(this));
  }
  /**
   * Reacts to an observed resize by using the most accurate pixel size information the browser can provide
   * @see https://web.dev/articles/device-pixel-content-box
   * @see https://webgpufundamentals.org/webgpu/lessons/webgpu-resizing-the-canvas.html
   */
  _handleResize(e) {
    const t = e.find((u) => u.target === this.canvas);
    if (!t)
      return;
    this.cssWidth = t.contentBoxSize[0].inlineSize, this.cssHeight = t.contentBoxSize[0].blockSize;
    const n = this.getDevicePixelSize(), i = t.devicePixelContentBoxSize?.[0].inlineSize || t.contentBoxSize[0].inlineSize * devicePixelRatio, s = t.devicePixelContentBoxSize?.[0].blockSize || t.contentBoxSize[0].blockSize * devicePixelRatio, [o, l] = this.getMaxDrawingBufferSize();
    this.devicePixelWidth = Math.max(1, Math.min(i, o)), this.devicePixelHeight = Math.max(1, Math.min(s, l)), this._updateDrawingBufferSize(), this.device.props.onResize(this, { oldPixelSize: n });
  }
  _updateDrawingBufferSize() {
    if (this.props.autoResize) {
      if (typeof this.props.useDevicePixels == "number") {
        const e = this.props.useDevicePixels;
        this.setDrawingBufferSize(this.cssWidth * e, this.cssHeight * e);
      } else this.props.useDevicePixels ? this.setDrawingBufferSize(this.devicePixelWidth, this.devicePixelHeight) : this.setDrawingBufferSize(this.cssWidth, this.cssHeight);
      this._updateDevice();
    }
    this._initializedResolvers.resolve(), this.isInitialized = !0, this.updatePosition();
  }
  /** Monitor DPR changes */
  _observeDevicePixelRatio() {
    const e = this.devicePixelRatio;
    this.devicePixelRatio = window.devicePixelRatio, this.updatePosition(), this.device.props.onDevicePixelRatioChange(this, { oldRatio: e }), matchMedia(`(resolution: ${this.devicePixelRatio}dppx)`).addEventListener("change", () => this._observeDevicePixelRatio(), { once: !0 });
  }
  /** Start tracking positions with a timer */
  _trackPosition(e = 100) {
    const t = setInterval(() => {
      this.destroyed ? clearInterval(t) : this.updatePosition();
    }, e);
  }
  /**
   * Calculated the absolute position of the canvas
   * @note - getBoundingClientRect() is normally cheap but can be expensive
   * if called before browser has finished a reflow. Should not be the case here.
   */
  updatePosition() {
    const e = this.htmlCanvas?.getBoundingClientRect();
    if (e) {
      const t = [e.left, e.top];
      if (this._position ??= t, t[0] !== this._position[0] || t[1] !== this._position[1]) {
        const i = this._position;
        this._position = t, this.device.props.onPositionChange?.(this, { oldPosition: i });
      }
    }
  }
}
function z9(r) {
  if (typeof r == "string") {
    const e = document.getElementById(r);
    if (!e)
      throw new Error(`${r} is not an HTML element`);
    return e;
  }
  return r || document.body;
}
function V9(r) {
  const e = document.getElementById(r);
  if (!Gf.isHTMLCanvas(e))
    throw new Error("Object is not a canvas element");
  return e;
}
function j9(r) {
  const { width: e, height: t } = r, n = document.createElement("canvas");
  n.id = B_("lumagl-auto-created-canvas"), n.width = e || 1, n.height = t || 1, n.style.width = Number.isFinite(e) ? `${e}px` : "100%", n.style.height = Number.isFinite(t) ? `${t}px` : "100%", r?.visible || (n.style.visibility = "hidden");
  const i = z9(r?.container || null);
  return i.insertBefore(n, i.firstChild), n;
}
function H9(r, e, t, n, i) {
  const s = r, o = WE(s[0], e, t);
  let l = $E(s[1], e, n, i), u = WE(s[0] + 1, e, t);
  const m = u === t - 1 ? u : u - 1;
  u = $E(s[1] + 1, e, n, i);
  let y;
  return i ? (u = u === 0 ? u : u + 1, y = l, l = u) : y = u === n - 1 ? u : u - 1, {
    x: o,
    y: l,
    // when ratio < 1, current css pixel and next css pixel may point to same device pixel, set width/height to 1 in those cases.
    width: Math.max(m - o + 1, 1),
    height: Math.max(y - l + 1, 1)
  };
}
function WE(r, e, t) {
  return Math.min(Math.round(r * e), t - 1);
}
function $E(r, e, t, n) {
  return n ? Math.max(0, t - 1 - Math.round(r * e)) : Math.min(Math.round(r * e), t - 1);
}
class th extends di {
  static defaultProps = {
    ...di.defaultProps,
    type: "color-sampler",
    addressModeU: "clamp-to-edge",
    addressModeV: "clamp-to-edge",
    addressModeW: "clamp-to-edge",
    magFilter: "nearest",
    minFilter: "nearest",
    mipmapFilter: "none",
    lodMinClamp: 0,
    lodMaxClamp: 32,
    // Per WebGPU spec
    compare: "less-equal",
    maxAnisotropy: 1
  };
  get [Symbol.toStringTag]() {
    return "Sampler";
  }
  constructor(e, t) {
    t = th.normalizeProps(e, t), super(e, t, th.defaultProps);
  }
  static normalizeProps(e, t) {
    return t;
  }
}
const G9 = {
  "1d": "1d",
  "2d": "2d",
  "2d-array": "2d",
  cube: "2d",
  "cube-array": "2d",
  "3d": "3d"
};
class ps extends di {
  /** The texture can be bound for use as a sampled texture in a shader */
  static SAMPLE = 4;
  /** The texture can be bound for use as a storage texture in a shader */
  static STORAGE = 8;
  /** The texture can be used as a color or depth/stencil attachment in a render pass */
  static RENDER = 16;
  /** The texture can be used as the source of a copy operation */
  static COPY_SRC = 1;
  /** he texture can be used as the destination of a copy or write operation */
  static COPY_DST = 2;
  /** @deprecated Use Texture.SAMPLE */
  static TEXTURE = 4;
  /** @deprecated Use Texture.RENDER */
  static RENDER_ATTACHMENT = 16;
  /** dimension of this texture */
  dimension;
  /** base dimension of this texture */
  baseDimension;
  /** format of this texture */
  format;
  /** width in pixels of this texture */
  width;
  /** height in pixels of this texture */
  height;
  /** depth of this texture */
  depth;
  /** mip levels in this texture */
  mipLevels;
  /** "Time" of last update. Monotonically increasing timestamp. TODO move to AsyncTexture? */
  updateTimestamp;
  get [Symbol.toStringTag]() {
    return "Texture";
  }
  toString() {
    return `Texture(${this.id},${this.format},${this.width}x${this.height})`;
  }
  /** Do not use directly. Create with device.createTexture() */
  constructor(e, t) {
    if (t = ps.normalizeProps(e, t), super(e, t, ps.defaultProps), this.dimension = this.props.dimension, this.baseDimension = G9[this.dimension], this.format = this.props.format, this.width = this.props.width, this.height = this.props.height, this.depth = this.props.depth, this.mipLevels = this.props.mipLevels, this.props.width === void 0 || this.props.height === void 0)
      if (e.isExternalImage(t.data)) {
        const n = e.getExternalImageSize(t.data);
        this.width = n?.width || 1, this.height = n?.height || 1;
      } else
        this.width = 1, this.height = 1, (this.props.width === void 0 || this.props.height === void 0) && qt.warn(`${this} created with undefined width or height. This is deprecated. Use AsyncTexture instead.`)();
    this.updateTimestamp = e.incrementTimestamp();
  }
  /** Set sampler props associated with this texture */
  setSampler(e) {
    this.sampler = e instanceof th ? e : this.device.createSampler(e);
  }
  /**
   * Create a new texture with the same parameters and optionally a different size
   * @note Textures are immutable and cannot be resized after creation, but we can create a similar texture with the same parameters but a new size.
   * @note Does not copy contents of the texture
   */
  clone(e) {
    return this.device.createTexture({ ...this.props, ...e });
  }
  /** Ensure we have integer coordinates */
  static normalizeProps(e, t) {
    const n = { ...t }, { width: i, height: s } = n;
    return typeof i == "number" && (n.width = Math.max(1, Math.ceil(i))), typeof s == "number" && (n.height = Math.max(1, Math.ceil(s))), n;
  }
  // HELPERS
  /** Initialize texture with supplied props */
  // eslint-disable-next-line max-statements
  _initializeData(e) {
    this.device.isExternalImage(e) ? this.copyExternalImage({
      image: e,
      width: this.width,
      height: this.height,
      depth: this.depth,
      mipLevel: 0,
      x: 0,
      y: 0,
      z: 0,
      aspect: "all",
      colorSpace: "srgb",
      premultipliedAlpha: !1,
      flipY: !1
    }) : e && this.copyImageData({
      data: e,
      // width: this.width,
      // height: this.height,
      // depth: this.depth,
      mipLevel: 0,
      x: 0,
      y: 0,
      z: 0,
      aspect: "all"
    });
  }
  _normalizeCopyImageDataOptions(e) {
    const { width: t, height: n, depth: i } = this, s = { ...ps.defaultCopyDataOptions, width: t, height: n, depth: i, ...e }, o = this.device.getTextureFormatInfo(this.format);
    if (!e.bytesPerRow && !o.bytesPerPixel)
      throw new Error(`bytesPerRow must be provided for texture format ${this.format}`);
    return s.bytesPerRow = e.bytesPerRow || t * (o.bytesPerPixel || 4), s.rowsPerImage = e.rowsPerImage || n, s;
  }
  _normalizeCopyExternalImageOptions(e) {
    const t = this.device.getExternalImageSize(e.image), n = { ...ps.defaultCopyExternalImageOptions, ...t, ...e };
    return n.width = Math.min(n.width, this.width - n.x), n.height = Math.min(n.height, this.height - n.y), n;
  }
  /** Default options */
  static defaultProps = {
    ...di.defaultProps,
    data: null,
    dimension: "2d",
    format: "rgba8unorm",
    usage: ps.TEXTURE | ps.RENDER_ATTACHMENT | ps.COPY_DST,
    width: void 0,
    height: void 0,
    depth: 1,
    mipLevels: 1,
    samples: void 0,
    sampler: {},
    view: void 0
  };
  static defaultCopyDataOptions = {
    data: void 0,
    byteOffset: 0,
    bytesPerRow: void 0,
    rowsPerImage: void 0,
    mipLevel: 0,
    x: 0,
    y: 0,
    z: 0,
    aspect: "all"
  };
  /** Default options */
  static defaultCopyExternalImageOptions = {
    image: void 0,
    sourceX: 0,
    sourceY: 0,
    width: void 0,
    height: void 0,
    depth: 1,
    mipLevel: 0,
    x: 0,
    y: 0,
    z: 0,
    aspect: "all",
    colorSpace: "srgb",
    premultipliedAlpha: !1,
    flipY: !1
  };
}
class O_ extends di {
  get [Symbol.toStringTag]() {
    return "TextureView";
  }
  /** Should not be constructed directly. Use `texture.createView(props)` */
  constructor(e, t) {
    super(e, t, O_.defaultProps);
  }
  static defaultProps = {
    ...di.defaultProps,
    format: void 0,
    dimension: void 0,
    aspect: "all",
    baseMipLevel: 0,
    mipLevelCount: void 0,
    baseArrayLayer: 0,
    arrayLayerCount: void 0
  };
}
function W9(r, e, t) {
  let n = "";
  const i = e.split(/\r?\n/), s = r.slice().sort((o, l) => o.lineNum - l.lineNum);
  switch (t?.showSourceCode || "no") {
    case "all":
      let o = 0;
      for (let l = 1; l <= i.length; l++)
        for (n += VB(i[l - 1], l, t); s.length > o && s[o].lineNum === l; ) {
          const u = s[o++];
          n += Tv(u, i, u.lineNum, {
            ...t,
            inlineSource: !1
          });
        }
      for (; s.length > o; ) {
        const l = s[o++];
        n += Tv(l, [], 0, {
          ...t,
          inlineSource: !1
        });
      }
      return n;
    case "issues":
    case "no":
      for (const l of r)
        n += Tv(l, i, l.lineNum, {
          inlineSource: t?.showSourceCode !== "no"
        });
      return n;
  }
}
function Tv(r, e, t, n) {
  if (n?.inlineSource) {
    const s = $9(e, t), o = r.linePos > 0 ? `${" ".repeat(r.linePos + 5)}^^^
` : "";
    return `
${s}${o}${r.type.toUpperCase()}: ${r.message}

`;
  }
  const i = r.type === "error" ? "red" : "#8B4000";
  return n?.html ? `<div class='luma-compiler-log-error' style="color:${i};"><b> ${r.type.toUpperCase()}: ${r.message}</b></div>` : `${r.type.toUpperCase()}: ${r.message}`;
}
function $9(r, e, t) {
  let n = "";
  for (let i = e - 2; i <= e; i++) {
    const s = r[i - 1];
    s !== void 0 && (n += VB(s, e, t));
  }
  return n;
}
function VB(r, e, t) {
  const n = t?.html ? X9(r) : r;
  return `${q9(String(e), 4)}: ${n}${t?.html ? "<br/>" : `
`}`;
}
function q9(r, e) {
  let t = "";
  for (let n = r.length; n < e; ++n)
    t += " ";
  return t + r;
}
function X9(r) {
  return r.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll('"', "&quot;").replaceAll("'", "&#039;");
}
class D_ extends di {
  get [Symbol.toStringTag]() {
    return "Shader";
  }
  /** The stage of this shader */
  stage;
  /** The source code of this shader */
  source;
  /** The compilation status of the shader. 'pending' if compilation is asynchronous, and on production */
  compilationStatus = "pending";
  /** Create a new Shader instance */
  constructor(e, t) {
    t = { ...t, debugShaders: t.debugShaders || e.props.debugShaders || "errors" }, super(e, { id: Z9(t), ...t }, D_.defaultProps), this.stage = this.props.stage, this.source = this.props.source;
  }
  /** Get compiler log synchronously (WebGL only) */
  getCompilationInfoSync() {
    return null;
  }
  /** Get translated shader source in host platform's native language (HLSL, GLSL, and even GLSL ES), if available */
  getTranslatedSource() {
    return null;
  }
  // PORTABLE HELPERS
  /** In browser logging of errors */
  async debugShader() {
    const e = this.props.debugShaders;
    switch (e) {
      case "never":
        return;
      case "errors":
        if (this.compilationStatus === "success")
          return;
        break;
    }
    const t = await this.getCompilationInfo();
    e === "warnings" && t?.length === 0 || this._displayShaderLog(t, this.id);
  }
  // PRIVATE
  /**
   * In-browser UI logging of errors
   * TODO - this HTML formatting code should not be in Device, should be pluggable
   */
  _displayShaderLog(e, t) {
    if (typeof document > "u" || !document?.createElement)
      return;
    const n = t, i = `${this.stage} shader "${n}"`;
    let s = W9(e, this.source, { showSourceCode: "all", html: !0 });
    const o = this.getTranslatedSource();
    o && (s += `<br /><br /><h1>Translated Source</h1><br /><br /><code style="user-select:text;"><pre>${o}</pre></code>`);
    const l = document.createElement("Button");
    l.innerHTML = `
<h1>Compilation error in ${i}</h1><br /><br />
<code style="user-select:text;"><pre>
${s}
</pre></code>`, l.style.top = "10px", l.style.left = "10px", l.style.position = "absolute", l.style.zIndex = "9999", l.style.width = "100%", l.style.textAlign = "left", document.body.appendChild(l), document.getElementsByClassName("luma-compiler-log-error")[0]?.scrollIntoView(), l.onclick = () => {
      const m = `data:text/plain,${encodeURIComponent(this.source)}`;
      navigator.clipboard.writeText(m);
    };
  }
  static defaultProps = {
    ...di.defaultProps,
    language: "auto",
    stage: void 0,
    source: "",
    sourceMap: null,
    entryPoint: "main",
    debugShaders: void 0
  };
}
function Z9(r) {
  return Y9(r.source) || r.id || B_(`unnamed ${r.stage}-shader`);
}
function Y9(r, e = "unnamed") {
  const n = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/.exec(r);
  return n ? n[1] : e;
}
class L_ extends di {
  get [Symbol.toStringTag]() {
    return "Framebuffer";
  }
  /** Width of all attachments in this framebuffer */
  width;
  /** Height of all attachments in this framebuffer */
  height;
  constructor(e, t = {}) {
    super(e, t, L_.defaultProps), this.width = this.props.width, this.height = this.props.height;
  }
  /**
   * Create a copy of this framebuffer with new attached textures, with same props but of the specified size.
   * @note Does not copy contents of the attached textures.
   */
  clone(e) {
    const t = this.colorAttachments.map((i) => i.texture.clone(e)), n = this.depthStencilAttachment && this.depthStencilAttachment.texture.clone(e);
    return this.device.createFramebuffer({ ...this.props, colorAttachments: t, depthStencilAttachment: n });
  }
  resize(e) {
    let t = !e;
    if (e) {
      const [n, i] = Array.isArray(e) ? e : [e.width, e.height];
      t = t || i !== this.height || n !== this.width, this.width = n, this.height = i;
    }
    t && (qt.log(2, `Resizing framebuffer ${this.id} to ${this.width}x${this.height}`)(), this.resizeAttachments(this.width, this.height));
  }
  /** Auto creates any textures */
  autoCreateAttachmentTextures() {
    if (this.props.colorAttachments.length === 0 && !this.props.depthStencilAttachment)
      throw new Error("Framebuffer has noattachments");
    this.colorAttachments = this.props.colorAttachments.map((t, n) => {
      if (typeof t == "string") {
        const i = this.createColorTexture(t, n);
        return this.attachResource(i), i.view;
      }
      return t instanceof ps ? t.view : t;
    });
    const e = this.props.depthStencilAttachment;
    if (e)
      if (typeof e == "string") {
        const t = this.createDepthStencilTexture(e);
        this.attachResource(t), this.depthStencilAttachment = t.view;
      } else e instanceof ps ? this.depthStencilAttachment = e.view : this.depthStencilAttachment = e;
  }
  /** Create a color texture */
  createColorTexture(e, t) {
    return this.device.createTexture({
      id: `${this.id}-color-attachment-${t}`,
      usage: ps.RENDER_ATTACHMENT,
      format: e,
      width: this.width,
      height: this.height,
      // TODO deprecated? - luma.gl v8 compatibility
      sampler: {
        magFilter: "linear",
        minFilter: "linear"
      }
    });
  }
  /** Create depth stencil texture */
  createDepthStencilTexture(e) {
    return this.device.createTexture({
      id: `${this.id}-depth-stencil-attachment`,
      usage: ps.RENDER_ATTACHMENT,
      format: e,
      width: this.width,
      height: this.height
    });
  }
  /**
   * Default implementation of resize
   * Creates new textures with correct size for all attachments.
   * and destroys existing textures if owned
   */
  resizeAttachments(e, t) {
    for (let n = 0; n < this.colorAttachments.length; ++n)
      if (this.colorAttachments[n]) {
        const i = this.colorAttachments[n].texture.clone({
          width: e,
          height: t
        });
        this.destroyAttachedResource(this.colorAttachments[n]), this.colorAttachments[n] = i.view, this.attachResource(i.view);
      }
    if (this.depthStencilAttachment) {
      const n = this.depthStencilAttachment.texture.clone({
        width: e,
        height: t
      });
      this.destroyAttachedResource(this.depthStencilAttachment), this.depthStencilAttachment = n.view, this.attachResource(n);
    }
    this.updateAttachments();
  }
  static defaultProps = {
    ...di.defaultProps,
    width: 1,
    height: 1,
    colorAttachments: [],
    // ['rgba8unorm'],
    depthStencilAttachment: null
    // 'depth24plus-stencil8'
  };
}
class Zf extends di {
  get [Symbol.toStringTag]() {
    return "RenderPipeline";
  }
  /** The merged layout */
  shaderLayout;
  /** Buffer map describing buffer interleaving etc */
  bufferLayout;
  /** The linking status of the pipeline. 'pending' if linking is asynchronous, and on production */
  linkStatus = "pending";
  /** The hash of the pipeline */
  hash = "";
  constructor(e, t) {
    super(e, t, Zf.defaultProps), this.shaderLayout = this.props.shaderLayout, this.bufferLayout = this.props.bufferLayout || [];
  }
  static defaultProps = {
    ...di.defaultProps,
    vs: null,
    vertexEntryPoint: "vertexMain",
    vsConstants: {},
    fs: null,
    fragmentEntryPoint: "fragmentMain",
    fsConstants: {},
    shaderLayout: null,
    bufferLayout: [],
    topology: "triangle-list",
    colorAttachmentFormats: void 0,
    depthStencilAttachmentFormat: void 0,
    parameters: {},
    bindings: {},
    uniforms: {}
  };
}
class Vf extends di {
  /** TODO - should be [0, 0, 0, 0], update once deck.gl tests run clean */
  static defaultClearColor = [0, 0, 0, 1];
  /** Depth 1.0 represents the far plance */
  static defaultClearDepth = 1;
  /** Clears all stencil bits */
  static defaultClearStencil = 0;
  get [Symbol.toStringTag]() {
    return "RenderPass";
  }
  constructor(e, t) {
    t = Vf.normalizeProps(e, t), super(e, t, Vf.defaultProps);
  }
  static normalizeProps(e, t) {
    return t;
  }
  /** Default properties for RenderPass */
  static defaultProps = {
    ...di.defaultProps,
    framebuffer: null,
    parameters: void 0,
    clearColor: Vf.defaultClearColor,
    clearColors: void 0,
    clearDepth: Vf.defaultClearDepth,
    clearStencil: Vf.defaultClearStencil,
    depthReadOnly: !1,
    stencilReadOnly: !1,
    discard: !1,
    occlusionQuerySet: void 0,
    timestampQuerySet: void 0,
    beginTimestampIndex: void 0,
    endTimestampIndex: void 0
  };
}
class Xm extends di {
  get [Symbol.toStringTag]() {
    return "ComputePipeline";
  }
  hash = "";
  /** The merged shader layout */
  shaderLayout;
  constructor(e, t) {
    super(e, t, Xm.defaultProps), this.shaderLayout = t.shaderLayout;
  }
  static defaultProps = {
    ...di.defaultProps,
    shader: void 0,
    entryPoint: void 0,
    constants: {},
    shaderLayout: void 0
  };
}
class dx extends di {
  get [Symbol.toStringTag]() {
    return "CommandEncoder";
  }
  constructor(e, t) {
    super(e, t, dx.defaultProps);
  }
  // TODO - luma.gl has these on the device, should we align with WebGPU API?
  // beginRenderPass(GPURenderPassDescriptor descriptor): GPURenderPassEncoder;
  // beginComputePass(optional GPUComputePassDescriptor descriptor = {}): GPUComputePassEncoder;
  static defaultProps = {
    ...di.defaultProps,
    measureExecutionTime: void 0
  };
}
class px extends di {
  get [Symbol.toStringTag]() {
    return "CommandBuffer";
  }
  constructor(e, t) {
    super(e, t, px.defaultProps);
  }
  static defaultProps = {
    ...di.defaultProps
  };
}
function jB(r) {
  return e7[r];
}
function K9(r) {
  const [e, t] = J9[r], n = e === "i32" || e === "u32", i = e !== "u32", s = Q9[e] * t;
  return {
    primitiveType: e,
    components: t,
    byteLength: s,
    integer: n,
    signed: i
  };
}
const Q9 = {
  f32: 4,
  f16: 2,
  i32: 4,
  u32: 4
  // 'bool-webgl': 4,
}, J9 = {
  f32: ["f32", 1],
  "vec2<f32>": ["f32", 2],
  "vec3<f32>": ["f32", 3],
  "vec4<f32>": ["f32", 4],
  f16: ["f16", 1],
  "vec2<f16>": ["f16", 2],
  "vec3<f16>": ["f16", 3],
  "vec4<f16>": ["f16", 4],
  i32: ["i32", 1],
  "vec2<i32>": ["i32", 2],
  "vec3<i32>": ["i32", 3],
  "vec4<i32>": ["i32", 4],
  u32: ["u32", 1],
  "vec2<u32>": ["u32", 2],
  "vec3<u32>": ["u32", 3],
  "vec4<u32>": ["u32", 4]
}, e7 = {
  f32: { type: "f32", components: 1 },
  f16: { type: "f16", components: 1 },
  i32: { type: "i32", components: 1 },
  u32: { type: "u32", components: 1 },
  // 'bool-webgl': {type: 'bool-webgl', components: 1},
  "vec2<f32>": { type: "f32", components: 2 },
  "vec3<f32>": { type: "f32", components: 3 },
  "vec4<f32>": { type: "f32", components: 4 },
  "vec2<f16>": { type: "f16", components: 2 },
  "vec3<f16>": { type: "f16", components: 3 },
  "vec4<f16>": { type: "f16", components: 4 },
  "vec2<i32>": { type: "i32", components: 2 },
  "vec3<i32>": { type: "i32", components: 3 },
  "vec4<i32>": { type: "i32", components: 4 },
  "vec2<u32>": { type: "u32", components: 2 },
  "vec3<u32>": { type: "u32", components: 3 },
  "vec4<u32>": { type: "u32", components: 4 },
  "mat2x2<f32>": { type: "f32", components: 4 },
  "mat2x3<f32>": { type: "f32", components: 6 },
  "mat2x4<f32>": { type: "f32", components: 8 },
  "mat3x2<f32>": { type: "f32", components: 6 },
  "mat3x3<f32>": { type: "f32", components: 9 },
  "mat3x4<f32>": { type: "f32", components: 12 },
  "mat4x2<f32>": { type: "f32", components: 8 },
  "mat4x3<f32>": { type: "f32", components: 12 },
  "mat4x4<f32>": { type: "f32", components: 16 },
  "mat2x2<f16>": { type: "f16", components: 4 },
  "mat2x3<f16>": { type: "f16", components: 6 },
  "mat2x4<f16>": { type: "f16", components: 8 },
  "mat3x2<f16>": { type: "f16", components: 6 },
  "mat3x3<f16>": { type: "f16", components: 9 },
  "mat3x4<f16>": { type: "f16", components: 12 },
  "mat4x2<f16>": { type: "f16", components: 8 },
  "mat4x3<f16>": { type: "f16", components: 12 },
  "mat4x4<f16>": { type: "f16", components: 16 },
  "mat2x2<i32>": { type: "i32", components: 4 },
  "mat2x3<i32>": { type: "i32", components: 6 },
  "mat2x4<i32>": { type: "i32", components: 8 },
  "mat3x2<i32>": { type: "i32", components: 6 },
  "mat3x3<i32>": { type: "i32", components: 9 },
  "mat3x4<i32>": { type: "i32", components: 12 },
  "mat4x2<i32>": { type: "i32", components: 8 },
  "mat4x3<i32>": { type: "i32", components: 12 },
  "mat4x4<i32>": { type: "i32", components: 16 },
  "mat2x2<u32>": { type: "u32", components: 4 },
  "mat2x3<u32>": { type: "u32", components: 6 },
  "mat2x4<u32>": { type: "u32", components: 8 },
  "mat3x2<u32>": { type: "u32", components: 6 },
  "mat3x3<u32>": { type: "u32", components: 9 },
  "mat3x4<u32>": { type: "u32", components: 12 },
  "mat4x2<u32>": { type: "u32", components: 8 },
  "mat4x3<u32>": { type: "u32", components: 12 },
  "mat4x4<u32>": { type: "u32", components: 16 }
};
function HB(r, e) {
  const t = {};
  for (const n of r.attributes) {
    const i = r7(r, e, n.name);
    i && (t[n.name] = i);
  }
  return t;
}
function t7(r, e, t = 16) {
  const n = HB(r, e), i = new Array(t).fill(null);
  for (const s of Object.values(n))
    i[s.location] = s;
  return i;
}
function r7(r, e, t) {
  const n = n7(r, t), i = i7(e, t);
  if (!n)
    return null;
  const s = K9(n.type), o = y9(s), l = i?.vertexFormat || o, u = hx(l);
  return {
    attributeName: i?.attributeName || n.name,
    bufferName: i?.bufferName || n.name,
    location: n.location,
    shaderType: n.type,
    primitiveType: s.primitiveType,
    shaderComponents: s.components,
    vertexFormat: l,
    bufferDataType: u.type,
    bufferComponents: u.components,
    // normalized is a property of the buffer's vertex format
    normalized: u.normalized,
    // integer is a property of the shader declaration
    integer: s.integer,
    stepMode: i?.stepMode || n.stepMode || "vertex",
    byteOffset: i?.byteOffset || 0,
    byteStride: i?.byteStride || 0
  };
}
function n7(r, e) {
  const t = r.attributes.find((n) => n.name === e);
  return t || qt.warn(`shader layout attribute "${e}" not present in shader`), t || null;
}
function i7(r, e) {
  s7(r);
  let t = o7(r, e);
  return t || (t = a7(r, e), t) ? t : (qt.warn(`layout for attribute "${e}" not present in buffer layout`), null);
}
function s7(r) {
  for (const e of r)
    (e.attributes && e.format || !e.attributes && !e.format) && qt.warn(`BufferLayout ${name} must have either 'attributes' or 'format' field`);
}
function o7(r, e) {
  for (const t of r)
    if (t.format && t.name === e)
      return {
        attributeName: t.name,
        bufferName: e,
        stepMode: t.stepMode,
        vertexFormat: t.format,
        // If offset is needed, use `attributes` field.
        byteOffset: 0,
        byteStride: t.byteStride || 0
      };
  return null;
}
function a7(r, e) {
  for (const t of r) {
    let n = t.byteStride;
    if (typeof t.byteStride != "number")
      for (const s of t.attributes || []) {
        const o = hx(s.format);
        n += o.byteLength;
      }
    const i = t.attributes?.find((s) => s.attribute === e);
    if (i)
      return {
        attributeName: i.attribute,
        bufferName: t.name,
        stepMode: t.stepMode,
        vertexFormat: i.format,
        byteOffset: i.byteOffset,
        // @ts-ignore
        byteStride: n
      };
  }
  return null;
}
class Ax extends di {
  static defaultProps = {
    ...di.defaultProps,
    shaderLayout: void 0,
    bufferLayout: []
  };
  get [Symbol.toStringTag]() {
    return "VertexArray";
  }
  /** Max number of vertex attributes */
  maxVertexAttributes;
  /** Attribute infos indexed by location - TODO only needed by webgl module? */
  attributeInfos;
  /** Index buffer */
  indexBuffer = null;
  /** Attributes indexed by buffer slot */
  attributes;
  constructor(e, t) {
    super(e, t, Ax.defaultProps), this.maxVertexAttributes = e.limits.maxVertexAttributes, this.attributes = new Array(this.maxVertexAttributes).fill(null), this.attributeInfos = t7(t.shaderLayout, t.bufferLayout, this.maxVertexAttributes);
  }
  // DEPRECATED METHODS
  /** @deprecated Set constant attributes (WebGL only) */
  setConstantWebGL(e, t) {
    this.device.reportError(new Error("constant attributes not supported"), this)();
  }
}
class gx extends di {
  static defaultProps = {
    ...di.defaultProps,
    layout: void 0,
    buffers: {}
  };
  get [Symbol.toStringTag]() {
    return "TransformFeedback";
  }
  constructor(e, t) {
    super(e, t, gx.defaultProps);
  }
}
class mx extends di {
  get [Symbol.toStringTag]() {
    return "QuerySet";
  }
  constructor(e, t) {
    super(e, t, mx.defaultProps);
  }
  static defaultProps = {
    ...di.defaultProps,
    type: void 0,
    count: void 0
  };
}
let Ag;
function GB(r) {
  return (!Ag || Ag.byteLength < r) && (Ag = new ArrayBuffer(r)), Ag;
}
function l7(r, e) {
  const t = GB(r.BYTES_PER_ELEMENT * e);
  return new r(t, 0, e);
}
function c7(r) {
  return ArrayBuffer.isView(r) && !(r instanceof DataView);
}
function Zm(r) {
  return Array.isArray(r) ? r.length === 0 || typeof r[0] == "number" : c7(r);
}
const u7 = 1024;
class f7 {
  layout = {};
  /** number of bytes needed for buffer allocation */
  byteLength;
  /** Create a new UniformBufferLayout given a map of attributes. */
  constructor(e, t = {}) {
    let n = 0;
    for (const [s, o] of Object.entries(e)) {
      const l = jB(o), { type: u, components: m } = l, y = m * (t?.[s] ?? 1);
      n = g9(n, y);
      const E = n;
      n += y, this.layout[s] = { type: u, size: y, offset: E };
    }
    n += (4 - n % 4) % 4;
    const i = n * 4;
    this.byteLength = Math.max(i, u7);
  }
  /** Get the data for the complete buffer */
  getData(e) {
    const t = GB(this.byteLength), n = {
      i32: new Int32Array(t),
      u32: new Uint32Array(t),
      f32: new Float32Array(t),
      // TODO not implemented
      f16: new Uint16Array(t)
    };
    for (const [i, s] of Object.entries(e)) {
      const o = this.layout[i];
      if (!o) {
        qt.warn(`Supplied uniform value ${i} not present in uniform block layout`)();
        continue;
      }
      const { type: l, size: u, offset: m } = o, y = n[l];
      if (u === 1) {
        if (typeof s != "number" && typeof s != "boolean") {
          qt.warn(`Supplied value for single component uniform ${i} is not a number: ${s}`)();
          continue;
        }
        y[m] = Number(s);
      } else {
        if (!Zm(s)) {
          qt.warn(`Supplied value for multi component / array uniform ${i} is not a numeric array: ${s}`)();
          continue;
        }
        y.set(s, m);
      }
    }
    return new Uint8Array(t, 0, this.byteLength);
  }
  /** Does this layout have a field with specified name */
  has(e) {
    return !!this.layout[e];
  }
  /** Get offset and size for a field with specified name */
  get(e) {
    return this.layout[e];
  }
}
function h7(r, e, t = 16) {
  if (r !== e)
    return !1;
  const n = r, i = e;
  if (!Zm(n))
    return !1;
  if (Zm(i) && n.length === i.length) {
    for (let s = 0; s < n.length; ++s)
      if (i[s] !== n[s])
        return !1;
  }
  return !0;
}
function d7(r) {
  return Zm(r) ? r.slice() : r;
}
class p7 {
  name;
  uniforms = {};
  modifiedUniforms = {};
  modified = !0;
  bindingLayout = {};
  needsRedraw = "initialized";
  constructor(e) {
    if (this.name = e?.name || "unnamed", e?.name && e?.shaderLayout) {
      const t = e?.shaderLayout.bindings?.find((i) => i.type === "uniform" && i.name === e?.name);
      if (!t)
        throw new Error(e?.name);
      const n = t;
      for (const i of n.uniforms || [])
        this.bindingLayout[i.name] = i;
    }
  }
  /** Set a map of uniforms */
  setUniforms(e) {
    for (const [t, n] of Object.entries(e))
      this._setUniform(t, n), this.needsRedraw || this.setNeedsRedraw(`${this.name}.${t}=${n}`);
  }
  setNeedsRedraw(e) {
    this.needsRedraw = this.needsRedraw || e;
  }
  /** Returns all uniforms */
  getAllUniforms() {
    return this.modifiedUniforms = {}, this.needsRedraw = !1, this.uniforms || {};
  }
  /** Set a single uniform */
  _setUniform(e, t) {
    h7(this.uniforms[e], t) || (this.uniforms[e] = d7(t), this.modifiedUniforms[e] = !0, this.modified = !0);
  }
}
class A7 {
  /** Stores the uniform values for each uniform block */
  uniformBlocks = /* @__PURE__ */ new Map();
  /** Can generate data for a uniform buffer for each block from data */
  uniformBufferLayouts = /* @__PURE__ */ new Map();
  /** Actual buffer for the blocks */
  uniformBuffers = /* @__PURE__ */ new Map();
  /**
   * Create a new UniformStore instance
   * @param blocks
   */
  constructor(e) {
    for (const [t, n] of Object.entries(e)) {
      const i = t, s = new f7(n.uniformTypes ?? {}, n.uniformSizes ?? {});
      this.uniformBufferLayouts.set(i, s);
      const o = new p7({ name: t });
      o.setUniforms(n.defaultUniforms || {}), this.uniformBlocks.set(i, o);
    }
  }
  /** Destroy any managed uniform buffers */
  destroy() {
    for (const e of this.uniformBuffers.values())
      e.destroy();
  }
  /**
   * Set uniforms
   * Makes all properties partial
   */
  setUniforms(e) {
    for (const [t, n] of Object.entries(e))
      this.uniformBlocks.get(t)?.setUniforms(n);
    this.updateUniformBuffers();
  }
  /** Get the required minimum length of the uniform buffer */
  getUniformBufferByteLength(e) {
    return this.uniformBufferLayouts.get(e)?.byteLength || 0;
  }
  /** Get formatted binary memory that can be uploaded to a buffer */
  getUniformBufferData(e) {
    const t = this.uniformBlocks.get(e)?.getAllUniforms() || {};
    return this.uniformBufferLayouts.get(e)?.getData(t);
  }
  /**
   * Creates an unmanaged uniform buffer (umnanaged means that application is responsible for destroying it)
   * The new buffer is initialized with current / supplied values
   */
  createUniformBuffer(e, t, n) {
    n && this.setUniforms(n);
    const i = this.getUniformBufferByteLength(t), s = e.createBuffer({
      usage: vi.UNIFORM | vi.COPY_DST,
      byteLength: i
    }), o = this.getUniformBufferData(t);
    return s.write(o), s;
  }
  /** Get the managed uniform buffer. "managed" resources are destroyed when the uniformStore is destroyed. */
  getManagedUniformBuffer(e, t) {
    if (!this.uniformBuffers.get(t)) {
      const n = this.getUniformBufferByteLength(t), i = e.createBuffer({
        usage: vi.UNIFORM | vi.COPY_DST,
        byteLength: n
      });
      this.uniformBuffers.set(t, i);
    }
    return this.uniformBuffers.get(t);
  }
  /** Updates all uniform buffers where values have changed */
  updateUniformBuffers() {
    let e = !1;
    for (const t of this.uniformBlocks.keys()) {
      const n = this.updateUniformBuffer(t);
      e ||= n;
    }
    return e && qt.log(3, `UniformStore.updateUniformBuffers(): ${e}`)(), e;
  }
  /** Update one uniform buffer. Only updates if values have changed */
  updateUniformBuffer(e) {
    const t = this.uniformBlocks.get(e);
    let n = this.uniformBuffers.get(e), i = !1;
    if (n && t?.needsRedraw) {
      i ||= t.needsRedraw;
      const s = this.getUniformBufferData(e);
      n = this.uniformBuffers.get(e), n?.write(s);
      const o = this.uniformBlocks.get(e)?.getAllUniforms();
      qt.log(4, `Writing to uniform buffer ${String(e)}`, s, o)();
    }
    return i;
  }
}
let Fa = class {
  constructor(e, t) {
    this.name = e, this.attributes = t, this.size = 0;
  }
  get isArray() {
    return !1;
  }
  get isStruct() {
    return !1;
  }
  get isTemplate() {
    return !1;
  }
  get isPointer() {
    return !1;
  }
  getTypeName() {
    return this.name;
  }
};
class qE {
  constructor(e, t, n) {
    this.name = e, this.type = t, this.attributes = n, this.offset = 0, this.size = 0;
  }
  get isArray() {
    return this.type.isArray;
  }
  get isStruct() {
    return this.type.isStruct;
  }
  get isTemplate() {
    return this.type.isTemplate;
  }
  get align() {
    return this.type.isStruct ? this.type.align : 0;
  }
  get members() {
    return this.type.isStruct ? this.type.members : null;
  }
  get format() {
    return this.type.isArray || this.type.isTemplate ? this.type.format : null;
  }
  get count() {
    return this.type.isArray ? this.type.count : 0;
  }
  get stride() {
    return this.type.isArray ? this.type.stride : this.size;
  }
}
class ju extends Fa {
  constructor(e, t) {
    super(e, t), this.members = [], this.align = 0, this.startLine = -1, this.endLine = -1, this.inUse = !1;
  }
  get isStruct() {
    return !0;
  }
}
class $u extends Fa {
  constructor(e, t) {
    super(e, t), this.count = 0, this.stride = 0;
  }
  get isArray() {
    return !0;
  }
  getTypeName() {
    return `array<${this.format.getTypeName()}, ${this.count}>`;
  }
}
class Cb extends Fa {
  constructor(e, t, n) {
    super(e, n), this.format = t;
  }
  get isPointer() {
    return !0;
  }
  getTypeName() {
    return `&${this.format.getTypeName()}`;
  }
}
let rh = class extends Fa {
  constructor(e, t, n, i) {
    super(e, n), this.format = t, this.access = i;
  }
  get isTemplate() {
    return !0;
  }
  getTypeName() {
    let e = this.name;
    if (this.format !== null) {
      if (e === "vec2" || e === "vec3" || e === "vec4" || e === "mat2x2" || e === "mat2x3" || e === "mat2x4" || e === "mat3x2" || e === "mat3x3" || e === "mat3x4" || e === "mat4x2" || e === "mat4x3" || e === "mat4x4") {
        if (this.format.name === "f32") return e += "f", e;
        if (this.format.name === "i32") return e += "i", e;
        if (this.format.name === "u32") return e += "u", e;
        if (this.format.name === "bool") return e += "b", e;
        if (this.format.name === "f16") return e += "h", e;
      }
      e += `<${this.format.name}>`;
    } else if (e === "vec2" || e === "vec3" || e === "vec4") return e;
    return e;
  }
};
var zu;
((r) => {
  r[r.Uniform = 0] = "Uniform", r[r.Storage = 1] = "Storage", r[r.Texture = 2] = "Texture", r[r.Sampler = 3] = "Sampler", r[r.StorageTexture = 4] = "StorageTexture";
})(zu || (zu = {}));
class gg {
  constructor(e, t, n, i, s, o, l) {
    this.name = e, this.type = t, this.group = n, this.binding = i, this.attributes = s, this.resourceType = o, this.access = l;
  }
  get isArray() {
    return this.type.isArray;
  }
  get isStruct() {
    return this.type.isStruct;
  }
  get isTemplate() {
    return this.type.isTemplate;
  }
  get size() {
    return this.type.size;
  }
  get align() {
    return this.type.isStruct ? this.type.align : 0;
  }
  get members() {
    return this.type.isStruct ? this.type.members : null;
  }
  get format() {
    return this.type.isArray || this.type.isTemplate ? this.type.format : null;
  }
  get count() {
    return this.type.isArray ? this.type.count : 0;
  }
  get stride() {
    return this.type.isArray ? this.type.stride : this.size;
  }
}
let g7 = class {
  constructor(e, t) {
    this.name = e, this.type = t;
  }
};
class m7 {
  constructor(e, t, n, i) {
    this.name = e, this.type = t, this.locationType = n, this.location = i, this.interpolation = null;
  }
}
let XE = class {
  constructor(e, t, n, i) {
    this.name = e, this.type = t, this.locationType = n, this.location = i;
  }
};
class _7 {
  constructor(e, t, n, i) {
    this.name = e, this.type = t, this.attributes = n, this.id = i;
  }
}
class y7 {
  constructor(e, t, n) {
    this.name = e, this.type = t, this.attributes = n;
  }
}
class v7 {
  constructor(e, t = null, n) {
    this.stage = null, this.inputs = [], this.outputs = [], this.arguments = [], this.returnType = null, this.resources = [], this.overrides = [], this.startLine = -1, this.endLine = -1, this.inUse = !1, this.calls = /* @__PURE__ */ new Set(), this.name = e, this.stage = t, this.attributes = n;
  }
}
let b7 = class {
  constructor() {
    this.vertex = [], this.fragment = [], this.compute = [];
  }
};
function x7(r) {
  var e = (32768 & r) >> 15, t = (31744 & r) >> 10, n = 1023 & r;
  return t == 0 ? (e ? -1 : 1) * Math.pow(2, -14) * (n / Math.pow(2, 10)) : t == 31 ? n ? NaN : 1 / 0 * (e ? -1 : 1) : (e ? -1 : 1) * Math.pow(2, t - 15) * (1 + n / Math.pow(2, 10));
}
const WB = new Float32Array(1), w7 = new Int32Array(WB.buffer), ho = new Uint16Array(1);
function T7(r) {
  WB[0] = r;
  const e = w7[0], t = e >> 31 & 1;
  let n = e >> 23 & 255, i = 8388607 & e;
  if (n === 255) return ho[0] = t << 15 | 31744 | (i !== 0 ? 512 : 0), ho[0];
  if (n === 0) {
    if (i === 0) return ho[0] = t << 15, ho[0];
    i |= 8388608;
    let s = 113;
    for (; !(8388608 & i); ) i <<= 1, s--;
    return n = 127 - s, i &= 8388607, n > 0 ? (i = (i >> 126 - n) + (i >> 127 - n & 1), ho[0] = t << 15 | n << 10 | i >> 13, ho[0]) : (ho[0] = t << 15, ho[0]);
  }
  return n = n - 127 + 15, n >= 31 ? (ho[0] = t << 15 | 31744, ho[0]) : n <= 0 ? n < -10 ? (ho[0] = t << 15, ho[0]) : (i = (8388608 | i) >> 1 - n, ho[0] = t << 15 | i >> 13, ho[0]) : (i >>= 13, ho[0] = t << 15 | n << 10 | i, ho[0]);
}
const _x = new Uint32Array(1), $B = new Float32Array(_x.buffer, 0, 1);
function ZE(r) {
  const e = 112 + (r >> 6 & 31) << 23 | (63 & r) << 17;
  return _x[0] = e, $B[0];
}
function E7(r, e, t, n, i, s, o, l, u) {
  const m = n * (o >>= i) * (s >>= i) + t * o + e * l;
  switch (u) {
    case "r8unorm":
      return [Kn(r, m, "8unorm", 1)[0]];
    case "r8snorm":
      return [Kn(r, m, "8snorm", 1)[0]];
    case "r8uint":
      return [Kn(r, m, "8uint", 1)[0]];
    case "r8sint":
      return [Kn(r, m, "8sint", 1)[0]];
    case "rg8unorm": {
      const y = Kn(r, m, "8unorm", 2);
      return [y[0], y[1]];
    }
    case "rg8snorm": {
      const y = Kn(r, m, "8snorm", 2);
      return [y[0], y[1]];
    }
    case "rg8uint": {
      const y = Kn(r, m, "8uint", 2);
      return [y[0], y[1]];
    }
    case "rg8sint": {
      const y = Kn(r, m, "8sint", 2);
      return [y[0], y[1]];
    }
    case "rgba8unorm-srgb":
    case "rgba8unorm": {
      const y = Kn(r, m, "8unorm", 4);
      return [y[0], y[1], y[2], y[3]];
    }
    case "rgba8snorm": {
      const y = Kn(r, m, "8snorm", 4);
      return [y[0], y[1], y[2], y[3]];
    }
    case "rgba8uint": {
      const y = Kn(r, m, "8uint", 4);
      return [y[0], y[1], y[2], y[3]];
    }
    case "rgba8sint": {
      const y = Kn(r, m, "8sint", 4);
      return [y[0], y[1], y[2], y[3]];
    }
    case "bgra8unorm-srgb":
    case "bgra8unorm": {
      const y = Kn(r, m, "8unorm", 4);
      return [y[2], y[1], y[0], y[3]];
    }
    case "r16uint":
      return [Kn(r, m, "16uint", 1)[0]];
    case "r16sint":
      return [Kn(r, m, "16sint", 1)[0]];
    case "r16float":
      return [Kn(r, m, "16float", 1)[0]];
    case "rg16uint": {
      const y = Kn(r, m, "16uint", 2);
      return [y[0], y[1]];
    }
    case "rg16sint": {
      const y = Kn(r, m, "16sint", 2);
      return [y[0], y[1]];
    }
    case "rg16float": {
      const y = Kn(r, m, "16float", 2);
      return [y[0], y[1]];
    }
    case "rgba16uint": {
      const y = Kn(r, m, "16uint", 4);
      return [y[0], y[1], y[2], y[3]];
    }
    case "rgba16sint": {
      const y = Kn(r, m, "16sint", 4);
      return [y[0], y[1], y[2], y[3]];
    }
    case "rgba16float": {
      const y = Kn(r, m, "16float", 4);
      return [y[0], y[1], y[2], y[3]];
    }
    case "r32uint":
      return [Kn(r, m, "32uint", 1)[0]];
    case "r32sint":
      return [Kn(r, m, "32sint", 1)[0]];
    case "depth16unorm":
    case "depth24plus":
    case "depth24plus-stencil8":
    case "depth32float":
    case "depth32float-stencil8":
    case "r32float":
      return [Kn(r, m, "32float", 1)[0]];
    case "rg32uint": {
      const y = Kn(r, m, "32uint", 2);
      return [y[0], y[1]];
    }
    case "rg32sint": {
      const y = Kn(r, m, "32sint", 2);
      return [y[0], y[1]];
    }
    case "rg32float": {
      const y = Kn(r, m, "32float", 2);
      return [y[0], y[1]];
    }
    case "rgba32uint": {
      const y = Kn(r, m, "32uint", 4);
      return [y[0], y[1], y[2], y[3]];
    }
    case "rgba32sint": {
      const y = Kn(r, m, "32sint", 4);
      return [y[0], y[1], y[2], y[3]];
    }
    case "rgba32float": {
      const y = Kn(r, m, "32float", 4);
      return [y[0], y[1], y[2], y[3]];
    }
    case "rg11b10ufloat": {
      const y = new Uint32Array(r.buffer, m, 1)[0], E = (4192256 & y) >> 11, P = (4290772992 & y) >> 22;
      return [ZE(2047 & y), ZE(E), (function(L) {
        const U = 112 + (L >> 5 & 31) << 23 | (31 & L) << 18;
        return _x[0] = U, $B[0];
      })(P), 1];
    }
  }
  return null;
}
function Kn(r, e, t, n) {
  const i = [0, 0, 0, 0];
  for (let s = 0; s < n; ++s) switch (t) {
    case "8unorm":
      i[s] = r[e] / 255, e++;
      break;
    case "8snorm":
      i[s] = r[e] / 255 * 2 - 1, e++;
      break;
    case "8uint":
      i[s] = r[e], e++;
      break;
    case "8sint":
      i[s] = r[e] - 127, e++;
      break;
    case "16uint":
      i[s] = r[e] | r[e + 1] << 8, e += 2;
      break;
    case "16sint":
      i[s] = (r[e] | r[e + 1] << 8) - 32768, e += 2;
      break;
    case "16float":
      i[s] = x7(r[e] | r[e + 1] << 8), e += 2;
      break;
    case "32uint":
    case "32sint":
      i[s] = r[e] | r[e + 1] << 8 | r[e + 2] << 16 | r[e + 3] << 24, e += 4;
      break;
    case "32float":
      i[s] = new Float32Array(r.buffer, e, 1)[0], e += 4;
  }
  return i;
}
function ri(r, e, t, n, i) {
  for (let s = 0; s < n; ++s) switch (t) {
    case "8unorm":
      r[e] = 255 * i[s], e++;
      break;
    case "8snorm":
      r[e] = 0.5 * (i[s] + 1) * 255, e++;
      break;
    case "8uint":
      r[e] = i[s], e++;
      break;
    case "8sint":
      r[e] = i[s] + 127, e++;
      break;
    case "16uint":
      new Uint16Array(r.buffer, e, 1)[0] = i[s], e += 2;
      break;
    case "16sint":
      new Int16Array(r.buffer, e, 1)[0] = i[s], e += 2;
      break;
    case "16float": {
      const o = T7(i[s]);
      new Uint16Array(r.buffer, e, 1)[0] = o, e += 2;
      break;
    }
    case "32uint":
      new Uint32Array(r.buffer, e, 1)[0] = i[s], e += 4;
      break;
    case "32sint":
      new Int32Array(r.buffer, e, 1)[0] = i[s], e += 4;
      break;
    case "32float":
      new Float32Array(r.buffer, e, 1)[0] = i[s], e += 4;
  }
  return i;
}
const Ev = { r8unorm: { bytesPerBlock: 1, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 1 }, r8snorm: { bytesPerBlock: 1, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 1 }, r8uint: { bytesPerBlock: 1, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 1 }, r8sint: { bytesPerBlock: 1, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 1 }, rg8unorm: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 2 }, rg8snorm: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 2 }, rg8uint: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 2 }, rg8sint: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 2 }, rgba8unorm: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 4 }, "rgba8unorm-srgb": { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 4 }, rgba8snorm: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 4 }, rgba8uint: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 4 }, rgba8sint: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 4 }, bgra8unorm: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 4 }, "bgra8unorm-srgb": { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 4 }, r16uint: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 1 }, r16sint: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 1 }, r16float: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 1 }, rg16uint: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 2 }, rg16sint: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 2 }, rg16float: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 2 }, rgba16uint: { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 4 }, rgba16sint: { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 4 }, rgba16float: { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 4 }, r32uint: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 1 }, r32sint: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 1 }, r32float: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 1 }, rg32uint: { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 2 }, rg32sint: { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 2 }, rg32float: { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 2 }, rgba32uint: { bytesPerBlock: 16, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 4 }, rgba32sint: { bytesPerBlock: 16, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 4 }, rgba32float: { bytesPerBlock: 16, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 4 }, rgb10a2uint: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 4 }, rgb10a2unorm: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 4 }, rg11b10ufloat: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 4 }, stencil8: { bytesPerBlock: 1, blockWidth: 1, blockHeight: 1, isCompressed: !1, isDepthStencil: !0, hasDepth: !1, hasStencil: !0, channels: 1 }, depth16unorm: { bytesPerBlock: 2, blockWidth: 1, blockHeight: 1, isCompressed: !1, isDepthStencil: !0, hasDepth: !0, hasStencil: !1, channels: 1 }, depth24plus: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, isDepthStencil: !0, hasDepth: !0, hasStencil: !1, depthOnlyFormat: "depth32float", channels: 1 }, "depth24plus-stencil8": { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: !1, isDepthStencil: !0, hasDepth: !0, hasStencil: !0, depthOnlyFormat: "depth32float", channels: 1 }, depth32float: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, isDepthStencil: !0, hasDepth: !0, hasStencil: !1, channels: 1 }, "depth32float-stencil8": { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: !1, isDepthStencil: !0, hasDepth: !0, hasStencil: !0, stencilOnlyFormat: "depth32float", channels: 1 }, rgb9e5ufloat: { bytesPerBlock: 4, blockWidth: 1, blockHeight: 1, isCompressed: !1, channels: 4 }, "bc1-rgba-unorm": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 4 }, "bc1-rgba-unorm-srgb": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 4 }, "bc2-rgba-unorm": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 4 }, "bc2-rgba-unorm-srgb": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 4 }, "bc3-rgba-unorm": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 4 }, "bc3-rgba-unorm-srgb": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 4 }, "bc4-r-unorm": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 1 }, "bc4-r-snorm": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 1 }, "bc5-rg-unorm": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 2 }, "bc5-rg-snorm": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 2 }, "bc6h-rgb-ufloat": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 4 }, "bc6h-rgb-float": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 4 }, "bc7-rgba-unorm": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 4 }, "bc7-rgba-unorm-srgb": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 4 }, "etc2-rgb8unorm": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 4 }, "etc2-rgb8unorm-srgb": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 4 }, "etc2-rgb8a1unorm": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 4 }, "etc2-rgb8a1unorm-srgb": { bytesPerBlock: 8, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 4 }, "etc2-rgba8unorm": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 4 }, "etc2-rgba8unorm-srgb": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 4 }, "eac-r11unorm": { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: !0, channels: 1 }, "eac-r11snorm": { bytesPerBlock: 8, blockWidth: 1, blockHeight: 1, isCompressed: !0, channels: 1 }, "eac-rg11unorm": { bytesPerBlock: 16, blockWidth: 1, blockHeight: 1, isCompressed: !0, channels: 2 }, "eac-rg11snorm": { bytesPerBlock: 16, blockWidth: 1, blockHeight: 1, isCompressed: !0, channels: 2 }, "astc-4x4-unorm": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 4 }, "astc-4x4-unorm-srgb": { bytesPerBlock: 16, blockWidth: 4, blockHeight: 4, isCompressed: !0, channels: 4 }, "astc-5x4-unorm": { bytesPerBlock: 16, blockWidth: 5, blockHeight: 4, isCompressed: !0, channels: 4 }, "astc-5x4-unorm-srgb": { bytesPerBlock: 16, blockWidth: 5, blockHeight: 4, isCompressed: !0, channels: 4 }, "astc-5x5-unorm": { bytesPerBlock: 16, blockWidth: 5, blockHeight: 5, isCompressed: !0, channels: 4 }, "astc-5x5-unorm-srgb": { bytesPerBlock: 16, blockWidth: 5, blockHeight: 5, isCompressed: !0, channels: 4 }, "astc-6x5-unorm": { bytesPerBlock: 16, blockWidth: 6, blockHeight: 5, isCompressed: !0, channels: 4 }, "astc-6x5-unorm-srgb": { bytesPerBlock: 16, blockWidth: 6, blockHeight: 5, isCompressed: !0, channels: 4 }, "astc-6x6-unorm": { bytesPerBlock: 16, blockWidth: 6, blockHeight: 6, isCompressed: !0, channels: 4 }, "astc-6x6-unorm-srgb": { bytesPerBlock: 16, blockWidth: 6, blockHeight: 6, isCompressed: !0, channels: 4 }, "astc-8x5-unorm": { bytesPerBlock: 16, blockWidth: 8, blockHeight: 5, isCompressed: !0, channels: 4 }, "astc-8x5-unorm-srgb": { bytesPerBlock: 16, blockWidth: 8, blockHeight: 5, isCompressed: !0, channels: 4 }, "astc-8x6-unorm": { bytesPerBlock: 16, blockWidth: 8, blockHeight: 6, isCompressed: !0, channels: 4 }, "astc-8x6-unorm-srgb": { bytesPerBlock: 16, blockWidth: 8, blockHeight: 6, isCompressed: !0, channels: 4 }, "astc-8x8-unorm": { bytesPerBlock: 16, blockWidth: 8, blockHeight: 8, isCompressed: !0, channels: 4 }, "astc-8x8-unorm-srgb": { bytesPerBlock: 16, blockWidth: 8, blockHeight: 8, isCompressed: !0, channels: 4 }, "astc-10x5-unorm": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 5, isCompressed: !0, channels: 4 }, "astc-10x5-unorm-srgb": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 5, isCompressed: !0, channels: 4 }, "astc-10x6-unorm": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 6, isCompressed: !0, channels: 4 }, "astc-10x6-unorm-srgb": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 6, isCompressed: !0, channels: 4 }, "astc-10x8-unorm": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 8, isCompressed: !0, channels: 4 }, "astc-10x8-unorm-srgb": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 8, isCompressed: !0, channels: 4 }, "astc-10x10-unorm": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 10, isCompressed: !0, channels: 4 }, "astc-10x10-unorm-srgb": { bytesPerBlock: 16, blockWidth: 10, blockHeight: 10, isCompressed: !0, channels: 4 }, "astc-12x10-unorm": { bytesPerBlock: 16, blockWidth: 12, blockHeight: 10, isCompressed: !0, channels: 4 }, "astc-12x10-unorm-srgb": { bytesPerBlock: 16, blockWidth: 12, blockHeight: 10, isCompressed: !0, channels: 4 }, "astc-12x12-unorm": { bytesPerBlock: 16, blockWidth: 12, blockHeight: 12, isCompressed: !0, channels: 4 }, "astc-12x12-unorm-srgb": { bytesPerBlock: 16, blockWidth: 12, blockHeight: 12, isCompressed: !0, channels: 4 } };
let fc = class qB {
  constructor() {
    this.id = qB._id++, this.line = 0;
  }
  get isAstNode() {
    return !0;
  }
  get astNodeType() {
    return "";
  }
  search(e) {
    e(this);
  }
  searchBlock(e, t) {
    if (e) {
      t(Ym.instance);
      for (const n of e) n instanceof Array ? this.searchBlock(n, t) : n.search(t);
      t(Km.instance);
    }
  }
  constEvaluate(e, t) {
    throw new Error("Cannot evaluate node");
  }
  constEvaluateString(e) {
    return this.constEvaluate(e).toString();
  }
};
fc._id = 0;
let Ym = class extends fc {
};
Ym.instance = new Ym();
class Km extends fc {
}
Km.instance = new Km();
const XB = /* @__PURE__ */ new Set(["all", "all", "any", "select", "arrayLength", "abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "clamp", "cos", "cosh", "countLeadingZeros", "countOneBits", "countTrailingZeros", "cross", "degrees", "determinant", "distance", "dot", "dot4U8Packed", "dot4I8Packed", "exp", "exp2", "extractBits", "faceForward", "firstLeadingBit", "firstTrailingBit", "floor", "fma", "fract", "frexp", "insertBits", "inverseSqrt", "ldexp", "length", "log", "log2", "max", "min", "mix", "modf", "normalize", "pow", "quantizeToF16", "radians", "reflect", "refract", "reverseBits", "round", "saturate", "sign", "sin", "sinh", "smoothStep", "sqrt", "step", "tan", "tanh", "transpose", "trunc", "dpdx", "dpdxCoarse", "dpdxFine", "dpdy", "dpdyCoarse", "dpdyFine", "fwidth", "fwidthCoarse", "fwidthFine", "textureDimensions", "textureGather", "textureGatherCompare", "textureLoad", "textureNumLayers", "textureNumLevels", "textureNumSamples", "textureSample", "textureSampleBias", "textureSampleCompare", "textureSampleCompareLevel", "textureSampleGrad", "textureSampleLevel", "textureSampleBaseClampToEdge", "textureStore", "atomicLoad", "atomicStore", "atomicAdd", "atomicSub", "atomicMax", "atomicMin", "atomicAnd", "atomicOr", "atomicXor", "atomicExchange", "atomicCompareExchangeWeak", "pack4x8snorm", "pack4x8unorm", "pack4xI8", "pack4xU8", "pack4x8Clamp", "pack4xU8Clamp", "pack2x16snorm", "pack2x16unorm", "pack2x16float", "unpack4x8snorm", "unpack4x8unorm", "unpack4xI8", "unpack4xU8", "unpack2x16snorm", "unpack2x16unorm", "unpack2x16float", "storageBarrier", "textureBarrier", "workgroupBarrier", "workgroupUniformLoad", "subgroupAdd", "subgroupExclusiveAdd", "subgroupInclusiveAdd", "subgroupAll", "subgroupAnd", "subgroupAny", "subgroupBallot", "subgroupBroadcast", "subgroupBroadcastFirst", "subgroupElect", "subgroupMax", "subgroupMin", "subgroupMul", "subgroupExclusiveMul", "subgroupInclusiveMul", "subgroupOr", "subgroupShuffle", "subgroupShuffleDown", "subgroupShuffleUp", "subgroupShuffleXor", "subgroupXor", "quadBroadcast", "quadSwapDiagonal", "quadSwapX", "quadSwapY"]);
let Ni = class extends fc {
  constructor() {
    super();
  }
}, t0 = class extends Ni {
  constructor(e, t, n, i, s, o) {
    super(), this.calls = /* @__PURE__ */ new Set(), this.name = e, this.args = t, this.returnType = n, this.body = i, this.startLine = s, this.endLine = o;
  }
  get astNodeType() {
    return "function";
  }
  search(e) {
    if (this.attributes) for (const t of this.attributes) e(t);
    e(this);
    for (const t of this.args) e(t);
    this.searchBlock(this.body, e);
  }
};
class C7 extends Ni {
  constructor(e) {
    super(), this.expression = e;
  }
  get astNodeType() {
    return "staticAssert";
  }
  search(e) {
    this.expression.search(e);
  }
}
let ZB = class extends Ni {
  constructor(e, t) {
    super(), this.condition = e, this.body = t;
  }
  get astNodeType() {
    return "while";
  }
  search(e) {
    this.condition.search(e), this.searchBlock(this.body, e);
  }
};
class Sb extends Ni {
  constructor(e, t) {
    super(), this.body = e, this.loopId = t;
  }
  get astNodeType() {
    return "continuing";
  }
  search(e) {
    this.searchBlock(this.body, e);
  }
}
let YB = class extends Ni {
  constructor(e, t, n, i) {
    super(), this.init = e, this.condition = t, this.increment = n, this.body = i;
  }
  get astNodeType() {
    return "for";
  }
  search(e) {
    var t, n, i;
    (t = this.init) === null || t === void 0 || t.search(e), (n = this.condition) === null || n === void 0 || n.search(e), (i = this.increment) === null || i === void 0 || i.search(e), this.searchBlock(this.body, e);
  }
}, Gc = class extends Ni {
  constructor(e, t, n, i, s) {
    super(), this.attributes = null, this.name = e, this.type = t, this.storage = n, this.access = i, this.value = s;
  }
  get astNodeType() {
    return "var";
  }
  search(e) {
    var t;
    e(this), (t = this.value) === null || t === void 0 || t.search(e);
  }
};
class yx extends Ni {
  constructor(e, t, n) {
    super(), this.attributes = null, this.name = e, this.type = t, this.value = n;
  }
  get astNodeType() {
    return "override";
  }
  search(e) {
    var t;
    (t = this.value) === null || t === void 0 || t.search(e);
  }
}
class UA extends Ni {
  constructor(e, t, n, i, s) {
    super(), this.attributes = null, this.name = e, this.type = t, this.storage = n, this.access = i, this.value = s;
  }
  get astNodeType() {
    return "let";
  }
  search(e) {
    var t;
    e(this), (t = this.value) === null || t === void 0 || t.search(e);
  }
}
class mm extends Ni {
  constructor(e, t, n, i, s) {
    super(), this.attributes = null, this.name = e, this.type = t, this.storage = n, this.access = i, this.value = s;
  }
  get astNodeType() {
    return "const";
  }
  constEvaluate(e, t) {
    return this.value.constEvaluate(e, t);
  }
  search(e) {
    var t;
    e(this), (t = this.value) === null || t === void 0 || t.search(e);
  }
}
var Wd, PA, wt, ft;
((r) => {
  r.increment = "++", r.decrement = "--";
})(Wd || (Wd = {})), ((r) => {
  r.parse = function(e) {
    const t = e;
    if (t == "parse") throw new Error("Invalid value for IncrementOperator");
    return r[t];
  };
})(Wd || (Wd = {}));
class KB extends Ni {
  constructor(e, t) {
    super(), this.operator = e, this.variable = t;
  }
  get astNodeType() {
    return "increment";
  }
  search(e) {
    this.variable.search(e);
  }
}
((r) => {
  r.assign = "=", r.addAssign = "+=", r.subtractAssin = "-=", r.multiplyAssign = "*=", r.divideAssign = "/=", r.moduloAssign = "%=", r.andAssign = "&=", r.orAssign = "|=", r.xorAssign = "^=", r.shiftLeftAssign = "<<=", r.shiftRightAssign = ">>=";
})(PA || (PA = {})), ((r) => {
  r.parse = function(e) {
    const t = e;
    if (t == "parse") throw new Error("Invalid value for AssignOperator");
    return t;
  };
})(PA || (PA = {}));
let QB = class extends Ni {
  constructor(e, t, n) {
    super(), this.operator = e, this.variable = t, this.value = n;
  }
  get astNodeType() {
    return "assign";
  }
  search(e) {
    this.variable.search(e), this.value.search(e);
  }
};
class vx extends Ni {
  constructor(e, t) {
    super(), this.name = e, this.args = t;
  }
  get astNodeType() {
    return "call";
  }
  isBuiltin() {
    return XB.has(this.name);
  }
  search(e) {
    for (const t of this.args) t.search(e);
    e(this);
  }
}
class JB extends Ni {
  constructor(e, t) {
    super(), this.body = e, this.continuing = t;
  }
  get astNodeType() {
    return "loop";
  }
  search(e) {
    var t;
    this.searchBlock(this.body, e), (t = this.continuing) === null || t === void 0 || t.search(e);
  }
}
class eO extends Ni {
  constructor(e, t) {
    super(), this.condition = e, this.cases = t;
  }
  get astNodeType() {
    return "switch";
  }
  search(e) {
    e(this);
    for (const t of this.cases) t.search(e);
  }
}
class tO extends Ni {
  constructor(e, t, n, i) {
    super(), this.condition = e, this.body = t, this.elseif = n, this.else = i;
  }
  get astNodeType() {
    return "if";
  }
  search(e) {
    this.condition.search(e), this.searchBlock(this.body, e), this.searchBlock(this.elseif, e), this.searchBlock(this.else, e);
  }
}
class rO extends Ni {
  constructor(e) {
    super(), this.value = e;
  }
  get astNodeType() {
    return "return";
  }
  search(e) {
    var t;
    (t = this.value) === null || t === void 0 || t.search(e);
  }
}
class S7 extends Ni {
  constructor(e) {
    super(), this.name = e;
  }
  get astNodeType() {
    return "enable";
  }
}
class I7 extends Ni {
  constructor(e) {
    super(), this.extensions = e;
  }
  get astNodeType() {
    return "requires";
  }
}
class nO extends Ni {
  constructor(e, t) {
    super(), this.severity = e, this.rule = t;
  }
  get astNodeType() {
    return "diagnostic";
  }
}
class bx extends Ni {
  constructor(e, t) {
    super(), this.name = e, this.type = t;
  }
  get astNodeType() {
    return "alias";
  }
}
class P7 extends Ni {
  constructor() {
    super();
  }
  get astNodeType() {
    return "discard";
  }
}
class iO extends Ni {
  constructor() {
    super(), this.condition = null, this.loopId = -1;
  }
  get astNodeType() {
    return "break";
  }
}
class sO extends Ni {
  constructor() {
    super(), this.loopId = -1;
  }
  get astNodeType() {
    return "continue";
  }
}
class $t extends Ni {
  constructor(e) {
    super(), this.attributes = null, this.name = e;
  }
  get astNodeType() {
    return "type";
  }
  get isStruct() {
    return !1;
  }
  get isArray() {
    return !1;
  }
  static maxFormatType(e) {
    let t = e[0];
    if (t.name === "f32") return t;
    for (let n = 1; n < e.length; ++n) {
      const i = $t._priority.get(t.name);
      $t._priority.get(e[n].name) < i && (t = e[n]);
    }
    return t.name === "x32" ? $t.i32 : t;
  }
  getTypeName() {
    return this.name;
  }
}
$t.x32 = new $t("x32"), $t.f32 = new $t("f32"), $t.i32 = new $t("i32"), $t.u32 = new $t("u32"), $t.f16 = new $t("f16"), $t.bool = new $t("bool"), $t.void = new $t("void"), $t._priority = /* @__PURE__ */ new Map([["f32", 0], ["f16", 1], ["u32", 2], ["i32", 3], ["x32", 3]]);
class YE extends $t {
  constructor(e) {
    super(e);
  }
}
class jc extends $t {
  constructor(e, t, n, i) {
    super(e), this.members = t, this.startLine = n, this.endLine = i;
  }
  get astNodeType() {
    return "struct";
  }
  get isStruct() {
    return !0;
  }
  getMemberIndex(e) {
    for (let t = 0; t < this.members.length; t++) if (this.members[t].name == e) return t;
    return -1;
  }
  search(e) {
    for (const t of this.members) e(t);
  }
}
class mt extends $t {
  constructor(e, t, n) {
    super(e), this.format = t, this.access = n;
  }
  get astNodeType() {
    return "template";
  }
  getTypeName() {
    let e = this.name;
    if (this.format !== null) {
      if (e === "vec2" || e === "vec3" || e === "vec4" || e === "mat2x2" || e === "mat2x3" || e === "mat2x4" || e === "mat3x2" || e === "mat3x3" || e === "mat3x4" || e === "mat4x2" || e === "mat4x3" || e === "mat4x4") {
        if (this.format.name === "f32") return e += "f", e;
        if (this.format.name === "i32") return e += "i", e;
        if (this.format.name === "u32") return e += "u", e;
        if (this.format.name === "bool") return e += "b", e;
        if (this.format.name === "f16") return e += "h", e;
      }
      e += `<${this.format.name}>`;
    } else if (e === "vec2" || e === "vec3" || e === "vec4") return e;
    return e;
  }
}
mt.vec2f = new mt("vec2", $t.f32, null), mt.vec3f = new mt("vec3", $t.f32, null), mt.vec4f = new mt("vec4", $t.f32, null), mt.vec2i = new mt("vec2", $t.i32, null), mt.vec3i = new mt("vec3", $t.i32, null), mt.vec4i = new mt("vec4", $t.i32, null), mt.vec2u = new mt("vec2", $t.u32, null), mt.vec3u = new mt("vec3", $t.u32, null), mt.vec4u = new mt("vec4", $t.u32, null), mt.vec2h = new mt("vec2", $t.f16, null), mt.vec3h = new mt("vec3", $t.f16, null), mt.vec4h = new mt("vec4", $t.f16, null), mt.vec2b = new mt("vec2", $t.bool, null), mt.vec3b = new mt("vec3", $t.bool, null), mt.vec4b = new mt("vec4", $t.bool, null), mt.mat2x2f = new mt("mat2x2", $t.f32, null), mt.mat2x3f = new mt("mat2x3", $t.f32, null), mt.mat2x4f = new mt("mat2x4", $t.f32, null), mt.mat3x2f = new mt("mat3x2", $t.f32, null), mt.mat3x3f = new mt("mat3x3", $t.f32, null), mt.mat3x4f = new mt("mat3x4", $t.f32, null), mt.mat4x2f = new mt("mat4x2", $t.f32, null), mt.mat4x3f = new mt("mat4x3", $t.f32, null), mt.mat4x4f = new mt("mat4x4", $t.f32, null), mt.mat2x2h = new mt("mat2x2", $t.f16, null), mt.mat2x3h = new mt("mat2x3", $t.f16, null), mt.mat2x4h = new mt("mat2x4", $t.f16, null), mt.mat3x2h = new mt("mat3x2", $t.f16, null), mt.mat3x3h = new mt("mat3x3", $t.f16, null), mt.mat3x4h = new mt("mat3x4", $t.f16, null), mt.mat4x2h = new mt("mat4x2", $t.f16, null), mt.mat4x3h = new mt("mat4x3", $t.f16, null), mt.mat4x4h = new mt("mat4x4", $t.f16, null), mt.mat2x2i = new mt("mat2x2", $t.i32, null), mt.mat2x3i = new mt("mat2x3", $t.i32, null), mt.mat2x4i = new mt("mat2x4", $t.i32, null), mt.mat3x2i = new mt("mat3x2", $t.i32, null), mt.mat3x3i = new mt("mat3x3", $t.i32, null), mt.mat3x4i = new mt("mat3x4", $t.i32, null), mt.mat4x2i = new mt("mat4x2", $t.i32, null), mt.mat4x3i = new mt("mat4x3", $t.i32, null), mt.mat4x4i = new mt("mat4x4", $t.i32, null), mt.mat2x2u = new mt("mat2x2", $t.u32, null), mt.mat2x3u = new mt("mat2x3", $t.u32, null), mt.mat2x4u = new mt("mat2x4", $t.u32, null), mt.mat3x2u = new mt("mat3x2", $t.u32, null), mt.mat3x3u = new mt("mat3x3", $t.u32, null), mt.mat3x4u = new mt("mat3x4", $t.u32, null), mt.mat4x2u = new mt("mat4x2", $t.u32, null), mt.mat4x3u = new mt("mat4x3", $t.u32, null), mt.mat4x4u = new mt("mat4x4", $t.u32, null);
class _m extends $t {
  constructor(e, t, n, i) {
    super(e), this.storage = t, this.type = n, this.access = i;
  }
  get astNodeType() {
    return "pointer";
  }
}
class zA extends $t {
  constructor(e, t, n, i) {
    super(e), this.attributes = t, this.format = n, this.count = i;
  }
  get astNodeType() {
    return "array";
  }
  get isArray() {
    return !0;
  }
}
class MA extends $t {
  constructor(e, t, n) {
    super(e), this.format = t, this.access = n;
  }
  get astNodeType() {
    return "sampler";
  }
}
class xl extends fc {
  constructor() {
    super(), this.postfix = null;
  }
}
class nh extends xl {
  constructor(e) {
    super(), this.value = e;
  }
  get astNodeType() {
    return "stringExpr";
  }
  toString() {
    return this.value;
  }
  constEvaluateString() {
    return this.value;
  }
}
class ec extends xl {
  constructor(e, t) {
    super(), this.type = e, this.args = t;
  }
  get astNodeType() {
    return "createExpr";
  }
  search(e) {
    if (e(this), this.args) for (const t of this.args) t.search(e);
  }
  constEvaluate(e, t) {
    return t && (t[0] = this.type), e.evalExpression(this, e.context);
  }
}
class xx extends xl {
  constructor(e, t) {
    super(), this.cachedReturnValue = null, this.name = e, this.args = t;
  }
  get astNodeType() {
    return "callExpr";
  }
  setCachedReturnValue(e) {
    this.cachedReturnValue = e;
  }
  get isBuiltin() {
    return XB.has(this.name);
  }
  constEvaluate(e, t) {
    return e.evalExpression(this, e.context);
  }
  search(e) {
    for (const t of this.args) t.search(e);
    e(this);
  }
}
class ua extends xl {
  constructor(e) {
    super(), this.name = e;
  }
  get astNodeType() {
    return "varExpr";
  }
  search(e) {
    e(this), this.postfix && this.postfix.search(e);
  }
  constEvaluate(e, t) {
    return e.evalExpression(this, e.context);
  }
}
class oO extends xl {
  constructor(e, t) {
    super(), this.name = e, this.initializer = t;
  }
  get astNodeType() {
    return "constExpr";
  }
  constEvaluate(e, t) {
    if (this.initializer) {
      const n = e.evalExpression(this.initializer, e.context);
      return n !== null && this.postfix ? n.getSubData(e, this.postfix, e.context) : n;
    }
    return null;
  }
  search(e) {
    this.initializer.search(e);
  }
}
class Es extends xl {
  constructor(e, t) {
    super(), this.value = e, this.type = t;
  }
  get astNodeType() {
    return "literalExpr";
  }
  constEvaluate(e, t) {
    return t !== void 0 && (t[0] = this.type), this.value;
  }
  get isScalar() {
    return this.value instanceof ut;
  }
  get isVector() {
    return this.value instanceof qe || this.value instanceof ln;
  }
  get scalarValue() {
    return this.value instanceof ut ? this.value.value : (console.error("Value is not scalar."), 0);
  }
  get vectorValue() {
    return this.value instanceof qe || this.value instanceof ln ? this.value.data : (console.error("Value is not a vector or matrix."), new Float32Array(0));
  }
}
class aO extends xl {
  constructor(e, t) {
    super(), this.type = e, this.value = t;
  }
  get astNodeType() {
    return "bitcastExpr";
  }
  search(e) {
    this.value.search(e);
  }
}
class mp extends xl {
  constructor(e) {
    super(), this.index = e;
  }
  search(e) {
    this.index.search(e);
  }
}
class lO extends xl {
  constructor() {
    super();
  }
}
class hs extends lO {
  constructor(e, t) {
    super(), this.operator = e, this.right = t;
  }
  get astNodeType() {
    return "unaryOp";
  }
  constEvaluate(e, t) {
    return e.evalExpression(this, e.context);
  }
  search(e) {
    this.right.search(e);
  }
}
class ol extends lO {
  constructor(e, t, n) {
    super(), this.operator = e, this.left = t, this.right = n;
  }
  get astNodeType() {
    return "binaryOp";
  }
  _getPromotedType(e, t) {
    return e.name === t.name ? e : e.name === "f32" || t.name === "f32" ? $t.f32 : e.name === "u32" || t.name === "u32" ? $t.u32 : $t.i32;
  }
  constEvaluate(e, t) {
    return e.evalExpression(this, e.context);
  }
  search(e) {
    this.left.search(e), this.right.search(e);
  }
}
class cO extends fc {
  constructor(e) {
    super(), this.body = e;
  }
  search(e) {
    e(this), this.searchBlock(this.body, e);
  }
}
class ym extends xl {
  constructor() {
    super();
  }
  get astNodeType() {
    return "default";
  }
}
class uO extends cO {
  constructor(e, t) {
    super(t), this.selectors = e;
  }
  get astNodeType() {
    return "case";
  }
  search(e) {
    this.searchBlock(this.body, e);
  }
}
class fO extends cO {
  constructor(e) {
    super(e);
  }
  get astNodeType() {
    return "default";
  }
  search(e) {
    this.searchBlock(this.body, e);
  }
}
class KE extends fc {
  constructor(e, t, n) {
    super(), this.name = e, this.type = t, this.attributes = n;
  }
  get astNodeType() {
    return "argument";
  }
}
class M7 extends fc {
  constructor(e, t) {
    super(), this.condition = e, this.body = t;
  }
  get astNodeType() {
    return "elseif";
  }
  search(e) {
    this.condition.search(e), this.searchBlock(this.body, e);
  }
}
class QE extends fc {
  constructor(e, t, n) {
    super(), this.name = e, this.type = t, this.attributes = n;
  }
  get astNodeType() {
    return "member";
  }
}
class hO extends fc {
  constructor(e, t) {
    super(), this.name = e, this.value = t;
  }
  get astNodeType() {
    return "attribute";
  }
}
class Ua {
  constructor(e, t) {
    this.parent = null, this.typeInfo = e, this.parent = t, this.id = Ua._id++;
  }
  clone() {
    throw `Clone: Not implemented for ${this.constructor.name}`;
  }
  setDataValue(e, t, n, i) {
    console.error(`SetDataValue: Not implemented for ${this.constructor.name}`);
  }
  getSubData(e, t, n) {
    return console.error(`GetDataValue: Not implemented for ${this.constructor.name}`), null;
  }
  toString() {
    return `<${this.typeInfo.getTypeName()}>`;
  }
}
Ua._id = 0;
class Ib extends Ua {
  constructor() {
    super(new Fa("void", null), null);
  }
  toString() {
    return "void";
  }
}
Ib.void = new Ib();
class yd extends Ua {
  constructor(e) {
    super(new Cb("pointer", e.typeInfo, null), null), this.reference = e;
  }
  clone() {
    return this;
  }
  setDataValue(e, t, n, i) {
    this.reference.setDataValue(e, t, n, i);
  }
  getSubData(e, t, n) {
    return t ? this.reference.getSubData(e, t, n) : this;
  }
  toString() {
    return `&${this.reference.toString()}`;
  }
}
class ut extends Ua {
  constructor(e, t, n = null) {
    super(t, n), e instanceof Int32Array || e instanceof Uint32Array || e instanceof Float32Array ? this.data = e : this.typeInfo.name === "x32" ? e - Math.floor(e) !== 0 ? this.data = new Float32Array([e]) : this.data = e >= 0 ? new Uint32Array([e]) : new Int32Array([e]) : this.typeInfo.name === "i32" || this.typeInfo.name === "bool" ? this.data = new Int32Array([e]) : this.typeInfo.name === "u32" ? this.data = new Uint32Array([e]) : this.typeInfo.name === "f32" || this.typeInfo.name === "f16" ? this.data = new Float32Array([e]) : console.error("ScalarData2: Invalid type", t);
  }
  clone() {
    if (this.data instanceof Float32Array) return new ut(new Float32Array(this.data), this.typeInfo, null);
    if (this.data instanceof Int32Array) return new ut(new Int32Array(this.data), this.typeInfo, null);
    if (this.data instanceof Uint32Array) return new ut(new Uint32Array(this.data), this.typeInfo, null);
    throw "ScalarData: Invalid data type";
  }
  get value() {
    return this.data[0];
  }
  set value(e) {
    this.data[0] = e;
  }
  setDataValue(e, t, n, i) {
    if (n) return void console.error("SetDataValue: Scalar data does not support postfix", n);
    if (!(t instanceof ut)) return void console.error("SetDataValue: Invalid value", t);
    let s = t.data[0];
    this.typeInfo.name === "i32" || this.typeInfo.name === "u32" ? s = Math.floor(s) : this.typeInfo.name === "bool" && (s = s ? 1 : 0), this.data[0] = s;
  }
  getSubData(e, t, n) {
    return t ? (console.error("getSubData: Scalar data does not support postfix", t), null) : this;
  }
  toString() {
    return `${this.value}`;
  }
}
function R7(r, e, t) {
  const n = e.length;
  return n === 2 ? t === "f32" ? new qe(new Float32Array(e), r.getTypeInfo("vec2f")) : t === "i32" || t === "bool" ? new qe(new Int32Array(e), r.getTypeInfo("vec2i")) : t === "u32" ? new qe(new Uint32Array(e), r.getTypeInfo("vec2u")) : t === "f16" ? new qe(new Float32Array(e), r.getTypeInfo("vec2h")) : (console.error(`getSubData: Unknown format ${t}`), null) : n === 3 ? t === "f32" ? new qe(new Float32Array(e), r.getTypeInfo("vec3f")) : t === "i32" || t === "bool" ? new qe(new Int32Array(e), r.getTypeInfo("vec3i")) : t === "u32" ? new qe(new Uint32Array(e), r.getTypeInfo("vec3u")) : t === "f16" ? new qe(new Float32Array(e), r.getTypeInfo("vec3h")) : (console.error(`getSubData: Unknown format ${t}`), null) : n === 4 ? t === "f32" ? new qe(new Float32Array(e), r.getTypeInfo("vec4f")) : t === "i32" || t === "bool" ? new qe(new Int32Array(e), r.getTypeInfo("vec4i")) : t === "u32" ? new qe(new Uint32Array(e), r.getTypeInfo("vec4u")) : t === "f16" ? new qe(new Float32Array(e), r.getTypeInfo("vec4h")) : (console.error(`getSubData: Unknown format ${t}`), null) : (console.error(`getSubData: Invalid vector size ${e.length}`), null);
}
class qe extends Ua {
  constructor(e, t, n = null) {
    if (super(t, n), e instanceof Float32Array || e instanceof Uint32Array || e instanceof Int32Array) this.data = e;
    else {
      const i = this.typeInfo.name;
      i === "vec2f" || i === "vec3f" || i === "vec4f" ? this.data = new Float32Array(e) : i === "vec2i" || i === "vec3i" || i === "vec4i" ? this.data = new Int32Array(e) : i === "vec2u" || i === "vec3u" || i === "vec4u" ? this.data = new Uint32Array(e) : i === "vec2h" || i === "vec3h" || i === "vec4h" ? this.data = new Float32Array(e) : i === "vec2b" || i === "vec3b" || i === "vec4b" ? this.data = new Int32Array(e) : i === "vec2" || i === "vec3" || i === "vec4" ? this.data = new Float32Array(e) : console.error(`VectorData: Invalid type ${i}`);
    }
  }
  clone() {
    if (this.data instanceof Float32Array) return new qe(new Float32Array(this.data), this.typeInfo, null);
    if (this.data instanceof Int32Array) return new qe(new Int32Array(this.data), this.typeInfo, null);
    if (this.data instanceof Uint32Array) return new qe(new Uint32Array(this.data), this.typeInfo, null);
    throw "VectorData: Invalid data type";
  }
  setDataValue(e, t, n, i) {
    n instanceof nh ? console.error("TODO: Set vector postfix") : t instanceof qe ? this.data = t.data : console.error("SetDataValue: Invalid value", t);
  }
  getSubData(e, t, n) {
    if (t === null) return this;
    let i = e.getTypeInfo("f32");
    if (this.typeInfo instanceof rh) i = this.typeInfo.format || i;
    else {
      const o = this.typeInfo.name;
      o === "vec2f" || o === "vec3f" || o === "vec4f" ? i = e.getTypeInfo("f32") : o === "vec2i" || o === "vec3i" || o === "vec4i" ? i = e.getTypeInfo("i32") : o === "vec2b" || o === "vec3b" || o === "vec4b" ? i = e.getTypeInfo("bool") : o === "vec2u" || o === "vec3u" || o === "vec4u" ? i = e.getTypeInfo("u32") : o === "vec2h" || o === "vec3h" || o === "vec4h" ? i = e.getTypeInfo("f16") : console.error(`GetSubData: Unknown type ${o}`);
    }
    let s = this;
    for (; t !== null && s !== null; ) {
      if (t instanceof mp) {
        const o = t.index;
        let l = -1;
        if (o instanceof Es) {
          if (!(o.value instanceof ut)) return console.error(`GetSubData: Invalid array index ${o.value}`), null;
          l = o.value.value;
        } else {
          const u = e.evalExpression(o, n);
          if (!(u instanceof ut)) return console.error("GetSubData: Unknown index type", o), null;
          l = u.value;
        }
        if (l < 0 || l >= s.data.length) return console.error("GetSubData: Index out of range", l), null;
        if (s.data instanceof Float32Array) {
          const u = new Float32Array(s.data.buffer, s.data.byteOffset + 4 * l, 1);
          return new ut(u, i);
        }
        if (s.data instanceof Int32Array) {
          const u = new Int32Array(s.data.buffer, s.data.byteOffset + 4 * l, 1);
          return new ut(u, i);
        }
        if (s.data instanceof Uint32Array) {
          const u = new Uint32Array(s.data.buffer, s.data.byteOffset + 4 * l, 1);
          return new ut(u, i);
        }
        throw "GetSubData: Invalid data type";
      }
      if (!(t instanceof nh)) return console.error("GetSubData: Unknown postfix", t), null;
      {
        const o = t.value.toLowerCase();
        if (o.length === 1) {
          let u = 0;
          if (o === "x" || o === "r") u = 0;
          else if (o === "y" || o === "g") u = 1;
          else if (o === "z" || o === "b") u = 2;
          else {
            if (o !== "w" && o !== "a") return console.error(`GetSubData: Unknown member ${o}`), null;
            u = 3;
          }
          if (this.data instanceof Float32Array) {
            let m = new Float32Array(this.data.buffer, this.data.byteOffset + 4 * u, 1);
            return new ut(m, i, this);
          }
          if (this.data instanceof Int32Array) {
            let m = new Int32Array(this.data.buffer, this.data.byteOffset + 4 * u, 1);
            return new ut(m, i, this);
          }
          if (this.data instanceof Uint32Array) {
            let m = new Uint32Array(this.data.buffer, this.data.byteOffset + 4 * u, 1);
            return new ut(m, i, this);
          }
        }
        const l = [];
        for (const u of o) u === "x" || u === "r" ? l.push(this.data[0]) : u === "y" || u === "g" ? l.push(this.data[1]) : u === "z" || u === "b" ? l.push(this.data[2]) : u === "w" || u === "a" ? l.push(this.data[3]) : console.error(`GetDataValue: Unknown member ${u}`);
        s = R7(e, l, i.name);
      }
      t = t.postfix;
    }
    return s;
  }
  toString() {
    let e = `${this.data[0]}`;
    for (let t = 1; t < this.data.length; ++t) e += `, ${this.data[t]}`;
    return e;
  }
}
class ln extends Ua {
  constructor(e, t, n = null) {
    super(t, n), e instanceof Float32Array ? this.data = e : this.data = new Float32Array(e);
  }
  clone() {
    return new ln(new Float32Array(this.data), this.typeInfo, null);
  }
  setDataValue(e, t, n, i) {
    n instanceof nh ? console.error("TODO: Set matrix postfix") : t instanceof ln ? this.data = t.data : console.error("SetDataValue: Invalid value", t);
  }
  getSubData(e, t, n) {
    if (t === null) return this;
    const i = this.typeInfo.name;
    if (e.getTypeInfo("f32"), this.typeInfo instanceof rh) this.typeInfo.format;
    else if (i.endsWith("f")) e.getTypeInfo("f32");
    else if (i.endsWith("i")) e.getTypeInfo("i32");
    else if (i.endsWith("u")) e.getTypeInfo("u32");
    else {
      if (!i.endsWith("h")) return console.error(`GetDataValue: Unknown type ${i}`), null;
      e.getTypeInfo("f16");
    }
    if (t instanceof mp) {
      const s = t.index;
      let o = -1;
      if (s instanceof Es) {
        if (!(s.value instanceof ut)) return console.error(`GetDataValue: Invalid array index ${s.value}`), null;
        o = s.value.value;
      } else {
        const m = e.evalExpression(s, n);
        if (!(m instanceof ut)) return console.error("GetDataValue: Unknown index type", s), null;
        o = m.value;
      }
      if (o < 0 || o >= this.data.length) return console.error("GetDataValue: Index out of range", o), null;
      const l = i.endsWith("h") ? "h" : "f";
      let u;
      if (i === "mat2x2" || i === "mat2x2f" || i === "mat2x2h" || i === "mat3x2" || i === "mat3x2f" || i === "mat3x2h" || i === "mat4x2" || i === "mat4x2f" || i === "mat4x2h") u = new qe(new Float32Array(this.data.buffer, this.data.byteOffset + 2 * o * 4, 2), e.getTypeInfo(`vec2${l}`));
      else if (i === "mat2x3" || i === "mat2x3f" || i === "mat2x3h" || i === "mat3x3" || i === "mat3x3f" || i === "mat3x3h" || i === "mat4x3" || i === "mat4x3f" || i === "mat4x3h") u = new qe(new Float32Array(this.data.buffer, this.data.byteOffset + 3 * o * 4, 3), e.getTypeInfo(`vec3${l}`));
      else {
        if (i !== "mat2x4" && i !== "mat2x4f" && i !== "mat2x4h" && i !== "mat3x4" && i !== "mat3x4f" && i !== "mat3x4h" && i !== "mat4x4" && i !== "mat4x4f" && i !== "mat4x4h") return console.error(`GetDataValue: Unknown type ${i}`), null;
        u = new qe(new Float32Array(this.data.buffer, this.data.byteOffset + 4 * o * 4, 4), e.getTypeInfo(`vec4${l}`));
      }
      return t.postfix ? u.getSubData(e, t.postfix, n) : u;
    }
    return console.error("GetDataValue: Invalid postfix", t), null;
  }
  toString() {
    let e = `${this.data[0]}`;
    for (let t = 1; t < this.data.length; ++t) e += `, ${this.data[t]}`;
    return e;
  }
}
class Ji extends Ua {
  constructor(e, t, n = 0, i = null) {
    super(t, i), this.buffer = e instanceof ArrayBuffer ? e : e.buffer, this.offset = n;
  }
  clone() {
    const e = new Uint8Array(new Uint8Array(this.buffer, this.offset, this.typeInfo.size));
    return new Ji(e.buffer, this.typeInfo, 0, null);
  }
  setDataValue(e, t, n, i) {
    if (t === null) return void console.log("setDataValue: NULL data.");
    let s = this.offset, o = this.typeInfo;
    for (; n; ) {
      if (n instanceof mp) if (o instanceof $u) {
        const l = n.index;
        if (l instanceof Es) {
          if (!(l.value instanceof ut)) return void console.error(`SetDataValue: Invalid index type ${l.value}`);
          s += l.value.value * o.stride;
        } else {
          const u = e.evalExpression(l, i);
          if (!(u instanceof ut)) return void console.error("SetDataValue: Unknown index type", l);
          s += u.value * o.stride;
        }
        o = o.format;
      } else console.error(`SetDataValue: Type ${o.getTypeName()} is not an array`);
      else {
        if (!(n instanceof nh)) return void console.error("SetDataValue: Unknown postfix type", n);
        {
          const l = n.value;
          if (o instanceof ju) {
            let u = !1;
            for (const m of o.members) if (m.name === l) {
              s += m.offset, o = m.type, u = !0;
              break;
            }
            if (!u) return void console.error(`SetDataValue: Member ${l} not found`);
          } else if (o instanceof Fa) {
            const u = o.getTypeName();
            let m = 0;
            if (l === "x" || l === "r") m = 0;
            else if (l === "y" || l === "g") m = 1;
            else if (l === "z" || l === "b") m = 2;
            else {
              if (l !== "w" && l !== "a") return void console.error(`SetDataValue: Unknown member ${l}`);
              m = 3;
            }
            if (!(t instanceof ut)) return void console.error("SetDataValue: Invalid value", t);
            const y = t.value;
            return u === "vec2f" ? void (new Float32Array(this.buffer, s, 2)[m] = y) : u === "vec3f" ? void (new Float32Array(this.buffer, s, 3)[m] = y) : u === "vec4f" ? void (new Float32Array(this.buffer, s, 4)[m] = y) : u === "vec2i" ? void (new Int32Array(this.buffer, s, 2)[m] = y) : u === "vec3i" ? void (new Int32Array(this.buffer, s, 3)[m] = y) : u === "vec4i" ? void (new Int32Array(this.buffer, s, 4)[m] = y) : u === "vec2u" ? void (new Uint32Array(this.buffer, s, 2)[m] = y) : u === "vec3u" ? void (new Uint32Array(this.buffer, s, 3)[m] = y) : u === "vec4u" ? void (new Uint32Array(this.buffer, s, 4)[m] = y) : void console.error(`SetDataValue: Type ${u} is not a struct`);
          }
        }
      }
      n = n.postfix;
    }
    this.setData(e, t, o, s, i);
  }
  setData(e, t, n, i, s) {
    const o = n.getTypeName();
    if (o !== "f32" && o !== "f16") if (o !== "i32" && o !== "atomic<i32>" && o !== "x32") if (o !== "u32" && o !== "atomic<u32>") if (o !== "bool") {
      if (o === "vec2f" || o === "vec2h") {
        const l = new Float32Array(this.buffer, i, 2);
        return void (t instanceof qe ? (l[0] = t.data[0], l[1] = t.data[1]) : (l[0] = t[0], l[1] = t[1]));
      }
      if (o === "vec3f" || o === "vec3h") {
        const l = new Float32Array(this.buffer, i, 3);
        return void (t instanceof qe ? (l[0] = t.data[0], l[1] = t.data[1], l[2] = t.data[2]) : (l[0] = t[0], l[1] = t[1], l[2] = t[2]));
      }
      if (o === "vec4f" || o === "vec4h") {
        const l = new Float32Array(this.buffer, i, 4);
        return void (t instanceof qe ? (l[0] = t.data[0], l[1] = t.data[1], l[2] = t.data[2], l[3] = t.data[3]) : (l[0] = t[0], l[1] = t[1], l[2] = t[2], l[3] = t[3]));
      }
      if (o === "vec2i") {
        const l = new Int32Array(this.buffer, i, 2);
        return void (t instanceof qe ? (l[0] = t.data[0], l[1] = t.data[1]) : (l[0] = t[0], l[1] = t[1]));
      }
      if (o === "vec3i") {
        const l = new Int32Array(this.buffer, i, 3);
        return void (t instanceof qe ? (l[0] = t.data[0], l[1] = t.data[1], l[2] = t.data[2]) : (l[0] = t[0], l[1] = t[1], l[2] = t[2]));
      }
      if (o === "vec4i") {
        const l = new Int32Array(this.buffer, i, 4);
        return void (t instanceof qe ? (l[0] = t.data[0], l[1] = t.data[1], l[2] = t.data[2], l[3] = t.data[3]) : (l[0] = t[0], l[1] = t[1], l[2] = t[2], l[3] = t[3]));
      }
      if (o === "vec2u") {
        const l = new Uint32Array(this.buffer, i, 2);
        return void (t instanceof qe ? (l[0] = t.data[0], l[1] = t.data[1]) : (l[0] = t[0], l[1] = t[1]));
      }
      if (o === "vec3u") {
        const l = new Uint32Array(this.buffer, i, 3);
        return void (t instanceof qe ? (l[0] = t.data[0], l[1] = t.data[1], l[2] = t.data[2]) : (l[0] = t[0], l[1] = t[1], l[2] = t[2]));
      }
      if (o === "vec4u") {
        const l = new Uint32Array(this.buffer, i, 4);
        return void (t instanceof qe ? (l[0] = t.data[0], l[1] = t.data[1], l[2] = t.data[2], l[3] = t.data[3]) : (l[0] = t[0], l[1] = t[1], l[2] = t[2], l[3] = t[3]));
      }
      if (o === "vec2b") {
        const l = new Uint32Array(this.buffer, i, 2);
        return void (t instanceof qe ? (l[0] = t.data[0], l[1] = t.data[1]) : (l[0] = t[0], l[1] = t[1]));
      }
      if (o === "vec3b") {
        const l = new Uint32Array(this.buffer, i, 3);
        return void (t instanceof qe ? (l[0] = t.data[0], l[1] = t.data[1], l[2] = t.data[2]) : (l[0] = t[0], l[1] = t[1], l[2] = t[2]));
      }
      if (o === "vec4b") {
        const l = new Uint32Array(this.buffer, i, 4);
        return void (t instanceof qe ? (l[0] = t.data[0], l[1] = t.data[1], l[2] = t.data[2], l[3] = t.data[3]) : (l[0] = t[0], l[1] = t[1], l[2] = t[2], l[3] = t[3]));
      }
      if (o === "mat2x2f" || o === "mat2x2h") {
        const l = new Float32Array(this.buffer, i, 4);
        return void (t instanceof ln ? (l[0] = t.data[0], l[1] = t.data[1], l[2] = t.data[2], l[3] = t.data[3]) : (l[0] = t[0], l[1] = t[1], l[2] = t[2], l[3] = t[3]));
      }
      if (o === "mat2x3f" || o === "mat2x3h") {
        const l = new Float32Array(this.buffer, i, 6);
        return void (t instanceof ln ? (l[0] = t.data[0], l[1] = t.data[1], l[2] = t.data[2], l[3] = t.data[3], l[4] = t.data[4], l[5] = t.data[5]) : (l[0] = t[0], l[1] = t[1], l[2] = t[2], l[3] = t[3], l[4] = t[4], l[5] = t[5]));
      }
      if (o === "mat2x4f" || o === "mat2x4h") {
        const l = new Float32Array(this.buffer, i, 8);
        return void (t instanceof ln ? (l[0] = t.data[0], l[1] = t.data[1], l[2] = t.data[2], l[3] = t.data[3], l[4] = t.data[4], l[5] = t.data[5], l[6] = t.data[6], l[7] = t.data[7]) : (l[0] = t[0], l[1] = t[1], l[2] = t[2], l[3] = t[3], l[4] = t[4], l[5] = t[5], l[6] = t[6], l[7] = t[7]));
      }
      if (o === "mat3x2f" || o === "mat3x2h") {
        const l = new Float32Array(this.buffer, i, 6);
        return void (t instanceof ln ? (l[0] = t.data[0], l[1] = t.data[1], l[2] = t.data[2], l[3] = t.data[3], l[4] = t.data[4], l[5] = t.data[5]) : (l[0] = t[0], l[1] = t[1], l[2] = t[2], l[3] = t[3], l[4] = t[4], l[5] = t[5]));
      }
      if (o === "mat3x3f" || o === "mat3x3h") {
        const l = new Float32Array(this.buffer, i, 9);
        return void (t instanceof ln ? (l[0] = t.data[0], l[1] = t.data[1], l[2] = t.data[2], l[3] = t.data[3], l[4] = t.data[4], l[5] = t.data[5], l[6] = t.data[6], l[7] = t.data[7], l[8] = t.data[8]) : (l[0] = t[0], l[1] = t[1], l[2] = t[2], l[3] = t[3], l[4] = t[4], l[5] = t[5], l[6] = t[6], l[7] = t[7], l[8] = t[8]));
      }
      if (o === "mat3x4f" || o === "mat3x4h") {
        const l = new Float32Array(this.buffer, i, 12);
        return void (t instanceof ln ? (l[0] = t.data[0], l[1] = t.data[1], l[2] = t.data[2], l[3] = t.data[3], l[4] = t.data[4], l[5] = t.data[5], l[6] = t.data[6], l[7] = t.data[7], l[8] = t.data[8], l[9] = t.data[9], l[10] = t.data[10], l[11] = t.data[11]) : (l[0] = t[0], l[1] = t[1], l[2] = t[2], l[3] = t[3], l[4] = t[4], l[5] = t[5], l[6] = t[6], l[7] = t[7], l[8] = t[8], l[9] = t[9], l[10] = t[10], l[11] = t[11]));
      }
      if (o === "mat4x2f" || o === "mat4x2h") {
        const l = new Float32Array(this.buffer, i, 8);
        return void (t instanceof ln ? (l[0] = t.data[0], l[1] = t.data[1], l[2] = t.data[2], l[3] = t.data[3], l[4] = t.data[4], l[5] = t.data[5], l[6] = t.data[6], l[7] = t.data[7]) : (l[0] = t[0], l[1] = t[1], l[2] = t[2], l[3] = t[3], l[4] = t[4], l[5] = t[5], l[6] = t[6], l[7] = t[7]));
      }
      if (o === "mat4x3f" || o === "mat4x3h") {
        const l = new Float32Array(this.buffer, i, 12);
        return void (t instanceof ln ? (l[0] = t.data[0], l[1] = t.data[1], l[2] = t.data[2], l[3] = t.data[3], l[4] = t.data[4], l[5] = t.data[5], l[6] = t.data[6], l[7] = t.data[7], l[8] = t.data[8], l[9] = t.data[9], l[10] = t.data[10], l[11] = t.data[11]) : (l[0] = t[0], l[1] = t[1], l[2] = t[2], l[3] = t[3], l[4] = t[4], l[5] = t[5], l[6] = t[6], l[7] = t[7], l[8] = t[8], l[9] = t[9], l[10] = t[10], l[11] = t[11]));
      }
      if (o === "mat4x4f" || o === "mat4x4h") {
        const l = new Float32Array(this.buffer, i, 16);
        return void (t instanceof ln ? (l[0] = t.data[0], l[1] = t.data[1], l[2] = t.data[2], l[3] = t.data[3], l[4] = t.data[4], l[5] = t.data[5], l[6] = t.data[6], l[7] = t.data[7], l[8] = t.data[8], l[9] = t.data[9], l[10] = t.data[10], l[11] = t.data[11], l[12] = t.data[12], l[13] = t.data[13], l[14] = t.data[14], l[15] = t.data[15]) : (l[0] = t[0], l[1] = t[1], l[2] = t[2], l[3] = t[3], l[4] = t[4], l[5] = t[5], l[6] = t[6], l[7] = t[7], l[8] = t[8], l[9] = t[9], l[10] = t[10], l[11] = t[11], l[12] = t[12], l[13] = t[13], l[14] = t[14], l[15] = t[15]));
      }
      if (t instanceof Ji) {
        if (n === t.typeInfo)
          return void new Uint8Array(this.buffer, i, t.buffer.byteLength).set(new Uint8Array(t.buffer));
        console.error("SetDataValue: Type mismatch", o, t.typeInfo.getTypeName());
      } else console.error(`SetData: Unknown type ${o}`);
    } else t instanceof ut && (new Int32Array(this.buffer, i, 1)[0] = t.value);
    else t instanceof ut && (new Uint32Array(this.buffer, i, 1)[0] = t.value);
    else t instanceof ut && (new Int32Array(this.buffer, i, 1)[0] = t.value);
    else t instanceof ut && (new Float32Array(this.buffer, i, 1)[0] = t.value);
  }
  getSubData(e, t, n) {
    var i, s, o;
    if (t === null) return this;
    let l = this.offset, u = this.typeInfo;
    for (; t; ) {
      if (t instanceof mp) {
        const y = t.index, E = y instanceof xl ? e.evalExpression(y, n) : y;
        let P = 0;
        if (E instanceof ut ? P = E.value : typeof E == "number" ? P = E : console.error("GetDataValue: Invalid index type", y), u instanceof $u) l += P * u.stride, u = u.format;
        else {
          const L = u.getTypeName();
          L === "mat4x4" || L === "mat4x4f" || L === "mat4x4h" ? (l += 16 * P, u = e.getTypeInfo("vec4f")) : console.error(`getDataValue: Type ${u.getTypeName()} is not an array`);
        }
      } else {
        if (!(t instanceof nh)) return console.error("GetDataValue: Unknown postfix type", t), null;
        {
          const y = t.value;
          if (u instanceof ju) {
            let E = !1;
            for (const P of u.members) if (P.name === y) {
              l += P.offset, u = P.type, E = !0;
              break;
            }
            if (!E) return console.error(`GetDataValue: Member ${y} not found`), null;
          } else if (u instanceof Fa) {
            const E = u.getTypeName();
            if (E === "vec2f" || E === "vec3f" || E === "vec4f" || E === "vec2i" || E === "vec3i" || E === "vec4i" || E === "vec2u" || E === "vec3u" || E === "vec4u" || E === "vec2b" || E === "vec3b" || E === "vec4b" || E === "vec2h" || E === "vec3h" || E === "vec4h" || E === "vec2" || E === "vec3" || E === "vec4") {
              if (y.length > 0 && y.length < 5) {
                let P = "f";
                const L = [];
                for (let U = 0; U < y.length; ++U) {
                  const V = y[U].toLowerCase();
                  let q = 0;
                  if (V === "x" || V === "r") q = 0;
                  else if (V === "y" || V === "g") q = 1;
                  else if (V === "z" || V === "b") q = 2;
                  else {
                    if (V !== "w" && V !== "a") return console.error(`Unknown member ${y}`), null;
                    q = 3;
                  }
                  if (y.length === 1) {
                    if (E.endsWith("f")) return this.buffer.byteLength < l + 4 * q + 4 ? (console.log("Insufficient buffer data"), null) : new ut(new Float32Array(this.buffer, l + 4 * q, 1), e.getTypeInfo("f32"), this);
                    if (E.endsWith("h")) return new ut(new Float32Array(this.buffer, l + 4 * q, 1), e.getTypeInfo("f16"), this);
                    if (E.endsWith("i")) return new ut(new Int32Array(this.buffer, l + 4 * q, 1), e.getTypeInfo("i32"), this);
                    if (E.endsWith("b")) return new ut(new Int32Array(this.buffer, l + 4 * q, 1), e.getTypeInfo("bool"), this);
                    if (E.endsWith("u")) return new ut(new Uint32Array(this.buffer, l + 4 * q, 1), e.getTypeInfo("i32"), this);
                  }
                  if (E === "vec2f") L.push(new Float32Array(this.buffer, l, 2)[q]);
                  else if (E === "vec3f") {
                    if (l + 12 >= this.buffer.byteLength) return console.log("Insufficient buffer data"), null;
                    const j = new Float32Array(this.buffer, l, 3);
                    L.push(j[q]);
                  } else if (E === "vec4f") L.push(new Float32Array(this.buffer, l, 4)[q]);
                  else if (E === "vec2i") P = "i", L.push(new Int32Array(this.buffer, l, 2)[q]);
                  else if (E === "vec3i") P = "i", L.push(new Int32Array(this.buffer, l, 3)[q]);
                  else if (E === "vec4i") P = "i", L.push(new Int32Array(this.buffer, l, 4)[q]);
                  else if (E === "vec2u") {
                    P = "u";
                    const j = new Uint32Array(this.buffer, l, 2);
                    L.push(j[q]);
                  } else E === "vec3u" ? (P = "u", L.push(new Uint32Array(this.buffer, l, 3)[q])) : E === "vec4u" && (P = "u", L.push(new Uint32Array(this.buffer, l, 4)[q]));
                }
                return L.length === 2 ? u = e.getTypeInfo(`vec2${P}`) : L.length === 3 ? u = e.getTypeInfo(`vec3${P}`) : L.length === 4 ? u = e.getTypeInfo(`vec4${P}`) : console.error(`GetDataValue: Invalid vector length ${L.length}`), new qe(L, u, null);
              }
              return console.error(`GetDataValue: Unknown member ${y}`), null;
            }
            return console.error(`GetDataValue: Type ${E} is not a struct`), null;
          }
        }
      }
      t = t.postfix;
    }
    const m = u.getTypeName();
    return m === "f32" ? new ut(new Float32Array(this.buffer, l, 1), u, this) : m === "i32" ? new ut(new Int32Array(this.buffer, l, 1), u, this) : m === "u32" ? new ut(new Uint32Array(this.buffer, l, 1), u, this) : m === "vec2f" ? new qe(new Float32Array(this.buffer, l, 2), u, this) : m === "vec3f" ? new qe(new Float32Array(this.buffer, l, 3), u, this) : m === "vec4f" ? new qe(new Float32Array(this.buffer, l, 4), u, this) : m === "vec2i" ? new qe(new Int32Array(this.buffer, l, 2), u, this) : m === "vec3i" ? new qe(new Int32Array(this.buffer, l, 3), u, this) : m === "vec4i" ? new qe(new Int32Array(this.buffer, l, 4), u, this) : m === "vec2u" ? new qe(new Uint32Array(this.buffer, l, 2), u, this) : m === "vec3u" ? new qe(new Uint32Array(this.buffer, l, 3), u, this) : m === "vec4u" ? new qe(new Uint32Array(this.buffer, l, 4), u, this) : u instanceof rh && u.name === "atomic" ? ((i = u.format) === null || i === void 0 ? void 0 : i.name) === "u32" ? new ut(new Uint32Array(this.buffer, l, 1)[0], u.format, this) : ((s = u.format) === null || s === void 0 ? void 0 : s.name) === "i32" ? new ut(new Int32Array(this.buffer, l, 1)[0], u.format, this) : (console.error(`GetDataValue: Invalid atomic format ${(o = u.format) === null || o === void 0 ? void 0 : o.name}`), null) : new Ji(this.buffer, u, l, this);
  }
  toString() {
    let e = "";
    if (this.typeInfo instanceof $u) if (this.typeInfo.format.name === "f32") {
      const t = new Float32Array(this.buffer, this.offset);
      e = `[${t[0]}`;
      for (let n = 1; n < t.length; ++n) e += `, ${t[n]}`;
    } else if (this.typeInfo.format.name === "i32") {
      const t = new Int32Array(this.buffer, this.offset);
      e = `[${t[0]}`;
      for (let n = 1; n < t.length; ++n) e += `, ${t[n]}`;
    } else if (this.typeInfo.format.name === "u32") {
      const t = new Uint32Array(this.buffer, this.offset);
      e = `[${t[0]}`;
      for (let n = 1; n < t.length; ++n) e += `, ${t[n]}`;
    } else if (this.typeInfo.format.name === "vec2f") {
      const t = new Float32Array(this.buffer, this.offset);
      e = `[${t[0]}, ${t[1]}]`;
      for (let n = 1; n < t.length / 2; ++n) e += `, [${t[2 * n]}, ${t[2 * n + 1]}]`;
    } else if (this.typeInfo.format.name === "vec3f") {
      const t = new Float32Array(this.buffer, this.offset);
      e = `[${t[0]}, ${t[1]}, ${t[2]}]`;
      for (let n = 4; n < t.length; n += 4) e += `, [${t[n]}, ${t[n + 1]}, ${t[n + 2]}]`;
    } else if (this.typeInfo.format.name === "vec4f") {
      const t = new Float32Array(this.buffer, this.offset);
      e = `[${t[0]}, ${t[1]}, ${t[2]}, ${t[3]}]`;
      for (let n = 4; n < t.length; n += 4) e += `, [${t[n]}, ${t[n + 1]}, ${t[n + 2]}, ${t[n + 3]}]`;
    } else e = "[...]";
    else this.typeInfo instanceof ju ? e += "{...}" : e = "[...]";
    return e;
  }
}
class Hc extends Ua {
  constructor(e, t, n, i) {
    super(t, null), this.data = e, this.descriptor = n, this.view = i;
  }
  clone() {
    return new Hc(this.data, this.typeInfo, this.descriptor, this.view);
  }
  get width() {
    var e, t;
    const n = this.descriptor.size;
    return n instanceof Array && n.length > 0 ? (e = n[0]) !== null && e !== void 0 ? e : 0 : n instanceof Object && (t = n.width) !== null && t !== void 0 ? t : 0;
  }
  get height() {
    var e, t;
    const n = this.descriptor.size;
    return n instanceof Array && n.length > 1 ? (e = n[1]) !== null && e !== void 0 ? e : 0 : n instanceof Object && (t = n.height) !== null && t !== void 0 ? t : 0;
  }
  get depthOrArrayLayers() {
    var e, t;
    const n = this.descriptor.size;
    return n instanceof Array && n.length > 2 ? (e = n[2]) !== null && e !== void 0 ? e : 0 : n instanceof Object && (t = n.depthOrArrayLayers) !== null && t !== void 0 ? t : 0;
  }
  get format() {
    var e;
    return this.descriptor && (e = this.descriptor.format) !== null && e !== void 0 ? e : "rgba8unorm";
  }
  get sampleCount() {
    var e;
    return this.descriptor && (e = this.descriptor.sampleCount) !== null && e !== void 0 ? e : 1;
  }
  get mipLevelCount() {
    var e;
    return this.descriptor && (e = this.descriptor.mipLevelCount) !== null && e !== void 0 ? e : 1;
  }
  get dimension() {
    var e;
    return this.descriptor && (e = this.descriptor.dimension) !== null && e !== void 0 ? e : "2d";
  }
  getMipLevelSize(e) {
    if (e >= this.mipLevelCount) return [0, 0, 0];
    const t = [this.width, this.height, this.depthOrArrayLayers];
    for (let n = 0; n < t.length; ++n) t[n] = Math.max(1, t[n] >> e);
    return t;
  }
  get texelByteSize() {
    const e = this.format, t = Ev[e];
    return t ? t.isDepthStencil ? 4 : t.bytesPerBlock : 0;
  }
  get bytesPerRow() {
    return this.width * this.texelByteSize;
  }
  get isDepthStencil() {
    const e = this.format, t = Ev[e];
    return !!t && t.isDepthStencil;
  }
  getGpuSize() {
    const e = this.format, t = Ev[e], n = this.width;
    if (!e || n <= 0 || !t) return -1;
    const i = this.height, s = this.depthOrArrayLayers, o = this.dimension;
    return n / t.blockWidth * (o === "1d" ? 1 : i / t.blockHeight) * t.bytesPerBlock * s;
  }
  getPixel(e, t, n = 0, i = 0) {
    const s = this.texelByteSize, o = this.bytesPerRow, l = this.height, u = this.data[i];
    return E7(new Uint8Array(u), e, t, n, i, l, o, s, this.format);
  }
  setPixel(e, t, n, i, s) {
    const o = this.texelByteSize, l = this.bytesPerRow, u = this.height, m = this.data[i];
    (function(y, E, P, L, U, V, q, j, K, Y) {
      const de = L * (q >>= U) * (V >>= U) + P * q + E * j;
      switch (K) {
        case "r8unorm":
          return void ri(y, de, "8unorm", 1, Y);
        case "r8snorm":
          return void ri(y, de, "8snorm", 1, Y);
        case "r8uint":
          return void ri(y, de, "8uint", 1, Y);
        case "r8sint":
          return void ri(y, de, "8sint", 1, Y);
        case "rg8unorm":
          return void ri(y, de, "8unorm", 2, Y);
        case "rg8snorm":
          return void ri(y, de, "8snorm", 2, Y);
        case "rg8uint":
          return void ri(y, de, "8uint", 2, Y);
        case "rg8sint":
          return void ri(y, de, "8sint", 2, Y);
        case "rgba8unorm-srgb":
        case "rgba8unorm":
        case "bgra8unorm-srgb":
        case "bgra8unorm":
          return void ri(y, de, "8unorm", 4, Y);
        case "rgba8snorm":
          return void ri(y, de, "8snorm", 4, Y);
        case "rgba8uint":
          return void ri(y, de, "8uint", 4, Y);
        case "rgba8sint":
          return void ri(y, de, "8sint", 4, Y);
        case "r16uint":
          return void ri(y, de, "16uint", 1, Y);
        case "r16sint":
          return void ri(y, de, "16sint", 1, Y);
        case "r16float":
          return void ri(y, de, "16float", 1, Y);
        case "rg16uint":
          return void ri(y, de, "16uint", 2, Y);
        case "rg16sint":
          return void ri(y, de, "16sint", 2, Y);
        case "rg16float":
          return void ri(y, de, "16float", 2, Y);
        case "rgba16uint":
          return void ri(y, de, "16uint", 4, Y);
        case "rgba16sint":
          return void ri(y, de, "16sint", 4, Y);
        case "rgba16float":
          return void ri(y, de, "16float", 4, Y);
        case "r32uint":
          return void ri(y, de, "32uint", 1, Y);
        case "r32sint":
          return void ri(y, de, "32sint", 1, Y);
        case "depth16unorm":
        case "depth24plus":
        case "depth24plus-stencil8":
        case "depth32float":
        case "depth32float-stencil8":
        case "r32float":
          return void ri(y, de, "32float", 1, Y);
        case "rg32uint":
          return void ri(y, de, "32uint", 2, Y);
        case "rg32sint":
          return void ri(y, de, "32sint", 2, Y);
        case "rg32float":
          return void ri(y, de, "32float", 2, Y);
        case "rgba32uint":
          return void ri(y, de, "32uint", 4, Y);
        case "rgba32sint":
          return void ri(y, de, "32sint", 4, Y);
        case "rgba32float":
          return void ri(y, de, "32float", 4, Y);
        case "rg11b10ufloat":
          console.error("TODO: rg11b10ufloat not supported for writing");
      }
    })(new Uint8Array(m), e, t, n, i, u, l, o, this.format, s);
  }
}
((r) => {
  r[r.token = 0] = "token", r[r.keyword = 1] = "keyword", r[r.reserved = 2] = "reserved";
})(ft || (ft = {}));
class ht {
  constructor(e, t, n) {
    this.name = e, this.type = t, this.rule = n;
  }
  toString() {
    return this.name;
  }
}
class Fe {
}
wt = Fe, Fe.none = new ht("", ft.reserved, ""), Fe.eof = new ht("EOF", ft.token, ""), Fe.reserved = { asm: new ht("asm", ft.reserved, "asm"), bf16: new ht("bf16", ft.reserved, "bf16"), do: new ht("do", ft.reserved, "do"), enum: new ht("enum", ft.reserved, "enum"), f16: new ht("f16", ft.reserved, "f16"), f64: new ht("f64", ft.reserved, "f64"), handle: new ht("handle", ft.reserved, "handle"), i8: new ht("i8", ft.reserved, "i8"), i16: new ht("i16", ft.reserved, "i16"), i64: new ht("i64", ft.reserved, "i64"), mat: new ht("mat", ft.reserved, "mat"), premerge: new ht("premerge", ft.reserved, "premerge"), regardless: new ht("regardless", ft.reserved, "regardless"), typedef: new ht("typedef", ft.reserved, "typedef"), u8: new ht("u8", ft.reserved, "u8"), u16: new ht("u16", ft.reserved, "u16"), u64: new ht("u64", ft.reserved, "u64"), unless: new ht("unless", ft.reserved, "unless"), using: new ht("using", ft.reserved, "using"), vec: new ht("vec", ft.reserved, "vec"), void: new ht("void", ft.reserved, "void") }, Fe.keywords = { array: new ht("array", ft.keyword, "array"), atomic: new ht("atomic", ft.keyword, "atomic"), bool: new ht("bool", ft.keyword, "bool"), f32: new ht("f32", ft.keyword, "f32"), i32: new ht("i32", ft.keyword, "i32"), mat2x2: new ht("mat2x2", ft.keyword, "mat2x2"), mat2x3: new ht("mat2x3", ft.keyword, "mat2x3"), mat2x4: new ht("mat2x4", ft.keyword, "mat2x4"), mat3x2: new ht("mat3x2", ft.keyword, "mat3x2"), mat3x3: new ht("mat3x3", ft.keyword, "mat3x3"), mat3x4: new ht("mat3x4", ft.keyword, "mat3x4"), mat4x2: new ht("mat4x2", ft.keyword, "mat4x2"), mat4x3: new ht("mat4x3", ft.keyword, "mat4x3"), mat4x4: new ht("mat4x4", ft.keyword, "mat4x4"), ptr: new ht("ptr", ft.keyword, "ptr"), sampler: new ht("sampler", ft.keyword, "sampler"), sampler_comparison: new ht("sampler_comparison", ft.keyword, "sampler_comparison"), struct: new ht("struct", ft.keyword, "struct"), texture_1d: new ht("texture_1d", ft.keyword, "texture_1d"), texture_2d: new ht("texture_2d", ft.keyword, "texture_2d"), texture_2d_array: new ht("texture_2d_array", ft.keyword, "texture_2d_array"), texture_3d: new ht("texture_3d", ft.keyword, "texture_3d"), texture_cube: new ht("texture_cube", ft.keyword, "texture_cube"), texture_cube_array: new ht("texture_cube_array", ft.keyword, "texture_cube_array"), texture_multisampled_2d: new ht("texture_multisampled_2d", ft.keyword, "texture_multisampled_2d"), texture_storage_1d: new ht("texture_storage_1d", ft.keyword, "texture_storage_1d"), texture_storage_2d: new ht("texture_storage_2d", ft.keyword, "texture_storage_2d"), texture_storage_2d_array: new ht("texture_storage_2d_array", ft.keyword, "texture_storage_2d_array"), texture_storage_3d: new ht("texture_storage_3d", ft.keyword, "texture_storage_3d"), texture_depth_2d: new ht("texture_depth_2d", ft.keyword, "texture_depth_2d"), texture_depth_2d_array: new ht("texture_depth_2d_array", ft.keyword, "texture_depth_2d_array"), texture_depth_cube: new ht("texture_depth_cube", ft.keyword, "texture_depth_cube"), texture_depth_cube_array: new ht("texture_depth_cube_array", ft.keyword, "texture_depth_cube_array"), texture_depth_multisampled_2d: new ht("texture_depth_multisampled_2d", ft.keyword, "texture_depth_multisampled_2d"), texture_external: new ht("texture_external", ft.keyword, "texture_external"), u32: new ht("u32", ft.keyword, "u32"), vec2: new ht("vec2", ft.keyword, "vec2"), vec3: new ht("vec3", ft.keyword, "vec3"), vec4: new ht("vec4", ft.keyword, "vec4"), bitcast: new ht("bitcast", ft.keyword, "bitcast"), block: new ht("block", ft.keyword, "block"), break: new ht("break", ft.keyword, "break"), case: new ht("case", ft.keyword, "case"), continue: new ht("continue", ft.keyword, "continue"), continuing: new ht("continuing", ft.keyword, "continuing"), default: new ht("default", ft.keyword, "default"), diagnostic: new ht("diagnostic", ft.keyword, "diagnostic"), discard: new ht("discard", ft.keyword, "discard"), else: new ht("else", ft.keyword, "else"), enable: new ht("enable", ft.keyword, "enable"), fallthrough: new ht("fallthrough", ft.keyword, "fallthrough"), false: new ht("false", ft.keyword, "false"), fn: new ht("fn", ft.keyword, "fn"), for: new ht("for", ft.keyword, "for"), function: new ht("function", ft.keyword, "function"), if: new ht("if", ft.keyword, "if"), let: new ht("let", ft.keyword, "let"), const: new ht("const", ft.keyword, "const"), loop: new ht("loop", ft.keyword, "loop"), while: new ht("while", ft.keyword, "while"), private: new ht("private", ft.keyword, "private"), read: new ht("read", ft.keyword, "read"), read_write: new ht("read_write", ft.keyword, "read_write"), return: new ht("return", ft.keyword, "return"), requires: new ht("requires", ft.keyword, "requires"), storage: new ht("storage", ft.keyword, "storage"), switch: new ht("switch", ft.keyword, "switch"), true: new ht("true", ft.keyword, "true"), alias: new ht("alias", ft.keyword, "alias"), type: new ht("type", ft.keyword, "type"), uniform: new ht("uniform", ft.keyword, "uniform"), var: new ht("var", ft.keyword, "var"), override: new ht("override", ft.keyword, "override"), workgroup: new ht("workgroup", ft.keyword, "workgroup"), write: new ht("write", ft.keyword, "write"), r8unorm: new ht("r8unorm", ft.keyword, "r8unorm"), r8snorm: new ht("r8snorm", ft.keyword, "r8snorm"), r8uint: new ht("r8uint", ft.keyword, "r8uint"), r8sint: new ht("r8sint", ft.keyword, "r8sint"), r16uint: new ht("r16uint", ft.keyword, "r16uint"), r16sint: new ht("r16sint", ft.keyword, "r16sint"), r16float: new ht("r16float", ft.keyword, "r16float"), rg8unorm: new ht("rg8unorm", ft.keyword, "rg8unorm"), rg8snorm: new ht("rg8snorm", ft.keyword, "rg8snorm"), rg8uint: new ht("rg8uint", ft.keyword, "rg8uint"), rg8sint: new ht("rg8sint", ft.keyword, "rg8sint"), r32uint: new ht("r32uint", ft.keyword, "r32uint"), r32sint: new ht("r32sint", ft.keyword, "r32sint"), r32float: new ht("r32float", ft.keyword, "r32float"), rg16uint: new ht("rg16uint", ft.keyword, "rg16uint"), rg16sint: new ht("rg16sint", ft.keyword, "rg16sint"), rg16float: new ht("rg16float", ft.keyword, "rg16float"), rgba8unorm: new ht("rgba8unorm", ft.keyword, "rgba8unorm"), rgba8unorm_srgb: new ht("rgba8unorm_srgb", ft.keyword, "rgba8unorm_srgb"), rgba8snorm: new ht("rgba8snorm", ft.keyword, "rgba8snorm"), rgba8uint: new ht("rgba8uint", ft.keyword, "rgba8uint"), rgba8sint: new ht("rgba8sint", ft.keyword, "rgba8sint"), bgra8unorm: new ht("bgra8unorm", ft.keyword, "bgra8unorm"), bgra8unorm_srgb: new ht("bgra8unorm_srgb", ft.keyword, "bgra8unorm_srgb"), rgb10a2unorm: new ht("rgb10a2unorm", ft.keyword, "rgb10a2unorm"), rg11b10float: new ht("rg11b10float", ft.keyword, "rg11b10float"), rg32uint: new ht("rg32uint", ft.keyword, "rg32uint"), rg32sint: new ht("rg32sint", ft.keyword, "rg32sint"), rg32float: new ht("rg32float", ft.keyword, "rg32float"), rgba16uint: new ht("rgba16uint", ft.keyword, "rgba16uint"), rgba16sint: new ht("rgba16sint", ft.keyword, "rgba16sint"), rgba16float: new ht("rgba16float", ft.keyword, "rgba16float"), rgba32uint: new ht("rgba32uint", ft.keyword, "rgba32uint"), rgba32sint: new ht("rgba32sint", ft.keyword, "rgba32sint"), rgba32float: new ht("rgba32float", ft.keyword, "rgba32float"), static_assert: new ht("static_assert", ft.keyword, "static_assert") }, Fe.tokens = { decimal_float_literal: new ht("decimal_float_literal", ft.token, /((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?[fh]?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+[fh]?)|(-?[0-9]+[fh])/), hex_float_literal: new ht("hex_float_literal", ft.token, /-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+[fh]?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+[fh]?))/), int_literal: new ht("int_literal", ft.token, /-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/), uint_literal: new ht("uint_literal", ft.token, /0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/), name: new ht("name", ft.token, /([_\p{XID_Start}][\p{XID_Continue}]+)|([\p{XID_Start}])/u), ident: new ht("ident", ft.token, /[_a-zA-Z][0-9a-zA-Z_]*/), and: new ht("and", ft.token, "&"), and_and: new ht("and_and", ft.token, "&&"), arrow: new ht("arrow ", ft.token, "->"), attr: new ht("attr", ft.token, "@"), forward_slash: new ht("forward_slash", ft.token, "/"), bang: new ht("bang", ft.token, "!"), bracket_left: new ht("bracket_left", ft.token, "["), bracket_right: new ht("bracket_right", ft.token, "]"), brace_left: new ht("brace_left", ft.token, "{"), brace_right: new ht("brace_right", ft.token, "}"), colon: new ht("colon", ft.token, ":"), comma: new ht("comma", ft.token, ","), equal: new ht("equal", ft.token, "="), equal_equal: new ht("equal_equal", ft.token, "=="), not_equal: new ht("not_equal", ft.token, "!="), greater_than: new ht("greater_than", ft.token, ">"), greater_than_equal: new ht("greater_than_equal", ft.token, ">="), shift_right: new ht("shift_right", ft.token, ">>"), less_than: new ht("less_than", ft.token, "<"), less_than_equal: new ht("less_than_equal", ft.token, "<="), shift_left: new ht("shift_left", ft.token, "<<"), modulo: new ht("modulo", ft.token, "%"), minus: new ht("minus", ft.token, "-"), minus_minus: new ht("minus_minus", ft.token, "--"), period: new ht("period", ft.token, "."), plus: new ht("plus", ft.token, "+"), plus_plus: new ht("plus_plus", ft.token, "++"), or: new ht("or", ft.token, "|"), or_or: new ht("or_or", ft.token, "||"), paren_left: new ht("paren_left", ft.token, "("), paren_right: new ht("paren_right", ft.token, ")"), semicolon: new ht("semicolon", ft.token, ";"), star: new ht("star", ft.token, "*"), tilde: new ht("tilde", ft.token, "~"), underscore: new ht("underscore", ft.token, "_"), xor: new ht("xor", ft.token, "^"), plus_equal: new ht("plus_equal", ft.token, "+="), minus_equal: new ht("minus_equal", ft.token, "-="), times_equal: new ht("times_equal", ft.token, "*="), division_equal: new ht("division_equal", ft.token, "/="), modulo_equal: new ht("modulo_equal", ft.token, "%="), and_equal: new ht("and_equal", ft.token, "&="), or_equal: new ht("or_equal", ft.token, "|="), xor_equal: new ht("xor_equal", ft.token, "^="), shift_right_equal: new ht("shift_right_equal", ft.token, ">>="), shift_left_equal: new ht("shift_left_equal", ft.token, "<<=") }, Fe.simpleTokens = { "@": wt.tokens.attr, "{": wt.tokens.brace_left, "}": wt.tokens.brace_right, ":": wt.tokens.colon, ",": wt.tokens.comma, "(": wt.tokens.paren_left, ")": wt.tokens.paren_right, ";": wt.tokens.semicolon }, Fe.literalTokens = { "&": wt.tokens.and, "&&": wt.tokens.and_and, "->": wt.tokens.arrow, "/": wt.tokens.forward_slash, "!": wt.tokens.bang, "[": wt.tokens.bracket_left, "]": wt.tokens.bracket_right, "=": wt.tokens.equal, "==": wt.tokens.equal_equal, "!=": wt.tokens.not_equal, ">": wt.tokens.greater_than, ">=": wt.tokens.greater_than_equal, ">>": wt.tokens.shift_right, "<": wt.tokens.less_than, "<=": wt.tokens.less_than_equal, "<<": wt.tokens.shift_left, "%": wt.tokens.modulo, "-": wt.tokens.minus, "--": wt.tokens.minus_minus, ".": wt.tokens.period, "+": wt.tokens.plus, "++": wt.tokens.plus_plus, "|": wt.tokens.or, "||": wt.tokens.or_or, "*": wt.tokens.star, "~": wt.tokens.tilde, _: wt.tokens.underscore, "^": wt.tokens.xor, "+=": wt.tokens.plus_equal, "-=": wt.tokens.minus_equal, "*=": wt.tokens.times_equal, "/=": wt.tokens.division_equal, "%=": wt.tokens.modulo_equal, "&=": wt.tokens.and_equal, "|=": wt.tokens.or_equal, "^=": wt.tokens.xor_equal, ">>=": wt.tokens.shift_right_equal, "<<=": wt.tokens.shift_left_equal }, Fe.regexTokens = { decimal_float_literal: wt.tokens.decimal_float_literal, hex_float_literal: wt.tokens.hex_float_literal, int_literal: wt.tokens.int_literal, uint_literal: wt.tokens.uint_literal, ident: wt.tokens.ident }, Fe.storage_class = [wt.keywords.function, wt.keywords.private, wt.keywords.workgroup, wt.keywords.uniform, wt.keywords.storage], Fe.access_mode = [wt.keywords.read, wt.keywords.write, wt.keywords.read_write], Fe.sampler_type = [wt.keywords.sampler, wt.keywords.sampler_comparison], Fe.sampled_texture_type = [wt.keywords.texture_1d, wt.keywords.texture_2d, wt.keywords.texture_2d_array, wt.keywords.texture_3d, wt.keywords.texture_cube, wt.keywords.texture_cube_array], Fe.multisampled_texture_type = [wt.keywords.texture_multisampled_2d], Fe.storage_texture_type = [wt.keywords.texture_storage_1d, wt.keywords.texture_storage_2d, wt.keywords.texture_storage_2d_array, wt.keywords.texture_storage_3d], Fe.depth_texture_type = [wt.keywords.texture_depth_2d, wt.keywords.texture_depth_2d_array, wt.keywords.texture_depth_cube, wt.keywords.texture_depth_cube_array, wt.keywords.texture_depth_multisampled_2d], Fe.texture_external_type = [wt.keywords.texture_external], Fe.any_texture_type = [...wt.sampled_texture_type, ...wt.multisampled_texture_type, ...wt.storage_texture_type, ...wt.depth_texture_type, ...wt.texture_external_type], Fe.texel_format = [wt.keywords.r8unorm, wt.keywords.r8snorm, wt.keywords.r8uint, wt.keywords.r8sint, wt.keywords.r16uint, wt.keywords.r16sint, wt.keywords.r16float, wt.keywords.rg8unorm, wt.keywords.rg8snorm, wt.keywords.rg8uint, wt.keywords.rg8sint, wt.keywords.r32uint, wt.keywords.r32sint, wt.keywords.r32float, wt.keywords.rg16uint, wt.keywords.rg16sint, wt.keywords.rg16float, wt.keywords.rgba8unorm, wt.keywords.rgba8unorm_srgb, wt.keywords.rgba8snorm, wt.keywords.rgba8uint, wt.keywords.rgba8sint, wt.keywords.bgra8unorm, wt.keywords.bgra8unorm_srgb, wt.keywords.rgb10a2unorm, wt.keywords.rg11b10float, wt.keywords.rg32uint, wt.keywords.rg32sint, wt.keywords.rg32float, wt.keywords.rgba16uint, wt.keywords.rgba16sint, wt.keywords.rgba16float, wt.keywords.rgba32uint, wt.keywords.rgba32sint, wt.keywords.rgba32float], Fe.const_literal = [wt.tokens.int_literal, wt.tokens.uint_literal, wt.tokens.decimal_float_literal, wt.tokens.hex_float_literal, wt.keywords.true, wt.keywords.false], Fe.literal_or_ident = [wt.tokens.ident, wt.tokens.int_literal, wt.tokens.uint_literal, wt.tokens.decimal_float_literal, wt.tokens.hex_float_literal, wt.tokens.name], Fe.element_count_expression = [wt.tokens.int_literal, wt.tokens.uint_literal, wt.tokens.ident], Fe.template_types = [wt.keywords.vec2, wt.keywords.vec3, wt.keywords.vec4, wt.keywords.mat2x2, wt.keywords.mat2x3, wt.keywords.mat2x4, wt.keywords.mat3x2, wt.keywords.mat3x3, wt.keywords.mat3x4, wt.keywords.mat4x2, wt.keywords.mat4x3, wt.keywords.mat4x4, wt.keywords.atomic, wt.keywords.bitcast, ...wt.any_texture_type], Fe.attribute_name = [wt.tokens.ident, wt.keywords.block, wt.keywords.diagnostic], Fe.assignment_operators = [wt.tokens.equal, wt.tokens.plus_equal, wt.tokens.minus_equal, wt.tokens.times_equal, wt.tokens.division_equal, wt.tokens.modulo_equal, wt.tokens.and_equal, wt.tokens.or_equal, wt.tokens.xor_equal, wt.tokens.shift_right_equal, wt.tokens.shift_left_equal], Fe.increment_operators = [wt.tokens.plus_plus, wt.tokens.minus_minus];
class JE {
  constructor(e, t, n, i, s) {
    this.type = e, this.lexeme = t, this.line = n, this.start = i, this.end = s;
  }
  toString() {
    return this.lexeme;
  }
  isTemplateType() {
    return Fe.template_types.indexOf(this.type) != -1;
  }
  isArrayType() {
    return this.type == Fe.keywords.array;
  }
  isArrayOrTemplateType() {
    return this.isArrayType() || this.isTemplateType();
  }
}
class B7 {
  constructor(e) {
    this._tokens = [], this._start = 0, this._current = 0, this._line = 1, this._source = e ?? "";
  }
  scanTokens() {
    for (; !this._isAtEnd(); ) if (this._start = this._current, !this.scanToken()) throw `Invalid syntax at line ${this._line}`;
    return this._tokens.push(new JE(Fe.eof, "", this._line, this._current, this._current)), this._tokens;
  }
  scanToken() {
    let e = this._advance();
    if (e == `
`) return this._line++, !0;
    if (this._isWhitespace(e)) return !0;
    if (e == "/") {
      if (this._peekAhead() == "/") {
        for (; e != `
`; ) {
          if (this._isAtEnd()) return !0;
          e = this._advance();
        }
        return this._line++, !0;
      }
      if (this._peekAhead() == "*") {
        this._advance();
        let o = 1;
        for (; o > 0; ) {
          if (this._isAtEnd()) return !0;
          if (e = this._advance(), e == `
`) this._line++;
          else if (e == "*") {
            if (this._peekAhead() == "/" && (this._advance(), o--, o == 0)) return !0;
          } else e == "/" && this._peekAhead() == "*" && (this._advance(), o++);
        }
        return !0;
      }
    }
    const t = Fe.simpleTokens[e];
    if (t) return this._addToken(t), !0;
    let n = Fe.none;
    const i = this._isAlpha(e), s = e === "_";
    if (this._isAlphaNumeric(e)) {
      let o = this._peekAhead();
      for (; this._isAlphaNumeric(o); ) e += this._advance(), o = this._peekAhead();
    }
    if (i) {
      const o = Fe.keywords[e];
      if (o) return this._addToken(o), !0;
    }
    if (i || s) return this._addToken(Fe.tokens.ident), !0;
    for (; ; ) {
      let o = this._findType(e);
      const l = this._peekAhead();
      if (e == "-" && this._tokens.length > 0) {
        if (l == "=") return this._current++, e += l, this._addToken(Fe.tokens.minus_equal), !0;
        if (l == "-") return this._current++, e += l, this._addToken(Fe.tokens.minus_minus), !0;
        const u = this._tokens.length - 1;
        if ((Fe.literal_or_ident.indexOf(this._tokens[u].type) != -1 || this._tokens[u].type == Fe.tokens.paren_right) && l != ">") return this._addToken(o), !0;
      }
      if (e == ">" && (l == ">" || l == "=")) {
        let u = !1, m = this._tokens.length - 1;
        for (let y = 0; y < 5 && m >= 0 && Fe.assignment_operators.indexOf(this._tokens[m].type) === -1; ++y, --m) if (this._tokens[m].type === Fe.tokens.less_than) {
          m > 0 && this._tokens[m - 1].isArrayOrTemplateType() && (u = !0);
          break;
        }
        if (u) return this._addToken(o), !0;
      }
      if (o === Fe.none) {
        let u = e, m = 0;
        const y = 2;
        for (let E = 0; E < y; ++E) if (u += this._peekAhead(E), o = this._findType(u), o !== Fe.none) {
          m = E;
          break;
        }
        if (o === Fe.none) return n !== Fe.none && (this._current--, this._addToken(n), !0);
        e = u, this._current += m + 1;
      }
      if (n = o, this._isAtEnd()) break;
      e += this._advance();
    }
    return n !== Fe.none && (this._addToken(n), !0);
  }
  _findType(e) {
    for (const n in Fe.regexTokens) {
      const i = Fe.regexTokens[n];
      if (this._match(e, i.rule)) return i;
    }
    return Fe.literalTokens[e] || Fe.none;
  }
  _match(e, t) {
    const n = t.exec(e);
    return n && n.index == 0 && n[0] == e;
  }
  _isAtEnd() {
    return this._current >= this._source.length;
  }
  _isAlpha(e) {
    return !this._isNumeric(e) && !this._isWhitespace(e) && e !== "_" && e !== "." && e !== "(" && e !== ")" && e !== "[" && e !== "]" && e !== "{" && e !== "}" && e !== "," && e !== ";" && e !== ":" && e !== "=" && e !== "!" && e !== "<" && e !== ">" && e !== "+" && e !== "-" && e !== "*" && e !== "/" && e !== "%" && e !== "&" && e !== "|" && e !== "^" && e !== "~" && e !== "@" && e !== "#" && e !== "?" && e !== "'" && e !== "`" && e !== '"' && e !== "\\" && e !== `
` && e !== "\r" && e !== "	" && e !== "\0";
  }
  _isNumeric(e) {
    return e >= "0" && e <= "9";
  }
  _isAlphaNumeric(e) {
    return this._isAlpha(e) || this._isNumeric(e) || e === "_";
  }
  _isWhitespace(e) {
    return e == " " || e == "	" || e == "\r";
  }
  _advance(e = 0) {
    let t = this._source[this._current];
    return e = e || 0, e++, this._current += e, t;
  }
  _peekAhead(e = 0) {
    return e = e || 0, this._current + e >= this._source.length ? "\0" : this._source[this._current + e];
  }
  _addToken(e) {
    const t = this._source.substring(this._start, this._current);
    this._tokens.push(new JE(e, t, this._line, this._start, this._current));
  }
}
function vr(r) {
  return Array.isArray(r) || r?.buffer instanceof ArrayBuffer;
}
const Qm = new Float32Array(1), O7 = new Uint32Array(Qm.buffer), D7 = new Uint32Array(Qm.buffer), Jm = new Int32Array(1), L7 = new Float32Array(Jm.buffer), k7 = new Uint32Array(Jm.buffer), e_ = new Uint32Array(1), F7 = new Float32Array(e_.buffer), N7 = new Int32Array(e_.buffer);
function eC(r, e, t) {
  if (e === t) return r;
  if (e === "f32") {
    if (t === "i32" || t === "x32") return Qm[0] = r, O7[0];
    if (t === "u32") return Qm[0] = r, D7[0];
  } else if (e === "i32" || e === "x32") {
    if (t === "f32") return Jm[0] = r, L7[0];
    if (t === "u32") return Jm[0] = r, k7[0];
  } else if (e === "u32") {
    if (t === "f32") return e_[0] = r, F7[0];
    if (t === "i32" || t === "x32") return e_[0] = r, N7[0];
  }
  return console.error(`Unsupported cast from ${e} to ${t}`), r;
}
class U7 {
  constructor(e) {
    this.resources = null, this.inUse = !1, this.info = null, this.node = e;
  }
}
class mg {
  constructor(e, t) {
    this.align = e, this.size = t;
  }
}
class nc {
  constructor() {
    this.uniforms = [], this.storage = [], this.textures = [], this.samplers = [], this.aliases = [], this.overrides = [], this.structs = [], this.entry = new b7(), this.functions = [], this._types = /* @__PURE__ */ new Map(), this._functions = /* @__PURE__ */ new Map();
  }
  _isStorageTexture(e) {
    return e.name == "texture_storage_1d" || e.name == "texture_storage_2d" || e.name == "texture_storage_2d_array" || e.name == "texture_storage_3d";
  }
  updateAST(e) {
    for (const t of e) t instanceof t0 && this._functions.set(t.name, new U7(t));
    for (const t of e) if (t instanceof jc) {
      const n = this.getTypeInfo(t, null);
      n instanceof ju && this.structs.push(n);
    }
    for (const t of e) if (t instanceof bx) this.aliases.push(this._getAliasInfo(t));
    else {
      if (t instanceof yx) {
        const n = t, i = this._getAttributeNum(n.attributes, "id", 0), s = n.type != null ? this.getTypeInfo(n.type, n.attributes) : null;
        this.overrides.push(new _7(n.name, s, n.attributes, i));
        continue;
      }
      if (this._isUniformVar(t)) {
        const n = t, i = this._getAttributeNum(n.attributes, "group", 0), s = this._getAttributeNum(n.attributes, "binding", 0), o = this.getTypeInfo(n.type, n.attributes), l = new gg(n.name, o, i, s, n.attributes, zu.Uniform, n.access);
        l.access || (l.access = "read"), this.uniforms.push(l);
        continue;
      }
      if (this._isStorageVar(t)) {
        const n = t, i = this._getAttributeNum(n.attributes, "group", 0), s = this._getAttributeNum(n.attributes, "binding", 0), o = this.getTypeInfo(n.type, n.attributes), l = this._isStorageTexture(o), u = new gg(n.name, o, i, s, n.attributes, l ? zu.StorageTexture : zu.Storage, n.access);
        u.access || (u.access = "read"), this.storage.push(u);
        continue;
      }
      if (this._isTextureVar(t)) {
        const n = t, i = this._getAttributeNum(n.attributes, "group", 0), s = this._getAttributeNum(n.attributes, "binding", 0), o = this.getTypeInfo(n.type, n.attributes), l = this._isStorageTexture(o), u = new gg(n.name, o, i, s, n.attributes, l ? zu.StorageTexture : zu.Texture, n.access);
        u.access || (u.access = "read"), l ? this.storage.push(u) : this.textures.push(u);
        continue;
      }
      if (this._isSamplerVar(t)) {
        const n = t, i = this._getAttributeNum(n.attributes, "group", 0), s = this._getAttributeNum(n.attributes, "binding", 0), o = this.getTypeInfo(n.type, n.attributes), l = new gg(n.name, o, i, s, n.attributes, zu.Sampler, n.access);
        this.samplers.push(l);
        continue;
      }
    }
    for (const t of e) if (t instanceof t0) {
      const n = this._getAttribute(t, "vertex"), i = this._getAttribute(t, "fragment"), s = this._getAttribute(t, "compute"), o = n || i || s, l = new v7(t.name, o?.name, t.attributes);
      l.attributes = t.attributes, l.startLine = t.startLine, l.endLine = t.endLine, this.functions.push(l), this._functions.get(t.name).info = l, o && (this._functions.get(t.name).inUse = !0, l.inUse = !0, l.resources = this._findResources(t, !!o), l.inputs = this._getInputs(t.args), l.outputs = this._getOutputs(t.returnType), this.entry[o.name].push(l)), l.arguments = t.args.map((u) => new y7(u.name, this.getTypeInfo(u.type, u.attributes), u.attributes)), l.returnType = t.returnType ? this.getTypeInfo(t.returnType, t.attributes) : null;
      continue;
    }
    for (const t of this._functions.values()) t.info && (t.info.inUse = t.inUse, this._addCalls(t.node, t.info.calls));
    for (const t of this._functions.values()) t.node.search((n) => {
      var i, s, o;
      if (n instanceof hO) {
        if (n.value) if (vr(n.value)) for (const l of n.value) for (const u of this.overrides) l === u.name && ((i = t.info) === null || i === void 0 || i.overrides.push(u));
        else for (const l of this.overrides) n.value === l.name && ((s = t.info) === null || s === void 0 || s.overrides.push(l));
      } else if (n instanceof ua) for (const l of this.overrides) n.name === l.name && ((o = t.info) === null || o === void 0 || o.overrides.push(l));
    });
    for (const t of this.uniforms) this._markStructsInUse(t.type);
    for (const t of this.storage) this._markStructsInUse(t.type);
  }
  getFunctionInfo(e) {
    for (const t of this.functions) if (t.name == e) return t;
    return null;
  }
  getStructInfo(e) {
    for (const t of this.structs) if (t.name == e) return t;
    return null;
  }
  getOverrideInfo(e) {
    for (const t of this.overrides) if (t.name == e) return t;
    return null;
  }
  _markStructsInUse(e) {
    if (e) if (e.isStruct) {
      if (e.inUse = !0, e.members) for (const t of e.members) this._markStructsInUse(t.type);
    } else if (e.isArray) this._markStructsInUse(e.format);
    else if (e.isTemplate) e.format && this._markStructsInUse(e.format);
    else {
      const t = this._getAlias(e.name);
      t && this._markStructsInUse(t);
    }
  }
  _addCalls(e, t) {
    var n;
    for (const i of e.calls) {
      const s = (n = this._functions.get(i.name)) === null || n === void 0 ? void 0 : n.info;
      s && t.add(s);
    }
  }
  findResource(e, t, n) {
    if (n) {
      for (const i of this.entry.compute) if (i.name === n) {
        for (const s of i.resources) if (s.group == e && s.binding == t) return s;
      }
      for (const i of this.entry.vertex) if (i.name === n) {
        for (const s of i.resources) if (s.group == e && s.binding == t) return s;
      }
      for (const i of this.entry.fragment) if (i.name === n) {
        for (const s of i.resources) if (s.group == e && s.binding == t) return s;
      }
    }
    for (const i of this.uniforms) if (i.group == e && i.binding == t) return i;
    for (const i of this.storage) if (i.group == e && i.binding == t) return i;
    for (const i of this.textures) if (i.group == e && i.binding == t) return i;
    for (const i of this.samplers) if (i.group == e && i.binding == t) return i;
    return null;
  }
  _findResource(e) {
    for (const t of this.uniforms) if (t.name == e) return t;
    for (const t of this.storage) if (t.name == e) return t;
    for (const t of this.textures) if (t.name == e) return t;
    for (const t of this.samplers) if (t.name == e) return t;
    return null;
  }
  _markStructsFromAST(e) {
    const t = this.getTypeInfo(e, null);
    this._markStructsInUse(t);
  }
  _findResources(e, t) {
    const n = [], i = this, s = [];
    return e.search((o) => {
      if (o instanceof Ym) s.push({});
      else if (o instanceof Km) s.pop();
      else if (o instanceof Gc) {
        const l = o;
        t && l.type !== null && this._markStructsFromAST(l.type), s.length > 0 && (s[s.length - 1][l.name] = l);
      } else if (o instanceof ec) {
        const l = o;
        t && l.type !== null && this._markStructsFromAST(l.type);
      } else if (o instanceof UA) {
        const l = o;
        t && l.type !== null && this._markStructsFromAST(l.type), s.length > 0 && (s[s.length - 1][l.name] = l);
      } else if (o instanceof ua) {
        const l = o;
        if (s.length > 0 && s[s.length - 1][l.name])
          return;
        const u = i._findResource(l.name);
        u && n.push(u);
      } else if (o instanceof xx) {
        const l = o, u = i._functions.get(l.name);
        u && (t && (u.inUse = !0), e.calls.add(u.node), u.resources === null && (u.resources = i._findResources(u.node, t)), n.push(...u.resources));
      } else if (o instanceof vx) {
        const l = o, u = i._functions.get(l.name);
        u && (t && (u.inUse = !0), e.calls.add(u.node), u.resources === null && (u.resources = i._findResources(u.node, t)), n.push(...u.resources));
      }
    }), [...new Map(n.map((o) => [o.name, o])).values()];
  }
  getBindGroups() {
    const e = [];
    function t(n, i) {
      n >= e.length && (e.length = n + 1), e[n] === void 0 && (e[n] = []), i >= e[n].length && (e[n].length = i + 1);
    }
    for (const n of this.uniforms)
      t(n.group, n.binding), e[n.group][n.binding] = n;
    for (const n of this.storage)
      t(n.group, n.binding), e[n.group][n.binding] = n;
    for (const n of this.textures)
      t(n.group, n.binding), e[n.group][n.binding] = n;
    for (const n of this.samplers)
      t(n.group, n.binding), e[n.group][n.binding] = n;
    return e;
  }
  _getOutputs(e, t = void 0) {
    if (t === void 0 && (t = []), e instanceof jc) this._getStructOutputs(e, t);
    else {
      const n = this._getOutputInfo(e);
      n !== null && t.push(n);
    }
    return t;
  }
  _getStructOutputs(e, t) {
    for (const n of e.members) if (n.type instanceof jc) this._getStructOutputs(n.type, t);
    else {
      const i = this._getAttribute(n, "location") || this._getAttribute(n, "builtin");
      if (i !== null) {
        const s = this.getTypeInfo(n.type, n.type.attributes), o = this._parseInt(i.value), l = new XE(n.name, s, i.name, o);
        t.push(l);
      }
    }
  }
  _getOutputInfo(e) {
    const t = this._getAttribute(e, "location") || this._getAttribute(e, "builtin");
    if (t !== null) {
      const n = this.getTypeInfo(e, e.attributes), i = this._parseInt(t.value);
      return new XE("", n, t.name, i);
    }
    return null;
  }
  _getInputs(e, t = void 0) {
    t === void 0 && (t = []);
    for (const n of e) if (n.type instanceof jc) this._getStructInputs(n.type, t);
    else {
      const i = this._getInputInfo(n);
      i !== null && t.push(i);
    }
    return t;
  }
  _getStructInputs(e, t) {
    for (const n of e.members) if (n.type instanceof jc) this._getStructInputs(n.type, t);
    else {
      const i = this._getInputInfo(n);
      i !== null && t.push(i);
    }
  }
  _getInputInfo(e) {
    const t = this._getAttribute(e, "location") || this._getAttribute(e, "builtin");
    if (t !== null) {
      const n = this._getAttribute(e, "interpolation"), i = this.getTypeInfo(e.type, e.attributes), s = this._parseInt(t.value), o = new m7(e.name, i, t.name, s);
      return n !== null && (o.interpolation = this._parseString(n.value)), o;
    }
    return null;
  }
  _parseString(e) {
    return e instanceof Array && (e = e[0]), e;
  }
  _parseInt(e) {
    e instanceof Array && (e = e[0]);
    const t = parseInt(e);
    return isNaN(t) ? e : t;
  }
  _getAlias(e) {
    for (const t of this.aliases) if (t.name == e) return t.type;
    return null;
  }
  _getAliasInfo(e) {
    return new g7(e.name, this.getTypeInfo(e.type, null));
  }
  getTypeInfoByName(e) {
    for (const t of this.structs) if (t.name == e) return t;
    for (const t of this.aliases) if (t.name == e) return t.type;
    return null;
  }
  getTypeInfo(e, t = null) {
    if (this._types.has(e)) return this._types.get(e);
    if (e instanceof _m) {
      const i = e.type ? this.getTypeInfo(e.type, e.attributes) : null, s = new Cb(e.name, i, t);
      return this._types.set(e, s), this._updateTypeInfo(s), s;
    }
    if (e instanceof zA) {
      const i = e, s = i.format ? this.getTypeInfo(i.format, i.attributes) : null, o = new $u(i.name, t);
      return o.format = s, o.count = i.count, this._types.set(e, o), this._updateTypeInfo(o), o;
    }
    if (e instanceof jc) {
      const i = e, s = new ju(i.name, t);
      s.startLine = i.startLine, s.endLine = i.endLine;
      for (const o of i.members) {
        const l = this.getTypeInfo(o.type, o.attributes);
        s.members.push(new qE(o.name, l, o.attributes));
      }
      return this._types.set(e, s), this._updateTypeInfo(s), s;
    }
    if (e instanceof MA) {
      const i = e, s = i.format instanceof $t, o = i.format ? s ? this.getTypeInfo(i.format, null) : new Fa(i.format, null) : null, l = new rh(i.name, o, t, i.access);
      return this._types.set(e, l), this._updateTypeInfo(l), l;
    }
    if (e instanceof mt) {
      const i = e, s = i.format ? this.getTypeInfo(i.format, null) : null, o = new rh(i.name, s, t, i.access);
      return this._types.set(e, o), this._updateTypeInfo(o), o;
    }
    const n = new Fa(e.name, t);
    return this._types.set(e, n), this._updateTypeInfo(n), n;
  }
  _updateTypeInfo(e) {
    var t, n, i;
    const s = this._getTypeSize(e);
    if (e.size = (t = s?.size) !== null && t !== void 0 ? t : 0, e instanceof $u && e.format) {
      const o = this._getTypeSize(e.format);
      e.stride = Math.max((n = o?.size) !== null && n !== void 0 ? n : 0, (i = o?.align) !== null && i !== void 0 ? i : 0), this._updateTypeInfo(e.format);
    }
    e instanceof Cb && this._updateTypeInfo(e.format), e instanceof ju && this._updateStructInfo(e);
  }
  _updateStructInfo(e) {
    var t;
    let n = 0, i = 0, s = 0, o = 0;
    for (let l = 0, u = e.members.length; l < u; ++l) {
      const m = e.members[l], y = this._getTypeSize(m);
      if (!y) continue;
      (t = this._getAlias(m.type.name)) !== null && t !== void 0 || m.type;
      const E = y.align, P = y.size;
      n = this._roundUp(E, n + i), i = P, s = n, o = Math.max(o, E), m.offset = n, m.size = P, this._updateTypeInfo(m.type);
    }
    e.size = this._roundUp(o, s + i), e.align = o;
  }
  _getTypeSize(e) {
    var t, n;
    if (e == null) return null;
    const i = this._getAttributeNum(e.attributes, "size", 0), s = this._getAttributeNum(e.attributes, "align", 0);
    if (e instanceof qE && (e = e.type), e instanceof Fa) {
      const o = this._getAlias(e.name);
      o !== null && (e = o);
    }
    {
      const o = nc._typeInfo[e.name];
      if (o !== void 0) {
        const l = ((t = e.format) === null || t === void 0 ? void 0 : t.name) === "f16" ? 2 : 1;
        return new mg(Math.max(s, o.align / l), Math.max(i, o.size / l));
      }
    }
    {
      const o = nc._typeInfo[e.name.substring(0, e.name.length - 1)];
      if (o) {
        const l = e.name[e.name.length - 1] === "h" ? 2 : 1;
        return new mg(Math.max(s, o.align / l), Math.max(i, o.size / l));
      }
    }
    if (e instanceof $u) {
      let o = e, l = 8, u = 8;
      const m = this._getTypeSize(o.format);
      return m !== null && (u = m.size, l = m.align), u = o.count * this._getAttributeNum((n = e?.attributes) !== null && n !== void 0 ? n : null, "stride", this._roundUp(l, u)), i && (u = i), new mg(Math.max(s, l), Math.max(i, u));
    }
    if (e instanceof ju) {
      let o = 0, l = 0, u = 0, m = 0, y = 0;
      for (const E of e.members) {
        const P = this._getTypeSize(E.type);
        P !== null && (o = Math.max(P.align, o), u = this._roundUp(P.align, u + m), m = P.size, y = u);
      }
      return l = this._roundUp(o, y + m), new mg(Math.max(s, o), Math.max(i, l));
    }
    return null;
  }
  _isUniformVar(e) {
    return e instanceof Gc && e.storage == "uniform";
  }
  _isStorageVar(e) {
    return e instanceof Gc && e.storage == "storage";
  }
  _isTextureVar(e) {
    return e instanceof Gc && e.type !== null && nc._textureTypes.indexOf(e.type.name) != -1;
  }
  _isSamplerVar(e) {
    return e instanceof Gc && e.type !== null && nc._samplerTypes.indexOf(e.type.name) != -1;
  }
  _getAttribute(e, t) {
    const n = e;
    if (!n || !n.attributes) return null;
    const i = n.attributes;
    for (let s of i) if (s.name == t) return s;
    return null;
  }
  _getAttributeNum(e, t, n) {
    if (e === null) return n;
    for (let i of e) if (i.name == t) {
      let s = i !== null && i.value !== null ? i.value : n;
      return s instanceof Array && (s = s[0]), typeof s == "number" ? s : typeof s == "string" ? parseInt(s) : n;
    }
    return n;
  }
  _roundUp(e, t) {
    return Math.ceil(t / e) * e;
  }
}
nc._typeInfo = { f16: { align: 2, size: 2 }, i32: { align: 4, size: 4 }, u32: { align: 4, size: 4 }, f32: { align: 4, size: 4 }, atomic: { align: 4, size: 4 }, vec2: { align: 8, size: 8 }, vec3: { align: 16, size: 12 }, vec4: { align: 16, size: 16 }, mat2x2: { align: 8, size: 16 }, mat3x2: { align: 8, size: 24 }, mat4x2: { align: 8, size: 32 }, mat2x3: { align: 16, size: 32 }, mat3x3: { align: 16, size: 48 }, mat4x3: { align: 16, size: 64 }, mat2x4: { align: 16, size: 32 }, mat3x4: { align: 16, size: 48 }, mat4x4: { align: 16, size: 64 } }, nc._textureTypes = Fe.any_texture_type.map((r) => r.name), nc._samplerTypes = Fe.sampler_type.map((r) => r.name);
let wx = 0;
class Tx {
  constructor(e, t, n) {
    this.id = wx++, this.name = e, this.value = t, this.node = n;
  }
  clone() {
    return new Tx(this.name, this.value, this.node);
  }
}
class Ex {
  constructor(e) {
    this.id = wx++, this.name = e.name, this.node = e;
  }
  clone() {
    return new Ex(this.node);
  }
}
class Cx {
  constructor(e) {
    this.parent = null, this.variables = /* @__PURE__ */ new Map(), this.functions = /* @__PURE__ */ new Map(), this.currentFunctionName = "", this.id = wx++, e && (this.parent = e, this.currentFunctionName = e.currentFunctionName);
  }
  getVariable(e) {
    var t;
    return this.variables.has(e) ? (t = this.variables.get(e)) !== null && t !== void 0 ? t : null : this.parent ? this.parent.getVariable(e) : null;
  }
  getFunction(e) {
    var t;
    return this.functions.has(e) ? (t = this.functions.get(e)) !== null && t !== void 0 ? t : null : this.parent ? this.parent.getFunction(e) : null;
  }
  createVariable(e, t, n) {
    this.variables.set(e, new Tx(e, t, n ?? null));
  }
  setVariable(e, t, n) {
    const i = this.getVariable(e);
    i !== null ? i.value = t : this.createVariable(e, t, n);
  }
  getVariableValue(e) {
    var t;
    const n = this.getVariable(e);
    return (t = n?.value) !== null && t !== void 0 ? t : null;
  }
  clone() {
    return new Cx(this);
  }
}
class z7 {
  evalExpression(e, t) {
    return null;
  }
  getTypeInfo(e) {
    return null;
  }
  getVariableName(e, t) {
    return "";
  }
}
class V7 {
  constructor(e) {
    this.exec = e;
  }
  getTypeInfo(e) {
    return this.exec.getTypeInfo(e);
  }
  All(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    let i = !0;
    if (n instanceof qe) return n.data.forEach((s) => {
      s || (i = !1);
    }), new ut(i ? 1 : 0, this.getTypeInfo("bool"));
    throw new Error(`All() expects a vector argument. Line ${e.line}`);
  }
  Any(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof qe) {
      const i = n.data.some((s) => s);
      return new ut(i ? 1 : 0, this.getTypeInfo("bool"));
    }
    throw new Error(`Any() expects a vector argument. Line ${e.line}`);
  }
  Select(e, t) {
    const n = this.exec.evalExpression(e.args[2], t);
    if (!(n instanceof ut)) throw new Error(`Select() expects a bool condition. Line ${e.line}`);
    return n.value ? this.exec.evalExpression(e.args[1], t) : this.exec.evalExpression(e.args[0], t);
  }
  ArrayLength(e, t) {
    let n = e.args[0];
    n instanceof hs && (n = n.right);
    const i = this.exec.evalExpression(n, t);
    if (i instanceof Ji && i.typeInfo.size === 0) {
      const s = i.typeInfo, o = i.buffer.byteLength / s.stride;
      return new ut(o, this.getTypeInfo("u32"));
    }
    return new ut(i.typeInfo.size, this.getTypeInfo("u32"));
  }
  Abs(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof qe) return new qe(n.data.map((s) => Math.abs(s)), n.typeInfo);
    const i = n;
    return new ut(Math.abs(i.value), i.typeInfo);
  }
  Acos(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof qe) return new qe(n.data.map((s) => Math.acos(s)), n.typeInfo);
    const i = n;
    return new ut(Math.acos(i.value), n.typeInfo);
  }
  Acosh(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof qe) return new qe(n.data.map((s) => Math.acosh(s)), n.typeInfo);
    const i = n;
    return new ut(Math.acosh(i.value), n.typeInfo);
  }
  Asin(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof qe) return new qe(n.data.map((s) => Math.asin(s)), n.typeInfo);
    const i = n;
    return new ut(Math.asin(i.value), n.typeInfo);
  }
  Asinh(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof qe) return new qe(n.data.map((s) => Math.asinh(s)), n.typeInfo);
    const i = n;
    return new ut(Math.asinh(i.value), n.typeInfo);
  }
  Atan(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof qe) return new qe(n.data.map((s) => Math.atan(s)), n.typeInfo);
    const i = n;
    return new ut(Math.atan(i.value), n.typeInfo);
  }
  Atanh(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof qe) return new qe(n.data.map((s) => Math.atanh(s)), n.typeInfo);
    const i = n;
    return new ut(Math.atanh(i.value), n.typeInfo);
  }
  Atan2(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t);
    if (n instanceof qe && i instanceof qe) return new qe(n.data.map((l, u) => Math.atan2(l, i.data[u])), n.typeInfo);
    const s = n, o = i;
    return new ut(Math.atan2(s.value, o.value), n.typeInfo);
  }
  Ceil(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof qe) return new qe(n.data.map((s) => Math.ceil(s)), n.typeInfo);
    const i = n;
    return new ut(Math.ceil(i.value), n.typeInfo);
  }
  _clamp(e, t, n) {
    return Math.min(Math.max(e, t), n);
  }
  Clamp(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t), s = this.exec.evalExpression(e.args[2], t);
    if (n instanceof qe && i instanceof qe && s instanceof qe) return new qe(n.data.map((m, y) => this._clamp(m, i.data[y], s.data[y])), n.typeInfo);
    const o = n, l = i, u = s;
    return new ut(this._clamp(o.value, l.value, u.value), n.typeInfo);
  }
  Cos(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof qe) return new qe(n.data.map((s) => Math.cos(s)), n.typeInfo);
    const i = n;
    return new ut(Math.cos(i.value), n.typeInfo);
  }
  Cosh(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof qe) return new qe(n.data.map((s) => Math.cosh(s)), n.typeInfo);
    const i = n;
    return new ut(Math.cos(i.value), n.typeInfo);
  }
  CountLeadingZeros(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof qe) return new qe(n.data.map((s) => Math.clz32(s)), n.typeInfo);
    const i = n;
    return new ut(Math.clz32(i.value), n.typeInfo);
  }
  _countOneBits(e) {
    let t = 0;
    for (; e !== 0; ) 1 & e && t++, e >>= 1;
    return t;
  }
  CountOneBits(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof qe) return new qe(n.data.map((s) => this._countOneBits(s)), n.typeInfo);
    const i = n;
    return new ut(this._countOneBits(i.value), n.typeInfo);
  }
  _countTrailingZeros(e) {
    if (e === 0) return 32;
    let t = 0;
    for (; !(1 & e); ) e >>= 1, t++;
    return t;
  }
  CountTrailingZeros(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof qe) return new qe(n.data.map((s) => this._countTrailingZeros(s)), n.typeInfo);
    const i = n;
    return new ut(this._countTrailingZeros(i.value), n.typeInfo);
  }
  Cross(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t);
    if (n instanceof qe && i instanceof qe) {
      if (n.data.length !== 3 || i.data.length !== 3) return console.error(`Cross() expects 3D vectors. Line ${e.line}`), null;
      const s = n.data, o = i.data;
      return new qe([s[1] * o[2] - o[1] * s[2], s[2] * o[0] - o[2] * s[0], s[0] * o[1] - o[0] * s[1]], n.typeInfo);
    }
    return console.error(`Cross() expects vector arguments. Line ${e.line}`), null;
  }
  Degrees(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = 180 / Math.PI;
    return n instanceof qe ? new qe(n.data.map((s) => s * i), n.typeInfo) : new ut(n.value * i, this.getTypeInfo("f32"));
  }
  Determinant(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof ln) {
      const i = n.data, s = n.typeInfo.getTypeName(), o = s.endsWith("h") ? this.getTypeInfo("f16") : this.getTypeInfo("f32");
      if (s === "mat2x2" || s === "mat2x2f" || s === "mat2x2h") return new ut(i[0] * i[3] - i[1] * i[2], o);
      if (s === "mat2x3" || s === "mat2x3f" || s === "mat2x3h") return new ut(i[0] * (i[4] * i[8] - i[5] * i[7]) - i[1] * (i[3] * i[8] - i[5] * i[6]) + i[2] * (i[3] * i[7] - i[4] * i[6]), o);
      if (s === "mat2x4" || s === "mat2x4f" || s === "mat2x4h") console.error(`TODO: Determinant for ${s}`);
      else if (s === "mat3x2" || s === "mat3x2f" || s === "mat3x2h") console.error(`TODO: Determinant for ${s}`);
      else {
        if (s === "mat3x3" || s === "mat3x3f" || s === "mat3x3h") return new ut(i[0] * (i[4] * i[8] - i[5] * i[7]) - i[1] * (i[3] * i[8] - i[5] * i[6]) + i[2] * (i[3] * i[7] - i[4] * i[6]), o);
        s === "mat3x4" || s === "mat3x4f" || s === "mat3x4h" || s === "mat4x2" || s === "mat4x2f" || s === "mat4x2h" || s === "mat4x3" || s === "mat4x3f" || s === "mat4x3h" ? console.error(`TODO: Determinant for ${s}`) : s !== "mat4x4" && s !== "mat4x4f" && s !== "mat4x4h" || console.error(`TODO: Determinant for ${s}`);
      }
    }
    return console.error(`Determinant expects a matrix argument. Line ${e.line}`), null;
  }
  Distance(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t);
    if (n instanceof qe && i instanceof qe) {
      let l = 0;
      for (let u = 0; u < n.data.length; ++u) l += (n.data[u] - i.data[u]) * (n.data[u] - i.data[u]);
      return new ut(Math.sqrt(l), this.getTypeInfo("f32"));
    }
    const s = n, o = i;
    return new ut(Math.abs(s.value - o.value), n.typeInfo);
  }
  _dot(e, t) {
    let n = 0;
    for (let i = 0; i < e.length; ++i) n += t[i] * e[i];
    return n;
  }
  Dot(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t);
    return n instanceof qe && i instanceof qe ? new ut(this._dot(n.data, i.data), this.getTypeInfo("f32")) : (console.error(`Dot() expects vector arguments. Line ${e.line}`), null);
  }
  Dot4U8Packed(e, t) {
    return console.error(`TODO: dot4U8Packed. Line ${e.line}`), null;
  }
  Dot4I8Packed(e, t) {
    return console.error(`TODO: dot4I8Packed. Line ${e.line}`), null;
  }
  Exp(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof qe) return new qe(n.data.map((s) => Math.exp(s)), n.typeInfo);
    const i = n;
    return new ut(Math.exp(i.value), n.typeInfo);
  }
  Exp2(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof qe) return new qe(n.data.map((s) => Math.pow(2, s)), n.typeInfo);
    const i = n;
    return new ut(Math.pow(2, i.value), n.typeInfo);
  }
  ExtractBits(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t), s = this.exec.evalExpression(e.args[2], t);
    if (i.typeInfo.name !== "u32" && i.typeInfo.name !== "x32") return console.error(`ExtractBits() expects an i32 offset argument. Line ${e.line}`), null;
    if (s.typeInfo.name !== "u32" && s.typeInfo.name !== "x32") return console.error(`ExtractBits() expects an i32 count argument. Line ${e.line}`), null;
    const o = i.value, l = s.value;
    if (n instanceof qe) return new qe(n.data.map((m) => m >> o & (1 << l) - 1), n.typeInfo);
    if (n.typeInfo.name !== "i32" && n.typeInfo.name !== "x32") return console.error(`ExtractBits() expects an i32 argument. Line ${e.line}`), null;
    const u = n.value;
    return new ut(u >> o & (1 << l) - 1, this.getTypeInfo("i32"));
  }
  FaceForward(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t), s = this.exec.evalExpression(e.args[2], t);
    if (n instanceof qe && i instanceof qe && s instanceof qe) {
      const o = this._dot(i.data, s.data);
      return new qe(o < 0 ? Array.from(n.data) : n.data.map((l) => -l), n.typeInfo);
    }
    return console.error(`FaceForward() expects vector arguments. Line ${e.line}`), null;
  }
  _firstLeadingBit(e) {
    return e === 0 ? -1 : 31 - Math.clz32(e);
  }
  FirstLeadingBit(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof qe) return new qe(n.data.map((s) => this._firstLeadingBit(s)), n.typeInfo);
    const i = n;
    return new ut(this._firstLeadingBit(i.value), n.typeInfo);
  }
  _firstTrailingBit(e) {
    return e === 0 ? -1 : Math.log2(e & -e);
  }
  FirstTrailingBit(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof qe) return new qe(n.data.map((s) => this._firstTrailingBit(s)), n.typeInfo);
    const i = n;
    return new ut(this._firstTrailingBit(i.value), n.typeInfo);
  }
  Floor(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof qe) return new qe(n.data.map((s) => Math.floor(s)), n.typeInfo);
    const i = n;
    return new ut(Math.floor(i.value), n.typeInfo);
  }
  Fma(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t), s = this.exec.evalExpression(e.args[2], t);
    if (n instanceof qe && i instanceof qe && s instanceof qe) return n.data.length !== i.data.length || n.data.length !== s.data.length ? (console.error(`Fma() expects vectors of the same length. Line ${e.line}`), null) : new qe(n.data.map((m, y) => m * i.data[y] + s.data[y]), n.typeInfo);
    const o = n, l = i, u = s;
    return new ut(o.value * l.value + u.value, o.typeInfo);
  }
  Fract(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof qe) return new qe(n.data.map((s) => s - Math.floor(s)), n.typeInfo);
    const i = n;
    return new ut(i.value - Math.floor(i.value), n.typeInfo);
  }
  Frexp(e, t) {
    return console.error(`TODO: frexp. Line ${e.line}`), null;
  }
  InsertBits(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t), s = this.exec.evalExpression(e.args[2], t), o = this.exec.evalExpression(e.args[3], t);
    if (s.typeInfo.name !== "u32" && s.typeInfo.name !== "x32") return console.error(`InsertBits() expects an i32 offset argument. Line ${e.line}`), null;
    const l = s.value, u = (1 << o.value) - 1 << l, m = ~u;
    if (n instanceof qe && i instanceof qe) return new qe(n.data.map((P, L) => P & m | i.data[L] << l & u), n.typeInfo);
    const y = n.value, E = i.value;
    return new ut(y & m | E << l & u, n.typeInfo);
  }
  InverseSqrt(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof qe) return new qe(n.data.map((s) => 1 / Math.sqrt(s)), n.typeInfo);
    const i = n;
    return new ut(1 / Math.sqrt(i.value), n.typeInfo);
  }
  Ldexp(e, t) {
    return console.error(`TODO: ldexp. Line ${e.line}`), null;
  }
  Length(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof qe) {
      let s = 0;
      return n.data.forEach((o) => {
        s += o * o;
      }), new ut(Math.sqrt(s), this.getTypeInfo("f32"));
    }
    const i = n;
    return new ut(Math.abs(i.value), n.typeInfo);
  }
  Log(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof qe) return new qe(n.data.map((s) => Math.log(s)), n.typeInfo);
    const i = n;
    return new ut(Math.log(i.value), n.typeInfo);
  }
  Log2(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof qe) return new qe(n.data.map((s) => Math.log2(s)), n.typeInfo);
    const i = n;
    return new ut(Math.log2(i.value), n.typeInfo);
  }
  Max(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t);
    if (n instanceof qe && i instanceof qe) return new qe(n.data.map((l, u) => Math.max(l, i.data[u])), n.typeInfo);
    const s = n, o = i;
    return new ut(Math.max(s.value, o.value), n.typeInfo);
  }
  Min(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t);
    if (n instanceof qe && i instanceof qe) return new qe(n.data.map((l, u) => Math.min(l, i.data[u])), n.typeInfo);
    const s = n, o = i;
    return new ut(Math.min(s.value, o.value), n.typeInfo);
  }
  Mix(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t), s = this.exec.evalExpression(e.args[2], t);
    if (n instanceof qe && i instanceof qe && s instanceof qe) return new qe(n.data.map((u, m) => n.data[m] * (1 - s.data[m]) + i.data[m] * s.data[m]), n.typeInfo);
    const o = i, l = s;
    return new ut(n.value * (1 - l.value) + o.value * l.value, n.typeInfo);
  }
  Modf(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t);
    if (n instanceof qe && i instanceof qe) return new qe(n.data.map((o, l) => o % i.data[l]), n.typeInfo);
    const s = i;
    return new ut(n.value % s.value, n.typeInfo);
  }
  Normalize(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof qe) {
      const i = this.Length(e, t).value;
      return new qe(n.data.map((s) => s / i), n.typeInfo);
    }
    return console.error(`Normalize() expects a vector argument. Line ${e.line}`), null;
  }
  Pow(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t);
    if (n instanceof qe && i instanceof qe) return new qe(n.data.map((l, u) => Math.pow(l, i.data[u])), n.typeInfo);
    const s = n, o = i;
    return new ut(Math.pow(s.value, o.value), n.typeInfo);
  }
  QuantizeToF16(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    return n instanceof qe ? new qe(n.data.map((i) => i), n.typeInfo) : new ut(n.value, n.typeInfo);
  }
  Radians(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    return n instanceof qe ? new qe(n.data.map((i) => i * Math.PI / 180), n.typeInfo) : new ut(n.value * Math.PI / 180, this.getTypeInfo("f32"));
  }
  Reflect(e, t) {
    let n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t);
    if (n instanceof qe && i instanceof qe) {
      const s = this._dot(n.data, i.data);
      return new qe(n.data.map((o, l) => o - 2 * s * i.data[l]), n.typeInfo);
    }
    return console.error(`Reflect() expects vector arguments. Line ${e.line}`), null;
  }
  Refract(e, t) {
    let n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t), s = this.exec.evalExpression(e.args[2], t);
    if (n instanceof qe && i instanceof qe && s instanceof ut) {
      const o = this._dot(i.data, n.data);
      return new qe(n.data.map((l, u) => {
        const m = 1 - s.value * s.value * (1 - o * o);
        if (m < 0) return 0;
        const y = Math.sqrt(m);
        return s.value * l - (s.value * o + y) * i.data[u];
      }), n.typeInfo);
    }
    return console.error(`Refract() expects vector arguments and a scalar argument. Line ${e.line}`), null;
  }
  ReverseBits(e, t) {
    return console.error(`TODO: reverseBits. Line ${e.line}`), null;
  }
  Round(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof qe) return new qe(n.data.map((s) => Math.round(s)), n.typeInfo);
    const i = n;
    return new ut(Math.round(i.value), n.typeInfo);
  }
  Saturate(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof qe) return new qe(n.data.map((s) => Math.min(Math.max(s, 0), 1)), n.typeInfo);
    const i = n;
    return new ut(Math.min(Math.max(i.value, 0), 1), n.typeInfo);
  }
  Sign(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof qe) return new qe(n.data.map((s) => Math.sign(s)), n.typeInfo);
    const i = n;
    return new ut(Math.sign(i.value), n.typeInfo);
  }
  Sin(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof qe) return new qe(n.data.map((s) => Math.sin(s)), n.typeInfo);
    const i = n;
    return new ut(Math.sin(i.value), n.typeInfo);
  }
  Sinh(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof qe) return new qe(n.data.map((s) => Math.sinh(s)), n.typeInfo);
    const i = n;
    return new ut(Math.sinh(i.value), n.typeInfo);
  }
  _smoothstep(e, t, n) {
    const i = Math.min(Math.max((n - e) / (t - e), 0), 1);
    return i * i * (3 - 2 * i);
  }
  SmoothStep(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t), s = this.exec.evalExpression(e.args[2], t);
    if (s instanceof qe && n instanceof qe && i instanceof qe) return new qe(s.data.map((m, y) => this._smoothstep(n.data[y], i.data[y], m)), s.typeInfo);
    const o = n, l = i, u = s;
    return new ut(this._smoothstep(o.value, l.value, u.value), s.typeInfo);
  }
  Sqrt(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof qe) return new qe(n.data.map((s) => Math.sqrt(s)), n.typeInfo);
    const i = n;
    return new ut(Math.sqrt(i.value), n.typeInfo);
  }
  Step(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t);
    if (i instanceof qe && n instanceof qe) return new qe(i.data.map((o, l) => o < n.data[l] ? 0 : 1), i.typeInfo);
    const s = n;
    return new ut(i.value < s.value ? 0 : 1, s.typeInfo);
  }
  Tan(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof qe) return new qe(n.data.map((s) => Math.tan(s)), n.typeInfo);
    const i = n;
    return new ut(Math.tan(i.value), n.typeInfo);
  }
  Tanh(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof qe) return new qe(n.data.map((s) => Math.tanh(s)), n.typeInfo);
    const i = n;
    return new ut(Math.tanh(i.value), n.typeInfo);
  }
  _getTransposeType(e) {
    const t = e.getTypeName();
    return t === "mat2x2f" || t === "mat2x2h" ? e : t === "mat2x3f" ? this.getTypeInfo("mat3x2f") : t === "mat2x3h" ? this.getTypeInfo("mat3x2h") : t === "mat2x4f" ? this.getTypeInfo("mat4x2f") : t === "mat2x4h" ? this.getTypeInfo("mat4x2h") : t === "mat3x2f" ? this.getTypeInfo("mat2x3f") : t === "mat3x2h" ? this.getTypeInfo("mat2x3h") : t === "mat3x3f" || t === "mat3x3h" ? e : t === "mat3x4f" ? this.getTypeInfo("mat4x3f") : t === "mat3x4h" ? this.getTypeInfo("mat4x3h") : t === "mat4x2f" ? this.getTypeInfo("mat2x4f") : t === "mat4x2h" ? this.getTypeInfo("mat2x4h") : t === "mat4x3f" ? this.getTypeInfo("mat3x4f") : t === "mat4x3h" ? this.getTypeInfo("mat3x4h") : (t === "mat4x4f" || t === "mat4x4h" || console.error(`Invalid matrix type ${t}`), e);
  }
  Transpose(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (!(n instanceof ln)) return console.error(`Transpose() expects a matrix argument. Line ${e.line}`), null;
    const i = this._getTransposeType(n.typeInfo);
    if (n.typeInfo.name === "mat2x2" || n.typeInfo.name === "mat2x2f" || n.typeInfo.name === "mat2x2h") {
      const s = n.data;
      return new ln([s[0], s[2], s[1], s[3]], i);
    }
    if (n.typeInfo.name === "mat2x3" || n.typeInfo.name === "mat2x3f" || n.typeInfo.name === "mat2x3h") {
      const s = n.data;
      return new ln([s[0], s[3], s[6], s[1], s[4], s[7]], i);
    }
    if (n.typeInfo.name === "mat2x4" || n.typeInfo.name === "mat2x4f" || n.typeInfo.name === "mat2x4h") {
      const s = n.data;
      return new ln([s[0], s[4], s[8], s[12], s[1], s[5], s[9], s[13]], i);
    }
    if (n.typeInfo.name === "mat3x2" || n.typeInfo.name === "mat3x2f" || n.typeInfo.name === "mat3x2h") {
      const s = n.data;
      return new ln([s[0], s[3], s[1], s[4], s[2], s[5]], i);
    }
    if (n.typeInfo.name === "mat3x3" || n.typeInfo.name === "mat3x3f" || n.typeInfo.name === "mat3x3h") {
      const s = n.data;
      return new ln([s[0], s[3], s[6], s[1], s[4], s[7], s[2], s[5], s[8]], i);
    }
    if (n.typeInfo.name === "mat3x4" || n.typeInfo.name === "mat3x4f" || n.typeInfo.name === "mat3x4h") {
      const s = n.data;
      return new ln([s[0], s[4], s[8], s[12], s[1], s[5], s[9], s[13], s[2], s[6], s[10], s[14]], i);
    }
    if (n.typeInfo.name === "mat4x2" || n.typeInfo.name === "mat4x2f" || n.typeInfo.name === "mat4x2h") {
      const s = n.data;
      return new ln([s[0], s[4], s[1], s[5], s[2], s[6]], i);
    }
    if (n.typeInfo.name === "mat4x3" || n.typeInfo.name === "mat4x3f" || n.typeInfo.name === "mat4x3h") {
      const s = n.data;
      return new ln([s[0], s[4], s[8], s[1], s[5], s[9], s[2], s[6], s[10]], i);
    }
    if (n.typeInfo.name === "mat4x4" || n.typeInfo.name === "mat4x4f" || n.typeInfo.name === "mat4x4h") {
      const s = n.data;
      return new ln([s[0], s[4], s[8], s[12], s[1], s[5], s[9], s[13], s[2], s[6], s[10], s[14], s[3], s[7], s[11], s[15]], i);
    }
    return console.error(`Invalid matrix type ${n.typeInfo.name}`), null;
  }
  Trunc(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof qe) return new qe(n.data.map((s) => Math.trunc(s)), n.typeInfo);
    const i = n;
    return new ut(Math.trunc(i.value), n.typeInfo);
  }
  Dpdx(e, t) {
    return console.error(`TODO: dpdx. Line ${e.line}`), null;
  }
  DpdxCoarse(e, t) {
    return console.error(`TODO: dpdxCoarse. Line ${e.line}`), null;
  }
  DpdxFine(e, t) {
    return console.error("TODO: dpdxFine"), null;
  }
  Dpdy(e, t) {
    return console.error("TODO: dpdy"), null;
  }
  DpdyCoarse(e, t) {
    return console.error("TODO: dpdyCoarse"), null;
  }
  DpdyFine(e, t) {
    return console.error("TODO: dpdyFine"), null;
  }
  Fwidth(e, t) {
    return console.error("TODO: fwidth"), null;
  }
  FwidthCoarse(e, t) {
    return console.error("TODO: fwidthCoarse"), null;
  }
  FwidthFine(e, t) {
    return console.error("TODO: fwidthFine"), null;
  }
  TextureDimensions(e, t) {
    const n = e.args[0], i = e.args.length > 1 ? this.exec.evalExpression(e.args[1], t).value : 0;
    if (n instanceof ua) {
      const s = n.name, o = t.getVariableValue(s);
      if (o instanceof Hc) {
        if (i < 0 || i >= o.mipLevelCount) return console.error(`Invalid mip level for textureDimensions. Line ${e.line}`), null;
        const l = o.getMipLevelSize(i), u = o.dimension;
        return u === "1d" ? new ut(l[0], this.getTypeInfo("u32")) : u === "3d" ? new qe(l, this.getTypeInfo("vec3u")) : u === "2d" ? new qe(l.slice(0, 2), this.getTypeInfo("vec2u")) : (console.error(`Invalid texture dimension ${u} not found. Line ${e.line}`), null);
      }
      return console.error(`Texture ${s} not found. Line ${e.line}`), null;
    }
    return console.error(`Invalid texture argument for textureDimensions. Line ${e.line}`), null;
  }
  TextureGather(e, t) {
    return console.error("TODO: textureGather"), null;
  }
  TextureGatherCompare(e, t) {
    return console.error("TODO: textureGatherCompare"), null;
  }
  TextureLoad(e, t) {
    const n = e.args[0], i = this.exec.evalExpression(e.args[1], t), s = e.args.length > 2 ? this.exec.evalExpression(e.args[2], t).value : 0;
    if (!(i instanceof qe) || i.data.length !== 2) return console.error(`Invalid UV argument for textureLoad. Line ${e.line}`), null;
    if (n instanceof ua) {
      const o = n.name, l = t.getVariableValue(o);
      if (l instanceof Hc) {
        const u = Math.floor(i.data[0]), m = Math.floor(i.data[1]);
        if (u < 0 || u >= l.width || m < 0 || m >= l.height) return console.error(`Texture ${o} out of bounds. Line ${e.line}`), null;
        const y = l.getPixel(u, m, 0, s);
        return y === null ? (console.error(`Invalid texture format for textureLoad. Line ${e.line}`), null) : new qe(y, this.getTypeInfo("vec4f"));
      }
      return console.error(`Texture ${o} not found. Line ${e.line}`), null;
    }
    return console.error(`Invalid texture argument for textureLoad. Line ${e.line}`), null;
  }
  TextureNumLayers(e, t) {
    const n = e.args[0];
    if (n instanceof ua) {
      const i = n.name, s = t.getVariableValue(i);
      return s instanceof Hc ? new ut(s.depthOrArrayLayers, this.getTypeInfo("u32")) : (console.error(`Texture ${i} not found. Line ${e.line}`), null);
    }
    return console.error(`Invalid texture argument for textureNumLayers. Line ${e.line}`), null;
  }
  TextureNumLevels(e, t) {
    const n = e.args[0];
    if (n instanceof ua) {
      const i = n.name, s = t.getVariableValue(i);
      return s instanceof Hc ? new ut(s.mipLevelCount, this.getTypeInfo("u32")) : (console.error(`Texture ${i} not found. Line ${e.line}`), null);
    }
    return console.error(`Invalid texture argument for textureNumLevels. Line ${e.line}`), null;
  }
  TextureNumSamples(e, t) {
    const n = e.args[0];
    if (n instanceof ua) {
      const i = n.name, s = t.getVariableValue(i);
      return s instanceof Hc ? new ut(s.sampleCount, this.getTypeInfo("u32")) : (console.error(`Texture ${i} not found. Line ${e.line}`), null);
    }
    return console.error(`Invalid texture argument for textureNumSamples. Line ${e.line}`), null;
  }
  TextureSample(e, t) {
    return console.error("TODO: textureSample"), null;
  }
  TextureSampleBias(e, t) {
    return console.error("TODO: textureSampleBias"), null;
  }
  TextureSampleCompare(e, t) {
    return console.error("TODO: textureSampleCompare"), null;
  }
  TextureSampleCompareLevel(e, t) {
    return console.error("TODO: textureSampleCompareLevel"), null;
  }
  TextureSampleGrad(e, t) {
    return console.error("TODO: textureSampleGrad"), null;
  }
  TextureSampleLevel(e, t) {
    return console.error("TODO: textureSampleLevel"), null;
  }
  TextureSampleBaseClampToEdge(e, t) {
    return console.error("TODO: textureSampleBaseClampToEdge"), null;
  }
  TextureStore(e, t) {
    const n = e.args[0], i = this.exec.evalExpression(e.args[1], t), s = e.args.length === 4 ? this.exec.evalExpression(e.args[2], t).value : 0, o = e.args.length === 4 ? this.exec.evalExpression(e.args[3], t).data : this.exec.evalExpression(e.args[2], t).data;
    if (o.length !== 4) return console.error(`Invalid value argument for textureStore. Line ${e.line}`), null;
    if (!(i instanceof qe) || i.data.length !== 2) return console.error(`Invalid UV argument for textureStore. Line ${e.line}`), null;
    if (n instanceof ua) {
      const l = n.name, u = t.getVariableValue(l);
      if (u instanceof Hc) {
        const m = u.getMipLevelSize(0), y = Math.floor(i.data[0]), E = Math.floor(i.data[1]);
        return y < 0 || y >= m[0] || E < 0 || E >= m[1] ? (console.error(`Texture ${l} out of bounds. Line ${e.line}`), null) : (u.setPixel(y, E, 0, s, Array.from(o)), null);
      }
      return console.error(`Texture ${l} not found. Line ${e.line}`), null;
    }
    return console.error(`Invalid texture argument for textureStore. Line ${e.line}`), null;
  }
  AtomicLoad(e, t) {
    let n = e.args[0];
    n instanceof hs && (n = n.right);
    const i = this.exec.getVariableName(n, t);
    return t.getVariable(i).value.getSubData(this.exec, n.postfix, t);
  }
  AtomicStore(e, t) {
    let n = e.args[0];
    n instanceof hs && (n = n.right);
    const i = this.exec.getVariableName(n, t), s = t.getVariable(i);
    let o = e.args[1];
    const l = this.exec.evalExpression(o, t), u = s.value.getSubData(this.exec, n.postfix, t);
    return u instanceof ut && l instanceof ut && (u.value = l.value), s.value instanceof Ji && s.value.setDataValue(this.exec, u, n.postfix, t), null;
  }
  AtomicAdd(e, t) {
    let n = e.args[0];
    n instanceof hs && (n = n.right);
    const i = this.exec.getVariableName(n, t), s = t.getVariable(i);
    let o = e.args[1];
    const l = this.exec.evalExpression(o, t), u = s.value.getSubData(this.exec, n.postfix, t), m = new ut(u.value, u.typeInfo);
    return u instanceof ut && l instanceof ut && (u.value += l.value), s.value instanceof Ji && s.value.setDataValue(this.exec, u, n.postfix, t), m;
  }
  AtomicSub(e, t) {
    let n = e.args[0];
    n instanceof hs && (n = n.right);
    const i = this.exec.getVariableName(n, t), s = t.getVariable(i);
    let o = e.args[1];
    const l = this.exec.evalExpression(o, t), u = s.value.getSubData(this.exec, n.postfix, t), m = new ut(u.value, u.typeInfo);
    return u instanceof ut && l instanceof ut && (u.value -= l.value), s.value instanceof Ji && s.value.setDataValue(this.exec, u, n.postfix, t), m;
  }
  AtomicMax(e, t) {
    let n = e.args[0];
    n instanceof hs && (n = n.right);
    const i = this.exec.getVariableName(n, t), s = t.getVariable(i);
    let o = e.args[1];
    const l = this.exec.evalExpression(o, t), u = s.value.getSubData(this.exec, n.postfix, t), m = new ut(u.value, u.typeInfo);
    return u instanceof ut && l instanceof ut && (u.value = Math.max(u.value, l.value)), s.value instanceof Ji && s.value.setDataValue(this.exec, u, n.postfix, t), m;
  }
  AtomicMin(e, t) {
    let n = e.args[0];
    n instanceof hs && (n = n.right);
    const i = this.exec.getVariableName(n, t), s = t.getVariable(i);
    let o = e.args[1];
    const l = this.exec.evalExpression(o, t), u = s.value.getSubData(this.exec, n.postfix, t), m = new ut(u.value, u.typeInfo);
    return u instanceof ut && l instanceof ut && (u.value = Math.min(u.value, l.value)), s.value instanceof Ji && s.value.setDataValue(this.exec, u, n.postfix, t), m;
  }
  AtomicAnd(e, t) {
    let n = e.args[0];
    n instanceof hs && (n = n.right);
    const i = this.exec.getVariableName(n, t), s = t.getVariable(i);
    let o = e.args[1];
    const l = this.exec.evalExpression(o, t), u = s.value.getSubData(this.exec, n.postfix, t), m = new ut(u.value, u.typeInfo);
    return u instanceof ut && l instanceof ut && (u.value = u.value & l.value), s.value instanceof Ji && s.value.setDataValue(this.exec, u, n.postfix, t), m;
  }
  AtomicOr(e, t) {
    let n = e.args[0];
    n instanceof hs && (n = n.right);
    const i = this.exec.getVariableName(n, t), s = t.getVariable(i);
    let o = e.args[1];
    const l = this.exec.evalExpression(o, t), u = s.value.getSubData(this.exec, n.postfix, t), m = new ut(u.value, u.typeInfo);
    return u instanceof ut && l instanceof ut && (u.value = u.value | l.value), s.value instanceof Ji && s.value.setDataValue(this.exec, u, n.postfix, t), m;
  }
  AtomicXor(e, t) {
    let n = e.args[0];
    n instanceof hs && (n = n.right);
    const i = this.exec.getVariableName(n, t), s = t.getVariable(i);
    let o = e.args[1];
    const l = this.exec.evalExpression(o, t), u = s.value.getSubData(this.exec, n.postfix, t), m = new ut(u.value, u.typeInfo);
    return u instanceof ut && l instanceof ut && (u.value = u.value ^ l.value), s.value instanceof Ji && s.value.setDataValue(this.exec, u, n.postfix, t), m;
  }
  AtomicExchange(e, t) {
    let n = e.args[0];
    n instanceof hs && (n = n.right);
    const i = this.exec.getVariableName(n, t), s = t.getVariable(i);
    let o = e.args[1];
    const l = this.exec.evalExpression(o, t), u = s.value.getSubData(this.exec, n.postfix, t), m = new ut(u.value, u.typeInfo);
    return u instanceof ut && l instanceof ut && (u.value = l.value), s.value instanceof Ji && s.value.setDataValue(this.exec, u, n.postfix, t), m;
  }
  AtomicCompareExchangeWeak(e, t) {
    return console.error("TODO: atomicCompareExchangeWeak"), null;
  }
  Pack4x8snorm(e, t) {
    return console.error("TODO: pack4x8snorm"), null;
  }
  Pack4x8unorm(e, t) {
    return console.error("TODO: pack4x8unorm"), null;
  }
  Pack4xI8(e, t) {
    return console.error("TODO: pack4xI8"), null;
  }
  Pack4xU8(e, t) {
    return console.error("TODO: pack4xU8"), null;
  }
  Pack4x8Clamp(e, t) {
    return console.error("TODO: pack4x8Clamp"), null;
  }
  Pack4xU8Clamp(e, t) {
    return console.error("TODO: pack4xU8Clamp"), null;
  }
  Pack2x16snorm(e, t) {
    return console.error("TODO: pack2x16snorm"), null;
  }
  Pack2x16unorm(e, t) {
    return console.error("TODO: pack2x16unorm"), null;
  }
  Pack2x16float(e, t) {
    return console.error("TODO: pack2x16float"), null;
  }
  Unpack4x8snorm(e, t) {
    return console.error("TODO: unpack4x8snorm"), null;
  }
  Unpack4x8unorm(e, t) {
    return console.error("TODO: unpack4x8unorm"), null;
  }
  Unpack4xI8(e, t) {
    return console.error("TODO: unpack4xI8"), null;
  }
  Unpack4xU8(e, t) {
    return console.error("TODO: unpack4xU8"), null;
  }
  Unpack2x16snorm(e, t) {
    return console.error("TODO: unpack2x16snorm"), null;
  }
  Unpack2x16unorm(e, t) {
    return console.error("TODO: unpack2x16unorm"), null;
  }
  Unpack2x16float(e, t) {
    return console.error("TODO: unpack2x16float"), null;
  }
  StorageBarrier(e, t) {
    return null;
  }
  TextureBarrier(e, t) {
    return null;
  }
  WorkgroupBarrier(e, t) {
    return null;
  }
  WorkgroupUniformLoad(e, t) {
    return null;
  }
  SubgroupAdd(e, t) {
    return console.error("TODO: subgroupAdd"), null;
  }
  SubgroupExclusiveAdd(e, t) {
    return console.error("TODO: subgroupExclusiveAdd"), null;
  }
  SubgroupInclusiveAdd(e, t) {
    return console.error("TODO: subgroupInclusiveAdd"), null;
  }
  SubgroupAll(e, t) {
    return console.error("TODO: subgroupAll"), null;
  }
  SubgroupAnd(e, t) {
    return console.error("TODO: subgroupAnd"), null;
  }
  SubgroupAny(e, t) {
    return console.error("TODO: subgroupAny"), null;
  }
  SubgroupBallot(e, t) {
    return console.error("TODO: subgroupBallot"), null;
  }
  SubgroupBroadcast(e, t) {
    return console.error("TODO: subgroupBroadcast"), null;
  }
  SubgroupBroadcastFirst(e, t) {
    return console.error("TODO: subgroupBroadcastFirst"), null;
  }
  SubgroupElect(e, t) {
    return console.error("TODO: subgroupElect"), null;
  }
  SubgroupMax(e, t) {
    return console.error("TODO: subgroupMax"), null;
  }
  SubgroupMin(e, t) {
    return console.error("TODO: subgroupMin"), null;
  }
  SubgroupMul(e, t) {
    return console.error("TODO: subgroupMul"), null;
  }
  SubgroupExclusiveMul(e, t) {
    return console.error("TODO: subgroupExclusiveMul"), null;
  }
  SubgroupInclusiveMul(e, t) {
    return console.error("TODO: subgroupInclusiveMul"), null;
  }
  SubgroupOr(e, t) {
    return console.error("TODO: subgroupOr"), null;
  }
  SubgroupShuffle(e, t) {
    return console.error("TODO: subgroupShuffle"), null;
  }
  SubgroupShuffleDown(e, t) {
    return console.error("TODO: subgroupShuffleDown"), null;
  }
  SubgroupShuffleUp(e, t) {
    return console.error("TODO: subgroupShuffleUp"), null;
  }
  SubgroupShuffleXor(e, t) {
    return console.error("TODO: subgroupShuffleXor"), null;
  }
  SubgroupXor(e, t) {
    return console.error("TODO: subgroupXor"), null;
  }
  QuadBroadcast(e, t) {
    return console.error("TODO: quadBroadcast"), null;
  }
  QuadSwapDiagonal(e, t) {
    return console.error("TODO: quadSwapDiagonal"), null;
  }
  QuadSwapX(e, t) {
    return console.error("TODO: quadSwapX"), null;
  }
  QuadSwapY(e, t) {
    return console.error("TODO: quadSwapY"), null;
  }
}
const Cv = { vec2: 2, vec2f: 2, vec2i: 2, vec2u: 2, vec2b: 2, vec2h: 2, vec3: 3, vec3f: 3, vec3i: 3, vec3u: 3, vec3b: 3, vec3h: 3, vec4: 4, vec4f: 4, vec4i: 4, vec4u: 4, vec4b: 4, vec4h: 4 }, Oo = { mat2x2: [2, 2, 4], mat2x2f: [2, 2, 4], mat2x2h: [2, 2, 4], mat2x3: [2, 3, 6], mat2x3f: [2, 3, 6], mat2x3h: [2, 3, 6], mat2x4: [2, 4, 8], mat2x4f: [2, 4, 8], mat2x4h: [2, 4, 8], mat3x2: [3, 2, 6], mat3x2f: [3, 2, 6], mat3x2h: [3, 2, 6], mat3x3: [3, 3, 9], mat3x3f: [3, 3, 9], mat3x3h: [3, 3, 9], mat3x4: [3, 4, 12], mat3x4f: [3, 4, 12], mat3x4h: [3, 4, 12], mat4x2: [4, 2, 8], mat4x2f: [4, 2, 8], mat4x2h: [4, 2, 8], mat4x3: [4, 3, 12], mat4x3f: [4, 3, 12], mat4x3h: [4, 3, 12], mat4x4: [4, 4, 16], mat4x4f: [4, 4, 16], mat4x4h: [4, 4, 16] };
class Ao extends z7 {
  constructor(e, t) {
    var n;
    super(), this.ast = e ?? [], this.reflection = new nc(), this.reflection.updateAST(this.ast), this.context = (n = t?.clone()) !== null && n !== void 0 ? n : new Cx(), this.builtins = new V7(this), this.typeInfo = { bool: this.getTypeInfo($t.bool), i32: this.getTypeInfo($t.i32), u32: this.getTypeInfo($t.u32), f32: this.getTypeInfo($t.f32), f16: this.getTypeInfo($t.f16), vec2f: this.getTypeInfo(mt.vec2f), vec2u: this.getTypeInfo(mt.vec2u), vec2i: this.getTypeInfo(mt.vec2i), vec2h: this.getTypeInfo(mt.vec2h), vec3f: this.getTypeInfo(mt.vec3f), vec3u: this.getTypeInfo(mt.vec3u), vec3i: this.getTypeInfo(mt.vec3i), vec3h: this.getTypeInfo(mt.vec3h), vec4f: this.getTypeInfo(mt.vec4f), vec4u: this.getTypeInfo(mt.vec4u), vec4i: this.getTypeInfo(mt.vec4i), vec4h: this.getTypeInfo(mt.vec4h), mat2x2f: this.getTypeInfo(mt.mat2x2f), mat2x3f: this.getTypeInfo(mt.mat2x3f), mat2x4f: this.getTypeInfo(mt.mat2x4f), mat3x2f: this.getTypeInfo(mt.mat3x2f), mat3x3f: this.getTypeInfo(mt.mat3x3f), mat3x4f: this.getTypeInfo(mt.mat3x4f), mat4x2f: this.getTypeInfo(mt.mat4x2f), mat4x3f: this.getTypeInfo(mt.mat4x3f), mat4x4f: this.getTypeInfo(mt.mat4x4f) };
  }
  getVariableValue(e) {
    var t, n;
    const i = (n = (t = this.context.getVariable(e)) === null || t === void 0 ? void 0 : t.value) !== null && n !== void 0 ? n : null;
    if (i === null) return null;
    if (i instanceof ut) return i.value;
    if (i instanceof qe || i instanceof ln) return Array.from(i.data);
    if (i instanceof Ji && i.typeInfo instanceof $u) {
      if (i.typeInfo.format.name === "u32") return Array.from(new Uint32Array(i.buffer, i.offset, i.typeInfo.count));
      if (i.typeInfo.format.name === "i32") return Array.from(new Int32Array(i.buffer, i.offset, i.typeInfo.count));
      if (i.typeInfo.format.name === "f32") return Array.from(new Float32Array(i.buffer, i.offset, i.typeInfo.count));
    }
    return console.error(`Unsupported return variable type ${i.typeInfo.name}`), null;
  }
  execute(e) {
    (e = e ?? {}).constants && this._setOverrides(e.constants, this.context), this._execStatements(this.ast, this.context);
  }
  dispatchWorkgroups(e, t, n, i) {
    const s = this.context.clone();
    (i = i ?? {}).constants && this._setOverrides(i.constants, s), this._execStatements(this.ast, s);
    const o = s.getFunction(e);
    if (!o) return void console.error(`Function ${e} not found`);
    if (typeof t == "number") t = [t, 1, 1];
    else {
      if (t.length === 0) return void console.error("Invalid dispatch count");
      t.length === 1 ? t = [t[0], 1, 1] : t.length === 2 ? t = [t[0], t[1], 1] : t.length > 3 && (t = [t[0], t[1], t[2]]);
    }
    const l = t[0], u = t[1], m = t[2], y = this.getTypeInfo("vec3u");
    s.setVariable("@num_workgroups", new qe(t, y));
    const E = this.reflection.getFunctionInfo(e);
    E === null && console.error(`Function ${e} not found in reflection data`);
    for (const P in n) for (const L in n[P]) {
      const U = n[P][L];
      s.variables.forEach((V) => {
        var q;
        const j = V.node;
        if (j?.attributes) {
          let K = null, Y = null;
          for (const de of j.attributes) de.name === "binding" ? K = de.value : de.name === "group" && (Y = de.value);
          if (L == K && P == Y) {
            let de = !1;
            for (const ne of E.resources) if (ne.name === V.name && ne.group === parseInt(P) && ne.binding === parseInt(L)) {
              de = !0;
              break;
            }
            if (de) if (U.texture !== void 0 && U.descriptor !== void 0) {
              const ne = new Hc(U.texture, this.getTypeInfo(j.type), U.descriptor, (q = U.texture.view) !== null && q !== void 0 ? q : null);
              V.value = ne;
            } else U.uniform !== void 0 ? V.value = new Ji(U.uniform, this.getTypeInfo(j.type)) : V.value = new Ji(U, this.getTypeInfo(j.type));
          }
        }
      });
    }
    for (let P = 0; P < m; ++P) for (let L = 0; L < u; ++L) for (let U = 0; U < l; ++U) s.setVariable("@workgroup_id", new qe([U, L, P], this.getTypeInfo("vec3u"))), this._dispatchWorkgroup(o, [U, L, P], s);
  }
  execStatement(e, t) {
    if (e instanceof rO) return this.evalExpression(e.value, t);
    if (e instanceof iO) {
      if (e.condition) {
        const n = this.evalExpression(e.condition, t);
        if (!(n instanceof ut)) throw new Error("Invalid break-if condition");
        if (!n.value) return null;
      }
      return Ao._breakObj;
    }
    if (e instanceof sO) return Ao._continueObj;
    if (e instanceof UA) this._let(e, t);
    else if (e instanceof Gc) this._var(e, t);
    else if (e instanceof mm) this._const(e, t);
    else if (e instanceof t0) this._function(e, t);
    else {
      if (e instanceof tO) return this._if(e, t);
      if (e instanceof eO) return this._switch(e, t);
      if (e instanceof YB) return this._for(e, t);
      if (e instanceof ZB) return this._while(e, t);
      if (e instanceof JB) return this._loop(e, t);
      if (e instanceof Sb) {
        const n = t.clone();
        return n.currentFunctionName = t.currentFunctionName, this._execStatements(e.body, n);
      }
      if (e instanceof QB) this._assign(e, t);
      else if (e instanceof KB) this._increment(e, t);
      else {
        if (e instanceof jc) return null;
        if (e instanceof yx) {
          const n = e.name;
          t.getVariable(n) === null && t.setVariable(n, new ut(0, this.getTypeInfo("u32")));
        } else if (e instanceof vx) this._call(e, t);
        else {
          if (e instanceof nO || e instanceof bx) return null;
          console.error("Invalid statement type.", e, `Line ${e.line}`);
        }
      }
    }
    return null;
  }
  evalExpression(e, t) {
    return e instanceof ol ? this._evalBinaryOp(e, t) : e instanceof Es ? this._evalLiteral(e, t) : e instanceof ua ? this._evalVariable(e, t) : e instanceof xx ? this._evalCall(e, t) : e instanceof ec ? this._evalCreate(e, t) : e instanceof oO ? this._evalConst(e, t) : e instanceof aO ? this._evalBitcast(e, t) : e instanceof hs ? this._evalUnaryOp(e, t) : (console.error("Invalid expression type", e, `Line ${e.line}`), null);
  }
  getTypeInfo(e) {
    var t;
    if (e instanceof $t) {
      const i = this.reflection.getTypeInfo(e);
      if (i !== null) return i;
    }
    let n = (t = this.typeInfo[e]) !== null && t !== void 0 ? t : null;
    return n !== null || (n = this.reflection.getTypeInfoByName(e)), n;
  }
  _setOverrides(e, t) {
    for (const n in e) {
      const i = e[n], s = this.reflection.getOverrideInfo(n);
      s !== null ? (s.type === null && (s.type = this.getTypeInfo("u32")), s.type.name === "u32" || s.type.name === "i32" || s.type.name === "f32" || s.type.name === "f16" ? t.setVariable(n, new ut(i, s.type)) : s.type.name === "bool" ? t.setVariable(n, new ut(i ? 1 : 0, s.type)) : s.type.name === "vec2" || s.type.name === "vec3" || s.type.name === "vec4" || s.type.name === "vec2f" || s.type.name === "vec3f" || s.type.name === "vec4f" || s.type.name === "vec2i" || s.type.name === "vec3i" || s.type.name === "vec4i" || s.type.name === "vec2u" || s.type.name === "vec3u" || s.type.name === "vec4u" || s.type.name === "vec2h" || s.type.name === "vec3h" || s.type.name === "vec4h" ? t.setVariable(n, new qe(i, s.type)) : console.error(`Invalid constant type for ${n}`)) : console.error(`Override ${n} does not exist in the shader.`);
    }
  }
  _dispatchWorkgroup(e, t, n) {
    const i = [1, 1, 1];
    for (const y of e.node.attributes) if (y.name === "workgroup_size") {
      if (y.value.length > 0) {
        const E = n.getVariableValue(y.value[0]);
        i[0] = E instanceof ut ? E.value : parseInt(y.value[0]);
      }
      if (y.value.length > 1) {
        const E = n.getVariableValue(y.value[1]);
        i[1] = E instanceof ut ? E.value : parseInt(y.value[1]);
      }
      if (y.value.length > 2) {
        const E = n.getVariableValue(y.value[2]);
        i[2] = E instanceof ut ? E.value : parseInt(y.value[2]);
      }
    }
    const s = this.getTypeInfo("vec3u"), o = this.getTypeInfo("u32");
    n.setVariable("@workgroup_size", new qe(i, s));
    const l = i[0], u = i[1], m = i[2];
    for (let y = 0, E = 0; y < m; ++y) for (let P = 0; P < u; ++P) for (let L = 0; L < l; ++L, ++E) {
      const U = [L, P, y], V = [L + t[0] * i[0], P + t[1] * i[1], y + t[2] * i[2]];
      n.setVariable("@local_invocation_id", new qe(U, s)), n.setVariable("@global_invocation_id", new qe(V, s)), n.setVariable("@local_invocation_index", new ut(E, o)), this._dispatchExec(e, n);
    }
  }
  _dispatchExec(e, t) {
    for (const n of e.node.args) for (const i of n.attributes) if (i.name === "builtin") {
      const s = `@${i.value}`, o = t.getVariable(s);
      o !== void 0 && t.variables.set(n.name, o);
    }
    this._execStatements(e.node.body, t);
  }
  getVariableName(e, t) {
    for (; e instanceof hs; ) e = e.right;
    return e instanceof ua ? e.name : (console.error("Unknown variable type", e, "Line", e.line), null);
  }
  _execStatements(e, t) {
    for (const n of e) {
      if (n instanceof Array) {
        const s = t.clone(), o = this._execStatements(n, s);
        if (o) return o;
        continue;
      }
      const i = this.execStatement(n, t);
      if (i) return i;
    }
    return null;
  }
  _call(e, t) {
    const n = t.clone();
    n.currentFunctionName = e.name;
    const i = t.getFunction(e.name);
    if (i) {
      for (let s = 0; s < i.node.args.length; ++s) {
        const o = i.node.args[s], l = this.evalExpression(e.args[s], n);
        n.setVariable(o.name, l, o);
      }
      this._execStatements(i.node.body, n);
    } else e.isBuiltin ? this._callBuiltinFunction(e, n) : this.getTypeInfo(e.name) && this._evalCreate(e, t);
  }
  _increment(e, t) {
    const n = this.getVariableName(e.variable, t), i = t.getVariable(n);
    i ? e.operator === "++" ? i.value instanceof ut ? i.value.value++ : console.error(`Variable ${n} is not a scalar. Line ${e.line}`) : e.operator === "--" ? i.value instanceof ut ? i.value.value-- : console.error(`Variable ${n} is not a scalar. Line ${e.line}`) : console.error(`Unknown increment operator ${e.operator}. Line ${e.line}`) : console.error(`Variable ${n} not found. Line ${e.line}`);
  }
  _getVariableData(e, t) {
    if (e instanceof ua) {
      const n = this.getVariableName(e, t), i = t.getVariable(n);
      return i === null ? (console.error(`Variable ${n} not found. Line ${e.line}`), null) : i.value.getSubData(this, e.postfix, t);
    }
    if (e instanceof hs) {
      if (e.operator === "*") {
        const n = this._getVariableData(e.right, t);
        return n instanceof yd ? n.reference.getSubData(this, e.postfix, t) : (console.error(`Variable ${e.right} is not a pointer. Line ${e.line}`), null);
      }
      if (e.operator === "&") {
        const n = this._getVariableData(e.right, t);
        return new yd(n);
      }
    }
    return null;
  }
  _assign(e, t) {
    let n = null, i = "<var>", s = null;
    if (e.variable instanceof hs) {
      const u = this._getVariableData(e.variable, t), m = this.evalExpression(e.value, t), y = e.operator;
      if (y === "=") {
        if (u instanceof ut || u instanceof qe || u instanceof ln) {
          if (m instanceof ut || m instanceof qe || m instanceof ln && u.data.length === m.data.length) return void u.data.set(m.data);
          console.error(`Invalid assignment. Line ${e.line}`);
        } else if (u instanceof Ji && m instanceof Ji && u.buffer.byteLength - u.offset >= m.buffer.byteLength - m.offset) return void (u.buffer.byteLength % 4 == 0 ? new Uint32Array(u.buffer, u.offset, u.typeInfo.size / 4).set(new Uint32Array(m.buffer, m.offset, m.typeInfo.size / 4)) : new Uint8Array(u.buffer, u.offset, u.typeInfo.size).set(new Uint8Array(m.buffer, m.offset, m.typeInfo.size)));
        return console.error(`Invalid assignment. Line ${e.line}`), null;
      }
      if (y === "+=") return u instanceof ut || u instanceof qe || u instanceof ln ? m instanceof ut || m instanceof qe || m instanceof ln ? void u.data.set(m.data.map((E, P) => u.data[P] + E)) : void console.error(`Invalid assignment . Line ${e.line}`) : void console.error(`Invalid assignment. Line ${e.line}`);
      if (y === "-=") return (u instanceof ut || u instanceof qe || u instanceof ln) && (m instanceof ut || m instanceof qe || m instanceof ln) ? void u.data.set(m.data.map((E, P) => u.data[P] - E)) : void console.error(`Invalid assignment. Line ${e.line}`);
    }
    if (e.variable instanceof hs) {
      if (e.variable.operator === "*") {
        i = this.getVariableName(e.variable.right, t);
        const u = t.getVariable(i);
        if (!(u && u.value instanceof yd)) return void console.error(`Variable ${i} is not a pointer. Line ${e.line}`);
        n = u.value.reference;
        let m = e.variable.postfix;
        if (!m) {
          let y = e.variable.right;
          for (; y instanceof hs; ) {
            if (y.postfix) {
              m = y.postfix;
              break;
            }
            y = y.right;
          }
        }
        m && (n = n.getSubData(this, m, t));
      }
    } else {
      s = e.variable.postfix, i = this.getVariableName(e.variable, t);
      const u = t.getVariable(i);
      if (u === null) return void console.error(`Variable ${i} not found. Line ${e.line}`);
      n = u.value;
    }
    if (n instanceof yd && (n = n.reference), n === null) return void console.error(`Variable ${i} not found. Line ${e.line}`);
    const o = this.evalExpression(e.value, t), l = e.operator;
    if (l !== "=") {
      const u = n.getSubData(this, s, t);
      if (u instanceof qe && o instanceof ut) {
        const m = u.data, y = o.value;
        if (l === "+=") for (let E = 0; E < m.length; ++E) m[E] += y;
        else if (l === "-=") for (let E = 0; E < m.length; ++E) m[E] -= y;
        else if (l === "*=") for (let E = 0; E < m.length; ++E) m[E] *= y;
        else if (l === "/=") for (let E = 0; E < m.length; ++E) m[E] /= y;
        else if (l === "%=") for (let E = 0; E < m.length; ++E) m[E] %= y;
        else if (l === "&=") for (let E = 0; E < m.length; ++E) m[E] &= y;
        else if (l === "|=") for (let E = 0; E < m.length; ++E) m[E] |= y;
        else if (l === "^=") for (let E = 0; E < m.length; ++E) m[E] ^= y;
        else if (l === "<<=") for (let E = 0; E < m.length; ++E) m[E] <<= y;
        else if (l === ">>=") for (let E = 0; E < m.length; ++E) m[E] >>= y;
        else console.error(`Invalid operator ${l}. Line ${e.line}`);
      } else if (u instanceof qe && o instanceof qe) {
        const m = u.data, y = o.data;
        if (m.length !== y.length) return void console.error(`Vector length mismatch. Line ${e.line}`);
        if (l === "+=") for (let E = 0; E < m.length; ++E) m[E] += y[E];
        else if (l === "-=") for (let E = 0; E < m.length; ++E) m[E] -= y[E];
        else if (l === "*=") for (let E = 0; E < m.length; ++E) m[E] *= y[E];
        else if (l === "/=") for (let E = 0; E < m.length; ++E) m[E] /= y[E];
        else if (l === "%=") for (let E = 0; E < m.length; ++E) m[E] %= y[E];
        else if (l === "&=") for (let E = 0; E < m.length; ++E) m[E] &= y[E];
        else if (l === "|=") for (let E = 0; E < m.length; ++E) m[E] |= y[E];
        else if (l === "^=") for (let E = 0; E < m.length; ++E) m[E] ^= y[E];
        else if (l === "<<=") for (let E = 0; E < m.length; ++E) m[E] <<= y[E];
        else if (l === ">>=") for (let E = 0; E < m.length; ++E) m[E] >>= y[E];
        else console.error(`Invalid operator ${l}. Line ${e.line}`);
      } else {
        if (!(u instanceof ut && o instanceof ut)) return void console.error(`Invalid type for ${e.operator} operator. Line ${e.line}`);
        l === "+=" ? u.value += o.value : l === "-=" ? u.value -= o.value : l === "*=" ? u.value *= o.value : l === "/=" ? u.value /= o.value : l === "%=" ? u.value %= o.value : l === "&=" ? u.value &= o.value : l === "|=" ? u.value |= o.value : l === "^=" ? u.value ^= o.value : l === "<<=" ? u.value <<= o.value : l === ">>=" ? u.value >>= o.value : console.error(`Invalid operator ${l}. Line ${e.line}`);
      }
      return void (n instanceof Ji && n.setDataValue(this, u, s, t));
    }
    if (n instanceof Ji) n.setDataValue(this, o, s, t);
    else if (s) {
      if (!(n instanceof qe || n instanceof ln)) return void console.error(`Variable ${i} is not a vector or matrix. Line ${e.line}`);
      if (s instanceof mp) {
        const u = this.evalExpression(s.index, t).value;
        if (n instanceof qe) {
          if (!(o instanceof ut)) return void console.error(`Invalid assignment to ${i}. Line ${e.line}`);
          n.data[u] = o.value;
        } else {
          if (!(n instanceof ln)) return void console.error(`Invalid assignment to ${i}. Line ${e.line}`);
          {
            const m = this.evalExpression(s.index, t).value;
            if (m < 0) return void console.error(`Invalid assignment to ${i}. Line ${e.line}`);
            if (!(o instanceof qe)) return void console.error(`Invalid assignment to ${i}. Line ${e.line}`);
            {
              const y = n.typeInfo.getTypeName();
              if (y === "mat2x2" || y === "mat2x2f" || y === "mat2x2h") {
                if (!(m < 2 && o.data.length === 2)) return void console.error(`Invalid assignment to ${i}. Line ${e.line}`);
                n.data[2 * m] = o.data[0], n.data[2 * m + 1] = o.data[1];
              } else if (y === "mat2x3" || y === "mat2x3f" || y === "mat2x3h") {
                if (!(m < 2 && o.data.length === 3)) return void console.error(`Invalid assignment to ${i}. Line ${e.line}`);
                n.data[3 * m] = o.data[0], n.data[3 * m + 1] = o.data[1], n.data[3 * m + 2] = o.data[2];
              } else if (y === "mat2x4" || y === "mat2x4f" || y === "mat2x4h") {
                if (!(m < 2 && o.data.length === 4)) return void console.error(`Invalid assignment to ${i}. Line ${e.line}`);
                n.data[4 * m] = o.data[0], n.data[4 * m + 1] = o.data[1], n.data[4 * m + 2] = o.data[2], n.data[4 * m + 3] = o.data[3];
              } else if (y === "mat3x2" || y === "mat3x2f" || y === "mat3x2h") {
                if (!(m < 3 && o.data.length === 2)) return void console.error(`Invalid assignment to ${i}. Line ${e.line}`);
                n.data[2 * m] = o.data[0], n.data[2 * m + 1] = o.data[1];
              } else if (y === "mat3x3" || y === "mat3x3f" || y === "mat3x3h") {
                if (!(m < 3 && o.data.length === 3)) return void console.error(`Invalid assignment to ${i}. Line ${e.line}`);
                n.data[3 * m] = o.data[0], n.data[3 * m + 1] = o.data[1], n.data[3 * m + 2] = o.data[2];
              } else if (y === "mat3x4" || y === "mat3x4f" || y === "mat3x4h") {
                if (!(m < 3 && o.data.length === 4)) return void console.error(`Invalid assignment to ${i}. Line ${e.line}`);
                n.data[4 * m] = o.data[0], n.data[4 * m + 1] = o.data[1], n.data[4 * m + 2] = o.data[2], n.data[4 * m + 3] = o.data[3];
              } else if (y === "mat4x2" || y === "mat4x2f" || y === "mat4x2h") {
                if (!(m < 4 && o.data.length === 2)) return void console.error(`Invalid assignment to ${i}. Line ${e.line}`);
                n.data[2 * m] = o.data[0], n.data[2 * m + 1] = o.data[1];
              } else if (y === "mat4x3" || y === "mat4x3f" || y === "mat4x3h") {
                if (!(m < 4 && o.data.length === 3)) return void console.error(`Invalid assignment to ${i}. Line ${e.line}`);
                n.data[3 * m] = o.data[0], n.data[3 * m + 1] = o.data[1], n.data[3 * m + 2] = o.data[2];
              } else {
                if (y !== "mat4x4" && y !== "mat4x4f" && y !== "mat4x4h") return void console.error(`Invalid assignment to ${i}. Line ${e.line}`);
                if (!(m < 4 && o.data.length === 4)) return void console.error(`Invalid assignment to ${i}. Line ${e.line}`);
                n.data[4 * m] = o.data[0], n.data[4 * m + 1] = o.data[1], n.data[4 * m + 2] = o.data[2], n.data[4 * m + 3] = o.data[3];
              }
            }
          }
        }
      } else if (s instanceof nh) {
        const u = s.value;
        if (!(n instanceof qe)) return void console.error(`Invalid assignment to ${u}. Variable ${i} is not a vector. Line ${e.line}`);
        if (o instanceof ut) {
          if (u.length > 1) return void console.error(`Invalid assignment to ${u} for variable ${i}. Line ${e.line}`);
          if (u === "x") n.data[0] = o.value;
          else if (u === "y") {
            if (n.data.length < 2) return void console.error(`Invalid assignment to ${u} for variable ${i}. Line ${e.line}`);
            n.data[1] = o.value;
          } else if (u === "z") {
            if (n.data.length < 3) return void console.error(`Invalid assignment to ${u} for variable ${i}. Line ${e.line}`);
            n.data[2] = o.value;
          } else if (u === "w") {
            if (n.data.length < 4) return void console.error(`Invalid assignment to ${u} for variable ${i}. Line ${e.line}`);
            n.data[3] = o.value;
          }
        } else {
          if (!(o instanceof qe)) return void console.error(`Invalid assignment to ${i}. Line ${e.line}`);
          if (u.length !== o.data.length) return void console.error(`Invalid assignment to ${u} for variable ${i}. Line ${e.line}`);
          for (let m = 0; m < u.length; ++m) {
            const y = u[m];
            if (y === "x" || y === "r") n.data[0] = o.data[m];
            else if (y === "y" || y === "g") {
              if (o.data.length < 2) return void console.error(`Invalid assignment to ${y} for variable ${i}. Line ${e.line}`);
              n.data[1] = o.data[m];
            } else if (y === "z" || y === "b") {
              if (o.data.length < 3) return void console.error(`Invalid assignment to ${y} for variable ${i}. Line ${e.line}`);
              n.data[2] = o.data[m];
            } else {
              if (y !== "w" && y !== "a") return void console.error(`Invalid assignment to ${y} for variable ${i}. Line ${e.line}`);
              if (o.data.length < 4) return void console.error(`Invalid assignment to ${y} for variable ${i}. Line ${e.line}`);
              n.data[3] = o.data[m];
            }
          }
        }
      }
    } else n instanceof ut && o instanceof ut ? n.value = o.value : n instanceof qe && o instanceof qe || n instanceof ln && o instanceof ln ? n.data.set(o.data) : console.error(`Invalid assignment to ${i}. Line ${e.line}`);
  }
  _function(e, t) {
    const n = new Ex(e);
    t.functions.set(e.name, n);
  }
  _const(e, t) {
    let n = null;
    e.value !== null && (n = this.evalExpression(e.value, t)), t.createVariable(e.name, n, e);
  }
  _let(e, t) {
    let n = null;
    if (e.value !== null) {
      if (n = this.evalExpression(e.value, t), n === null) return void console.error(`Invalid value for variable ${e.name}. Line ${e.line}`);
      e.value instanceof hs || (n = n.clone());
    } else {
      const i = e.type.name;
      if (i === "f32" || i === "i32" || i === "u32" || i === "bool" || i === "f16" || i === "vec2" || i === "vec3" || i === "vec4" || i === "vec2f" || i === "vec3f" || i === "vec4f" || i === "vec2i" || i === "vec3i" || i === "vec4i" || i === "vec2u" || i === "vec3u" || i === "vec4u" || i === "vec2h" || i === "vec3h" || i === "vec4h" || i === "vec2b" || i === "vec3b" || i === "vec4b" || i === "mat2x2" || i === "mat2x3" || i === "mat2x4" || i === "mat3x2" || i === "mat3x3" || i === "mat3x4" || i === "mat4x2" || i === "mat4x3" || i === "mat4x4" || i === "mat2x2f" || i === "mat2x3f" || i === "mat2x4f" || i === "mat3x2f" || i === "mat3x3f" || i === "mat3x4f" || i === "mat4x2f" || i === "mat4x3f" || i === "mat4x4f" || i === "mat2x2h" || i === "mat2x3h" || i === "mat2x4h" || i === "mat3x2h" || i === "mat3x3h" || i === "mat3x4h" || i === "mat4x2h" || i === "mat4x3h" || i === "mat4x4h" || i === "array") {
        const s = new ec(e.type, []);
        n = this._evalCreate(s, t);
      }
    }
    t.createVariable(e.name, n, e);
  }
  _var(e, t) {
    let n = null;
    if (e.value !== null) {
      if (n = this.evalExpression(e.value, t), n === null) return void console.error(`Invalid value for variable ${e.name}. Line ${e.line}`);
      e.value instanceof hs || (n = n.clone());
    } else {
      if (e.type === null) return void console.error(`Variable ${e.name} has no type. Line ${e.line}`);
      const i = e.type.name;
      if (i === "f32" || i === "i32" || i === "u32" || i === "bool" || i === "f16" || i === "vec2" || i === "vec3" || i === "vec4" || i === "vec2f" || i === "vec3f" || i === "vec4f" || i === "vec2i" || i === "vec3i" || i === "vec4i" || i === "vec2u" || i === "vec3u" || i === "vec4u" || i === "vec2h" || i === "vec3h" || i === "vec4h" || i === "vec2b" || i === "vec3b" || i === "vec4b" || i === "mat2x2" || i === "mat2x3" || i === "mat2x4" || i === "mat3x2" || i === "mat3x3" || i === "mat3x4" || i === "mat4x2" || i === "mat4x3" || i === "mat4x4" || i === "mat2x2f" || i === "mat2x3f" || i === "mat2x4f" || i === "mat3x2f" || i === "mat3x3f" || i === "mat3x4f" || i === "mat4x2f" || i === "mat4x3f" || i === "mat4x4f" || i === "mat2x2h" || i === "mat2x3h" || i === "mat2x4h" || i === "mat3x2h" || i === "mat3x3h" || i === "mat3x4h" || i === "mat4x2h" || i === "mat4x3h" || i === "mat4x4h" || e.type instanceof zA || e.type instanceof jc || e.type instanceof mt) {
        const s = new ec(e.type, []);
        n = this._evalCreate(s, t);
      }
    }
    t.createVariable(e.name, n, e);
  }
  _switch(e, t) {
    t = t.clone();
    const n = this.evalExpression(e.condition, t);
    if (!(n instanceof ut)) return console.error(`Invalid if condition. Line ${e.line}`), null;
    let i = null;
    for (const s of e.cases) if (s instanceof uO) for (const o of s.selectors) {
      if (o instanceof ym) {
        i = s;
        continue;
      }
      const l = this.evalExpression(o, t);
      if (!(l instanceof ut)) return console.error(`Invalid case selector. Line ${e.line}`), null;
      if (l.value === n.value) return this._execStatements(s.body, t);
    }
    else s instanceof fO && (i = s);
    return i ? this._execStatements(i.body, t) : null;
  }
  _if(e, t) {
    t = t.clone();
    const n = this.evalExpression(e.condition, t);
    if (!(n instanceof ut)) return console.error(`Invalid if condition. Line ${e.line}`), null;
    if (n.value) return this._execStatements(e.body, t);
    for (const i of e.elseif) {
      const s = this.evalExpression(i.condition, t);
      if (!(s instanceof ut)) return console.error(`Invalid if condition. Line ${e.line}`), null;
      if (s.value) return this._execStatements(i.body, t);
    }
    return e.else ? this._execStatements(e.else, t) : null;
  }
  _getScalarValue(e) {
    return e instanceof ut ? e.value : (console.error("Expected scalar value.", e), 0);
  }
  _for(e, t) {
    for (t = t.clone(), this.execStatement(e.init, t); this._getScalarValue(this.evalExpression(e.condition, t)); ) {
      const n = this._execStatements(e.body, t);
      if (n === Ao._breakObj) break;
      if (n !== null && n !== Ao._continueObj) return n;
      this.execStatement(e.increment, t);
    }
    return null;
  }
  _loop(e, t) {
    for (t = t.clone(); ; ) {
      const n = this._execStatements(e.body, t);
      if (n === Ao._breakObj) break;
      if (n === Ao._continueObj) {
        if (e.continuing && this._execStatements(e.continuing.body, t) === Ao._breakObj)
          break;
      } else if (n !== null) return n;
    }
    return null;
  }
  _while(e, t) {
    for (t = t.clone(); this._getScalarValue(this.evalExpression(e.condition, t)); ) {
      const n = this._execStatements(e.body, t);
      if (n === Ao._breakObj) break;
      if (n !== Ao._continueObj && n !== null) return n;
    }
    return null;
  }
  _evalBitcast(e, t) {
    const n = this.evalExpression(e.value, t), i = e.type;
    if (n instanceof ut) {
      const s = eC(n.value, n.typeInfo.name, i.name);
      return new ut(s, this.getTypeInfo(i));
    }
    if (n instanceof qe) {
      const s = n.typeInfo.getTypeName();
      let o = "";
      if (s.endsWith("f")) o = "f32";
      else if (s.endsWith("i")) o = "i32";
      else if (s.endsWith("u")) o = "u32";
      else if (s.endsWith("b")) o = "bool";
      else {
        if (!s.endsWith("h")) return console.error(`Unknown vector type ${s}. Line ${e.line}`), null;
        o = "f16";
      }
      const l = i.getTypeName();
      let u = "";
      if (l.endsWith("f")) u = "f32";
      else if (l.endsWith("i")) u = "i32";
      else if (l.endsWith("u")) u = "u32";
      else if (l.endsWith("b")) u = "bool";
      else {
        if (!l.endsWith("h")) return console.error(`Unknown vector type ${u}. Line ${e.line}`), null;
        u = "f16";
      }
      const m = (function(y, E, P) {
        if (E === P) return y;
        const L = new Array(y.length);
        for (let U = 0; U < y.length; U++) L[U] = eC(y[U], E, P);
        return L;
      })(Array.from(n.data), o, u);
      return new qe(m, this.getTypeInfo(i));
    }
    return console.error(`TODO: bitcast for ${n.typeInfo.name}. Line ${e.line}`), null;
  }
  _evalConst(e, t) {
    return t.getVariableValue(e.name).clone().getSubData(this, e.postfix, t);
  }
  _evalCreate(e, t) {
    var n;
    if (e instanceof ec) {
      if (e.type === null) return Ib.void;
      switch (e.type.getTypeName()) {
        case "bool":
        case "i32":
        case "u32":
        case "f32":
        case "f16":
          return this._callConstructorValue(e, t);
        case "vec2":
        case "vec3":
        case "vec4":
        case "vec2f":
        case "vec3f":
        case "vec4f":
        case "vec2h":
        case "vec3h":
        case "vec4h":
        case "vec2i":
        case "vec3i":
        case "vec4i":
        case "vec2u":
        case "vec3u":
        case "vec4u":
        case "vec2b":
        case "vec3b":
        case "vec4b":
          return this._callConstructorVec(e, t);
        case "mat2x2":
        case "mat2x2f":
        case "mat2x2h":
        case "mat2x3":
        case "mat2x3f":
        case "mat2x3h":
        case "mat2x4":
        case "mat2x4f":
        case "mat2x4h":
        case "mat3x2":
        case "mat3x2f":
        case "mat3x2h":
        case "mat3x3":
        case "mat3x3f":
        case "mat3x3h":
        case "mat3x4":
        case "mat3x4f":
        case "mat3x4h":
        case "mat4x2":
        case "mat4x2f":
        case "mat4x2h":
        case "mat4x3":
        case "mat4x3f":
        case "mat4x3h":
        case "mat4x4":
        case "mat4x4f":
        case "mat4x4h":
          return this._callConstructorMatrix(e, t);
      }
    }
    const i = e instanceof ec ? e.type.name : e.name, s = e instanceof ec ? this.getTypeInfo(e.type) : this.getTypeInfo(e.name);
    if (s === null) return console.error(`Unknown type ${i}. Line ${e.line}`), null;
    if (s.size === 0) return null;
    const o = new Ji(new ArrayBuffer(s.size), s, 0);
    if (s instanceof ju) {
      if (e.args) for (let l = 0; l < e.args.length; ++l) {
        const u = s.members[l], m = e.args[l], y = this.evalExpression(m, t);
        o.setData(this, y, u.type, u.offset, t);
      }
    } else if (s instanceof $u) {
      let l = 0;
      if (e.args) for (let u = 0; u < e.args.length; ++u) {
        const m = e.args[u], y = this.evalExpression(m, t);
        s.format === null && (((n = y.typeInfo) === null || n === void 0 ? void 0 : n.name) === "x32" ? s.format = this.getTypeInfo("i32") : s.format = y.typeInfo), o.setData(this, y, s.format, l, t), l += s.stride;
      }
    } else console.error(`Unknown type "${i}". Line ${e.line}`);
    return e instanceof ec ? o.getSubData(this, e.postfix, t) : o;
  }
  _evalLiteral(e, t) {
    const n = this.getTypeInfo(e.type), i = n.name;
    return i === "x32" || i === "u32" || i === "f32" || i === "f16" || i === "i32" || i === "bool" ? new ut(e.scalarValue, n) : i === "vec2" || i === "vec3" || i === "vec4" || i === "vec2f" || i === "vec3f" || i === "vec4f" || i === "vec2h" || i === "vec3h" || i === "vec4h" || i === "vec2i" || i === "vec3i" || i === "vec4i" || i === "vec2u" || i === "vec3u" || i === "vec4u" ? this._callConstructorVec(e, t) : i === "mat2x2" || i === "mat2x3" || i === "mat2x4" || i === "mat3x2" || i === "mat3x3" || i === "mat3x4" || i === "mat4x2" || i === "mat4x3" || i === "mat4x4" || i === "mat2x2f" || i === "mat2x3f" || i === "mat2x4f" || i === "mat3x2f" || i === "mat3x3f" || i === "mat3x4f" || i === "mat4x2f" || i === "mat4x3f" || i === "mat4x4f" || i === "mat2x2h" || i === "mat2x3h" || i === "mat2x4h" || i === "mat3x2h" || i === "mat3x3h" || i === "mat3x4h" || i === "mat4x2h" || i === "mat4x3h" || i === "mat4x4h" ? this._callConstructorMatrix(e, t) : e.value;
  }
  _evalVariable(e, t) {
    const n = t.getVariableValue(e.name);
    return n === null ? n : n.getSubData(this, e.postfix, t);
  }
  _maxFormatTypeInfo(e) {
    let t = e[0];
    if (t.name === "f32") return t;
    for (let n = 1; n < e.length; ++n) {
      const i = Ao._priority.get(t.name);
      Ao._priority.get(e[n].name) < i && (t = e[n]);
    }
    return t.name === "x32" ? this.getTypeInfo("i32") : t;
  }
  _evalUnaryOp(e, t) {
    const n = this.evalExpression(e.right, t);
    if (e.operator === "&") return new yd(n);
    if (e.operator === "*") return n instanceof yd ? n.reference.getSubData(this, e.postfix, t) : (console.error(`Invalid dereference. Line ${e.line}`), null);
    const i = n instanceof ut ? n.value : n instanceof qe ? Array.from(n.data) : null;
    switch (e.operator) {
      case "+": {
        if (vr(i)) {
          const l = i.map((u, m) => +u);
          return new qe(l, n.typeInfo);
        }
        const s = i, o = this._maxFormatTypeInfo([n.typeInfo, n.typeInfo]);
        return new ut(+s, o);
      }
      case "-": {
        if (vr(i)) {
          const l = i.map((u, m) => -u);
          return new qe(l, n.typeInfo);
        }
        const s = i, o = this._maxFormatTypeInfo([n.typeInfo, n.typeInfo]);
        return new ut(-s, o);
      }
      case "!": {
        if (vr(i)) {
          const l = i.map((u, m) => u ? 0 : 1);
          return new qe(l, n.typeInfo);
        }
        const s = i, o = this._maxFormatTypeInfo([n.typeInfo, n.typeInfo]);
        return new ut(s ? 0 : 1, o);
      }
      case "~": {
        if (vr(i)) {
          const l = i.map((u, m) => ~u);
          return new qe(l, n.typeInfo);
        }
        const s = i, o = this._maxFormatTypeInfo([n.typeInfo, n.typeInfo]);
        return new ut(~s, o);
      }
    }
    return console.error(`Invalid unary operator ${e.operator}. Line ${e.line}`), null;
  }
  _evalBinaryOp(e, t) {
    const n = this.evalExpression(e.left, t), i = this.evalExpression(e.right, t), s = n instanceof ut ? n.value : n instanceof qe || n instanceof ln ? Array.from(n.data) : null, o = i instanceof ut ? i.value : i instanceof qe || i instanceof ln ? Array.from(i.data) : null;
    switch (e.operator) {
      case "+": {
        if (vr(s) && vr(o)) {
          const y = s, E = o;
          if (y.length !== E.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const P = y.map((L, U) => L + E[U]);
          return new qe(P, n.typeInfo);
        }
        if (vr(s)) {
          const y = o, E = s.map((P, L) => P + y);
          return new qe(E, n.typeInfo);
        }
        if (vr(o)) {
          const y = s, E = o.map((P, L) => y + P);
          return new qe(E, i.typeInfo);
        }
        const l = s, u = o, m = this._maxFormatTypeInfo([n.typeInfo, i.typeInfo]);
        return new ut(l + u, m);
      }
      case "-": {
        if (vr(s) && vr(o)) {
          const y = s, E = o;
          if (y.length !== E.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const P = y.map((L, U) => L - E[U]);
          return new qe(P, n.typeInfo);
        }
        if (vr(s)) {
          const y = o, E = s.map((P, L) => P - y);
          return new qe(E, n.typeInfo);
        }
        if (vr(o)) {
          const y = s, E = o.map((P, L) => y - P);
          return new qe(E, i.typeInfo);
        }
        const l = s, u = o, m = this._maxFormatTypeInfo([n.typeInfo, i.typeInfo]);
        return new ut(l - u, m);
      }
      case "*": {
        if (vr(s) && vr(o)) {
          const y = s, E = o;
          if (n instanceof ln && i instanceof ln) {
            const P = (function(q, j, K, Y) {
              if (Oo[j.name] === void 0 || Oo[Y.name] === void 0) return null;
              const de = Oo[j.name][0], ne = Oo[j.name][1], ae = Oo[Y.name][0];
              if (de !== Oo[Y.name][1]) return null;
              const De = new Array(ae * ne);
              for (let Ge = 0; Ge < ne; Ge++) for (let fe = 0; fe < ae; fe++) {
                let ve = 0;
                for (let me = 0; me < de; me++) ve += q[me * ne + Ge] * K[fe * de + me];
                De[Ge * ae + fe] = ve;
              }
              return De;
            })(y, n.typeInfo, E, i.typeInfo);
            if (P === null) return console.error(`Matrix multiplication failed. Line ${e.line}.`), null;
            const L = Oo[i.typeInfo.name][0], U = Oo[n.typeInfo.name][1], V = this.getTypeInfo(`mat${L}x${U}f`);
            return new ln(P, V);
          }
          if (n instanceof ln && i instanceof qe) {
            const P = (function(L, U, V, q) {
              if (Oo[U.name] === void 0 || Cv[q.name] === void 0) return null;
              const j = Oo[U.name][0], K = Oo[U.name][1];
              if (j !== V.length) return null;
              const Y = new Array(K);
              for (let de = 0; de < K; de++) {
                let ne = 0;
                for (let ae = 0; ae < j; ae++) ne += L[ae * K + de] * V[ae];
                Y[de] = ne;
              }
              return Y;
            })(y, n.typeInfo, E, i.typeInfo);
            return P === null ? (console.error(`Matrix vector multiplication failed. Line ${e.line}.`), null) : new qe(P, i.typeInfo);
          }
          if (n instanceof qe && i instanceof ln) {
            const P = (function(L, U, V, q) {
              if (Cv[U.name] === void 0 || Oo[q.name] === void 0) return null;
              const j = Oo[q.name][0], K = Oo[q.name][1];
              if (K !== L.length) return null;
              const Y = [];
              for (let de = 0; de < j; de++) {
                let ne = 0;
                for (let ae = 0; ae < K; ae++) ne += L[ae] * V[ae * j + de];
                Y[de] = ne;
              }
              return Y;
            })(y, n.typeInfo, E, i.typeInfo);
            return P === null ? (console.error(`Matrix vector multiplication failed. Line ${e.line}.`), null) : new qe(P, n.typeInfo);
          }
          {
            if (y.length !== E.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
            const P = y.map((L, U) => L * E[U]);
            return new qe(P, n.typeInfo);
          }
        }
        if (vr(s)) {
          const y = o, E = s.map((P, L) => P * y);
          return n instanceof ln ? new ln(E, n.typeInfo) : new qe(E, n.typeInfo);
        }
        if (vr(o)) {
          const y = s, E = o.map((P, L) => y * P);
          return i instanceof ln ? new ln(E, i.typeInfo) : new qe(E, i.typeInfo);
        }
        const l = s, u = o, m = this._maxFormatTypeInfo([n.typeInfo, i.typeInfo]);
        return new ut(l * u, m);
      }
      case "%": {
        if (vr(s) && vr(o)) {
          const y = s, E = o;
          if (y.length !== E.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const P = y.map((L, U) => L % E[U]);
          return new qe(P, n.typeInfo);
        }
        if (vr(s)) {
          const y = o, E = s.map((P, L) => P % y);
          return new qe(E, n.typeInfo);
        }
        if (vr(o)) {
          const y = s, E = o.map((P, L) => y % P);
          return new qe(E, i.typeInfo);
        }
        const l = s, u = o, m = this._maxFormatTypeInfo([n.typeInfo, i.typeInfo]);
        return new ut(l % u, m);
      }
      case "/": {
        if (vr(s) && vr(o)) {
          const y = s, E = o;
          if (y.length !== E.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const P = y.map((L, U) => L / E[U]);
          return new qe(P, n.typeInfo);
        }
        if (vr(s)) {
          const y = o, E = s.map((P, L) => P / y);
          return new qe(E, n.typeInfo);
        }
        if (vr(o)) {
          const y = s, E = o.map((P, L) => y / P);
          return new qe(E, i.typeInfo);
        }
        const l = s, u = o, m = this._maxFormatTypeInfo([n.typeInfo, i.typeInfo]);
        return new ut(l / u, m);
      }
      case "&": {
        if (vr(s) && vr(o)) {
          const y = s, E = o;
          if (y.length !== E.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const P = y.map((L, U) => L & E[U]);
          return new qe(P, n.typeInfo);
        }
        if (vr(s)) {
          const y = o, E = s.map((P, L) => P & y);
          return new qe(E, n.typeInfo);
        }
        if (vr(o)) {
          const y = s, E = o.map((P, L) => y & P);
          return new qe(E, i.typeInfo);
        }
        const l = s, u = o, m = this._maxFormatTypeInfo([n.typeInfo, i.typeInfo]);
        return new ut(l & u, m);
      }
      case "|": {
        if (vr(s) && vr(o)) {
          const y = s, E = o;
          if (y.length !== E.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const P = y.map((L, U) => L | E[U]);
          return new qe(P, n.typeInfo);
        }
        if (vr(s)) {
          const y = o, E = s.map((P, L) => P | y);
          return new qe(E, n.typeInfo);
        }
        if (vr(o)) {
          const y = s, E = o.map((P, L) => y | P);
          return new qe(E, i.typeInfo);
        }
        const l = s, u = o, m = this._maxFormatTypeInfo([n.typeInfo, i.typeInfo]);
        return new ut(l | u, m);
      }
      case "^": {
        if (vr(s) && vr(o)) {
          const y = s, E = o;
          if (y.length !== E.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const P = y.map((L, U) => L ^ E[U]);
          return new qe(P, n.typeInfo);
        }
        if (vr(s)) {
          const y = o, E = s.map((P, L) => P ^ y);
          return new qe(E, n.typeInfo);
        }
        if (vr(o)) {
          const y = s, E = o.map((P, L) => y ^ P);
          return new qe(E, i.typeInfo);
        }
        const l = s, u = o, m = this._maxFormatTypeInfo([n.typeInfo, i.typeInfo]);
        return new ut(l ^ u, m);
      }
      case "<<": {
        if (vr(s) && vr(o)) {
          const y = s, E = o;
          if (y.length !== E.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const P = y.map((L, U) => L << E[U]);
          return new qe(P, n.typeInfo);
        }
        if (vr(s)) {
          const y = o, E = s.map((P, L) => P << y);
          return new qe(E, n.typeInfo);
        }
        if (vr(o)) {
          const y = s, E = o.map((P, L) => y << P);
          return new qe(E, i.typeInfo);
        }
        const l = s, u = o, m = this._maxFormatTypeInfo([n.typeInfo, i.typeInfo]);
        return new ut(l << u, m);
      }
      case ">>": {
        if (vr(s) && vr(o)) {
          const y = s, E = o;
          if (y.length !== E.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const P = y.map((L, U) => L >> E[U]);
          return new qe(P, n.typeInfo);
        }
        if (vr(s)) {
          const y = o, E = s.map((P, L) => P >> y);
          return new qe(E, n.typeInfo);
        }
        if (vr(o)) {
          const y = s, E = o.map((P, L) => y >> P);
          return new qe(E, i.typeInfo);
        }
        const l = s, u = o, m = this._maxFormatTypeInfo([n.typeInfo, i.typeInfo]);
        return new ut(l >> u, m);
      }
      case ">":
        if (vr(s) && vr(o)) {
          const l = s, u = o;
          if (l.length !== u.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const m = l.map((y, E) => y > u[E] ? 1 : 0);
          return new qe(m, n.typeInfo);
        }
        if (vr(s)) {
          const l = o, u = s.map((m, y) => m > l ? 1 : 0);
          return new qe(u, n.typeInfo);
        }
        if (vr(o)) {
          const l = s, u = o.map((m, y) => l > m ? 1 : 0);
          return new qe(u, i.typeInfo);
        }
        return new ut(s > o ? 1 : 0, this.getTypeInfo("bool"));
      case "<":
        if (vr(s) && vr(o)) {
          const l = s, u = o;
          if (l.length !== u.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const m = l.map((y, E) => y < u[E] ? 1 : 0);
          return new qe(m, n.typeInfo);
        }
        if (vr(s)) {
          const l = o, u = s.map((m, y) => m < l ? 1 : 0);
          return new qe(u, n.typeInfo);
        }
        if (vr(o)) {
          const l = s, u = o.map((m, y) => l < m ? 1 : 0);
          return new qe(u, i.typeInfo);
        }
        return new ut(s < o ? 1 : 0, this.getTypeInfo("bool"));
      case "==":
        if (vr(s) && vr(o)) {
          const l = s, u = o;
          if (l.length !== u.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const m = l.map((y, E) => y === u[E] ? 1 : 0);
          return new qe(m, n.typeInfo);
        }
        if (vr(s)) {
          const l = o, u = s.map((m, y) => m == l ? 1 : 0);
          return new qe(u, n.typeInfo);
        }
        if (vr(o)) {
          const l = s, u = o.map((m, y) => l == m ? 1 : 0);
          return new qe(u, i.typeInfo);
        }
        return new ut(s === o ? 1 : 0, this.getTypeInfo("bool"));
      case "!=":
        if (vr(s) && vr(o)) {
          const l = s, u = o;
          if (l.length !== u.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const m = l.map((y, E) => y !== u[E] ? 1 : 0);
          return new qe(m, n.typeInfo);
        }
        if (vr(s)) {
          const l = o, u = s.map((m, y) => m !== l ? 1 : 0);
          return new qe(u, n.typeInfo);
        }
        if (vr(o)) {
          const l = s, u = o.map((m, y) => l !== m ? 1 : 0);
          return new qe(u, i.typeInfo);
        }
        return new ut(s !== o ? 1 : 0, this.getTypeInfo("bool"));
      case ">=":
        if (vr(s) && vr(o)) {
          const l = s, u = o;
          if (l.length !== u.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const m = l.map((y, E) => y >= u[E] ? 1 : 0);
          return new qe(m, n.typeInfo);
        }
        if (vr(s)) {
          const l = o, u = s.map((m, y) => m >= l ? 1 : 0);
          return new qe(u, n.typeInfo);
        }
        if (vr(o)) {
          const l = s, u = o.map((m, y) => l >= m ? 1 : 0);
          return new qe(u, i.typeInfo);
        }
        return new ut(s >= o ? 1 : 0, this.getTypeInfo("bool"));
      case "<=":
        if (vr(s) && vr(o)) {
          const l = s, u = o;
          if (l.length !== u.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const m = l.map((y, E) => y <= u[E] ? 1 : 0);
          return new qe(m, n.typeInfo);
        }
        if (vr(s)) {
          const l = o, u = s.map((m, y) => m <= l ? 1 : 0);
          return new qe(u, n.typeInfo);
        }
        if (vr(o)) {
          const l = s, u = o.map((m, y) => l <= m ? 1 : 0);
          return new qe(u, i.typeInfo);
        }
        return new ut(s <= o ? 1 : 0, this.getTypeInfo("bool"));
      case "&&":
        if (vr(s) && vr(o)) {
          const l = s, u = o;
          if (l.length !== u.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const m = l.map((y, E) => y && u[E] ? 1 : 0);
          return new qe(m, n.typeInfo);
        }
        if (vr(s)) {
          const l = o, u = s.map((m, y) => m && l ? 1 : 0);
          return new qe(u, n.typeInfo);
        }
        if (vr(o)) {
          const l = s, u = o.map((m, y) => l && m ? 1 : 0);
          return new qe(u, i.typeInfo);
        }
        return new ut(s && o ? 1 : 0, this.getTypeInfo("bool"));
      case "||":
        if (vr(s) && vr(o)) {
          const l = s, u = o;
          if (l.length !== u.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const m = l.map((y, E) => y || u[E] ? 1 : 0);
          return new qe(m, n.typeInfo);
        }
        if (vr(s)) {
          const l = o, u = s.map((m, y) => m || l ? 1 : 0);
          return new qe(u, n.typeInfo);
        }
        if (vr(o)) {
          const l = s, u = o.map((m, y) => l || m ? 1 : 0);
          return new qe(u, i.typeInfo);
        }
        return new ut(s || o ? 1 : 0, this.getTypeInfo("bool"));
    }
    return console.error(`Unknown operator ${e.operator}. Line ${e.line}`), null;
  }
  _evalCall(e, t) {
    if (e.cachedReturnValue !== null) return e.cachedReturnValue;
    const n = t.clone();
    n.currentFunctionName = e.name;
    const i = t.getFunction(e.name);
    if (!i)
      return e.isBuiltin ? this._callBuiltinFunction(e, n) : this.getTypeInfo(e.name) ? this._evalCreate(e, t) : (console.error(`Unknown function "${e.name}". Line ${e.line}`), null);
    for (let s = 0; s < i.node.args.length; ++s) {
      const o = i.node.args[s], l = this.evalExpression(e.args[s], n);
      n.createVariable(o.name, l, o);
    }
    return this._execStatements(i.node.body, n);
  }
  _callBuiltinFunction(e, t) {
    switch (e.name) {
      case "all":
        return this.builtins.All(e, t);
      case "any":
        return this.builtins.Any(e, t);
      case "select":
        return this.builtins.Select(e, t);
      case "arrayLength":
        return this.builtins.ArrayLength(e, t);
      case "abs":
        return this.builtins.Abs(e, t);
      case "acos":
        return this.builtins.Acos(e, t);
      case "acosh":
        return this.builtins.Acosh(e, t);
      case "asin":
        return this.builtins.Asin(e, t);
      case "asinh":
        return this.builtins.Asinh(e, t);
      case "atan":
        return this.builtins.Atan(e, t);
      case "atanh":
        return this.builtins.Atanh(e, t);
      case "atan2":
        return this.builtins.Atan2(e, t);
      case "ceil":
        return this.builtins.Ceil(e, t);
      case "clamp":
        return this.builtins.Clamp(e, t);
      case "cos":
        return this.builtins.Cos(e, t);
      case "cosh":
        return this.builtins.Cosh(e, t);
      case "countLeadingZeros":
        return this.builtins.CountLeadingZeros(e, t);
      case "countOneBits":
        return this.builtins.CountOneBits(e, t);
      case "countTrailingZeros":
        return this.builtins.CountTrailingZeros(e, t);
      case "cross":
        return this.builtins.Cross(e, t);
      case "degrees":
        return this.builtins.Degrees(e, t);
      case "determinant":
        return this.builtins.Determinant(e, t);
      case "distance":
        return this.builtins.Distance(e, t);
      case "dot":
        return this.builtins.Dot(e, t);
      case "dot4U8Packed":
        return this.builtins.Dot4U8Packed(e, t);
      case "dot4I8Packed":
        return this.builtins.Dot4I8Packed(e, t);
      case "exp":
        return this.builtins.Exp(e, t);
      case "exp2":
        return this.builtins.Exp2(e, t);
      case "extractBits":
        return this.builtins.ExtractBits(e, t);
      case "faceForward":
        return this.builtins.FaceForward(e, t);
      case "firstLeadingBit":
        return this.builtins.FirstLeadingBit(e, t);
      case "firstTrailingBit":
        return this.builtins.FirstTrailingBit(e, t);
      case "floor":
        return this.builtins.Floor(e, t);
      case "fma":
        return this.builtins.Fma(e, t);
      case "fract":
        return this.builtins.Fract(e, t);
      case "frexp":
        return this.builtins.Frexp(e, t);
      case "insertBits":
        return this.builtins.InsertBits(e, t);
      case "inverseSqrt":
        return this.builtins.InverseSqrt(e, t);
      case "ldexp":
        return this.builtins.Ldexp(e, t);
      case "length":
        return this.builtins.Length(e, t);
      case "log":
        return this.builtins.Log(e, t);
      case "log2":
        return this.builtins.Log2(e, t);
      case "max":
        return this.builtins.Max(e, t);
      case "min":
        return this.builtins.Min(e, t);
      case "mix":
        return this.builtins.Mix(e, t);
      case "modf":
        return this.builtins.Modf(e, t);
      case "normalize":
        return this.builtins.Normalize(e, t);
      case "pow":
        return this.builtins.Pow(e, t);
      case "quantizeToF16":
        return this.builtins.QuantizeToF16(e, t);
      case "radians":
        return this.builtins.Radians(e, t);
      case "reflect":
        return this.builtins.Reflect(e, t);
      case "refract":
        return this.builtins.Refract(e, t);
      case "reverseBits":
        return this.builtins.ReverseBits(e, t);
      case "round":
        return this.builtins.Round(e, t);
      case "saturate":
        return this.builtins.Saturate(e, t);
      case "sign":
        return this.builtins.Sign(e, t);
      case "sin":
        return this.builtins.Sin(e, t);
      case "sinh":
        return this.builtins.Sinh(e, t);
      case "smoothstep":
        return this.builtins.SmoothStep(e, t);
      case "sqrt":
        return this.builtins.Sqrt(e, t);
      case "step":
        return this.builtins.Step(e, t);
      case "tan":
        return this.builtins.Tan(e, t);
      case "tanh":
        return this.builtins.Tanh(e, t);
      case "transpose":
        return this.builtins.Transpose(e, t);
      case "trunc":
        return this.builtins.Trunc(e, t);
      case "dpdx":
        return this.builtins.Dpdx(e, t);
      case "dpdxCoarse":
        return this.builtins.DpdxCoarse(e, t);
      case "dpdxFine":
        return this.builtins.DpdxFine(e, t);
      case "dpdy":
        return this.builtins.Dpdy(e, t);
      case "dpdyCoarse":
        return this.builtins.DpdyCoarse(e, t);
      case "dpdyFine":
        return this.builtins.DpdyFine(e, t);
      case "fwidth":
        return this.builtins.Fwidth(e, t);
      case "fwidthCoarse":
        return this.builtins.FwidthCoarse(e, t);
      case "fwidthFine":
        return this.builtins.FwidthFine(e, t);
      case "textureDimensions":
        return this.builtins.TextureDimensions(e, t);
      case "textureGather":
        return this.builtins.TextureGather(e, t);
      case "textureGatherCompare":
        return this.builtins.TextureGatherCompare(e, t);
      case "textureLoad":
        return this.builtins.TextureLoad(e, t);
      case "textureNumLayers":
        return this.builtins.TextureNumLayers(e, t);
      case "textureNumLevels":
        return this.builtins.TextureNumLevels(e, t);
      case "textureNumSamples":
        return this.builtins.TextureNumSamples(e, t);
      case "textureSample":
        return this.builtins.TextureSample(e, t);
      case "textureSampleBias":
        return this.builtins.TextureSampleBias(e, t);
      case "textureSampleCompare":
        return this.builtins.TextureSampleCompare(e, t);
      case "textureSampleCompareLevel":
        return this.builtins.TextureSampleCompareLevel(e, t);
      case "textureSampleGrad":
        return this.builtins.TextureSampleGrad(e, t);
      case "textureSampleLevel":
        return this.builtins.TextureSampleLevel(e, t);
      case "textureSampleBaseClampToEdge":
        return this.builtins.TextureSampleBaseClampToEdge(e, t);
      case "textureStore":
        return this.builtins.TextureStore(e, t);
      case "atomicLoad":
        return this.builtins.AtomicLoad(e, t);
      case "atomicStore":
        return this.builtins.AtomicStore(e, t);
      case "atomicAdd":
        return this.builtins.AtomicAdd(e, t);
      case "atomicSub":
        return this.builtins.AtomicSub(e, t);
      case "atomicMax":
        return this.builtins.AtomicMax(e, t);
      case "atomicMin":
        return this.builtins.AtomicMin(e, t);
      case "atomicAnd":
        return this.builtins.AtomicAnd(e, t);
      case "atomicOr":
        return this.builtins.AtomicOr(e, t);
      case "atomicXor":
        return this.builtins.AtomicXor(e, t);
      case "atomicExchange":
        return this.builtins.AtomicExchange(e, t);
      case "atomicCompareExchangeWeak":
        return this.builtins.AtomicCompareExchangeWeak(e, t);
      case "pack4x8snorm":
        return this.builtins.Pack4x8snorm(e, t);
      case "pack4x8unorm":
        return this.builtins.Pack4x8unorm(e, t);
      case "pack4xI8":
        return this.builtins.Pack4xI8(e, t);
      case "pack4xU8":
        return this.builtins.Pack4xU8(e, t);
      case "pack4x8Clamp":
        return this.builtins.Pack4x8Clamp(e, t);
      case "pack4xU8Clamp":
        return this.builtins.Pack4xU8Clamp(e, t);
      case "pack2x16snorm":
        return this.builtins.Pack2x16snorm(e, t);
      case "pack2x16unorm":
        return this.builtins.Pack2x16unorm(e, t);
      case "pack2x16float":
        return this.builtins.Pack2x16float(e, t);
      case "unpack4x8snorm":
        return this.builtins.Unpack4x8snorm(e, t);
      case "unpack4x8unorm":
        return this.builtins.Unpack4x8unorm(e, t);
      case "unpack4xI8":
        return this.builtins.Unpack4xI8(e, t);
      case "unpack4xU8":
        return this.builtins.Unpack4xU8(e, t);
      case "unpack2x16snorm":
        return this.builtins.Unpack2x16snorm(e, t);
      case "unpack2x16unorm":
        return this.builtins.Unpack2x16unorm(e, t);
      case "unpack2x16float":
        return this.builtins.Unpack2x16float(e, t);
      case "storageBarrier":
        return this.builtins.StorageBarrier(e, t);
      case "textureBarrier":
        return this.builtins.TextureBarrier(e, t);
      case "workgroupBarrier":
        return this.builtins.WorkgroupBarrier(e, t);
      case "workgroupUniformLoad":
        return this.builtins.WorkgroupUniformLoad(e, t);
      case "subgroupAdd":
        return this.builtins.SubgroupAdd(e, t);
      case "subgroupExclusiveAdd":
        return this.builtins.SubgroupExclusiveAdd(e, t);
      case "subgroupInclusiveAdd":
        return this.builtins.SubgroupInclusiveAdd(e, t);
      case "subgroupAll":
        return this.builtins.SubgroupAll(e, t);
      case "subgroupAnd":
        return this.builtins.SubgroupAnd(e, t);
      case "subgroupAny":
        return this.builtins.SubgroupAny(e, t);
      case "subgroupBallot":
        return this.builtins.SubgroupBallot(e, t);
      case "subgroupBroadcast":
        return this.builtins.SubgroupBroadcast(e, t);
      case "subgroupBroadcastFirst":
        return this.builtins.SubgroupBroadcastFirst(e, t);
      case "subgroupElect":
        return this.builtins.SubgroupElect(e, t);
      case "subgroupMax":
        return this.builtins.SubgroupMax(e, t);
      case "subgroupMin":
        return this.builtins.SubgroupMin(e, t);
      case "subgroupMul":
        return this.builtins.SubgroupMul(e, t);
      case "subgroupExclusiveMul":
        return this.builtins.SubgroupExclusiveMul(e, t);
      case "subgroupInclusiveMul":
        return this.builtins.SubgroupInclusiveMul(e, t);
      case "subgroupOr":
        return this.builtins.SubgroupOr(e, t);
      case "subgroupShuffle":
        return this.builtins.SubgroupShuffle(e, t);
      case "subgroupShuffleDown":
        return this.builtins.SubgroupShuffleDown(e, t);
      case "subgroupShuffleUp":
        return this.builtins.SubgroupShuffleUp(e, t);
      case "subgroupShuffleXor":
        return this.builtins.SubgroupShuffleXor(e, t);
      case "subgroupXor":
        return this.builtins.SubgroupXor(e, t);
      case "quadBroadcast":
        return this.builtins.QuadBroadcast(e, t);
      case "quadSwapDiagonal":
        return this.builtins.QuadSwapDiagonal(e, t);
      case "quadSwapX":
        return this.builtins.QuadSwapX(e, t);
      case "quadSwapY":
        return this.builtins.QuadSwapY(e, t);
    }
    const n = t.getFunction(e.name);
    if (n) {
      const i = t.clone();
      for (let s = 0; s < n.node.args.length; ++s) {
        const o = n.node.args[s], l = this.evalExpression(e.args[s], i);
        i.setVariable(o.name, l, o);
      }
      return this._execStatements(n.node.body, i);
    }
    return null;
  }
  _callConstructorValue(e, t) {
    if (!e.args || e.args.length === 0) return new ut(0, this.getTypeInfo(e.type));
    const n = this.evalExpression(e.args[0], t);
    return n.typeInfo = this.getTypeInfo(e.type), n.getSubData(this, e.postfix, t).clone();
  }
  _callConstructorVec(e, t) {
    const n = this.getTypeInfo(e.type), i = e.type.getTypeName(), s = Cv[i];
    if (s === void 0) return console.error(`Invalid vec constructor ${i}. Line ${e.line}`), null;
    const o = [];
    if (e instanceof Es) if (e.isVector) {
      const l = e.vectorValue;
      for (const u of l) o.push(u);
    } else o.push(e.scalarValue);
    else if (e.args) for (const l of e.args) {
      const u = this.evalExpression(l, t);
      if (u instanceof qe) {
        const m = u.data;
        for (let y = 0; y < m.length; ++y) {
          let E = m[y];
          o.push(E);
        }
      } else if (u instanceof ut) {
        let m = u.value;
        o.push(m);
      }
    }
    if (e.type instanceof mt && e.type.format === null && (e.type.format = mt.f32), o.length === 0) {
      const l = new Array(s).fill(0);
      return new qe(l, n).getSubData(this, e.postfix, t);
    }
    if (o.length === 1) for (; o.length < s; ) o.push(o[0]);
    return o.length < s ? (console.error(`Invalid vec constructor. Line ${e.line}`), null) : new qe(o.length > s ? o.slice(0, s) : o, n).getSubData(this, e.postfix, t);
  }
  _callConstructorMatrix(e, t) {
    const n = this.getTypeInfo(e.type), i = e.type.getTypeName(), s = Oo[i];
    if (s === void 0) return console.error(`Invalid matrix constructor ${i}. Line ${e.line}`), null;
    const o = [];
    if (e instanceof Es) if (e.isVector) {
      const l = e.vectorValue;
      for (const u of l) o.push(u);
    } else o.push(e.scalarValue);
    else if (e.args) for (const l of e.args) {
      const u = this.evalExpression(l, t);
      u instanceof qe ? o.push(...u.data) : u instanceof ut ? o.push(u.value) : u instanceof ln && o.push(...u.data);
    }
    if (n instanceof rh && n.format === null && (n.format = this.getTypeInfo("f32")), o.length === 0) {
      const l = new Array(s[2]).fill(0);
      return new ln(l, n).getSubData(this, e.postfix, t);
    }
    return o.length !== s[2] ? (console.error(`Invalid matrix constructor. Line ${e.line}`), null) : new ln(o, n).getSubData(this, e.postfix, t);
  }
}
Ao._breakObj = new Ua(new Fa("BREAK", null), null), Ao._continueObj = new Ua(new Fa("CONTINUE", null), null), Ao._priority = /* @__PURE__ */ new Map([["f32", 0], ["f16", 1], ["u32", 2], ["i32", 3], ["x32", 3]]);
class j7 {
  constructor() {
    this.constants = /* @__PURE__ */ new Map(), this.aliases = /* @__PURE__ */ new Map(), this.structs = /* @__PURE__ */ new Map();
  }
}
class H7 {
  constructor() {
    this._tokens = [], this._current = 0, this._currentLine = 1, this._deferArrayCountEval = [], this._currentLoop = [], this._context = new j7(), this._exec = new Ao(), this._forwardTypeCount = 0;
  }
  parse(e) {
    this._initialize(e), this._deferArrayCountEval.length = 0;
    const t = [];
    for (; !this._isAtEnd(); ) {
      const n = this._global_decl_or_directive();
      if (!n) break;
      t.push(n);
    }
    if (this._deferArrayCountEval.length > 0) {
      for (const n of this._deferArrayCountEval) {
        const i = n.arrayType, s = n.countNode;
        if (s instanceof ua) {
          const o = s.name, l = this._context.constants.get(o);
          if (l) try {
            const u = l.constEvaluate(this._exec);
            i.count = u;
          } catch {
          }
        }
      }
      this._deferArrayCountEval.length = 0;
    }
    if (this._forwardTypeCount > 0) for (const n of t) n.search((i) => {
      i instanceof QE || i instanceof _m ? i.type = this._forwardType(i.type) : i instanceof zA ? i.format = this._forwardType(i.format) : i instanceof Gc || i instanceof UA || i instanceof mm ? i.type = this._forwardType(i.type) : i instanceof t0 ? i.returnType = this._forwardType(i.returnType) : i instanceof KE && (i.type = this._forwardType(i.type));
    });
    return t;
  }
  _forwardType(e) {
    if (e instanceof YE) {
      const t = this._getType(e.name);
      if (t) return t;
    } else e instanceof _m ? e.type = this._forwardType(e.type) : e instanceof zA && (e.format = this._forwardType(e.format));
    return e;
  }
  _initialize(e) {
    if (e) if (typeof e == "string") {
      const t = new B7(e);
      this._tokens = t.scanTokens();
    } else this._tokens = e;
    else this._tokens = [];
    this._current = 0;
  }
  _updateNode(e, t) {
    return e.line = t ?? this._currentLine, e;
  }
  _error(e, t) {
    return { token: e, message: t, toString: () => `${t}` };
  }
  _isAtEnd() {
    return this._current >= this._tokens.length || this._peek().type == Fe.eof;
  }
  _match(e) {
    if (e instanceof ht) return !!this._check(e) && (this._advance(), !0);
    for (let t = 0, n = e.length; t < n; ++t) {
      const i = e[t];
      if (this._check(i)) return this._advance(), !0;
    }
    return !1;
  }
  _consume(e, t) {
    if (this._check(e)) return this._advance();
    throw this._error(this._peek(), `${t}. Line:${this._currentLine}`);
  }
  _check(e) {
    if (this._isAtEnd()) return !1;
    const t = this._peek();
    if (e instanceof Array) {
      const n = t.type;
      let i = !1;
      for (const s of e) {
        if (n === s) return !0;
        s === Fe.tokens.name && (i = !0);
      }
      if (i) {
        const s = Fe.tokens.name.rule.exec(t.lexeme);
        if (s && s.index == 0 && s[0] == t.lexeme) return !0;
      }
      return !1;
    }
    if (t.type === e) return !0;
    if (e === Fe.tokens.name) {
      const n = Fe.tokens.name.rule.exec(t.lexeme);
      return n && n.index == 0 && n[0] == t.lexeme;
    }
    return !1;
  }
  _advance() {
    var e, t;
    return this._currentLine = (t = (e = this._peek()) === null || e === void 0 ? void 0 : e.line) !== null && t !== void 0 ? t : -1, this._isAtEnd() || this._current++, this._previous();
  }
  _peek() {
    return this._tokens[this._current];
  }
  _previous() {
    return this._tokens[this._current - 1];
  }
  _global_decl_or_directive() {
    for (; this._match(Fe.tokens.semicolon) && !this._isAtEnd(); ) ;
    if (this._match(Fe.keywords.alias)) {
      const t = this._type_alias();
      return this._consume(Fe.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([t]), t;
    }
    if (this._match(Fe.keywords.diagnostic)) {
      const t = this._diagnostic();
      return this._consume(Fe.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([t]), t;
    }
    if (this._match(Fe.keywords.requires)) {
      const t = this._requires_directive();
      return this._consume(Fe.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([t]), t;
    }
    if (this._match(Fe.keywords.enable)) {
      const t = this._enable_directive();
      return this._consume(Fe.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([t]), t;
    }
    const e = this._attribute();
    if (this._check(Fe.keywords.var)) {
      const t = this._global_variable_decl();
      return t != null && (t.attributes = e), this._consume(Fe.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([t]), t;
    }
    if (this._check(Fe.keywords.override)) {
      const t = this._override_variable_decl();
      return t != null && (t.attributes = e), this._consume(Fe.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([t]), t;
    }
    if (this._check(Fe.keywords.let)) {
      const t = this._global_let_decl();
      return t != null && (t.attributes = e), this._consume(Fe.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([t]), t;
    }
    if (this._check(Fe.keywords.const)) {
      const t = this._global_const_decl();
      return t != null && (t.attributes = e), this._consume(Fe.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([t]), t;
    }
    if (this._check(Fe.keywords.struct)) {
      const t = this._struct_decl();
      return t != null && (t.attributes = e), this._exec.reflection.updateAST([t]), t;
    }
    if (this._check(Fe.keywords.fn)) {
      const t = this._function_decl();
      return t != null && (t.attributes = e), this._exec.reflection.updateAST([t]), t;
    }
    return null;
  }
  _function_decl() {
    if (!this._match(Fe.keywords.fn)) return null;
    const e = this._currentLine, t = this._consume(Fe.tokens.ident, "Expected function name.").toString();
    this._consume(Fe.tokens.paren_left, "Expected '(' for function arguments.");
    const n = [];
    if (!this._check(Fe.tokens.paren_right)) do {
      if (this._check(Fe.tokens.paren_right)) break;
      const l = this._attribute(), u = this._consume(Fe.tokens.name, "Expected argument name.").toString();
      this._consume(Fe.tokens.colon, "Expected ':' for argument type.");
      const m = this._attribute(), y = this._type_decl();
      y != null && (y.attributes = m, n.push(this._updateNode(new KE(u, y, l))));
    } while (this._match(Fe.tokens.comma));
    this._consume(Fe.tokens.paren_right, "Expected ')' after function arguments.");
    let i = null;
    if (this._match(Fe.tokens.arrow)) {
      const l = this._attribute();
      i = this._type_decl(), i != null && (i.attributes = l);
    }
    const s = this._compound_statement(), o = this._currentLine;
    return this._updateNode(new t0(t, n, i, s, e, o), e);
  }
  _compound_statement() {
    const e = [];
    for (this._consume(Fe.tokens.brace_left, "Expected '{' for block."); !this._check(Fe.tokens.brace_right); ) {
      const t = this._statement();
      t !== null && e.push(t);
    }
    return this._consume(Fe.tokens.brace_right, "Expected '}' for block."), e;
  }
  _statement() {
    for (; this._match(Fe.tokens.semicolon) && !this._isAtEnd(); ) ;
    if (this._check(Fe.tokens.attr) && this._attribute(), this._check(Fe.keywords.if)) return this._if_statement();
    if (this._check(Fe.keywords.switch)) return this._switch_statement();
    if (this._check(Fe.keywords.loop)) return this._loop_statement();
    if (this._check(Fe.keywords.for)) return this._for_statement();
    if (this._check(Fe.keywords.while)) return this._while_statement();
    if (this._check(Fe.keywords.continuing)) return this._continuing_statement();
    if (this._check(Fe.keywords.static_assert)) return this._static_assert_statement();
    if (this._check(Fe.tokens.brace_left)) return this._compound_statement();
    let e = null;
    if (this._check(Fe.keywords.return)) e = this._return_statement();
    else if (this._check([Fe.keywords.var, Fe.keywords.let, Fe.keywords.const])) e = this._variable_statement();
    else if (this._match(Fe.keywords.discard)) e = this._updateNode(new P7());
    else if (this._match(Fe.keywords.break)) {
      const t = this._updateNode(new iO());
      if (this._currentLoop.length > 0) {
        const n = this._currentLoop[this._currentLoop.length - 1];
        t.loopId = n.id;
      }
      e = t, this._check(Fe.keywords.if) && (this._advance(), t.condition = this._optional_paren_expression());
    } else if (this._match(Fe.keywords.continue)) {
      const t = this._updateNode(new sO());
      if (!(this._currentLoop.length > 0)) throw this._error(this._peek(), `Continue statement must be inside a loop. Line: ${t.line}`);
      {
        const n = this._currentLoop[this._currentLoop.length - 1];
        t.loopId = n.id;
      }
      e = t;
    } else e = this._increment_decrement_statement() || this._func_call_statement() || this._assignment_statement();
    return e != null && this._consume(Fe.tokens.semicolon, "Expected ';' after statement."), e;
  }
  _static_assert_statement() {
    if (!this._match(Fe.keywords.static_assert)) return null;
    const e = this._currentLine, t = this._optional_paren_expression();
    return this._updateNode(new C7(t), e);
  }
  _while_statement() {
    if (!this._match(Fe.keywords.while)) return null;
    const e = this._updateNode(new ZB(null, null));
    return this._currentLoop.push(e), e.condition = this._optional_paren_expression(), this._check(Fe.tokens.attr) && this._attribute(), e.body = this._compound_statement(), this._currentLoop.pop(), e;
  }
  _continuing_statement() {
    const e = this._currentLoop.length > 0 ? this._currentLoop[this._currentLoop.length - 1].id : -1;
    if (!this._match(Fe.keywords.continuing)) return null;
    const t = this._currentLine, n = this._compound_statement();
    return this._updateNode(new Sb(n, e), t);
  }
  _for_statement() {
    if (!this._match(Fe.keywords.for)) return null;
    this._consume(Fe.tokens.paren_left, "Expected '('.");
    const e = this._updateNode(new YB(null, null, null, null));
    return this._currentLoop.push(e), e.init = this._check(Fe.tokens.semicolon) ? null : this._for_init(), this._consume(Fe.tokens.semicolon, "Expected ';'."), e.condition = this._check(Fe.tokens.semicolon) ? null : this._short_circuit_or_expression(), this._consume(Fe.tokens.semicolon, "Expected ';'."), e.increment = this._check(Fe.tokens.paren_right) ? null : this._for_increment(), this._consume(Fe.tokens.paren_right, "Expected ')'."), this._check(Fe.tokens.attr) && this._attribute(), e.body = this._compound_statement(), this._currentLoop.pop(), e;
  }
  _for_init() {
    return this._variable_statement() || this._func_call_statement() || this._assignment_statement();
  }
  _for_increment() {
    return this._func_call_statement() || this._increment_decrement_statement() || this._assignment_statement();
  }
  _variable_statement() {
    if (this._check(Fe.keywords.var)) {
      const e = this._variable_decl();
      if (e === null) throw this._error(this._peek(), "Variable declaration expected.");
      let t = null;
      return this._match(Fe.tokens.equal) && (t = this._short_circuit_or_expression()), this._updateNode(new Gc(e.name, e.type, e.storage, e.access, t), e.line);
    }
    if (this._match(Fe.keywords.let)) {
      const e = this._currentLine, t = this._consume(Fe.tokens.name, "Expected name for let.").toString();
      let n = null;
      if (this._match(Fe.tokens.colon)) {
        const s = this._attribute();
        n = this._type_decl(), n != null && (n.attributes = s);
      }
      this._consume(Fe.tokens.equal, "Expected '=' for let.");
      const i = this._short_circuit_or_expression();
      return this._updateNode(new UA(t, n, null, null, i), e);
    }
    if (this._match(Fe.keywords.const)) {
      const e = this._currentLine, t = this._consume(Fe.tokens.name, "Expected name for const.").toString();
      let n = null;
      if (this._match(Fe.tokens.colon)) {
        const s = this._attribute();
        n = this._type_decl(), n != null && (n.attributes = s);
      }
      this._consume(Fe.tokens.equal, "Expected '=' for const.");
      const i = this._short_circuit_or_expression();
      return n === null && i instanceof Es && (n = i.type), this._updateNode(new mm(t, n, null, null, i), e);
    }
    return null;
  }
  _increment_decrement_statement() {
    const e = this._current, t = this._unary_expression();
    if (t == null) return null;
    if (!this._check(Fe.increment_operators)) return this._current = e, null;
    const n = this._consume(Fe.increment_operators, "Expected increment operator");
    return this._updateNode(new KB(n.type === Fe.tokens.plus_plus ? Wd.increment : Wd.decrement, t));
  }
  _assignment_statement() {
    let e = null;
    const t = this._currentLine;
    if (this._check(Fe.tokens.brace_right)) return null;
    let n = this._match(Fe.tokens.underscore);
    if (n || (e = this._unary_expression()), !n && e == null) return null;
    const i = this._consume(Fe.assignment_operators, "Expected assignment operator."), s = this._short_circuit_or_expression();
    return this._updateNode(new QB(PA.parse(i.lexeme), e, s), t);
  }
  _func_call_statement() {
    if (!this._check(Fe.tokens.ident)) return null;
    const e = this._currentLine, t = this._current, n = this._consume(Fe.tokens.ident, "Expected function name."), i = this._argument_expression_list();
    return i === null ? (this._current = t, null) : this._updateNode(new vx(n.lexeme, i), e);
  }
  _loop_statement() {
    if (!this._match(Fe.keywords.loop)) return null;
    this._check(Fe.tokens.attr) && this._attribute(), this._consume(Fe.tokens.brace_left, "Expected '{' for loop.");
    const e = this._updateNode(new JB([], null));
    this._currentLoop.push(e);
    let t = this._statement();
    for (; t !== null; ) {
      if (Array.isArray(t)) for (let n of t) e.body.push(n);
      else e.body.push(t);
      if (t instanceof Sb) {
        e.continuing = t;
        break;
      }
      t = this._statement();
    }
    return this._currentLoop.pop(), this._consume(Fe.tokens.brace_right, "Expected '}' for loop."), e;
  }
  _switch_statement() {
    if (!this._match(Fe.keywords.switch)) return null;
    const e = this._updateNode(new eO(null, []));
    if (this._currentLoop.push(e), e.condition = this._optional_paren_expression(), this._check(Fe.tokens.attr) && this._attribute(), this._consume(Fe.tokens.brace_left, "Expected '{' for switch."), e.cases = this._switch_body(), e.cases == null || e.cases.length == 0) throw this._error(this._previous(), "Expected 'case' or 'default'.");
    return this._consume(Fe.tokens.brace_right, "Expected '}' for switch."), this._currentLoop.pop(), e;
  }
  _switch_body() {
    const e = [];
    let t = !1;
    for (; this._check([Fe.keywords.default, Fe.keywords.case]); ) {
      if (this._match(Fe.keywords.case)) {
        const n = this._case_selectors();
        for (const s of n) if (s instanceof ym) {
          if (t) throw this._error(this._previous(), "Multiple default cases in switch statement.");
          t = !0;
          break;
        }
        this._match(Fe.tokens.colon), this._check(Fe.tokens.attr) && this._attribute(), this._consume(Fe.tokens.brace_left, "Exected '{' for switch case.");
        const i = this._case_body();
        this._consume(Fe.tokens.brace_right, "Exected '}' for switch case."), e.push(this._updateNode(new uO(n, i)));
      }
      if (this._match(Fe.keywords.default)) {
        if (t) throw this._error(this._previous(), "Multiple default cases in switch statement.");
        this._match(Fe.tokens.colon), this._check(Fe.tokens.attr) && this._attribute(), this._consume(Fe.tokens.brace_left, "Exected '{' for switch default.");
        const n = this._case_body();
        this._consume(Fe.tokens.brace_right, "Exected '}' for switch default."), e.push(this._updateNode(new fO(n)));
      }
    }
    return e;
  }
  _case_selectors() {
    const e = [];
    for (this._match(Fe.keywords.default) ? e.push(this._updateNode(new ym())) : e.push(this._shift_expression()); this._match(Fe.tokens.comma); ) this._match(Fe.keywords.default) ? e.push(this._updateNode(new ym())) : e.push(this._shift_expression());
    return e;
  }
  _case_body() {
    if (this._match(Fe.keywords.fallthrough)) return this._consume(Fe.tokens.semicolon, "Expected ';'"), [];
    let e = this._statement();
    if (e == null) return [];
    e instanceof Array || (e = [e]);
    const t = this._case_body();
    return t.length == 0 ? e : [...e, t[0]];
  }
  _if_statement() {
    if (!this._match(Fe.keywords.if)) return null;
    const e = this._currentLine, t = this._optional_paren_expression();
    this._check(Fe.tokens.attr) && this._attribute();
    const n = this._compound_statement();
    let i = [];
    this._match_elseif() && (this._check(Fe.tokens.attr) && this._attribute(), i = this._elseif_statement(i));
    let s = null;
    return this._match(Fe.keywords.else) && (this._check(Fe.tokens.attr) && this._attribute(), s = this._compound_statement()), this._updateNode(new tO(t, n, i, s), e);
  }
  _match_elseif() {
    return this._tokens[this._current].type === Fe.keywords.else && this._tokens[this._current + 1].type === Fe.keywords.if && (this._advance(), this._advance(), !0);
  }
  _elseif_statement(e = []) {
    const t = this._optional_paren_expression(), n = this._compound_statement();
    return e.push(this._updateNode(new M7(t, n))), this._match_elseif() && (this._check(Fe.tokens.attr) && this._attribute(), this._elseif_statement(e)), e;
  }
  _return_statement() {
    if (!this._match(Fe.keywords.return)) return null;
    const e = this._short_circuit_or_expression();
    return this._updateNode(new rO(e));
  }
  _short_circuit_or_expression() {
    let e = this._short_circuit_and_expr();
    for (; this._match(Fe.tokens.or_or); ) e = this._updateNode(new ol(this._previous().toString(), e, this._short_circuit_and_expr()));
    return e;
  }
  _short_circuit_and_expr() {
    let e = this._inclusive_or_expression();
    for (; this._match(Fe.tokens.and_and); ) e = this._updateNode(new ol(this._previous().toString(), e, this._inclusive_or_expression()));
    return e;
  }
  _inclusive_or_expression() {
    let e = this._exclusive_or_expression();
    for (; this._match(Fe.tokens.or); ) e = this._updateNode(new ol(this._previous().toString(), e, this._exclusive_or_expression()));
    return e;
  }
  _exclusive_or_expression() {
    let e = this._and_expression();
    for (; this._match(Fe.tokens.xor); ) e = this._updateNode(new ol(this._previous().toString(), e, this._and_expression()));
    return e;
  }
  _and_expression() {
    let e = this._equality_expression();
    for (; this._match(Fe.tokens.and); ) e = this._updateNode(new ol(this._previous().toString(), e, this._equality_expression()));
    return e;
  }
  _equality_expression() {
    const e = this._relational_expression();
    return this._match([Fe.tokens.equal_equal, Fe.tokens.not_equal]) ? this._updateNode(new ol(this._previous().toString(), e, this._relational_expression())) : e;
  }
  _relational_expression() {
    let e = this._shift_expression();
    for (; this._match([Fe.tokens.less_than, Fe.tokens.greater_than, Fe.tokens.less_than_equal, Fe.tokens.greater_than_equal]); ) e = this._updateNode(new ol(this._previous().toString(), e, this._shift_expression()));
    return e;
  }
  _shift_expression() {
    let e = this._additive_expression();
    for (; this._match([Fe.tokens.shift_left, Fe.tokens.shift_right]); ) e = this._updateNode(new ol(this._previous().toString(), e, this._additive_expression()));
    return e;
  }
  _additive_expression() {
    let e = this._multiplicative_expression();
    for (; this._match([Fe.tokens.plus, Fe.tokens.minus]); ) e = this._updateNode(new ol(this._previous().toString(), e, this._multiplicative_expression()));
    return e;
  }
  _multiplicative_expression() {
    let e = this._unary_expression();
    for (; this._match([Fe.tokens.star, Fe.tokens.forward_slash, Fe.tokens.modulo]); ) e = this._updateNode(new ol(this._previous().toString(), e, this._unary_expression()));
    return e;
  }
  _unary_expression() {
    return this._match([Fe.tokens.minus, Fe.tokens.bang, Fe.tokens.tilde, Fe.tokens.star, Fe.tokens.and]) ? this._updateNode(new hs(this._previous().toString(), this._unary_expression())) : this._singular_expression();
  }
  _singular_expression() {
    const e = this._primary_expression(), t = this._postfix_expression();
    return t && (e.postfix = t), e;
  }
  _postfix_expression() {
    if (this._match(Fe.tokens.bracket_left)) {
      const e = this._short_circuit_or_expression();
      this._consume(Fe.tokens.bracket_right, "Expected ']'.");
      const t = this._updateNode(new mp(e)), n = this._postfix_expression();
      return n && (t.postfix = n), t;
    }
    if (this._match(Fe.tokens.period)) {
      const e = this._consume(Fe.tokens.name, "Expected member name."), t = this._postfix_expression(), n = this._updateNode(new nh(e.lexeme));
      return t && (n.postfix = t), n;
    }
    return null;
  }
  _getStruct(e) {
    return this._context.aliases.has(e) ? this._context.aliases.get(e).type : this._context.structs.has(e) ? this._context.structs.get(e) : null;
  }
  _getType(e) {
    const t = this._getStruct(e);
    if (t !== null) return t;
    switch (e) {
      case "void":
        return $t.void;
      case "bool":
        return $t.bool;
      case "i32":
        return $t.i32;
      case "u32":
        return $t.u32;
      case "f32":
        return $t.f32;
      case "f16":
        return $t.f16;
      case "vec2f":
        return mt.vec2f;
      case "vec3f":
        return mt.vec3f;
      case "vec4f":
        return mt.vec4f;
      case "vec2i":
        return mt.vec2i;
      case "vec3i":
        return mt.vec3i;
      case "vec4i":
        return mt.vec4i;
      case "vec2u":
        return mt.vec2u;
      case "vec3u":
        return mt.vec3u;
      case "vec4u":
        return mt.vec4u;
      case "vec2h":
        return mt.vec2h;
      case "vec3h":
        return mt.vec3h;
      case "vec4h":
        return mt.vec4h;
      case "mat2x2f":
        return mt.mat2x2f;
      case "mat2x3f":
        return mt.mat2x3f;
      case "mat2x4f":
        return mt.mat2x4f;
      case "mat3x2f":
        return mt.mat3x2f;
      case "mat3x3f":
        return mt.mat3x3f;
      case "mat3x4f":
        return mt.mat3x4f;
      case "mat4x2f":
        return mt.mat4x2f;
      case "mat4x3f":
        return mt.mat4x3f;
      case "mat4x4f":
        return mt.mat4x4f;
      case "mat2x2h":
        return mt.mat2x2h;
      case "mat2x3h":
        return mt.mat2x3h;
      case "mat2x4h":
        return mt.mat2x4h;
      case "mat3x2h":
        return mt.mat3x2h;
      case "mat3x3h":
        return mt.mat3x3h;
      case "mat3x4h":
        return mt.mat3x4h;
      case "mat4x2h":
        return mt.mat4x2h;
      case "mat4x3h":
        return mt.mat4x3h;
      case "mat4x4h":
        return mt.mat4x4h;
      case "mat2x2i":
        return mt.mat2x2i;
      case "mat2x3i":
        return mt.mat2x3i;
      case "mat2x4i":
        return mt.mat2x4i;
      case "mat3x2i":
        return mt.mat3x2i;
      case "mat3x3i":
        return mt.mat3x3i;
      case "mat3x4i":
        return mt.mat3x4i;
      case "mat4x2i":
        return mt.mat4x2i;
      case "mat4x3i":
        return mt.mat4x3i;
      case "mat4x4i":
        return mt.mat4x4i;
      case "mat2x2u":
        return mt.mat2x2u;
      case "mat2x3u":
        return mt.mat2x3u;
      case "mat2x4u":
        return mt.mat2x4u;
      case "mat3x2u":
        return mt.mat3x2u;
      case "mat3x3u":
        return mt.mat3x3u;
      case "mat3x4u":
        return mt.mat3x4u;
      case "mat4x2u":
        return mt.mat4x2u;
      case "mat4x3u":
        return mt.mat4x3u;
      case "mat4x4u":
        return mt.mat4x4u;
    }
    return null;
  }
  _validateTypeRange(e, t) {
    if (t.name === "i32") {
      if (e < -2147483648 || e > 2147483647) throw this._error(this._previous(), `Value out of range for i32: ${e}. Line: ${this._currentLine}.`);
    } else if (t.name === "u32" && (e < 0 || e > 4294967295)) throw this._error(this._previous(), `Value out of range for u32: ${e}. Line: ${this._currentLine}.`);
  }
  _primary_expression() {
    if (this._match(Fe.tokens.ident)) {
      const n = this._previous().toString();
      if (this._check(Fe.tokens.paren_left)) {
        const i = this._argument_expression_list(), s = this._getType(n);
        return s !== null ? this._updateNode(new ec(s, i)) : this._updateNode(new xx(n, i));
      }
      if (this._context.constants.has(n)) {
        const i = this._context.constants.get(n);
        return this._updateNode(new oO(n, i.value));
      }
      return this._updateNode(new ua(n));
    }
    if (this._match(Fe.tokens.int_literal)) {
      const n = this._previous().toString();
      let i = n.endsWith("i") || n.endsWith("i") ? $t.i32 : n.endsWith("u") || n.endsWith("U") ? $t.u32 : $t.x32;
      const s = parseInt(n);
      return this._validateTypeRange(s, i), this._updateNode(new Es(new ut(s, this._exec.getTypeInfo(i)), i));
    }
    if (this._match(Fe.tokens.uint_literal)) {
      const n = parseInt(this._previous().toString());
      return this._validateTypeRange(n, $t.u32), this._updateNode(new Es(new ut(n, this._exec.getTypeInfo($t.u32)), $t.u32));
    }
    if (this._match([Fe.tokens.decimal_float_literal, Fe.tokens.hex_float_literal])) {
      let n = this._previous().toString(), i = n.endsWith("h");
      i && (n = n.substring(0, n.length - 1));
      const s = parseFloat(n);
      this._validateTypeRange(s, i ? $t.f16 : $t.f32);
      const o = i ? $t.f16 : $t.f32;
      return this._updateNode(new Es(new ut(s, this._exec.getTypeInfo(o)), o));
    }
    if (this._match([Fe.keywords.true, Fe.keywords.false])) {
      let n = this._previous().toString() === Fe.keywords.true.rule;
      return this._updateNode(new Es(new ut(n ? 1 : 0, this._exec.getTypeInfo($t.bool)), $t.bool));
    }
    if (this._check(Fe.tokens.paren_left)) return this._paren_expression();
    if (this._match(Fe.keywords.bitcast)) {
      this._consume(Fe.tokens.less_than, "Expected '<'.");
      const n = this._type_decl();
      this._consume(Fe.tokens.greater_than, "Expected '>'.");
      const i = this._paren_expression();
      return this._updateNode(new aO(n, i));
    }
    const e = this._type_decl(), t = this._argument_expression_list();
    return this._updateNode(new ec(e, t));
  }
  _argument_expression_list() {
    if (!this._match(Fe.tokens.paren_left)) return null;
    const e = [];
    do {
      if (this._check(Fe.tokens.paren_right)) break;
      const t = this._short_circuit_or_expression();
      e.push(t);
    } while (this._match(Fe.tokens.comma));
    return this._consume(Fe.tokens.paren_right, "Expected ')' for agument list"), e;
  }
  _optional_paren_expression() {
    this._match(Fe.tokens.paren_left);
    const e = this._short_circuit_or_expression();
    return this._match(Fe.tokens.paren_right), e;
  }
  _paren_expression() {
    this._consume(Fe.tokens.paren_left, "Expected '('.");
    const e = this._short_circuit_or_expression();
    return this._consume(Fe.tokens.paren_right, "Expected ')'."), e;
  }
  _struct_decl() {
    if (!this._match(Fe.keywords.struct)) return null;
    const e = this._currentLine, t = this._consume(Fe.tokens.ident, "Expected name for struct.").toString();
    this._consume(Fe.tokens.brace_left, "Expected '{' for struct body.");
    const n = [];
    for (; !this._check(Fe.tokens.brace_right); ) {
      const o = this._attribute(), l = this._consume(Fe.tokens.name, "Expected variable name.").toString();
      this._consume(Fe.tokens.colon, "Expected ':' for struct member type.");
      const u = this._attribute(), m = this._type_decl();
      m != null && (m.attributes = u), this._check(Fe.tokens.brace_right) ? this._match(Fe.tokens.comma) : this._consume(Fe.tokens.comma, "Expected ',' for struct member."), n.push(this._updateNode(new QE(l, m, o)));
    }
    this._consume(Fe.tokens.brace_right, "Expected '}' after struct body.");
    const i = this._currentLine, s = this._updateNode(new jc(t, n, e, i), e);
    return this._context.structs.set(t, s), s;
  }
  _global_variable_decl() {
    const e = this._variable_decl();
    if (!e) return null;
    if (this._match(Fe.tokens.equal)) {
      const t = this._const_expression();
      e.value = t;
    }
    if (e.type !== null && e.value instanceof Es) {
      if (e.value.type.name !== "x32" && e.type.getTypeName() !== e.value.type.getTypeName())
        throw this._error(this._peek(), `Invalid cast from ${e.value.type.name} to ${e.type.name}. Line:${this._currentLine}`);
      e.value.isScalar && this._validateTypeRange(e.value.scalarValue, e.type), e.value.type = e.type;
    } else e.type === null && e.value instanceof Es && (e.type = e.value.type.name === "x32" ? $t.i32 : e.value.type, e.value.isScalar && this._validateTypeRange(e.value.scalarValue, e.type));
    return e;
  }
  _override_variable_decl() {
    const e = this._override_decl();
    return e && this._match(Fe.tokens.equal) && (e.value = this._const_expression()), e;
  }
  _global_const_decl() {
    var e;
    if (!this._match(Fe.keywords.const)) return null;
    const t = this._consume(Fe.tokens.name, "Expected variable name"), n = this._currentLine;
    let i = null;
    if (this._match(Fe.tokens.colon)) {
      const u = this._attribute();
      i = this._type_decl(), i != null && (i.attributes = u);
    }
    let s = null;
    this._consume(Fe.tokens.equal, "const declarations require an assignment");
    const o = this._short_circuit_or_expression();
    try {
      let u = [$t.f32], m = o.constEvaluate(this._exec, u);
      m instanceof ut && this._validateTypeRange(m.value, u[0]), u[0] instanceof mt && u[0].format === null && m.typeInfo instanceof rh && m.typeInfo.format !== null && (m.typeInfo.format.name === "f16" ? u[0].format = $t.f16 : m.typeInfo.format.name === "f32" ? u[0].format = $t.f32 : m.typeInfo.format.name === "i32" ? u[0].format = $t.i32 : m.typeInfo.format.name === "u32" ? u[0].format = $t.u32 : m.typeInfo.format.name === "bool" ? u[0].format = $t.bool : console.error(`TODO: impelement template format type ${m.typeInfo.format.name}`)), s = this._updateNode(new Es(m, u[0])), this._exec.context.setVariable(t.toString(), m);
    } catch {
      s = o;
    }
    if (i !== null && s instanceof Es) {
      if (s.type.name !== "x32" && i.getTypeName() !== s.type.getTypeName())
        throw this._error(this._peek(), `Invalid cast from ${s.type.name} to ${i.name}. Line:${this._currentLine}`);
      s.type = i, s.isScalar && this._validateTypeRange(s.scalarValue, s.type);
    } else i === null && s instanceof Es && (i = (e = s?.type) !== null && e !== void 0 ? e : $t.f32, i === $t.x32 && (i = $t.i32));
    const l = this._updateNode(new mm(t.toString(), i, "", "", s), n);
    return this._context.constants.set(l.name, l), l;
  }
  _global_let_decl() {
    if (!this._match(Fe.keywords.let)) return null;
    const e = this._currentLine, t = this._consume(Fe.tokens.name, "Expected variable name");
    let n = null;
    if (this._match(Fe.tokens.colon)) {
      const s = this._attribute();
      n = this._type_decl(), n != null && (n.attributes = s);
    }
    let i = null;
    if (this._match(Fe.tokens.equal) && (i = this._const_expression()), n !== null && i instanceof Es) {
      if (i.type.name !== "x32" && n.getTypeName() !== i.type.getTypeName())
        throw this._error(this._peek(), `Invalid cast from ${i.type.name} to ${n.name}. Line:${this._currentLine}`);
      i.type = n;
    } else n === null && i instanceof Es && (n = i.type.name === "x32" ? $t.i32 : i.type);
    return i instanceof Es && i.isScalar && this._validateTypeRange(i.scalarValue, n), this._updateNode(new UA(t.toString(), n, "", "", i), e);
  }
  _const_expression() {
    return this._short_circuit_or_expression();
  }
  _variable_decl() {
    if (!this._match(Fe.keywords.var)) return null;
    const e = this._currentLine;
    let t = "", n = "";
    this._match(Fe.tokens.less_than) && (t = this._consume(Fe.storage_class, "Expected storage_class.").toString(), this._match(Fe.tokens.comma) && (n = this._consume(Fe.access_mode, "Expected access_mode.").toString()), this._consume(Fe.tokens.greater_than, "Expected '>'."));
    const i = this._consume(Fe.tokens.name, "Expected variable name");
    let s = null;
    if (this._match(Fe.tokens.colon)) {
      const o = this._attribute();
      s = this._type_decl(), s != null && (s.attributes = o);
    }
    return this._updateNode(new Gc(i.toString(), s, t, n, null), e);
  }
  _override_decl() {
    if (!this._match(Fe.keywords.override)) return null;
    const e = this._consume(Fe.tokens.name, "Expected variable name");
    let t = null;
    if (this._match(Fe.tokens.colon)) {
      const n = this._attribute();
      t = this._type_decl(), t != null && (t.attributes = n);
    }
    return this._updateNode(new yx(e.toString(), t, null));
  }
  _diagnostic() {
    this._consume(Fe.tokens.paren_left, "Expected '('");
    const e = this._consume(Fe.tokens.ident, "Expected severity control name.");
    this._consume(Fe.tokens.comma, "Expected ','");
    let t = this._consume(Fe.tokens.ident, "Expected diagnostic rule name.").toString();
    return this._match(Fe.tokens.period) && (t += `.${this._consume(Fe.tokens.ident, "Expected diagnostic message.").toString()}`), this._consume(Fe.tokens.paren_right, "Expected ')'"), this._updateNode(new nO(e.toString(), t));
  }
  _enable_directive() {
    const e = this._consume(Fe.tokens.ident, "identity expected.");
    return this._updateNode(new S7(e.toString()));
  }
  _requires_directive() {
    const e = [this._consume(Fe.tokens.ident, "identity expected.").toString()];
    for (; this._match(Fe.tokens.comma); ) {
      const t = this._consume(Fe.tokens.ident, "identity expected.");
      e.push(t.toString());
    }
    return this._updateNode(new I7(e));
  }
  _type_alias() {
    const e = this._consume(Fe.tokens.ident, "identity expected.");
    this._consume(Fe.tokens.equal, "Expected '=' for type alias.");
    let t = this._type_decl();
    if (t === null) throw this._error(this._peek(), "Expected Type for Alias.");
    this._context.aliases.has(t.name) && (t = this._context.aliases.get(t.name).type);
    const n = this._updateNode(new bx(e.toString(), t));
    return this._context.aliases.set(n.name, n), n;
  }
  _type_decl() {
    if (this._check([Fe.tokens.ident, ...Fe.texel_format, Fe.keywords.bool, Fe.keywords.f32, Fe.keywords.i32, Fe.keywords.u32])) {
      const n = this._advance().toString();
      if (this._context.structs.has(n)) return this._context.structs.get(n);
      if (this._context.aliases.has(n)) return this._context.aliases.get(n).type;
      if (!this._getType(n)) {
        const i = this._updateNode(new YE(n));
        return this._forwardTypeCount++, i;
      }
      return this._updateNode(new $t(n));
    }
    let e = this._texture_sampler_types();
    if (e) return e;
    if (this._check(Fe.template_types)) {
      let n = this._advance().toString(), i = null, s = null;
      return this._match(Fe.tokens.less_than) && (i = this._type_decl(), s = null, this._match(Fe.tokens.comma) && (s = this._consume(Fe.access_mode, "Expected access_mode for pointer").toString()), this._consume(Fe.tokens.greater_than, "Expected '>' for type.")), this._updateNode(new mt(n, i, s));
    }
    if (this._match(Fe.keywords.ptr)) {
      let n = this._previous().toString();
      this._consume(Fe.tokens.less_than, "Expected '<' for pointer.");
      const i = this._consume(Fe.storage_class, "Expected storage_class for pointer");
      this._consume(Fe.tokens.comma, "Expected ',' for pointer.");
      const s = this._type_decl();
      let o = null;
      return this._match(Fe.tokens.comma) && (o = this._consume(Fe.access_mode, "Expected access_mode for pointer").toString()), this._consume(Fe.tokens.greater_than, "Expected '>' for pointer."), this._updateNode(new _m(n, i.toString(), s, o));
    }
    const t = this._attribute();
    if (this._match(Fe.keywords.array)) {
      let n = null, i = -1;
      const s = this._previous();
      let o = null;
      if (this._match(Fe.tokens.less_than)) {
        n = this._type_decl(), this._context.aliases.has(n.name) && (n = this._context.aliases.get(n.name).type);
        let u = "";
        if (this._match(Fe.tokens.comma)) {
          o = this._shift_expression();
          try {
            u = o.constEvaluate(this._exec).toString(), o = null;
          } catch {
            u = "1";
          }
        }
        this._consume(Fe.tokens.greater_than, "Expected '>' for array."), i = u ? parseInt(u) : 0;
      }
      const l = this._updateNode(new zA(s.toString(), t, n, i));
      return o && this._deferArrayCountEval.push({ arrayType: l, countNode: o }), l;
    }
    return null;
  }
  _texture_sampler_types() {
    if (this._match(Fe.sampler_type)) return this._updateNode(new MA(this._previous().toString(), null, null));
    if (this._match(Fe.depth_texture_type)) return this._updateNode(new MA(this._previous().toString(), null, null));
    if (this._match(Fe.sampled_texture_type) || this._match(Fe.multisampled_texture_type)) {
      const e = this._previous();
      this._consume(Fe.tokens.less_than, "Expected '<' for sampler type.");
      const t = this._type_decl();
      return this._consume(Fe.tokens.greater_than, "Expected '>' for sampler type."), this._updateNode(new MA(e.toString(), t, null));
    }
    if (this._match(Fe.storage_texture_type)) {
      const e = this._previous();
      this._consume(Fe.tokens.less_than, "Expected '<' for sampler type.");
      const t = this._consume(Fe.texel_format, "Invalid texel format.").toString();
      this._consume(Fe.tokens.comma, "Expected ',' after texel format.");
      const n = this._consume(Fe.access_mode, "Expected access mode for storage texture type.").toString();
      return this._consume(Fe.tokens.greater_than, "Expected '>' for sampler type."), this._updateNode(new MA(e.toString(), t, n));
    }
    return null;
  }
  _attribute() {
    let e = [];
    for (; this._match(Fe.tokens.attr); ) {
      const t = this._consume(Fe.attribute_name, "Expected attribute name"), n = this._updateNode(new hO(t.toString(), null));
      if (this._match(Fe.tokens.paren_left)) {
        if (n.value = this._consume(Fe.literal_or_ident, "Expected attribute value").toString(), this._check(Fe.tokens.comma)) {
          this._advance();
          do {
            const i = this._consume(Fe.literal_or_ident, "Expected attribute value").toString();
            n.value instanceof Array || (n.value = [n.value]), n.value.push(i);
          } while (this._match(Fe.tokens.comma));
        }
        this._consume(Fe.tokens.paren_right, "Expected ')'");
      }
      e.push(n);
    }
    return e.length == 0 ? null : e;
  }
}
class G7 extends nc {
  constructor(e) {
    super(), e && this.update(e);
  }
  update(e) {
    const t = new H7().parse(e);
    this.updateAST(t);
  }
}
function W7(r) {
  const e = { attributes: [], bindings: [] };
  let t;
  try {
    t = $7(r);
  } catch (s) {
    return qt.error(s.message)(), e;
  }
  for (const s of t.uniforms) {
    const o = [];
    for (const l of s.type?.members || [])
      o.push({
        name: l.name,
        type: tC(l.type)
      });
    e.bindings.push({
      type: "uniform",
      name: s.name,
      group: s.group,
      location: s.binding,
      // @ts-expect-error TODO - unused for now but needs fixing
      members: o
    });
  }
  for (const s of t.textures)
    e.bindings.push({
      type: "texture",
      name: s.name,
      group: s.group,
      location: s.binding
    });
  for (const s of t.samplers)
    e.bindings.push({
      type: "sampler",
      name: s.name,
      group: s.group,
      location: s.binding
    });
  const n = t.entry.vertex[0], i = n?.inputs.length || 0;
  for (let s = 0; s < i; s++) {
    const o = n.inputs[s];
    if (o.locationType === "location") {
      const l = tC(o.type);
      e.attributes.push({
        name: o.name,
        location: Number(o.location),
        type: l
      });
    }
  }
  return e;
}
function tC(r) {
  return r?.format ? `${r.name}<${r.format.name}>` : r.name;
}
function $7(r) {
  try {
    return new G7(r);
  } catch (e) {
    if (e instanceof Error)
      throw e;
    let t = "WGSL parse error";
    throw typeof e == "object" && e?.message && (t += `: ${e.message} `), typeof e == "object" && e?.token && (t += e.token.line || ""), new Error(t, { cause: e });
  }
}
const q7 = 1 / Math.PI * 180, X7 = 1 / 180 * Math.PI, Z7 = {
  EPSILON: 1e-12,
  debug: !1,
  precision: 4,
  printTypes: !1,
  printDegrees: !1,
  printRowMajor: !0,
  _cartographicRadians: !1
};
globalThis.mathgl = globalThis.mathgl || { config: { ...Z7 } };
const Ss = globalThis.mathgl.config;
function Y7(r, { precision: e = Ss.precision } = {}) {
  return r = eV(r), `${parseFloat(r.toPrecision(e))}`;
}
function Zu(r) {
  return Array.isArray(r) || ArrayBuffer.isView(r) && !(r instanceof DataView);
}
function K7(r) {
  return J7(r);
}
function Q7(r) {
  return cl(r);
}
function J7(r, e) {
  return Sx(r, (t) => t * X7, e);
}
function cl(r, e) {
  return Sx(r, (t) => t * q7, e);
}
function $c(r, e, t) {
  return Sx(r, (n) => Math.max(e, Math.min(t, n)));
}
function ml(r, e, t) {
  return Zu(r) ? r.map((n, i) => ml(n, e[i], t)) : t * e + (1 - t) * r;
}
function Aa(r, e, t) {
  const n = Ss.EPSILON;
  t && (Ss.EPSILON = t);
  try {
    if (r === e)
      return !0;
    if (Zu(r) && Zu(e)) {
      if (r.length !== e.length)
        return !1;
      for (let i = 0; i < r.length; ++i)
        if (!Aa(r[i], e[i]))
          return !1;
      return !0;
    }
    return r && r.equals ? r.equals(e) : e && e.equals ? e.equals(r) : typeof r == "number" && typeof e == "number" ? Math.abs(r - e) <= Ss.EPSILON * Math.max(1, Math.abs(r), Math.abs(e)) : !1;
  } finally {
    Ss.EPSILON = n;
  }
}
function eV(r) {
  return Math.round(r / Ss.EPSILON) * Ss.EPSILON;
}
function tV(r) {
  return r.clone ? r.clone() : new Array(r.length);
}
function Sx(r, e, t) {
  if (Zu(r)) {
    const n = r;
    t = t || tV(n);
    for (let i = 0; i < t.length && i < n.length; ++i) {
      const s = typeof r == "number" ? r : r[i];
      t[i] = e(s, i, t);
    }
    return t;
  }
  return e(r);
}
class Ix extends Array {
  // Common methods
  /**
   * Clone the current object
   * @returns a new copy of this object
   */
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < this.ELEMENTS; ++n)
      this[n] = e[n + t];
    return this.check();
  }
  toArray(e = [], t = 0) {
    for (let n = 0; n < this.ELEMENTS; ++n)
      e[t + n] = this[n];
    return e;
  }
  toObject(e) {
    return e;
  }
  from(e) {
    return Array.isArray(e) ? this.copy(e) : (
      // @ts-ignore
      this.fromObject(e)
    );
  }
  to(e) {
    return e === this ? this : Zu(e) ? this.toArray(e) : this.toObject(e);
  }
  toTarget(e) {
    return e ? this.to(e) : this;
  }
  /** @deprecated */
  toFloat32Array() {
    return new Float32Array(this);
  }
  toString() {
    return this.formatString(Ss);
  }
  /** Formats string according to options */
  formatString(e) {
    let t = "";
    for (let n = 0; n < this.ELEMENTS; ++n)
      t += (n > 0 ? ", " : "") + Y7(this[n], e);
    return `${e.printTypes ? this.constructor.name : ""}[${t}]`;
  }
  equals(e) {
    if (!e || this.length !== e.length)
      return !1;
    for (let t = 0; t < this.ELEMENTS; ++t)
      if (!Aa(this[t], e[t]))
        return !1;
    return !0;
  }
  exactEquals(e) {
    if (!e || this.length !== e.length)
      return !1;
    for (let t = 0; t < this.ELEMENTS; ++t)
      if (this[t] !== e[t])
        return !1;
    return !0;
  }
  // Modifiers
  /** Negates all values in this object */
  negate() {
    for (let e = 0; e < this.ELEMENTS; ++e)
      this[e] = -this[e];
    return this.check();
  }
  lerp(e, t, n) {
    if (n === void 0)
      return this.lerp(this, e, t);
    for (let i = 0; i < this.ELEMENTS; ++i) {
      const s = e[i], o = typeof t == "number" ? t : t[i];
      this[i] = s + n * (o - s);
    }
    return this.check();
  }
  /** Minimal */
  min(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] = Math.min(e[t], this[t]);
    return this.check();
  }
  /** Maximal */
  max(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] = Math.max(e[t], this[t]);
    return this.check();
  }
  clamp(e, t) {
    for (let n = 0; n < this.ELEMENTS; ++n)
      this[n] = Math.min(Math.max(this[n], e[n]), t[n]);
    return this.check();
  }
  add(...e) {
    for (const t of e)
      for (let n = 0; n < this.ELEMENTS; ++n)
        this[n] += t[n];
    return this.check();
  }
  subtract(...e) {
    for (const t of e)
      for (let n = 0; n < this.ELEMENTS; ++n)
        this[n] -= t[n];
    return this.check();
  }
  scale(e) {
    if (typeof e == "number")
      for (let t = 0; t < this.ELEMENTS; ++t)
        this[t] *= e;
    else
      for (let t = 0; t < this.ELEMENTS && t < e.length; ++t)
        this[t] *= e[t];
    return this.check();
  }
  /**
   * Multiplies all elements by `scale`
   * Note: `Matrix4.multiplyByScalar` only scales its 3x3 "minor"
   */
  multiplyByScalar(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] *= e;
    return this.check();
  }
  // Debug checks
  /** Throws an error if array length is incorrect or contains illegal values */
  check() {
    if (Ss.debug && !this.validate())
      throw new Error(`math.gl: ${this.constructor.name} some fields set to invalid numbers'`);
    return this;
  }
  /** Returns false if the array length is incorrect or contains illegal values */
  validate() {
    let e = this.length === this.ELEMENTS;
    for (let t = 0; t < this.ELEMENTS; ++t)
      e = e && Number.isFinite(this[t]);
    return e;
  }
  // three.js compatibility
  /** @deprecated */
  sub(e) {
    return this.subtract(e);
  }
  /** @deprecated */
  setScalar(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] = e;
    return this.check();
  }
  /** @deprecated */
  addScalar(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] += e;
    return this.check();
  }
  /** @deprecated */
  subScalar(e) {
    return this.addScalar(-e);
  }
  /** @deprecated */
  multiplyScalar(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] *= e;
    return this.check();
  }
  /** @deprecated */
  divideScalar(e) {
    return this.multiplyByScalar(1 / e);
  }
  /** @deprecated */
  clampScalar(e, t) {
    for (let n = 0; n < this.ELEMENTS; ++n)
      this[n] = Math.min(Math.max(this[n], e), t);
    return this.check();
  }
  /** @deprecated */
  get elements() {
    return this;
  }
}
function rV(r, e) {
  if (r.length !== e)
    return !1;
  for (let t = 0; t < r.length; ++t)
    if (!Number.isFinite(r[t]))
      return !1;
  return !0;
}
function Qn(r) {
  if (!Number.isFinite(r))
    throw new Error(`Invalid number ${JSON.stringify(r)}`);
  return r;
}
function VA(r, e, t = "") {
  if (Ss.debug && !rV(r, e))
    throw new Error(`math.gl: ${t} some fields set to invalid numbers'`);
  return r;
}
function fl(r, e) {
  if (!r)
    throw new Error(`math.gl assertion ${e}`);
}
class Px extends Ix {
  // ACCESSORS
  get x() {
    return this[0];
  }
  set x(e) {
    this[0] = Qn(e);
  }
  get y() {
    return this[1];
  }
  set y(e) {
    this[1] = Qn(e);
  }
  /**
   * Returns the length of the vector from the origin to the point described by this vector
   *
   * @note `length` is a reserved word for Arrays, so `v.length()` will return number of elements
   * Instead we provide `len` and `magnitude`
   */
  len() {
    return Math.sqrt(this.lengthSquared());
  }
  /**
   * Returns the length of the vector from the origin to the point described by this vector
   */
  magnitude() {
    return this.len();
  }
  /**
   * Returns the squared length of the vector from the origin to the point described by this vector
   */
  lengthSquared() {
    let e = 0;
    for (let t = 0; t < this.ELEMENTS; ++t)
      e += this[t] * this[t];
    return e;
  }
  /**
   * Returns the squared length of the vector from the origin to the point described by this vector
   */
  magnitudeSquared() {
    return this.lengthSquared();
  }
  distance(e) {
    return Math.sqrt(this.distanceSquared(e));
  }
  distanceSquared(e) {
    let t = 0;
    for (let n = 0; n < this.ELEMENTS; ++n) {
      const i = this[n] - e[n];
      t += i * i;
    }
    return Qn(t);
  }
  dot(e) {
    let t = 0;
    for (let n = 0; n < this.ELEMENTS; ++n)
      t += this[n] * e[n];
    return Qn(t);
  }
  // MODIFIERS
  normalize() {
    const e = this.magnitude();
    if (e !== 0)
      for (let t = 0; t < this.ELEMENTS; ++t)
        this[t] /= e;
    return this.check();
  }
  multiply(...e) {
    for (const t of e)
      for (let n = 0; n < this.ELEMENTS; ++n)
        this[n] *= t[n];
    return this.check();
  }
  divide(...e) {
    for (const t of e)
      for (let n = 0; n < this.ELEMENTS; ++n)
        this[n] /= t[n];
    return this.check();
  }
  // THREE.js compatibility
  lengthSq() {
    return this.lengthSquared();
  }
  distanceTo(e) {
    return this.distance(e);
  }
  distanceToSquared(e) {
    return this.distanceSquared(e);
  }
  getComponent(e) {
    return fl(e >= 0 && e < this.ELEMENTS, "index is out of range"), Qn(this[e]);
  }
  setComponent(e, t) {
    return fl(e >= 0 && e < this.ELEMENTS, "index is out of range"), this[e] = t, this.check();
  }
  addVectors(e, t) {
    return this.copy(e).add(t);
  }
  subVectors(e, t) {
    return this.copy(e).subtract(t);
  }
  multiplyVectors(e, t) {
    return this.copy(e).multiply(t);
  }
  addScaledVector(e, t) {
    return this.add(new this.constructor(e).multiplyScalar(t));
  }
}
const jA = 1e-6;
let vl = typeof Float32Array < "u" ? Float32Array : Array;
function nV() {
  const r = new vl(2);
  return vl != Float32Array && (r[0] = 0, r[1] = 0), r;
}
function rC(r, e, t) {
  return r[0] = e[0] + t[0], r[1] = e[1] + t[1], r;
}
function iV(r, e) {
  return r[0] = -e[0], r[1] = -e[1], r;
}
function dO(r, e, t, n) {
  const i = e[0], s = e[1];
  return r[0] = i + n * (t[0] - i), r[1] = s + n * (t[1] - s), r;
}
function sV(r, e, t) {
  const n = e[0], i = e[1];
  return r[0] = t[0] * n + t[2] * i, r[1] = t[1] * n + t[3] * i, r;
}
function oV(r, e, t) {
  const n = e[0], i = e[1];
  return r[0] = t[0] * n + t[2] * i + t[4], r[1] = t[1] * n + t[3] * i + t[5], r;
}
function pO(r, e, t) {
  const n = e[0], i = e[1];
  return r[0] = t[0] * n + t[3] * i + t[6], r[1] = t[1] * n + t[4] * i + t[7], r;
}
function AO(r, e, t) {
  const n = e[0], i = e[1];
  return r[0] = t[0] * n + t[4] * i + t[12], r[1] = t[1] * n + t[5] * i + t[13], r;
}
(function() {
  const r = nV();
  return function(e, t, n, i, s, o) {
    let l, u;
    for (t || (t = 2), n || (n = 0), i ? u = Math.min(i * t + n, e.length) : u = e.length, l = n; l < u; l += t)
      r[0] = e[l], r[1] = e[l + 1], s(r, r, o), e[l] = r[0], e[l + 1] = r[1];
    return e;
  };
})();
function gO(r, e, t) {
  const n = e[0], i = e[1], s = t[3] * n + t[7] * i || 1;
  return r[0] = (t[0] * n + t[4] * i) / s, r[1] = (t[1] * n + t[5] * i) / s, r;
}
function mO(r, e, t) {
  const n = e[0], i = e[1], s = e[2], o = t[3] * n + t[7] * i + t[11] * s || 1;
  return r[0] = (t[0] * n + t[4] * i + t[8] * s) / o, r[1] = (t[1] * n + t[5] * i + t[9] * s) / o, r[2] = (t[2] * n + t[6] * i + t[10] * s) / o, r;
}
function aV(r, e, t) {
  const n = e[0], i = e[1];
  return r[0] = t[0] * n + t[2] * i, r[1] = t[1] * n + t[3] * i, r[2] = e[2], r;
}
function lV(r, e, t) {
  const n = e[0], i = e[1];
  return r[0] = t[0] * n + t[2] * i, r[1] = t[1] * n + t[3] * i, r[2] = e[2], r[3] = e[3], r;
}
function _O(r, e, t) {
  const n = e[0], i = e[1], s = e[2];
  return r[0] = t[0] * n + t[3] * i + t[6] * s, r[1] = t[1] * n + t[4] * i + t[7] * s, r[2] = t[2] * n + t[5] * i + t[8] * s, r[3] = e[3], r;
}
class Mx extends Px {
  // Creates a new, empty vec2
  constructor(e = 0, t = 0) {
    super(2), Zu(e) && arguments.length === 1 ? this.copy(e) : (Ss.debug && (Qn(e), Qn(t)), this[0] = e, this[1] = t);
  }
  set(e, t) {
    return this[0] = e, this[1] = t, this.check();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this.check();
  }
  fromObject(e) {
    return Ss.debug && (Qn(e.x), Qn(e.y)), this[0] = e.x, this[1] = e.y, this.check();
  }
  toObject(e) {
    return e.x = this[0], e.y = this[1], e;
  }
  // Getters/setters
  get ELEMENTS() {
    return 2;
  }
  /**
   * Returns angle from x axis
   * @returns
   */
  horizontalAngle() {
    return Math.atan2(this.y, this.x);
  }
  /**
   * Returns angle from y axis
   * @returns
   */
  verticalAngle() {
    return Math.atan2(this.x, this.y);
  }
  // Transforms
  /**
   * Transforms as point
   * @param matrix4
   * @returns
   */
  transform(e) {
    return this.transformAsPoint(e);
  }
  /**
   * transforms as point (4th component is implicitly 1)
   * @param matrix4
   * @returns
   */
  transformAsPoint(e) {
    return AO(this, this, e), this.check();
  }
  /**
   * transforms as vector (4th component is implicitly 0, ignores translation. slightly faster)
   * @param matrix4
   * @returns
   */
  transformAsVector(e) {
    return gO(this, this, e), this.check();
  }
  transformByMatrix3(e) {
    return pO(this, this, e), this.check();
  }
  transformByMatrix2x3(e) {
    return oV(this, this, e), this.check();
  }
  transformByMatrix2(e) {
    return sV(this, this, e), this.check();
  }
}
function yO() {
  const r = new vl(3);
  return vl != Float32Array && (r[0] = 0, r[1] = 0, r[2] = 0), r;
}
function vO(r) {
  const e = r[0], t = r[1], n = r[2];
  return Math.sqrt(e * e + t * t + n * n);
}
function nC(r, e, t) {
  const n = new vl(3);
  return n[0] = r, n[1] = e, n[2] = t, n;
}
function cV(r, e, t) {
  return r[0] = e[0] - t[0], r[1] = e[1] - t[1], r[2] = e[2] - t[2], r;
}
function uV(r) {
  const e = r[0], t = r[1], n = r[2];
  return e * e + t * t + n * n;
}
function fV(r, e) {
  return r[0] = -e[0], r[1] = -e[1], r[2] = -e[2], r;
}
function hV(r, e) {
  const t = e[0], n = e[1], i = e[2];
  let s = t * t + n * n + i * i;
  return s > 0 && (s = 1 / Math.sqrt(s)), r[0] = e[0] * s, r[1] = e[1] * s, r[2] = e[2] * s, r;
}
function Rx(r, e) {
  return r[0] * e[0] + r[1] * e[1] + r[2] * e[2];
}
function vm(r, e, t) {
  const n = e[0], i = e[1], s = e[2], o = t[0], l = t[1], u = t[2];
  return r[0] = i * u - s * l, r[1] = s * o - n * u, r[2] = n * l - i * o, r;
}
function dV(r, e, t, n) {
  const i = e[0], s = e[1], o = e[2];
  return r[0] = i + n * (t[0] - i), r[1] = s + n * (t[1] - s), r[2] = o + n * (t[2] - o), r;
}
function Bx(r, e, t) {
  const n = e[0], i = e[1], s = e[2];
  let o = t[3] * n + t[7] * i + t[11] * s + t[15];
  return o = o || 1, r[0] = (t[0] * n + t[4] * i + t[8] * s + t[12]) / o, r[1] = (t[1] * n + t[5] * i + t[9] * s + t[13]) / o, r[2] = (t[2] * n + t[6] * i + t[10] * s + t[14]) / o, r;
}
function bO(r, e, t) {
  const n = e[0], i = e[1], s = e[2];
  return r[0] = n * t[0] + i * t[3] + s * t[6], r[1] = n * t[1] + i * t[4] + s * t[7], r[2] = n * t[2] + i * t[5] + s * t[8], r;
}
function xO(r, e, t) {
  const n = t[0], i = t[1], s = t[2], o = t[3], l = e[0], u = e[1], m = e[2];
  let y = i * m - s * u, E = s * l - n * m, P = n * u - i * l, L = i * P - s * E, U = s * y - n * P, V = n * E - i * y;
  const q = o * 2;
  return y *= q, E *= q, P *= q, L *= 2, U *= 2, V *= 2, r[0] = l + y + L, r[1] = u + E + U, r[2] = m + P + V, r;
}
function pV(r, e, t, n) {
  const i = [], s = [];
  return i[0] = e[0] - t[0], i[1] = e[1] - t[1], i[2] = e[2] - t[2], s[0] = i[0], s[1] = i[1] * Math.cos(n) - i[2] * Math.sin(n), s[2] = i[1] * Math.sin(n) + i[2] * Math.cos(n), r[0] = s[0] + t[0], r[1] = s[1] + t[1], r[2] = s[2] + t[2], r;
}
function AV(r, e, t, n) {
  const i = [], s = [];
  return i[0] = e[0] - t[0], i[1] = e[1] - t[1], i[2] = e[2] - t[2], s[0] = i[2] * Math.sin(n) + i[0] * Math.cos(n), s[1] = i[1], s[2] = i[2] * Math.cos(n) - i[0] * Math.sin(n), r[0] = s[0] + t[0], r[1] = s[1] + t[1], r[2] = s[2] + t[2], r;
}
function gV(r, e, t, n) {
  const i = [], s = [];
  return i[0] = e[0] - t[0], i[1] = e[1] - t[1], i[2] = e[2] - t[2], s[0] = i[0] * Math.cos(n) - i[1] * Math.sin(n), s[1] = i[0] * Math.sin(n) + i[1] * Math.cos(n), s[2] = i[2], r[0] = s[0] + t[0], r[1] = s[1] + t[1], r[2] = s[2] + t[2], r;
}
function mV(r, e) {
  const t = r[0], n = r[1], i = r[2], s = e[0], o = e[1], l = e[2], u = Math.sqrt((t * t + n * n + i * i) * (s * s + o * o + l * l)), m = u && Rx(r, e) / u;
  return Math.acos(Math.min(Math.max(m, -1), 1));
}
const wO = cV, TO = vO, Sv = uV;
(function() {
  const r = yO();
  return function(e, t, n, i, s, o) {
    let l, u;
    for (t || (t = 3), n || (n = 0), i ? u = Math.min(i * t + n, e.length) : u = e.length, l = n; l < u; l += t)
      r[0] = e[l], r[1] = e[l + 1], r[2] = e[l + 2], s(r, r, o), e[l] = r[0], e[l + 1] = r[1], e[l + 2] = r[2];
    return e;
  };
})();
const Iv = [0, 0, 0];
let _g;
class yt extends Px {
  static get ZERO() {
    return _g || (_g = new yt(0, 0, 0), Object.freeze(_g)), _g;
  }
  /**
   * @class
   * @param x
   * @param y
   * @param z
   */
  constructor(e = 0, t = 0, n = 0) {
    super(-0, -0, -0), arguments.length === 1 && Zu(e) ? this.copy(e) : (Ss.debug && (Qn(e), Qn(t), Qn(n)), this[0] = e, this[1] = t, this[2] = n);
  }
  set(e, t, n) {
    return this[0] = e, this[1] = t, this[2] = n, this.check();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this.check();
  }
  fromObject(e) {
    return Ss.debug && (Qn(e.x), Qn(e.y), Qn(e.z)), this[0] = e.x, this[1] = e.y, this[2] = e.z, this.check();
  }
  toObject(e) {
    return e.x = this[0], e.y = this[1], e.z = this[2], e;
  }
  // Getters/setters
  get ELEMENTS() {
    return 3;
  }
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = Qn(e);
  }
  // ACCESSORS
  angle(e) {
    return mV(this, e);
  }
  // MODIFIERS
  cross(e) {
    return vm(this, this, e), this.check();
  }
  rotateX({ radians: e, origin: t = Iv }) {
    return pV(this, this, t, e), this.check();
  }
  rotateY({ radians: e, origin: t = Iv }) {
    return AV(this, this, t, e), this.check();
  }
  rotateZ({ radians: e, origin: t = Iv }) {
    return gV(this, this, t, e), this.check();
  }
  // Transforms
  // transforms as point (4th component is implicitly 1)
  transform(e) {
    return this.transformAsPoint(e);
  }
  // transforms as point (4th component is implicitly 1)
  transformAsPoint(e) {
    return Bx(this, this, e), this.check();
  }
  // transforms as vector  (4th component is implicitly 0, ignores translation. slightly faster)
  transformAsVector(e) {
    return mO(this, this, e), this.check();
  }
  transformByMatrix3(e) {
    return bO(this, this, e), this.check();
  }
  transformByMatrix2(e) {
    return aV(this, this, e), this.check();
  }
  transformByQuaternion(e) {
    return xO(this, this, e), this.check();
  }
}
let yg;
class Ox extends Px {
  static get ZERO() {
    return yg || (yg = new Ox(0, 0, 0, 0), Object.freeze(yg)), yg;
  }
  constructor(e = 0, t = 0, n = 0, i = 0) {
    super(-0, -0, -0, -0), Zu(e) && arguments.length === 1 ? this.copy(e) : (Ss.debug && (Qn(e), Qn(t), Qn(n), Qn(i)), this[0] = e, this[1] = t, this[2] = n, this[3] = i);
  }
  set(e, t, n, i) {
    return this[0] = e, this[1] = t, this[2] = n, this[3] = i, this.check();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this.check();
  }
  fromObject(e) {
    return Ss.debug && (Qn(e.x), Qn(e.y), Qn(e.z), Qn(e.w)), this[0] = e.x, this[1] = e.y, this[2] = e.z, this[3] = e.w, this;
  }
  toObject(e) {
    return e.x = this[0], e.y = this[1], e.z = this[2], e.w = this[3], e;
  }
  // Getters/setters
  /* eslint-disable no-multi-spaces, brace-style, no-return-assign */
  get ELEMENTS() {
    return 4;
  }
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = Qn(e);
  }
  get w() {
    return this[3];
  }
  set w(e) {
    this[3] = Qn(e);
  }
  transform(e) {
    return Bx(this, this, e), this.check();
  }
  transformByMatrix3(e) {
    return _O(this, this, e), this.check();
  }
  transformByMatrix2(e) {
    return lV(this, this, e), this.check();
  }
  transformByQuaternion(e) {
    return xO(this, this, e), this.check();
  }
  // three.js compatibility
  applyMatrix4(e) {
    return e.transform(this, this), this;
  }
}
class EO extends Ix {
  // fromObject(object) {
  //   const array = object.elements;
  //   return this.fromRowMajor(array);
  // }
  // toObject(object) {
  //   const array = object.elements;
  //   this.toRowMajor(array);
  //   return object;
  // }
  // TODO better override formatString?
  toString() {
    let e = "[";
    if (Ss.printRowMajor) {
      e += "row-major:";
      for (let t = 0; t < this.RANK; ++t)
        for (let n = 0; n < this.RANK; ++n)
          e += ` ${this[n * this.RANK + t]}`;
    } else {
      e += "column-major:";
      for (let t = 0; t < this.ELEMENTS; ++t)
        e += ` ${this[t]}`;
    }
    return e += "]", e;
  }
  getElementIndex(e, t) {
    return t * this.RANK + e;
  }
  // By default assumes row major indices
  getElement(e, t) {
    return this[t * this.RANK + e];
  }
  // By default assumes row major indices
  setElement(e, t, n) {
    return this[t * this.RANK + e] = Qn(n), this;
  }
  getColumn(e, t = new Array(this.RANK).fill(-0)) {
    const n = e * this.RANK;
    for (let i = 0; i < this.RANK; ++i)
      t[i] = this[n + i];
    return t;
  }
  setColumn(e, t) {
    const n = e * this.RANK;
    for (let i = 0; i < this.RANK; ++i)
      this[n + i] = t[i];
    return this;
  }
}
function _V() {
  const r = new vl(9);
  return vl != Float32Array && (r[1] = 0, r[2] = 0, r[3] = 0, r[5] = 0, r[6] = 0, r[7] = 0), r[0] = 1, r[4] = 1, r[8] = 1, r;
}
function yV(r, e) {
  if (r === e) {
    const t = e[1], n = e[2], i = e[5];
    r[1] = e[3], r[2] = e[6], r[3] = t, r[5] = e[7], r[6] = n, r[7] = i;
  } else
    r[0] = e[0], r[1] = e[3], r[2] = e[6], r[3] = e[1], r[4] = e[4], r[5] = e[7], r[6] = e[2], r[7] = e[5], r[8] = e[8];
  return r;
}
function vV(r, e) {
  const t = e[0], n = e[1], i = e[2], s = e[3], o = e[4], l = e[5], u = e[6], m = e[7], y = e[8], E = y * o - l * m, P = -y * s + l * u, L = m * s - o * u;
  let U = t * E + n * P + i * L;
  return U ? (U = 1 / U, r[0] = E * U, r[1] = (-y * n + i * m) * U, r[2] = (l * n - i * o) * U, r[3] = P * U, r[4] = (y * t - i * u) * U, r[5] = (-l * t + i * s) * U, r[6] = L * U, r[7] = (-m * t + n * u) * U, r[8] = (o * t - n * s) * U, r) : null;
}
function bV(r) {
  const e = r[0], t = r[1], n = r[2], i = r[3], s = r[4], o = r[5], l = r[6], u = r[7], m = r[8];
  return e * (m * s - o * u) + t * (-m * i + o * l) + n * (u * i - s * l);
}
function iC(r, e, t) {
  const n = e[0], i = e[1], s = e[2], o = e[3], l = e[4], u = e[5], m = e[6], y = e[7], E = e[8], P = t[0], L = t[1], U = t[2], V = t[3], q = t[4], j = t[5], K = t[6], Y = t[7], de = t[8];
  return r[0] = P * n + L * o + U * m, r[1] = P * i + L * l + U * y, r[2] = P * s + L * u + U * E, r[3] = V * n + q * o + j * m, r[4] = V * i + q * l + j * y, r[5] = V * s + q * u + j * E, r[6] = K * n + Y * o + de * m, r[7] = K * i + Y * l + de * y, r[8] = K * s + Y * u + de * E, r;
}
function xV(r, e, t) {
  const n = e[0], i = e[1], s = e[2], o = e[3], l = e[4], u = e[5], m = e[6], y = e[7], E = e[8], P = t[0], L = t[1];
  return r[0] = n, r[1] = i, r[2] = s, r[3] = o, r[4] = l, r[5] = u, r[6] = P * n + L * o + m, r[7] = P * i + L * l + y, r[8] = P * s + L * u + E, r;
}
function wV(r, e, t) {
  const n = e[0], i = e[1], s = e[2], o = e[3], l = e[4], u = e[5], m = e[6], y = e[7], E = e[8], P = Math.sin(t), L = Math.cos(t);
  return r[0] = L * n + P * o, r[1] = L * i + P * l, r[2] = L * s + P * u, r[3] = L * o - P * n, r[4] = L * l - P * i, r[5] = L * u - P * s, r[6] = m, r[7] = y, r[8] = E, r;
}
function sC(r, e, t) {
  const n = t[0], i = t[1];
  return r[0] = n * e[0], r[1] = n * e[1], r[2] = n * e[2], r[3] = i * e[3], r[4] = i * e[4], r[5] = i * e[5], r[6] = e[6], r[7] = e[7], r[8] = e[8], r;
}
function TV(r, e) {
  const t = e[0], n = e[1], i = e[2], s = e[3], o = t + t, l = n + n, u = i + i, m = t * o, y = n * o, E = n * l, P = i * o, L = i * l, U = i * u, V = s * o, q = s * l, j = s * u;
  return r[0] = 1 - E - U, r[3] = y - j, r[6] = P + q, r[1] = y + j, r[4] = 1 - m - U, r[7] = L - V, r[2] = P - q, r[5] = L + V, r[8] = 1 - m - E, r;
}
var Pb;
(function(r) {
  r[r.COL0ROW0 = 0] = "COL0ROW0", r[r.COL0ROW1 = 1] = "COL0ROW1", r[r.COL0ROW2 = 2] = "COL0ROW2", r[r.COL1ROW0 = 3] = "COL1ROW0", r[r.COL1ROW1 = 4] = "COL1ROW1", r[r.COL1ROW2 = 5] = "COL1ROW2", r[r.COL2ROW0 = 6] = "COL2ROW0", r[r.COL2ROW1 = 7] = "COL2ROW1", r[r.COL2ROW2 = 8] = "COL2ROW2";
})(Pb || (Pb = {}));
const EV = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);
class es extends EO {
  static get IDENTITY() {
    return SV();
  }
  static get ZERO() {
    return CV();
  }
  get ELEMENTS() {
    return 9;
  }
  get RANK() {
    return 3;
  }
  get INDICES() {
    return Pb;
  }
  constructor(e, ...t) {
    super(-0, -0, -0, -0, -0, -0, -0, -0, -0), arguments.length === 1 && Array.isArray(e) ? this.copy(e) : t.length > 0 ? this.copy([e, ...t]) : this.identity();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this[4] = e[4], this[5] = e[5], this[6] = e[6], this[7] = e[7], this[8] = e[8], this.check();
  }
  // Constructors
  identity() {
    return this.copy(EV);
  }
  /**
   *
   * @param object
   * @returns self
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  fromObject(e) {
    return this.check();
  }
  /** Calculates a 3x3 matrix from the given quaternion
   * q quat  Quaternion to create matrix from
   */
  fromQuaternion(e) {
    return TV(this, e), this.check();
  }
  /**
   * accepts column major order, stores in column major order
   */
  // eslint-disable-next-line max-params
  set(e, t, n, i, s, o, l, u, m) {
    return this[0] = e, this[1] = t, this[2] = n, this[3] = i, this[4] = s, this[5] = o, this[6] = l, this[7] = u, this[8] = m, this.check();
  }
  /**
   * accepts row major order, stores as column major
   */
  // eslint-disable-next-line max-params
  setRowMajor(e, t, n, i, s, o, l, u, m) {
    return this[0] = e, this[1] = i, this[2] = l, this[3] = t, this[4] = s, this[5] = u, this[6] = n, this[7] = o, this[8] = m, this.check();
  }
  // Accessors
  determinant() {
    return bV(this);
  }
  // Modifiers
  transpose() {
    return yV(this, this), this.check();
  }
  /** Invert a matrix. Note that this can fail if the matrix is not invertible */
  invert() {
    return vV(this, this), this.check();
  }
  // Operations
  multiplyLeft(e) {
    return iC(this, e, this), this.check();
  }
  multiplyRight(e) {
    return iC(this, this, e), this.check();
  }
  rotate(e) {
    return wV(this, this, e), this.check();
  }
  scale(e) {
    return Array.isArray(e) ? sC(this, this, e) : sC(this, this, [e, e]), this.check();
  }
  translate(e) {
    return xV(this, this, e), this.check();
  }
  // Transforms
  transform(e, t) {
    let n;
    switch (e.length) {
      case 2:
        n = pO(t || [-0, -0], e, this);
        break;
      case 3:
        n = bO(t || [-0, -0, -0], e, this);
        break;
      case 4:
        n = _O(t || [-0, -0, -0, -0], e, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    return VA(n, e.length), n;
  }
  /** @deprecated */
  transformVector(e, t) {
    return this.transform(e, t);
  }
  /** @deprecated */
  transformVector2(e, t) {
    return this.transform(e, t);
  }
  /** @deprecated */
  transformVector3(e, t) {
    return this.transform(e, t);
  }
}
let vg, bg = null;
function CV() {
  return vg || (vg = new es([0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(vg)), vg;
}
function SV() {
  return bg || (bg = new es(), Object.freeze(bg)), bg;
}
function IV(r) {
  return r[0] = 1, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = 1, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 1, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1, r;
}
function PV(r, e) {
  if (r === e) {
    const t = e[1], n = e[2], i = e[3], s = e[6], o = e[7], l = e[11];
    r[1] = e[4], r[2] = e[8], r[3] = e[12], r[4] = t, r[6] = e[9], r[7] = e[13], r[8] = n, r[9] = s, r[11] = e[14], r[12] = i, r[13] = o, r[14] = l;
  } else
    r[0] = e[0], r[1] = e[4], r[2] = e[8], r[3] = e[12], r[4] = e[1], r[5] = e[5], r[6] = e[9], r[7] = e[13], r[8] = e[2], r[9] = e[6], r[10] = e[10], r[11] = e[14], r[12] = e[3], r[13] = e[7], r[14] = e[11], r[15] = e[15];
  return r;
}
function Mb(r, e) {
  const t = e[0], n = e[1], i = e[2], s = e[3], o = e[4], l = e[5], u = e[6], m = e[7], y = e[8], E = e[9], P = e[10], L = e[11], U = e[12], V = e[13], q = e[14], j = e[15], K = t * l - n * o, Y = t * u - i * o, de = t * m - s * o, ne = n * u - i * l, ae = n * m - s * l, De = i * m - s * u, Ge = y * V - E * U, fe = y * q - P * U, ve = y * j - L * U, me = E * q - P * V, X = E * j - L * V, re = P * j - L * q;
  let Me = K * re - Y * X + de * me + ne * ve - ae * fe + De * Ge;
  return Me ? (Me = 1 / Me, r[0] = (l * re - u * X + m * me) * Me, r[1] = (i * X - n * re - s * me) * Me, r[2] = (V * De - q * ae + j * ne) * Me, r[3] = (P * ae - E * De - L * ne) * Me, r[4] = (u * ve - o * re - m * fe) * Me, r[5] = (t * re - i * ve + s * fe) * Me, r[6] = (q * de - U * De - j * Y) * Me, r[7] = (y * De - P * de + L * Y) * Me, r[8] = (o * X - l * ve + m * Ge) * Me, r[9] = (n * ve - t * X - s * Ge) * Me, r[10] = (U * ae - V * de + j * K) * Me, r[11] = (E * de - y * ae - L * K) * Me, r[12] = (l * fe - o * me - u * Ge) * Me, r[13] = (t * me - n * fe + i * Ge) * Me, r[14] = (V * Y - U * ne - q * K) * Me, r[15] = (y * ne - E * Y + P * K) * Me, r) : null;
}
function MV(r) {
  const e = r[0], t = r[1], n = r[2], i = r[3], s = r[4], o = r[5], l = r[6], u = r[7], m = r[8], y = r[9], E = r[10], P = r[11], L = r[12], U = r[13], V = r[14], q = r[15], j = e * o - t * s, K = e * l - n * s, Y = t * l - n * o, de = m * U - y * L, ne = m * V - E * L, ae = y * V - E * U, De = e * ae - t * ne + n * de, Ge = s * ae - o * ne + l * de, fe = m * Y - y * K + E * j, ve = L * Y - U * K + V * j;
  return u * De - i * Ge + q * fe - P * ve;
}
function Yf(r, e, t) {
  const n = e[0], i = e[1], s = e[2], o = e[3], l = e[4], u = e[5], m = e[6], y = e[7], E = e[8], P = e[9], L = e[10], U = e[11], V = e[12], q = e[13], j = e[14], K = e[15];
  let Y = t[0], de = t[1], ne = t[2], ae = t[3];
  return r[0] = Y * n + de * l + ne * E + ae * V, r[1] = Y * i + de * u + ne * P + ae * q, r[2] = Y * s + de * m + ne * L + ae * j, r[3] = Y * o + de * y + ne * U + ae * K, Y = t[4], de = t[5], ne = t[6], ae = t[7], r[4] = Y * n + de * l + ne * E + ae * V, r[5] = Y * i + de * u + ne * P + ae * q, r[6] = Y * s + de * m + ne * L + ae * j, r[7] = Y * o + de * y + ne * U + ae * K, Y = t[8], de = t[9], ne = t[10], ae = t[11], r[8] = Y * n + de * l + ne * E + ae * V, r[9] = Y * i + de * u + ne * P + ae * q, r[10] = Y * s + de * m + ne * L + ae * j, r[11] = Y * o + de * y + ne * U + ae * K, Y = t[12], de = t[13], ne = t[14], ae = t[15], r[12] = Y * n + de * l + ne * E + ae * V, r[13] = Y * i + de * u + ne * P + ae * q, r[14] = Y * s + de * m + ne * L + ae * j, r[15] = Y * o + de * y + ne * U + ae * K, r;
}
function t_(r, e, t) {
  const n = t[0], i = t[1], s = t[2];
  let o, l, u, m, y, E, P, L, U, V, q, j;
  return e === r ? (r[12] = e[0] * n + e[4] * i + e[8] * s + e[12], r[13] = e[1] * n + e[5] * i + e[9] * s + e[13], r[14] = e[2] * n + e[6] * i + e[10] * s + e[14], r[15] = e[3] * n + e[7] * i + e[11] * s + e[15]) : (o = e[0], l = e[1], u = e[2], m = e[3], y = e[4], E = e[5], P = e[6], L = e[7], U = e[8], V = e[9], q = e[10], j = e[11], r[0] = o, r[1] = l, r[2] = u, r[3] = m, r[4] = y, r[5] = E, r[6] = P, r[7] = L, r[8] = U, r[9] = V, r[10] = q, r[11] = j, r[12] = o * n + y * i + U * s + e[12], r[13] = l * n + E * i + V * s + e[13], r[14] = u * n + P * i + q * s + e[14], r[15] = m * n + L * i + j * s + e[15]), r;
}
function Dx(r, e, t) {
  const n = t[0], i = t[1], s = t[2];
  return r[0] = e[0] * n, r[1] = e[1] * n, r[2] = e[2] * n, r[3] = e[3] * n, r[4] = e[4] * i, r[5] = e[5] * i, r[6] = e[6] * i, r[7] = e[7] * i, r[8] = e[8] * s, r[9] = e[9] * s, r[10] = e[10] * s, r[11] = e[11] * s, r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15], r;
}
function RV(r, e, t, n) {
  let i = n[0], s = n[1], o = n[2], l = Math.sqrt(i * i + s * s + o * o), u, m, y, E, P, L, U, V, q, j, K, Y, de, ne, ae, De, Ge, fe, ve, me, X, re, Me, ot;
  return l < jA ? null : (l = 1 / l, i *= l, s *= l, o *= l, m = Math.sin(t), u = Math.cos(t), y = 1 - u, E = e[0], P = e[1], L = e[2], U = e[3], V = e[4], q = e[5], j = e[6], K = e[7], Y = e[8], de = e[9], ne = e[10], ae = e[11], De = i * i * y + u, Ge = s * i * y + o * m, fe = o * i * y - s * m, ve = i * s * y - o * m, me = s * s * y + u, X = o * s * y + i * m, re = i * o * y + s * m, Me = s * o * y - i * m, ot = o * o * y + u, r[0] = E * De + V * Ge + Y * fe, r[1] = P * De + q * Ge + de * fe, r[2] = L * De + j * Ge + ne * fe, r[3] = U * De + K * Ge + ae * fe, r[4] = E * ve + V * me + Y * X, r[5] = P * ve + q * me + de * X, r[6] = L * ve + j * me + ne * X, r[7] = U * ve + K * me + ae * X, r[8] = E * re + V * Me + Y * ot, r[9] = P * re + q * Me + de * ot, r[10] = L * re + j * Me + ne * ot, r[11] = U * re + K * Me + ae * ot, e !== r && (r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r);
}
function CO(r, e, t) {
  const n = Math.sin(t), i = Math.cos(t), s = e[4], o = e[5], l = e[6], u = e[7], m = e[8], y = e[9], E = e[10], P = e[11];
  return e !== r && (r[0] = e[0], r[1] = e[1], r[2] = e[2], r[3] = e[3], r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r[4] = s * i + m * n, r[5] = o * i + y * n, r[6] = l * i + E * n, r[7] = u * i + P * n, r[8] = m * i - s * n, r[9] = y * i - o * n, r[10] = E * i - l * n, r[11] = P * i - u * n, r;
}
function BV(r, e, t) {
  const n = Math.sin(t), i = Math.cos(t), s = e[0], o = e[1], l = e[2], u = e[3], m = e[8], y = e[9], E = e[10], P = e[11];
  return e !== r && (r[4] = e[4], r[5] = e[5], r[6] = e[6], r[7] = e[7], r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r[0] = s * i - m * n, r[1] = o * i - y * n, r[2] = l * i - E * n, r[3] = u * i - P * n, r[8] = s * n + m * i, r[9] = o * n + y * i, r[10] = l * n + E * i, r[11] = u * n + P * i, r;
}
function SO(r, e, t) {
  const n = Math.sin(t), i = Math.cos(t), s = e[0], o = e[1], l = e[2], u = e[3], m = e[4], y = e[5], E = e[6], P = e[7];
  return e !== r && (r[8] = e[8], r[9] = e[9], r[10] = e[10], r[11] = e[11], r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r[0] = s * i + m * n, r[1] = o * i + y * n, r[2] = l * i + E * n, r[3] = u * i + P * n, r[4] = m * i - s * n, r[5] = y * i - o * n, r[6] = E * i - l * n, r[7] = P * i - u * n, r;
}
function OV(r, e) {
  const t = e[0], n = e[1], i = e[2], s = e[4], o = e[5], l = e[6], u = e[8], m = e[9], y = e[10];
  return r[0] = Math.sqrt(t * t + n * n + i * i), r[1] = Math.sqrt(s * s + o * o + l * l), r[2] = Math.sqrt(u * u + m * m + y * y), r;
}
function DV(r, e) {
  const t = e[0], n = e[1], i = e[2], s = e[3], o = t + t, l = n + n, u = i + i, m = t * o, y = n * o, E = n * l, P = i * o, L = i * l, U = i * u, V = s * o, q = s * l, j = s * u;
  return r[0] = 1 - E - U, r[1] = y + j, r[2] = P - q, r[3] = 0, r[4] = y - j, r[5] = 1 - m - U, r[6] = L + V, r[7] = 0, r[8] = P + q, r[9] = L - V, r[10] = 1 - m - E, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1, r;
}
function LV(r, e, t, n, i, s, o) {
  const l = 1 / (t - e), u = 1 / (i - n), m = 1 / (s - o);
  return r[0] = s * 2 * l, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = s * 2 * u, r[6] = 0, r[7] = 0, r[8] = (t + e) * l, r[9] = (i + n) * u, r[10] = (o + s) * m, r[11] = -1, r[12] = 0, r[13] = 0, r[14] = o * s * 2 * m, r[15] = 0, r;
}
function kV(r, e, t, n, i) {
  const s = 1 / Math.tan(e / 2);
  if (r[0] = s / t, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = s, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[11] = -1, r[12] = 0, r[13] = 0, r[15] = 0, i != null && i !== 1 / 0) {
    const o = 1 / (n - i);
    r[10] = (i + n) * o, r[14] = 2 * i * n * o;
  } else
    r[10] = -1, r[14] = -2 * n;
  return r;
}
const FV = kV;
function NV(r, e, t, n, i, s, o) {
  const l = 1 / (e - t), u = 1 / (n - i), m = 1 / (s - o);
  return r[0] = -2 * l, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = -2 * u, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 2 * m, r[11] = 0, r[12] = (e + t) * l, r[13] = (i + n) * u, r[14] = (o + s) * m, r[15] = 1, r;
}
const UV = NV;
function zV(r, e, t, n) {
  let i, s, o, l, u, m, y, E, P, L;
  const U = e[0], V = e[1], q = e[2], j = n[0], K = n[1], Y = n[2], de = t[0], ne = t[1], ae = t[2];
  return Math.abs(U - de) < jA && Math.abs(V - ne) < jA && Math.abs(q - ae) < jA ? IV(r) : (E = U - de, P = V - ne, L = q - ae, i = 1 / Math.sqrt(E * E + P * P + L * L), E *= i, P *= i, L *= i, s = K * L - Y * P, o = Y * E - j * L, l = j * P - K * E, i = Math.sqrt(s * s + o * o + l * l), i ? (i = 1 / i, s *= i, o *= i, l *= i) : (s = 0, o = 0, l = 0), u = P * l - L * o, m = L * s - E * l, y = E * o - P * s, i = Math.sqrt(u * u + m * m + y * y), i ? (i = 1 / i, u *= i, m *= i, y *= i) : (u = 0, m = 0, y = 0), r[0] = s, r[1] = u, r[2] = E, r[3] = 0, r[4] = o, r[5] = m, r[6] = P, r[7] = 0, r[8] = l, r[9] = y, r[10] = L, r[11] = 0, r[12] = -(s * U + o * V + l * q), r[13] = -(u * U + m * V + y * q), r[14] = -(E * U + P * V + L * q), r[15] = 1, r);
}
function VV() {
  const r = new vl(4);
  return vl != Float32Array && (r[0] = 0, r[1] = 0, r[2] = 0, r[3] = 0), r;
}
function jV(r, e, t) {
  return r[0] = e[0] + t[0], r[1] = e[1] + t[1], r[2] = e[2] + t[2], r[3] = e[3] + t[3], r;
}
function Lx(r, e, t) {
  return r[0] = e[0] * t, r[1] = e[1] * t, r[2] = e[2] * t, r[3] = e[3] * t, r;
}
function HV(r) {
  const e = r[0], t = r[1], n = r[2], i = r[3];
  return Math.sqrt(e * e + t * t + n * n + i * i);
}
function GV(r) {
  const e = r[0], t = r[1], n = r[2], i = r[3];
  return e * e + t * t + n * n + i * i;
}
function WV(r, e) {
  const t = e[0], n = e[1], i = e[2], s = e[3];
  let o = t * t + n * n + i * i + s * s;
  return o > 0 && (o = 1 / Math.sqrt(o)), r[0] = t * o, r[1] = n * o, r[2] = i * o, r[3] = s * o, r;
}
function $V(r, e) {
  return r[0] * e[0] + r[1] * e[1] + r[2] * e[2] + r[3] * e[3];
}
function qV(r, e, t, n) {
  const i = e[0], s = e[1], o = e[2], l = e[3];
  return r[0] = i + n * (t[0] - i), r[1] = s + n * (t[1] - s), r[2] = o + n * (t[2] - o), r[3] = l + n * (t[3] - l), r;
}
function Dp(r, e, t) {
  const n = e[0], i = e[1], s = e[2], o = e[3];
  return r[0] = t[0] * n + t[4] * i + t[8] * s + t[12] * o, r[1] = t[1] * n + t[5] * i + t[9] * s + t[13] * o, r[2] = t[2] * n + t[6] * i + t[10] * s + t[14] * o, r[3] = t[3] * n + t[7] * i + t[11] * s + t[15] * o, r;
}
function XV(r, e, t) {
  const n = e[0], i = e[1], s = e[2], o = t[0], l = t[1], u = t[2], m = t[3], y = m * n + l * s - u * i, E = m * i + u * n - o * s, P = m * s + o * i - l * n, L = -o * n - l * i - u * s;
  return r[0] = y * m + L * -o + E * -u - P * -l, r[1] = E * m + L * -l + P * -o - y * -u, r[2] = P * m + L * -u + y * -l - E * -o, r[3] = e[3], r;
}
(function() {
  const r = VV();
  return function(e, t, n, i, s, o) {
    let l, u;
    for (t || (t = 4), n || (n = 0), i ? u = Math.min(i * t + n, e.length) : u = e.length, l = n; l < u; l += t)
      r[0] = e[l], r[1] = e[l + 1], r[2] = e[l + 2], r[3] = e[l + 3], s(r, r, o), e[l] = r[0], e[l + 1] = r[1], e[l + 2] = r[2], e[l + 3] = r[3];
    return e;
  };
})();
var Rb;
(function(r) {
  r[r.COL0ROW0 = 0] = "COL0ROW0", r[r.COL0ROW1 = 1] = "COL0ROW1", r[r.COL0ROW2 = 2] = "COL0ROW2", r[r.COL0ROW3 = 3] = "COL0ROW3", r[r.COL1ROW0 = 4] = "COL1ROW0", r[r.COL1ROW1 = 5] = "COL1ROW1", r[r.COL1ROW2 = 6] = "COL1ROW2", r[r.COL1ROW3 = 7] = "COL1ROW3", r[r.COL2ROW0 = 8] = "COL2ROW0", r[r.COL2ROW1 = 9] = "COL2ROW1", r[r.COL2ROW2 = 10] = "COL2ROW2", r[r.COL2ROW3 = 11] = "COL2ROW3", r[r.COL3ROW0 = 12] = "COL3ROW0", r[r.COL3ROW1 = 13] = "COL3ROW1", r[r.COL3ROW2 = 14] = "COL3ROW2", r[r.COL3ROW3 = 15] = "COL3ROW3";
})(Rb || (Rb = {}));
const ZV = 45 * Math.PI / 180, YV = 1, Pv = 0.1, Mv = 500, KV = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
class xn extends EO {
  static get IDENTITY() {
    return JV();
  }
  static get ZERO() {
    return QV();
  }
  get ELEMENTS() {
    return 16;
  }
  get RANK() {
    return 4;
  }
  get INDICES() {
    return Rb;
  }
  constructor(e) {
    super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0), arguments.length === 1 && Array.isArray(e) ? this.copy(e) : this.identity();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this[4] = e[4], this[5] = e[5], this[6] = e[6], this[7] = e[7], this[8] = e[8], this[9] = e[9], this[10] = e[10], this[11] = e[11], this[12] = e[12], this[13] = e[13], this[14] = e[14], this[15] = e[15], this.check();
  }
  // eslint-disable-next-line max-params
  set(e, t, n, i, s, o, l, u, m, y, E, P, L, U, V, q) {
    return this[0] = e, this[1] = t, this[2] = n, this[3] = i, this[4] = s, this[5] = o, this[6] = l, this[7] = u, this[8] = m, this[9] = y, this[10] = E, this[11] = P, this[12] = L, this[13] = U, this[14] = V, this[15] = q, this.check();
  }
  // accepts row major order, stores as column major
  // eslint-disable-next-line max-params
  setRowMajor(e, t, n, i, s, o, l, u, m, y, E, P, L, U, V, q) {
    return this[0] = e, this[1] = s, this[2] = m, this[3] = L, this[4] = t, this[5] = o, this[6] = y, this[7] = U, this[8] = n, this[9] = l, this[10] = E, this[11] = V, this[12] = i, this[13] = u, this[14] = P, this[15] = q, this.check();
  }
  toRowMajor(e) {
    return e[0] = this[0], e[1] = this[4], e[2] = this[8], e[3] = this[12], e[4] = this[1], e[5] = this[5], e[6] = this[9], e[7] = this[13], e[8] = this[2], e[9] = this[6], e[10] = this[10], e[11] = this[14], e[12] = this[3], e[13] = this[7], e[14] = this[11], e[15] = this[15], e;
  }
  // Constructors
  /** Set to identity matrix */
  identity() {
    return this.copy(KV);
  }
  /**
   *
   * @param object
   * @returns self
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  fromObject(e) {
    return this.check();
  }
  /**
   * Calculates a 4x4 matrix from the given quaternion
   * @param quaternion Quaternion to create matrix from
   * @returns self
   */
  fromQuaternion(e) {
    return DV(this, e), this.check();
  }
  /**
   * Generates a frustum matrix with the given bounds
   * @param view.left - Left bound of the frustum
   * @param view.right - Right bound of the frustum
   * @param view.bottom - Bottom bound of the frustum
   * @param view.top - Top bound of the frustum
   * @param view.near - Near bound of the frustum
   * @param view.far - Far bound of the frustum. Can be set to Infinity.
   * @returns self
   */
  frustum(e) {
    const { left: t, right: n, bottom: i, top: s, near: o = Pv, far: l = Mv } = e;
    return l === 1 / 0 ? ej(this, t, n, i, s, o) : LV(this, t, n, i, s, o, l), this.check();
  }
  /**
   * Generates a look-at matrix with the given eye position, focal point,
   * and up axis
   * @param view.eye - (vector) Position of the viewer
   * @param view.center - (vector) Point the viewer is looking at
   * @param view.up - (vector) Up axis
   * @returns self
   */
  lookAt(e) {
    const { eye: t, center: n = [0, 0, 0], up: i = [0, 1, 0] } = e;
    return zV(this, t, n, i), this.check();
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds
   * from "traditional" view space parameters
   * @param view.left - Left bound of the frustum
   * @param view.right number  Right bound of the frustum
   * @param view.bottom - Bottom bound of the frustum
   * @param view.top number  Top bound of the frustum
   * @param view.near - Near bound of the frustum
   * @param view.far number  Far bound of the frustum
   * @returns self
   */
  ortho(e) {
    const { left: t, right: n, bottom: i, top: s, near: o = Pv, far: l = Mv } = e;
    return UV(this, t, n, i, s, o, l), this.check();
  }
  /**
   * Generates an orthogonal projection matrix with the same parameters
   * as a perspective matrix (plus focalDistance)
   * @param view.fovy Vertical field of view in radians
   * @param view.aspect Aspect ratio. Typically viewport width / viewport height
   * @param view.focalDistance Distance in the view frustum used for extent calculations
   * @param view.near Near bound of the frustum
   * @param view.far Far bound of the frustum
   * @returns self
   */
  orthographic(e) {
    const { fovy: t = ZV, aspect: n = YV, focalDistance: i = 1, near: s = Pv, far: o = Mv } = e;
    oC(t);
    const l = t / 2, u = i * Math.tan(l), m = u * n;
    return this.ortho({
      left: -m,
      right: m,
      bottom: -u,
      top: u,
      near: s,
      far: o
    });
  }
  /**
   * Generates a perspective projection matrix with the given bounds
   * @param view.fovy Vertical field of view in radians
   * @param view.aspect Aspect ratio. typically viewport width/height
   * @param view.near Near bound of the frustum
   * @param view.far Far bound of the frustum
   * @returns self
   */
  perspective(e) {
    const { fovy: t = 45 * Math.PI / 180, aspect: n = 1, near: i = 0.1, far: s = 500 } = e;
    return oC(t), FV(this, t, n, i, s), this.check();
  }
  // Accessors
  determinant() {
    return MV(this);
  }
  /**
   * Extracts the non-uniform scale assuming the matrix is an affine transformation.
   * The scales are the "lengths" of the column vectors in the upper-left 3x3 matrix.
   * @param result
   * @returns self
   */
  getScale(e = [-0, -0, -0]) {
    return e[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]), e[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]), e[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]), e;
  }
  /**
   * Gets the translation portion, assuming the matrix is a affine transformation matrix.
   * @param result
   * @returns self
   */
  getTranslation(e = [-0, -0, -0]) {
    return e[0] = this[12], e[1] = this[13], e[2] = this[14], e;
  }
  /**
   * Gets upper left 3x3 pure rotation matrix (non-scaling), assume affine transformation matrix
   * @param result
   * @param scaleResult
   * @returns self
   */
  getRotation(e, t) {
    e = e || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0], t = t || [-0, -0, -0];
    const n = this.getScale(t), i = 1 / n[0], s = 1 / n[1], o = 1 / n[2];
    return e[0] = this[0] * i, e[1] = this[1] * s, e[2] = this[2] * o, e[3] = 0, e[4] = this[4] * i, e[5] = this[5] * s, e[6] = this[6] * o, e[7] = 0, e[8] = this[8] * i, e[9] = this[9] * s, e[10] = this[10] * o, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   *
   * @param result
   * @param scaleResult
   * @returns self
   */
  getRotationMatrix3(e, t) {
    e = e || [-0, -0, -0, -0, -0, -0, -0, -0, -0], t = t || [-0, -0, -0];
    const n = this.getScale(t), i = 1 / n[0], s = 1 / n[1], o = 1 / n[2];
    return e[0] = this[0] * i, e[1] = this[1] * s, e[2] = this[2] * o, e[3] = this[4] * i, e[4] = this[5] * s, e[5] = this[6] * o, e[6] = this[8] * i, e[7] = this[9] * s, e[8] = this[10] * o, e;
  }
  // Modifiers
  transpose() {
    return PV(this, this), this.check();
  }
  invert() {
    return Mb(this, this), this.check();
  }
  // Operations
  multiplyLeft(e) {
    return Yf(this, e, this), this.check();
  }
  multiplyRight(e) {
    return Yf(this, this, e), this.check();
  }
  // Rotates a matrix by the given angle around the X axis
  rotateX(e) {
    return CO(this, this, e), this.check();
  }
  // Rotates a matrix by the given angle around the Y axis.
  rotateY(e) {
    return BV(this, this, e), this.check();
  }
  /**
   * Rotates a matrix by the given angle around the Z axis.
   * @param radians
   * @returns self
   */
  rotateZ(e) {
    return SO(this, this, e), this.check();
  }
  /**
   *
   * @param param0
   * @returns self
   */
  rotateXYZ(e) {
    return this.rotateX(e[0]).rotateY(e[1]).rotateZ(e[2]);
  }
  /**
   *
   * @param radians
   * @param axis
   * @returns self
   */
  rotateAxis(e, t) {
    return RV(this, this, e, t), this.check();
  }
  /**
   *
   * @param factor
   * @returns self
   */
  scale(e) {
    return Dx(this, this, Array.isArray(e) ? e : [e, e, e]), this.check();
  }
  /**
   *
   * @param vec
   * @returns self
   */
  translate(e) {
    return t_(this, this, e), this.check();
  }
  // Transforms
  /**
   * Transforms any 2, 3 or 4 element vector. 2 and 3 elements are treated as points
   * @param vector
   * @param result
   * @returns self
   */
  transform(e, t) {
    return e.length === 4 ? (t = Dp(t || [-0, -0, -0, -0], e, this), VA(t, 4), t) : this.transformAsPoint(e, t);
  }
  /**
   * Transforms any 2 or 3 element array as point (w implicitly 1)
   * @param vector
   * @param result
   * @returns self
   */
  transformAsPoint(e, t) {
    const { length: n } = e;
    let i;
    switch (n) {
      case 2:
        i = AO(t || [-0, -0], e, this);
        break;
      case 3:
        i = Bx(t || [-0, -0, -0], e, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    return VA(i, e.length), i;
  }
  /**
   * Transforms any 2 or 3 element array as vector (w implicitly 0)
   * @param vector
   * @param result
   * @returns self
   */
  transformAsVector(e, t) {
    let n;
    switch (e.length) {
      case 2:
        n = gO(t || [-0, -0], e, this);
        break;
      case 3:
        n = mO(t || [-0, -0, -0], e, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    return VA(n, e.length), n;
  }
  /** @deprecated */
  transformPoint(e, t) {
    return this.transformAsPoint(e, t);
  }
  /** @deprecated */
  transformVector(e, t) {
    return this.transformAsPoint(e, t);
  }
  /** @deprecated */
  transformDirection(e, t) {
    return this.transformAsVector(e, t);
  }
  // three.js math API compatibility
  makeRotationX(e) {
    return this.identity().rotateX(e);
  }
  makeTranslation(e, t, n) {
    return this.identity().translate([e, t, n]);
  }
}
let xg, wg;
function QV() {
  return xg || (xg = new xn([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(xg)), xg;
}
function JV() {
  return wg || (wg = new xn(), Object.freeze(wg)), wg;
}
function oC(r) {
  if (r > Math.PI * 2)
    throw Error("expected radians");
}
function ej(r, e, t, n, i, s) {
  const o = 2 * s / (t - e), l = 2 * s / (i - n), u = (t + e) / (t - e), m = (i + n) / (i - n), y = -1, E = -1, P = -2 * s;
  return r[0] = o, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = l, r[6] = 0, r[7] = 0, r[8] = u, r[9] = m, r[10] = y, r[11] = E, r[12] = 0, r[13] = 0, r[14] = P, r[15] = 0, r;
}
function aC() {
  const r = new vl(4);
  return vl != Float32Array && (r[0] = 0, r[1] = 0, r[2] = 0), r[3] = 1, r;
}
function tj(r) {
  return r[0] = 0, r[1] = 0, r[2] = 0, r[3] = 1, r;
}
function IO(r, e, t) {
  t = t * 0.5;
  const n = Math.sin(t);
  return r[0] = n * e[0], r[1] = n * e[1], r[2] = n * e[2], r[3] = Math.cos(t), r;
}
function lC(r, e, t) {
  const n = e[0], i = e[1], s = e[2], o = e[3], l = t[0], u = t[1], m = t[2], y = t[3];
  return r[0] = n * y + o * l + i * m - s * u, r[1] = i * y + o * u + s * l - n * m, r[2] = s * y + o * m + n * u - i * l, r[3] = o * y - n * l - i * u - s * m, r;
}
function rj(r, e, t) {
  t *= 0.5;
  const n = e[0], i = e[1], s = e[2], o = e[3], l = Math.sin(t), u = Math.cos(t);
  return r[0] = n * u + o * l, r[1] = i * u + s * l, r[2] = s * u - i * l, r[3] = o * u - n * l, r;
}
function nj(r, e, t) {
  t *= 0.5;
  const n = e[0], i = e[1], s = e[2], o = e[3], l = Math.sin(t), u = Math.cos(t);
  return r[0] = n * u - s * l, r[1] = i * u + o * l, r[2] = s * u + n * l, r[3] = o * u - i * l, r;
}
function ij(r, e, t) {
  t *= 0.5;
  const n = e[0], i = e[1], s = e[2], o = e[3], l = Math.sin(t), u = Math.cos(t);
  return r[0] = n * u + i * l, r[1] = i * u - n * l, r[2] = s * u + o * l, r[3] = o * u - s * l, r;
}
function sj(r, e) {
  const t = e[0], n = e[1], i = e[2];
  return r[0] = t, r[1] = n, r[2] = i, r[3] = Math.sqrt(Math.abs(1 - t * t - n * n - i * i)), r;
}
function bm(r, e, t, n) {
  const i = e[0], s = e[1], o = e[2], l = e[3];
  let u = t[0], m = t[1], y = t[2], E = t[3], P, L, U, V, q;
  return P = i * u + s * m + o * y + l * E, P < 0 && (P = -P, u = -u, m = -m, y = -y, E = -E), 1 - P > jA ? (L = Math.acos(P), q = Math.sin(L), U = Math.sin((1 - n) * L) / q, V = Math.sin(n * L) / q) : (U = 1 - n, V = n), r[0] = U * i + V * u, r[1] = U * s + V * m, r[2] = U * o + V * y, r[3] = U * l + V * E, r;
}
function oj(r, e) {
  const t = e[0], n = e[1], i = e[2], s = e[3], o = t * t + n * n + i * i + s * s, l = o ? 1 / o : 0;
  return r[0] = -t * l, r[1] = -n * l, r[2] = -i * l, r[3] = s * l, r;
}
function aj(r, e) {
  return r[0] = -e[0], r[1] = -e[1], r[2] = -e[2], r[3] = e[3], r;
}
function PO(r, e) {
  const t = e[0] + e[4] + e[8];
  let n;
  if (t > 0)
    n = Math.sqrt(t + 1), r[3] = 0.5 * n, n = 0.5 / n, r[0] = (e[5] - e[7]) * n, r[1] = (e[6] - e[2]) * n, r[2] = (e[1] - e[3]) * n;
  else {
    let i = 0;
    e[4] > e[0] && (i = 1), e[8] > e[i * 3 + i] && (i = 2);
    const s = (i + 1) % 3, o = (i + 2) % 3;
    n = Math.sqrt(e[i * 3 + i] - e[s * 3 + s] - e[o * 3 + o] + 1), r[i] = 0.5 * n, n = 0.5 / n, r[3] = (e[s * 3 + o] - e[o * 3 + s]) * n, r[s] = (e[s * 3 + i] + e[i * 3 + s]) * n, r[o] = (e[o * 3 + i] + e[i * 3 + o]) * n;
  }
  return r;
}
const lj = jV, cj = Lx, uj = $V, fj = qV, hj = HV, dj = GV, MO = WV, pj = (function() {
  const r = yO(), e = nC(1, 0, 0), t = nC(0, 1, 0);
  return function(n, i, s) {
    const o = Rx(i, s);
    return o < -0.999999 ? (vm(r, e, i), TO(r) < 1e-6 && vm(r, t, i), hV(r, r), IO(n, r, Math.PI), n) : o > 0.999999 ? (n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 1, n) : (vm(r, i, s), n[0] = r[0], n[1] = r[1], n[2] = r[2], n[3] = 1 + o, MO(n, n));
  };
})();
(function() {
  const r = aC(), e = aC();
  return function(t, n, i, s, o, l) {
    return bm(r, n, o, l), bm(e, i, s, l), bm(t, r, e, 2 * l * (1 - l)), t;
  };
})();
(function() {
  const r = _V();
  return function(e, t, n, i) {
    return r[0] = n[0], r[3] = n[1], r[6] = n[2], r[1] = i[0], r[4] = i[1], r[7] = i[2], r[2] = -t[0], r[5] = -t[1], r[8] = -t[2], MO(e, PO(e, r));
  };
})();
const Aj = [0, 0, 0, 1];
class r0 extends Ix {
  constructor(e = 0, t = 0, n = 0, i = 1) {
    super(-0, -0, -0, -0), Array.isArray(e) && arguments.length === 1 ? this.copy(e) : this.set(e, t, n, i);
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this.check();
  }
  set(e, t, n, i) {
    return this[0] = e, this[1] = t, this[2] = n, this[3] = i, this.check();
  }
  fromObject(e) {
    return this[0] = e.x, this[1] = e.y, this[2] = e.z, this[3] = e.w, this.check();
  }
  /**
   * Creates a quaternion from the given 3x3 rotation matrix.
   * NOTE: The resultant quaternion is not normalized, so you should
   * be sure to renormalize the quaternion yourself where necessary.
   * @param m
   * @returns
   */
  fromMatrix3(e) {
    return PO(this, e), this.check();
  }
  fromAxisRotation(e, t) {
    return IO(this, e, t), this.check();
  }
  /** Set a quat to the identity quaternion */
  identity() {
    return tj(this), this.check();
  }
  // Set the components of a quat to the given values
  // set(i, j, k, l) {
  //   quat_set(this, i, j, k, l);
  //   return this.check();
  // }
  // Sets a quat from the given angle and rotation axis, then returns it.
  setAxisAngle(e, t) {
    return this.fromAxisRotation(e, t);
  }
  // Getters/setters
  get ELEMENTS() {
    return 4;
  }
  get x() {
    return this[0];
  }
  set x(e) {
    this[0] = Qn(e);
  }
  get y() {
    return this[1];
  }
  set y(e) {
    this[1] = Qn(e);
  }
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = Qn(e);
  }
  get w() {
    return this[3];
  }
  set w(e) {
    this[3] = Qn(e);
  }
  // Calculates the length of a quat
  len() {
    return hj(this);
  }
  // Calculates the squared length of a quat
  lengthSquared() {
    return dj(this);
  }
  // Calculates the dot product of two quat's
  // @return {Number}
  dot(e) {
    return uj(this, e);
  }
  // Gets the rotation axis and angle for a given quaternion.
  // If a quaternion is created with setAxisAngle, this method will
  // return the same values as providied in the original parameter
  // list OR functionally equivalent values.
  // Example: The quaternion formed by axis [0, 0, 1] and angle -90
  // is the same as the quaternion formed by [0, 0, 1] and 270.
  // This method favors the latter.
  // @return {{[x,y,z], Number}}
  // getAxisAngle() {
  //   const axis = [];
  // //   const angle = quat_getAxisAngle(axis, this);
  //   return {axis, angle};
  // }
  // MODIFIERS
  // Sets a quaternion to represent the shortest rotation from one vector
  // to another. Both vectors are assumed to be unit length.
  rotationTo(e, t) {
    return pj(this, e, t), this.check();
  }
  // Sets the specified quaternion with values corresponding to the given axes.
  // Each axis is a vec3 and is expected to be unit length and perpendicular
  // to all other specified axes.
  // setAxes() {
  //   Number
  // }
  // Performs a spherical linear interpolation with two control points
  // sqlerp() {
  //   Number;
  // }
  // Adds two quat's
  add(e) {
    return lj(this, this, e), this.check();
  }
  // Calculates the W component of a quat from the X, Y, and Z components.
  // Any existing W component will be ignored.
  calculateW() {
    return sj(this, this), this.check();
  }
  // Calculates the conjugate of a quat If the quaternion is normalized,
  // this function is faster than quat_invert and produces the same result.
  conjugate() {
    return aj(this, this), this.check();
  }
  // Calculates the inverse of a quat
  invert() {
    return oj(this, this), this.check();
  }
  // Performs a linear interpolation between two quat's
  lerp(e, t, n) {
    return n === void 0 ? this.lerp(this, e, t) : (fj(this, e, t, n), this.check());
  }
  // Multiplies two quat's
  multiplyRight(e) {
    return lC(this, this, e), this.check();
  }
  multiplyLeft(e) {
    return lC(this, e, this), this.check();
  }
  // Normalize a quat
  normalize() {
    const e = this.len(), t = e > 0 ? 1 / e : 0;
    return this[0] = this[0] * t, this[1] = this[1] * t, this[2] = this[2] * t, this[3] = this[3] * t, e === 0 && (this[3] = 1), this.check();
  }
  // Rotates a quaternion by the given angle about the X axis
  rotateX(e) {
    return rj(this, this, e), this.check();
  }
  // Rotates a quaternion by the given angle about the Y axis
  rotateY(e) {
    return nj(this, this, e), this.check();
  }
  // Rotates a quaternion by the given angle about the Z axis
  rotateZ(e) {
    return ij(this, this, e), this.check();
  }
  // Scales a quat by a scalar number
  scale(e) {
    return cj(this, this, e), this.check();
  }
  // Performs a spherical linear interpolation between two quat
  slerp(e, t, n) {
    let i, s, o;
    switch (arguments.length) {
      case 1:
        ({
          start: i = Aj,
          target: s,
          ratio: o
        } = e);
        break;
      case 2:
        i = this, s = e, o = t;
        break;
      default:
        i = e, s = t, o = n;
    }
    return bm(this, i, s, o), this.check();
  }
  transformVector4(e, t = new Ox()) {
    return XV(t, e, this), VA(t, 4);
  }
  // THREE.js Math API compatibility
  lengthSq() {
    return this.lengthSquared();
  }
  setFromAxisAngle(e, t) {
    return this.setAxisAngle(e, t);
  }
  premultiply(e) {
    return this.multiplyLeft(e);
  }
  multiply(e) {
    return this.multiplyRight(e);
  }
}
const gj = 0.1, mj = 1e-12, RO = 1e-15, _j = 1e-20;
function BO(r, e = [], t = 0) {
  const n = Math.fround(r), i = r - n;
  return e[t] = n, e[t + 1] = i, e;
}
function yj(r) {
  return r - Math.fround(r);
}
function vj(r) {
  const e = new Float32Array(32);
  for (let t = 0; t < 4; ++t)
    for (let n = 0; n < 4; ++n) {
      const i = t * 4 + n;
      BO(r[n * 4 + t], e, i * 2);
    }
  return e;
}
const bj = (
  /* glsl */
  `#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND

// All these functions are for substituting tan() function from Intel GPU only
const float TWO_PI = 6.2831854820251465;
const float PI_2 = 1.5707963705062866;
const float PI_16 = 0.1963495463132858;

const float SIN_TABLE_0 = 0.19509032368659973;
const float SIN_TABLE_1 = 0.3826834261417389;
const float SIN_TABLE_2 = 0.5555702447891235;
const float SIN_TABLE_3 = 0.7071067690849304;

const float COS_TABLE_0 = 0.9807852506637573;
const float COS_TABLE_1 = 0.9238795042037964;
const float COS_TABLE_2 = 0.8314695954322815;
const float COS_TABLE_3 = 0.7071067690849304;

const float INVERSE_FACTORIAL_3 = 1.666666716337204e-01; // 1/3!
const float INVERSE_FACTORIAL_5 = 8.333333767950535e-03; // 1/5!
const float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04; // 1/7!
const float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06; // 1/9!

float sin_taylor_fp32(float a) {
  float r, s, t, x;

  if (a == 0.0) {
    return 0.0;
  }

  x = -a * a;
  s = a;
  r = a;

  r = r * x;
  t = r * INVERSE_FACTORIAL_3;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_5;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_7;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_9;
  s = s + t;

  return s;
}

void sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {
  if (a == 0.0) {
    sin_t = 0.0;
    cos_t = 1.0;
  }
  sin_t = sin_taylor_fp32(a);
  cos_t = sqrt(1.0 - sin_t * sin_t);
}

float tan_taylor_fp32(float a) {
    float sin_a;
    float cos_a;

    if (a == 0.0) {
        return 0.0;
    }

    // 2pi range reduction
    float z = floor(a / TWO_PI);
    float r = a - TWO_PI * z;

    float t;
    float q = floor(r / PI_2 + 0.5);
    int j = int(q);

    if (j < -2 || j > 2) {
        return 1.0 / 0.0;
    }

    t = r - PI_2 * q;

    q = floor(t / PI_16 + 0.5);
    int k = int(q);
    int abs_k = int(abs(float(k)));

    if (abs_k > 4) {
        return 1.0 / 0.0;
    } else {
        t = t - PI_16 * q;
    }

    float u = 0.0;
    float v = 0.0;

    float sin_t, cos_t;
    float s, c;
    sincos_taylor_fp32(t, sin_t, cos_t);

    if (k == 0) {
        s = sin_t;
        c = cos_t;
    } else {
        if (abs(float(abs_k) - 1.0) < 0.5) {
            u = COS_TABLE_0;
            v = SIN_TABLE_0;
        } else if (abs(float(abs_k) - 2.0) < 0.5) {
            u = COS_TABLE_1;
            v = SIN_TABLE_1;
        } else if (abs(float(abs_k) - 3.0) < 0.5) {
            u = COS_TABLE_2;
            v = SIN_TABLE_2;
        } else if (abs(float(abs_k) - 4.0) < 0.5) {
            u = COS_TABLE_3;
            v = SIN_TABLE_3;
        }
        if (k > 0) {
            s = u * sin_t + v * cos_t;
            c = u * cos_t - v * sin_t;
        } else {
            s = u * sin_t - v * cos_t;
            c = u * cos_t + v * sin_t;
        }
    }

    if (j == 0) {
        sin_a = s;
        cos_a = c;
    } else if (j == 1) {
        sin_a = c;
        cos_a = -s;
    } else if (j == -1) {
        sin_a = -c;
        cos_a = s;
    } else {
        sin_a = -s;
        cos_a = -c;
    }
    return sin_a / cos_a;
}
#endif

float tan_fp32(float a) {
#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
  return tan_taylor_fp32(a);
#else
  return tan(a);
#endif
}
`
), xj = {
  name: "fp32",
  vs: bj
}, wj = (
  /* glsl */
  `
uniform fp64arithmeticUniforms {
  uniform float ONE;
} fp64;

/*
About LUMA_FP64_CODE_ELIMINATION_WORKAROUND

The purpose of this workaround is to prevent shader compilers from
optimizing away necessary arithmetic operations by swapping their sequences
or transform the equation to some 'equivalent' form.

The method is to multiply an artifical variable, ONE, which will be known to
the compiler to be 1 only at runtime. The whole expression is then represented
as a polynomial with respective to ONE. In the coefficients of all terms, only one a
and one b should appear

err = (a + b) * ONE^6 - a * ONE^5 - (a + b) * ONE^4 + a * ONE^3 - b - (a + b) * ONE^2 + a * ONE
*/

// Divide float number to high and low floats to extend fraction bits
vec2 split(float a) {
  const float SPLIT = 4097.0;
  float t = a * SPLIT;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float a_hi = t * fp64.ONE - (t - a);
  float a_lo = a * fp64.ONE - a_hi;
#else
  float a_hi = t - (t - a);
  float a_lo = a - a_hi;
#endif
  return vec2(a_hi, a_lo);
}

// Divide float number again when high float uses too many fraction bits
vec2 split2(vec2 a) {
  vec2 b = split(a.x);
  b.y += a.y;
  return b;
}

// Special sum operation when a > b
vec2 quickTwoSum(float a, float b) {
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float sum = (a + b) * fp64.ONE;
  float err = b - (sum - a) * fp64.ONE;
#else
  float sum = a + b;
  float err = b - (sum - a);
#endif
  return vec2(sum, err);
}

// General sum operation
vec2 twoSum(float a, float b) {
  float s = (a + b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float v = (s * fp64.ONE - a) * fp64.ONE;
  float err = (a - (s - v) * fp64.ONE) * fp64.ONE * fp64.ONE * fp64.ONE + (b - v);
#else
  float v = s - a;
  float err = (a - (s - v)) + (b - v);
#endif
  return vec2(s, err);
}

vec2 twoSub(float a, float b) {
  float s = (a - b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float v = (s * fp64.ONE - a) * fp64.ONE;
  float err = (a - (s - v) * fp64.ONE) * fp64.ONE * fp64.ONE * fp64.ONE - (b + v);
#else
  float v = s - a;
  float err = (a - (s - v)) - (b + v);
#endif
  return vec2(s, err);
}

vec2 twoSqr(float a) {
  float prod = a * a;
  vec2 a_fp64 = split(a);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float err = ((a_fp64.x * a_fp64.x - prod) * fp64.ONE + 2.0 * a_fp64.x *
    a_fp64.y * fp64.ONE * fp64.ONE) + a_fp64.y * a_fp64.y * fp64.ONE * fp64.ONE * fp64.ONE;
#else
  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;
#endif
  return vec2(prod, err);
}

vec2 twoProd(float a, float b) {
  float prod = a * b;
  vec2 a_fp64 = split(a);
  vec2 b_fp64 = split(b);
  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +
    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;
  return vec2(prod, err);
}

vec2 sum_fp64(vec2 a, vec2 b) {
  vec2 s, t;
  s = twoSum(a.x, b.x);
  t = twoSum(a.y, b.y);
  s.y += t.x;
  s = quickTwoSum(s.x, s.y);
  s.y += t.y;
  s = quickTwoSum(s.x, s.y);
  return s;
}

vec2 sub_fp64(vec2 a, vec2 b) {
  vec2 s, t;
  s = twoSub(a.x, b.x);
  t = twoSub(a.y, b.y);
  s.y += t.x;
  s = quickTwoSum(s.x, s.y);
  s.y += t.y;
  s = quickTwoSum(s.x, s.y);
  return s;
}

vec2 mul_fp64(vec2 a, vec2 b) {
  vec2 prod = twoProd(a.x, b.x);
  // y component is for the error
  prod.y += a.x * b.y;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  prod = split2(prod);
#endif
  prod = quickTwoSum(prod.x, prod.y);
  prod.y += a.y * b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  prod = split2(prod);
#endif
  prod = quickTwoSum(prod.x, prod.y);
  return prod;
}

vec2 div_fp64(vec2 a, vec2 b) {
  float xn = 1.0 / b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  vec2 yn = mul_fp64(a, vec2(xn, 0));
#else
  vec2 yn = a * xn;
#endif
  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;
  vec2 prod = twoProd(xn, diff);
  return sum_fp64(yn, prod);
}

vec2 sqrt_fp64(vec2 a) {
  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);
  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);

  float x = 1.0 / sqrt(a.x);
  float yn = a.x * x;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  vec2 yn_sqr = twoSqr(yn) * fp64.ONE;
#else
  vec2 yn_sqr = twoSqr(yn);
#endif
  float diff = sub_fp64(a, yn_sqr).x;
  vec2 prod = twoProd(x * 0.5, diff);
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  return sum_fp64(split(yn), prod);
#else
  return sum_fp64(vec2(yn, 0.0), prod);
#endif
}
`
), Tj = {
  // Used in LUMA_FP64_CODE_ELIMINATION_WORKAROUND
  ONE: 1
}, Ej = {
  name: "fp64arithmetic",
  vs: wj,
  defaultUniforms: Tj,
  uniformTypes: { ONE: "f32" },
  // Additional Functions
  fp64ify: BO,
  fp64LowPart: yj,
  fp64ifyMatrix4: vj
}, Cj = [0, 1, 1, 1], Sj = (
  /* glsl */
  `uniform pickingUniforms {
  float isActive;
  float isAttribute;
  float isHighlightActive;
  float useFloatColors;
  vec3 highlightedObjectColor;
  vec4 highlightColor;
} picking;

out vec4 picking_vRGBcolor_Avalid;

// Normalize unsigned byte color to 0-1 range
vec3 picking_normalizeColor(vec3 color) {
  return picking.useFloatColors > 0.5 ? color : color / 255.0;
}

// Normalize unsigned byte color to 0-1 range
vec4 picking_normalizeColor(vec4 color) {
  return picking.useFloatColors > 0.5 ? color : color / 255.0;
}

bool picking_isColorZero(vec3 color) {
  return dot(color, vec3(1.0)) < 0.00001;
}

bool picking_isColorValid(vec3 color) {
  return dot(color, vec3(1.0)) > 0.00001;
}

// Check if this vertex is highlighted 
bool isVertexHighlighted(vec3 vertexColor) {
  vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);
  return
    bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));
}

// Set the current picking color
void picking_setPickingColor(vec3 pickingColor) {
  pickingColor = picking_normalizeColor(pickingColor);

  if (bool(picking.isActive)) {
    // Use alpha as the validity flag. If pickingColor is [0, 0, 0] fragment is non-pickable
    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));

    if (!bool(picking.isAttribute)) {
      // Stores the picking color so that the fragment shader can render it during picking
      picking_vRGBcolor_Avalid.rgb = pickingColor;
    }
  } else {
    // Do the comparison with selected item color in vertex shader as it should mean fewer compares
    picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));
  }
}

void picking_setPickingAttribute(float value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.r = value;
  }
}

void picking_setPickingAttribute(vec2 value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.rg = value;
  }
}

void picking_setPickingAttribute(vec3 value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.rgb = value;
  }
}
`
), Ij = (
  /* glsl */
  `uniform pickingUniforms {
  float isActive;
  float isAttribute;
  float isHighlightActive;
  float useFloatColors;
  vec3 highlightedObjectColor;
  vec4 highlightColor;
} picking;

in vec4 picking_vRGBcolor_Avalid;

/*
 * Returns highlight color if this item is selected.
 */
vec4 picking_filterHighlightColor(vec4 color) {
  // If we are still picking, we don't highlight
  if (picking.isActive > 0.5) {
    return color;
  }

  bool selected = bool(picking_vRGBcolor_Avalid.a);

  if (selected) {
    // Blend in highlight color based on its alpha value
    float highLightAlpha = picking.highlightColor.a;
    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);
    float highLightRatio = highLightAlpha / blendedAlpha;

    vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);
    return vec4(blendedRGB, blendedAlpha);
  } else {
    return color;
  }
}

/*
 * Returns picking color if picking enabled else unmodified argument.
 */
vec4 picking_filterPickingColor(vec4 color) {
  if (bool(picking.isActive)) {
    if (picking_vRGBcolor_Avalid.a == 0.0) {
      discard;
    }
    return picking_vRGBcolor_Avalid;
  }
  return color;
}

/*
 * Returns picking color if picking is enabled if not
 * highlight color if this item is selected, otherwise unmodified argument.
 */
vec4 picking_filterColor(vec4 color) {
  vec4 highlightColor = picking_filterHighlightColor(color);
  return picking_filterPickingColor(highlightColor);
}
`
), cC = {
  props: {},
  uniforms: {},
  name: "picking",
  uniformTypes: {
    isActive: "f32",
    isAttribute: "f32",
    isHighlightActive: "f32",
    useFloatColors: "f32",
    highlightedObjectColor: "vec3<f32>",
    highlightColor: "vec4<f32>"
  },
  defaultUniforms: {
    isActive: !1,
    isAttribute: !1,
    isHighlightActive: !1,
    useFloatColors: !0,
    highlightedObjectColor: [0, 0, 0],
    highlightColor: Cj
  },
  vs: Sj,
  fs: Ij,
  getUniforms: Pj
};
function Pj(r = {}, e) {
  const t = {};
  if (r.highlightedObjectColor !== void 0) if (r.highlightedObjectColor === null)
    t.isHighlightActive = !1;
  else {
    t.isHighlightActive = !0;
    const n = r.highlightedObjectColor.slice(0, 3);
    t.highlightedObjectColor = n;
  }
  if (r.highlightColor) {
    const n = Array.from(r.highlightColor, (i) => i / 255);
    Number.isFinite(n[3]) || (n[3] = 1), t.highlightColor = n;
  }
  return r.isActive !== void 0 && (t.isActive = !!r.isActive, t.isAttribute = !!r.isAttribute), r.useFloatColors !== void 0 && (t.useFloatColors = !!r.useFloatColors), t;
}
const uC = (
  /* glsl */
  `precision highp int;

// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
  vec3 color;
};

struct PointLight {
  vec3 color;
  vec3 position;
  vec3 attenuation; // 2nd order x:Constant-y:Linear-z:Exponential
};

struct DirectionalLight {
  vec3 color;
  vec3 direction;
};

uniform lightingUniforms {
  int enabled;
  int lightType;

  int directionalLightCount;
  int pointLightCount;

  vec3 ambientColor;

  vec3 lightColor0;
  vec3 lightPosition0;
  vec3 lightDirection0;
  vec3 lightAttenuation0;

  vec3 lightColor1;
  vec3 lightPosition1;
  vec3 lightDirection1;
  vec3 lightAttenuation1;

  vec3 lightColor2;
  vec3 lightPosition2;
  vec3 lightDirection2;
  vec3 lightAttenuation2;
} lighting;

PointLight lighting_getPointLight(int index) {
  switch (index) {
    case 0:
      return PointLight(lighting.lightColor0, lighting.lightPosition0, lighting.lightAttenuation0);
    case 1:
      return PointLight(lighting.lightColor1, lighting.lightPosition1, lighting.lightAttenuation1);
    case 2:
    default:  
      return PointLight(lighting.lightColor2, lighting.lightPosition2, lighting.lightAttenuation2);
  }
}

DirectionalLight lighting_getDirectionalLight(int index) {
  switch (index) {
    case 0:
      return DirectionalLight(lighting.lightColor0, lighting.lightDirection0);
    case 1:
      return DirectionalLight(lighting.lightColor1, lighting.lightDirection1);
    case 2:
    default:   
      return DirectionalLight(lighting.lightColor2, lighting.lightDirection2);
  }
} 

float getPointLightAttenuation(PointLight pointLight, float distance) {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}

// #endif
`
), Mj = (
  /* wgsl */
  `// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
  color: vec3<f32>,
};

struct PointLight {
  color: vec3<f32>,
  position: vec3<f32>,
  attenuation: vec3<f32>, // 2nd order x:Constant-y:Linear-z:Exponential
};

struct DirectionalLight {
  color: vec3<f32>,
  direction: vec3<f32>,
};

struct lightingUniforms {
  enabled: i32,
  pointLightCount: i32,
  directionalLightCount: i32,

  ambientColor: vec3<f32>,

  // TODO - support multiple lights by uncommenting arrays below
  lightType: i32,
  lightColor: vec3<f32>,
  lightDirection: vec3<f32>,
  lightPosition: vec3<f32>,
  lightAttenuation: vec3<f32>,

  // AmbientLight ambientLight;
  // PointLight pointLight[MAX_LIGHTS];
  // DirectionalLight directionalLight[MAX_LIGHTS];
};

// Binding 0:1 is reserved for lighting (Note: could go into separate bind group as it is stable across draw calls)
@binding(1) @group(0) var<uniform> lighting : lightingUniforms;

fn lighting_getPointLight(index: i32) -> PointLight {
  return PointLight(lighting.lightColor, lighting.lightPosition, lighting.lightAttenuation);
}

fn lighting_getDirectionalLight(index: i32) -> DirectionalLight {
  return DirectionalLight(lighting.lightColor, lighting.lightDirection);
} 

fn getPointLightAttenuation(pointLight: PointLight, distance: f32) -> f32 {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}
`
), Rj = 5, Bj = 255;
var n0;
(function(r) {
  r[r.POINT = 0] = "POINT", r[r.DIRECTIONAL = 1] = "DIRECTIONAL";
})(n0 || (n0 = {}));
const sp = {
  props: {},
  uniforms: {},
  name: "lighting",
  defines: {
    // MAX_LIGHTS
  },
  uniformTypes: {
    enabled: "i32",
    lightType: "i32",
    directionalLightCount: "i32",
    pointLightCount: "i32",
    ambientColor: "vec3<f32>",
    // TODO define as arrays once we have appropriate uniformTypes
    lightColor0: "vec3<f32>",
    lightPosition0: "vec3<f32>",
    // TODO - could combine direction and attenuation
    lightDirection0: "vec3<f32>",
    lightAttenuation0: "vec3<f32>",
    lightColor1: "vec3<f32>",
    lightPosition1: "vec3<f32>",
    lightDirection1: "vec3<f32>",
    lightAttenuation1: "vec3<f32>",
    lightColor2: "vec3<f32>",
    lightPosition2: "vec3<f32>",
    lightDirection2: "vec3<f32>",
    lightAttenuation2: "vec3<f32>"
  },
  defaultUniforms: {
    enabled: 1,
    lightType: n0.POINT,
    directionalLightCount: 0,
    pointLightCount: 0,
    ambientColor: [0.1, 0.1, 0.1],
    lightColor0: [1, 1, 1],
    lightPosition0: [1, 1, 2],
    // TODO - could combine direction and attenuation
    lightDirection0: [1, 1, 1],
    lightAttenuation0: [1, 0, 0],
    lightColor1: [1, 1, 1],
    lightPosition1: [1, 1, 2],
    lightDirection1: [1, 1, 1],
    lightAttenuation1: [1, 0, 0],
    lightColor2: [1, 1, 1],
    lightPosition2: [1, 1, 2],
    lightDirection2: [1, 1, 1],
    lightAttenuation2: [1, 0, 0]
  },
  source: Mj,
  vs: uC,
  fs: uC,
  getUniforms: Oj
};
function Oj(r, e = {}) {
  if (r = r && { ...r }, !r)
    return { ...sp.defaultUniforms };
  r.lights && (r = { ...r, ...Lj(r.lights), lights: void 0 });
  const { ambientLight: t, pointLights: n, directionalLights: i } = r || {};
  if (!(t || n && n.length > 0 || i && i.length > 0))
    return { ...sp.defaultUniforms, enabled: 0 };
  const o = {
    ...sp.defaultUniforms,
    ...e,
    ...Dj({ ambientLight: t, pointLights: n, directionalLights: i })
  };
  return r.enabled !== void 0 && (o.enabled = r.enabled ? 1 : 0), o;
}
function Dj({ ambientLight: r, pointLights: e = [], directionalLights: t = [] }) {
  const n = {};
  n.ambientColor = Rv(r);
  let i = 0;
  for (const s of e) {
    n.lightType = n0.POINT;
    const o = i;
    n[`lightColor${o}`] = Rv(s), n[`lightPosition${o}`] = s.position, n[`lightAttenuation${o}`] = s.attenuation || [1, 0, 0], i++;
  }
  for (const s of t) {
    n.lightType = n0.DIRECTIONAL;
    const o = i;
    n[`lightColor${o}`] = Rv(s), n[`lightDirection${o}`] = s.direction, i++;
  }
  return i > Rj && qt.warn("MAX_LIGHTS exceeded")(), n.directionalLightCount = t.length, n.pointLightCount = e.length, n;
}
function Lj(r) {
  const e = { pointLights: [], directionalLights: [] };
  for (const t of r || [])
    switch (t.type) {
      case "ambient":
        e.ambientLight = t;
        break;
      case "directional":
        e.directionalLights?.push(t);
        break;
      case "point":
        e.pointLights?.push(t);
        break;
    }
  return e;
}
function Rv(r = {}) {
  const { color: e = [0, 0, 0], intensity: t = 1 } = r;
  return e.map((n) => n * t / Bj);
}
const OO = (
  /* glsl */
  `uniform phongMaterialUniforms {
  uniform float ambient;
  uniform float diffuse;
  uniform float shininess;
  uniform vec3  specularColor;
} material;
`
), DO = (
  /* glsl */
  `#define MAX_LIGHTS 3

uniform phongMaterialUniforms {
  uniform float ambient;
  uniform float diffuse;
  uniform float shininess;
  uniform vec3  specularColor;
} material;

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {
  vec3 halfway_direction = normalize(light_direction + view_direction);
  float lambertian = dot(light_direction, normal_worldspace);
  float specular = 0.0;
  if (lambertian > 0.0) {
    float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
    specular = pow(specular_angle, material.shininess);
  }
  lambertian = max(lambertian, 0.0);
  return (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;
}

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
  vec3 lightColor = surfaceColor;

  if (lighting.enabled == 0) {
    return lightColor;
  }

  vec3 view_direction = normalize(cameraPosition - position_worldspace);
  lightColor = material.ambient * surfaceColor * lighting.ambientColor;

  for (int i = 0; i < lighting.pointLightCount; i++) {
    PointLight pointLight = lighting_getPointLight(i);
    vec3 light_position_worldspace = pointLight.position;
    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
    float light_attenuation = getPointLightAttenuation(pointLight, distance(light_position_worldspace, position_worldspace));
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color / light_attenuation);
  }

  int totalLights = min(MAX_LIGHTS, lighting.pointLightCount + lighting.directionalLightCount);
  for (int i = lighting.pointLightCount; i < totalLights; i++) {
    DirectionalLight directionalLight = lighting_getDirectionalLight(i);
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  
  return lightColor;
}
`
), LO = (
  /* wgsl */
  `struct phongMaterialUniforms {
  ambient: f32,
  diffuse: f32,
  shininess: f32,
  specularColor: vec3<f32>,
};

@binding(2) @group(0) var<uniform> phongMaterial : phongMaterialUniforms;

fn lighting_getLightColor(surfaceColor: vec3<f32>, light_direction: vec3<f32>, view_direction: vec3<f32>, normal_worldspace: vec3<f32>, color: vec3<f32>) -> vec3<f32> {
  let halfway_direction: vec3<f32> = normalize(light_direction + view_direction);
  var lambertian: f32 = dot(light_direction, normal_worldspace);
  var specular: f32 = 0.0;
  if (lambertian > 0.0) {
    let specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
    specular = pow(specular_angle, phongMaterial.shininess);
  }
  lambertian = max(lambertian, 0.0);
  return (lambertian * phongMaterial.diffuse * surfaceColor + specular * phongMaterial.specularColor) * color;
}

fn lighting_getLightColor2(surfaceColor: vec3<f32>, cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32> {
  var lightColor: vec3<f32> = surfaceColor;

  if (lighting.enabled == 0) {
    return lightColor;
  }

  let view_direction: vec3<f32> = normalize(cameraPosition - position_worldspace);
  lightColor = phongMaterial.ambient * surfaceColor * lighting.ambientColor;

  if (lighting.lightType == 0) {
    let pointLight: PointLight  = lighting_getPointLight(0);
    let light_position_worldspace: vec3<f32> = pointLight.position;
    let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
  } else if (lighting.lightType == 1) {
    var directionalLight: DirectionalLight = lighting_getDirectionalLight(0);
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  
  return lightColor;
  /*
  for (int i = 0; i < MAX_LIGHTS; i++) {
    if (i >= lighting.pointLightCount) {
      break;
    }
    PointLight pointLight = lighting.pointLight[i];
    vec3 light_position_worldspace = pointLight.position;
    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
  }

  for (int i = 0; i < MAX_LIGHTS; i++) {
    if (i >= lighting.directionalLightCount) {
      break;
    }
    DirectionalLight directionalLight = lighting.directionalLight[i];
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  */
}

fn lighting_getSpecularLightColor(cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32>{
  var lightColor = vec3<f32>(0, 0, 0);
  let surfaceColor = vec3<f32>(0, 0, 0);

  if (lighting.enabled == 0) {
    let view_direction = normalize(cameraPosition - position_worldspace);

    switch (lighting.lightType) {
      case 0, default: {
        let pointLight: PointLight = lighting_getPointLight(0);
        let light_position_worldspace: vec3<f32> = pointLight.position;
        let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);
        lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
      }
      case 1: {
        let directionalLight: DirectionalLight = lighting_getDirectionalLight(0);
        lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
      }
    }
  }
  return lightColor;
}
`
), k_ = {
  props: {},
  name: "gouraudMaterial",
  // Note these are switched between phong and gouraud
  vs: DO.replace("phongMaterial", "gouraudMaterial"),
  fs: OO.replace("phongMaterial", "gouraudMaterial"),
  source: LO.replaceAll("phongMaterial", "gouraudMaterial"),
  defines: {
    LIGHTING_VERTEX: !0
  },
  dependencies: [sp],
  uniformTypes: {
    ambient: "f32",
    diffuse: "f32",
    shininess: "f32",
    specularColor: "vec3<f32>"
  },
  defaultUniforms: {
    ambient: 0.35,
    diffuse: 0.6,
    shininess: 32,
    specularColor: [0.15, 0.15, 0.15]
  },
  getUniforms(r) {
    const e = { ...r };
    return e.specularColor && (e.specularColor = e.specularColor.map((t) => t / 255)), { ...k_.defaultUniforms, ...e };
  }
}, kx = {
  name: "phongMaterial",
  dependencies: [sp],
  // Note these are switched between phong and gouraud
  source: LO,
  vs: OO,
  fs: DO,
  defines: {
    LIGHTING_FRAGMENT: !0
  },
  uniformTypes: {
    ambient: "f32",
    diffuse: "f32",
    shininess: "f32",
    specularColor: "vec3<f32>"
  },
  defaultUniforms: {
    ambient: 0.35,
    diffuse: 0.6,
    shininess: 32,
    specularColor: [0.15, 0.15, 0.15]
  },
  getUniforms(r) {
    const e = { ...r };
    return e.specularColor && (e.specularColor = e.specularColor.map((t) => t / 255)), { ...kx.defaultUniforms, ...e };
  }
}, kj = (
  /* glsl */
  `out vec3 pbr_vPosition;
out vec2 pbr_vUV;

#ifdef HAS_NORMALS
# ifdef HAS_TANGENTS
out mat3 pbr_vTBN;
# else
out vec3 pbr_vNormal;
# endif
#endif

void pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)
{
  vec4 pos = pbrProjection.modelMatrix * position;
  pbr_vPosition = vec3(pos.xyz) / pos.w;

#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
  vec3 normalW = normalize(vec3(pbrProjection.normalMatrix * vec4(normal.xyz, 0.0)));
  vec3 tangentW = normalize(vec3(pbrProjection.modelMatrix * vec4(tangent.xyz, 0.0)));
  vec3 bitangentW = cross(normalW, tangentW) * tangent.w;
  pbr_vTBN = mat3(tangentW, bitangentW, normalW);
#else // HAS_TANGENTS != 1
  pbr_vNormal = normalize(vec3(pbrProjection.modelMatrix * vec4(normal.xyz, 0.0)));
#endif
#endif

#ifdef HAS_UV
  pbr_vUV = uv;
#else
  pbr_vUV = vec2(0.,0.);
#endif
}
`
), Fj = (
  /* glsl */
  `precision highp float;

uniform pbrMaterialUniforms {
  // Material is unlit
  bool unlit;

  // Base color map
  bool baseColorMapEnabled;
  vec4 baseColorFactor;

  bool normalMapEnabled;  
  float normalScale; // #ifdef HAS_NORMALMAP

  bool emissiveMapEnabled;
  vec3 emissiveFactor; // #ifdef HAS_EMISSIVEMAP

  vec2 metallicRoughnessValues;
  bool metallicRoughnessMapEnabled;

  bool occlusionMapEnabled;
  float occlusionStrength; // #ifdef HAS_OCCLUSIONMAP
  
  bool alphaCutoffEnabled;
  float alphaCutoff; // #ifdef ALPHA_CUTOFF
  
  // IBL
  bool IBLenabled;
  vec2 scaleIBLAmbient; // #ifdef USE_IBL
  
  // debugging flags used for shader output of intermediate PBR variables
  // #ifdef PBR_DEBUG
  vec4 scaleDiffBaseMR;
  vec4 scaleFGDSpec;
  // #endif
} pbrMaterial;

// Samplers
#ifdef HAS_BASECOLORMAP
uniform sampler2D pbr_baseColorSampler;
#endif
#ifdef HAS_NORMALMAP
uniform sampler2D pbr_normalSampler;
#endif
#ifdef HAS_EMISSIVEMAP
uniform sampler2D pbr_emissiveSampler;
#endif
#ifdef HAS_METALROUGHNESSMAP
uniform sampler2D pbr_metallicRoughnessSampler;
#endif
#ifdef HAS_OCCLUSIONMAP
uniform sampler2D pbr_occlusionSampler;
#endif
#ifdef USE_IBL
uniform samplerCube pbr_diffuseEnvSampler;
uniform samplerCube pbr_specularEnvSampler;
uniform sampler2D pbr_brdfLUT;
#endif

// Inputs from vertex shader

in vec3 pbr_vPosition;
in vec2 pbr_vUV;

#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
in mat3 pbr_vTBN;
#else
in vec3 pbr_vNormal;
#endif
#endif

// Encapsulate the various inputs used by the various functions in the shading equation
// We store values in this struct to simplify the integration of alternative implementations
// of the shading terms, outlined in the Readme.MD Appendix.
struct PBRInfo {
  float NdotL;                  // cos angle between normal and light direction
  float NdotV;                  // cos angle between normal and view direction
  float NdotH;                  // cos angle between normal and half vector
  float LdotH;                  // cos angle between light direction and half vector
  float VdotH;                  // cos angle between view direction and half vector
  float perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)
  float metalness;              // metallic value at the surface
  vec3 reflectance0;            // full reflectance color (normal incidence angle)
  vec3 reflectance90;           // reflectance color at grazing angle
  float alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])
  vec3 diffuseColor;            // color contribution from diffuse lighting
  vec3 specularColor;           // color contribution from specular lighting
  vec3 n;                       // normal at surface point
  vec3 v;                       // vector from surface point to camera
};

const float M_PI = 3.141592653589793;
const float c_MinRoughness = 0.04;

vec4 SRGBtoLINEAR(vec4 srgbIn)
{
#ifdef MANUAL_SRGB
#ifdef SRGB_FAST_APPROXIMATION
  vec3 linOut = pow(srgbIn.xyz,vec3(2.2));
#else // SRGB_FAST_APPROXIMATION
  vec3 bLess = step(vec3(0.04045),srgbIn.xyz);
  vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );
#endif //SRGB_FAST_APPROXIMATION
  return vec4(linOut,srgbIn.w);;
#else //MANUAL_SRGB
  return srgbIn;
#endif //MANUAL_SRGB
}

// Find the normal for this fragment, pulling either from a predefined normal map
// or from the interpolated mesh normal and tangent attributes.
vec3 getNormal()
{
  // Retrieve the tangent space matrix
#ifndef HAS_TANGENTS
  vec3 pos_dx = dFdx(pbr_vPosition);
  vec3 pos_dy = dFdy(pbr_vPosition);
  vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));
  vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));
  vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);

#ifdef HAS_NORMALS
  vec3 ng = normalize(pbr_vNormal);
#else
  vec3 ng = cross(pos_dx, pos_dy);
#endif

  t = normalize(t - ng * dot(ng, t));
  vec3 b = normalize(cross(ng, t));
  mat3 tbn = mat3(t, b, ng);
#else // HAS_TANGENTS
  mat3 tbn = pbr_vTBN;
#endif

#ifdef HAS_NORMALMAP
  vec3 n = texture(pbr_normalSampler, pbr_vUV).rgb;
  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(pbrMaterial.normalScale, pbrMaterial.normalScale, 1.0)));
#else
  // The tbn matrix is linearly interpolated, so we need to re-normalize
  vec3 n = normalize(tbn[2].xyz);
#endif

  return n;
}

// Calculation of the lighting contribution from an optional Image Based Light source.
// Precomputed Environment Maps are required uniform inputs and are computed as outlined in [1].
// See our README.md on Environment Maps [3] for additional discussion.
#ifdef USE_IBL
vec3 getIBLContribution(PBRInfo pbrInfo, vec3 n, vec3 reflection)
{
  float mipCount = 9.0; // resolution of 512x512
  float lod = (pbrInfo.perceptualRoughness * mipCount);
  // retrieve a scale and bias to F0. See [1], Figure 3
  vec3 brdf = SRGBtoLINEAR(texture(pbr_brdfLUT,
    vec2(pbrInfo.NdotV, 1.0 - pbrInfo.perceptualRoughness))).rgb;
  vec3 diffuseLight = SRGBtoLINEAR(texture(pbr_diffuseEnvSampler, n)).rgb;

#ifdef USE_TEX_LOD
  vec3 specularLight = SRGBtoLINEAR(texture(pbr_specularEnvSampler, reflection, lod)).rgb;
#else
  vec3 specularLight = SRGBtoLINEAR(texture(pbr_specularEnvSampler, reflection)).rgb;
#endif

  vec3 diffuse = diffuseLight * pbrInfo.diffuseColor;
  vec3 specular = specularLight * (pbrInfo.specularColor * brdf.x + brdf.y);

  // For presentation, this allows us to disable IBL terms
  diffuse *= pbrMaterial.scaleIBLAmbient.x;
  specular *= pbrMaterial.scaleIBLAmbient.y;

  return diffuse + specular;
}
#endif

// Basic Lambertian diffuse
// Implementation from Lambert's Photometria https://archive.org/details/lambertsphotome00lambgoog
// See also [1], Equation 1
vec3 diffuse(PBRInfo pbrInfo)
{
  return pbrInfo.diffuseColor / M_PI;
}

// The following equation models the Fresnel reflectance term of the spec equation (aka F())
// Implementation of fresnel from [4], Equation 15
vec3 specularReflection(PBRInfo pbrInfo)
{
  return pbrInfo.reflectance0 +
    (pbrInfo.reflectance90 - pbrInfo.reflectance0) *
    pow(clamp(1.0 - pbrInfo.VdotH, 0.0, 1.0), 5.0);
}

// This calculates the specular geometric attenuation (aka G()),
// where rougher material will reflect less light back to the viewer.
// This implementation is based on [1] Equation 4, and we adopt their modifications to
// alphaRoughness as input as originally proposed in [2].
float geometricOcclusion(PBRInfo pbrInfo)
{
  float NdotL = pbrInfo.NdotL;
  float NdotV = pbrInfo.NdotV;
  float r = pbrInfo.alphaRoughness;

  float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));
  float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));
  return attenuationL * attenuationV;
}

// The following equation(s) model the distribution of microfacet normals across
// the area being drawn (aka D())
// Implementation from "Average Irregularity Representation of a Roughened Surface
// for Ray Reflection" by T. S. Trowbridge, and K. P. Reitz
// Follows the distribution function recommended in the SIGGRAPH 2013 course notes
// from EPIC Games [1], Equation 3.
float microfacetDistribution(PBRInfo pbrInfo)
{
  float roughnessSq = pbrInfo.alphaRoughness * pbrInfo.alphaRoughness;
  float f = (pbrInfo.NdotH * roughnessSq - pbrInfo.NdotH) * pbrInfo.NdotH + 1.0;
  return roughnessSq / (M_PI * f * f);
}

void PBRInfo_setAmbientLight(inout PBRInfo pbrInfo) {
  pbrInfo.NdotL = 1.0;
  pbrInfo.NdotH = 0.0;
  pbrInfo.LdotH = 0.0;
  pbrInfo.VdotH = 1.0;
}

void PBRInfo_setDirectionalLight(inout PBRInfo pbrInfo, vec3 lightDirection) {
  vec3 n = pbrInfo.n;
  vec3 v = pbrInfo.v;
  vec3 l = normalize(lightDirection);             // Vector from surface point to light
  vec3 h = normalize(l+v);                        // Half vector between both l and v

  pbrInfo.NdotL = clamp(dot(n, l), 0.001, 1.0);
  pbrInfo.NdotH = clamp(dot(n, h), 0.0, 1.0);
  pbrInfo.LdotH = clamp(dot(l, h), 0.0, 1.0);
  pbrInfo.VdotH = clamp(dot(v, h), 0.0, 1.0);
}

void PBRInfo_setPointLight(inout PBRInfo pbrInfo, PointLight pointLight) {
  vec3 light_direction = normalize(pointLight.position - pbr_vPosition);
  PBRInfo_setDirectionalLight(pbrInfo, light_direction);
}

vec3 calculateFinalColor(PBRInfo pbrInfo, vec3 lightColor) {
  // Calculate the shading terms for the microfacet specular shading model
  vec3 F = specularReflection(pbrInfo);
  float G = geometricOcclusion(pbrInfo);
  float D = microfacetDistribution(pbrInfo);

  // Calculation of analytical lighting contribution
  vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInfo);
  vec3 specContrib = F * G * D / (4.0 * pbrInfo.NdotL * pbrInfo.NdotV);
  // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)
  return pbrInfo.NdotL * lightColor * (diffuseContrib + specContrib);
}

vec4 pbr_filterColor(vec4 colorUnused)
{
  // The albedo may be defined from a base texture or a flat color
#ifdef HAS_BASECOLORMAP
  vec4 baseColor = SRGBtoLINEAR(texture(pbr_baseColorSampler, pbr_vUV)) * pbrMaterial.baseColorFactor;
#else
  vec4 baseColor = pbrMaterial.baseColorFactor;
#endif

#ifdef ALPHA_CUTOFF
  if (baseColor.a < pbrMaterial.alphaCutoff) {
    discard;
  }
#endif

  vec3 color = vec3(0, 0, 0);

  if(pbrMaterial.unlit){
    color.rgb = baseColor.rgb;
  }
  else{
    // Metallic and Roughness material properties are packed together
    // In glTF, these factors can be specified by fixed scalar values
    // or from a metallic-roughness map
    float perceptualRoughness = pbrMaterial.metallicRoughnessValues.y;
    float metallic = pbrMaterial.metallicRoughnessValues.x;
#ifdef HAS_METALROUGHNESSMAP
    // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.
    // This layout intentionally reserves the 'r' channel for (optional) occlusion map data
    vec4 mrSample = texture(pbr_metallicRoughnessSampler, pbr_vUV);
    perceptualRoughness = mrSample.g * perceptualRoughness;
    metallic = mrSample.b * metallic;
#endif
    perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);
    metallic = clamp(metallic, 0.0, 1.0);
    // Roughness is authored as perceptual roughness; as is convention,
    // convert to material roughness by squaring the perceptual roughness [2].
    float alphaRoughness = perceptualRoughness * perceptualRoughness;

    vec3 f0 = vec3(0.04);
    vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);
    diffuseColor *= 1.0 - metallic;
    vec3 specularColor = mix(f0, baseColor.rgb, metallic);

    // Compute reflectance.
    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);

    // For typical incident reflectance range (between 4% to 100%) set the grazing
    // reflectance to 100% for typical fresnel effect.
    // For very low reflectance range on highly diffuse objects (below 4%),
    // incrementally reduce grazing reflecance to 0%.
    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);
    vec3 specularEnvironmentR0 = specularColor.rgb;
    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;

    vec3 n = getNormal();                          // normal at surface point
    vec3 v = normalize(pbrProjection.camera - pbr_vPosition);  // Vector from surface point to camera

    float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);
    vec3 reflection = -normalize(reflect(v, n));

    PBRInfo pbrInfo = PBRInfo(
      0.0, // NdotL
      NdotV,
      0.0, // NdotH
      0.0, // LdotH
      0.0, // VdotH
      perceptualRoughness,
      metallic,
      specularEnvironmentR0,
      specularEnvironmentR90,
      alphaRoughness,
      diffuseColor,
      specularColor,
      n,
      v
    );


#ifdef USE_LIGHTS
    // Apply ambient light
    PBRInfo_setAmbientLight(pbrInfo);
    color += calculateFinalColor(pbrInfo, lighting.ambientColor);

    // Apply directional light
    for(int i = 0; i < lighting.directionalLightCount; i++) {
      if (i < lighting.directionalLightCount) {
        PBRInfo_setDirectionalLight(pbrInfo, lighting_getDirectionalLight(i).direction);
        color += calculateFinalColor(pbrInfo, lighting_getDirectionalLight(i).color);
      }
    }

    // Apply point light
    for(int i = 0; i < lighting.pointLightCount; i++) {
      if (i < lighting.pointLightCount) {
        PBRInfo_setPointLight(pbrInfo, lighting_getPointLight(i));
        float attenuation = getPointLightAttenuation(lighting_getPointLight(i), distance(lighting_getPointLight(i).position, pbr_vPosition));
        color += calculateFinalColor(pbrInfo, lighting_getPointLight(i).color / attenuation);
      }
    }
#endif

    // Calculate lighting contribution from image based lighting source (IBL)
#ifdef USE_IBL
    if (pbrMaterial.IBLenabled) {
      color += getIBLContribution(pbrInfo, n, reflection);
    }
#endif

 // Apply optional PBR terms for additional (optional) shading
#ifdef HAS_OCCLUSIONMAP
    if (pbrMaterial.occlusionMapEnabled) {
      float ao = texture(pbr_occlusionSampler, pbr_vUV).r;
      color = mix(color, color * ao, pbrMaterial.occlusionStrength);
    }
#endif

#ifdef HAS_EMISSIVEMAP
    if (pbrMaterial.emissiveMapEnabled) {
      vec3 emissive = SRGBtoLINEAR(texture(pbr_emissiveSampler, pbr_vUV)).rgb * pbrMaterial.emissiveFactor;
      color += emissive;
    }
#endif

    // This section uses mix to override final color for reference app visualization
    // of various parameters in the lighting equation.
#ifdef PBR_DEBUG
    // TODO: Figure out how to debug multiple lights

    // color = mix(color, F, pbr_scaleFGDSpec.x);
    // color = mix(color, vec3(G), pbr_scaleFGDSpec.y);
    // color = mix(color, vec3(D), pbr_scaleFGDSpec.z);
    // color = mix(color, specContrib, pbr_scaleFGDSpec.w);

    // color = mix(color, diffuseContrib, pbr_scaleDiffBaseMR.x);
    color = mix(color, baseColor.rgb, pbrMaterial.scaleDiffBaseMR.y);
    color = mix(color, vec3(metallic), pbrMaterial.scaleDiffBaseMR.z);
    color = mix(color, vec3(perceptualRoughness), pbrMaterial.scaleDiffBaseMR.w);
#endif

  }

  return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);
}
`
), Nj = (
  /* wgsl */
  `struct PBRFragmentInputs {
  pbr_vPosition: vec3f,
  pbr_vUV: vec2f,
  pbr_vTBN: mat3f,
  pbr_vNormal: vec3f
};

var fragmentInputs: PBRFragmentInputs;

fn pbr_setPositionNormalTangentUV(position: vec4f, normal: vec4f, tangent: vec4f, uv: vec2f)
{
  var pos: vec4f = pbrProjection.modelMatrix * position;
  pbr_vPosition = vec3(pos.xyz) / pos.w;

#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
  let normalW: vec3f = normalize(vec3(pbrProjection.normalMatrix * vec4(normal.xyz, 0.0)));
  let tangentW: vec3f = normalize(vec3(pbrProjection.modelMatrix * vec4(tangent.xyz, 0.0)));
  let bitangentW: vec3f = cross(normalW, tangentW) * tangent.w;
  fragmentInputs,pbr_vTBN = mat3(tangentW, bitangentW, normalW);
#else // HAS_TANGENTS != 1
  fragmentInputs.pbr_vNormal = normalize(vec3(pbrProjection.modelMatrix * vec4(normal.xyz, 0.0)));
#endif
#endif

#ifdef HAS_UV
  pbr_vUV = uv;
#else
  pbr_vUV = vec2(0.,0.);
#endif
}

struct pbrMaterialUniforms {
  // Material is unlit
  unlit: uint32,

  // Base color map
  baseColorMapEnabled: uint32,
  baseColorFactor: vec4f,

  normalMapEnabled : uint32,
  normalScale: f32,  // #ifdef HAS_NORMALMAP

  emissiveMapEnabled: uint32,
  emissiveFactor: vec3f, // #ifdef HAS_EMISSIVEMAP

  metallicRoughnessValues: vec2f,
  metallicRoughnessMapEnabled: uint32,

  occlusionMapEnabled: i32,
  occlusionStrength: f32, // #ifdef HAS_OCCLUSIONMAP
  
  alphaCutoffEnabled: i32,
  alphaCutoff: f32, // #ifdef ALPHA_CUTOFF
  
  // IBL
  IBLenabled: i32,
  scaleIBLAmbient: vec2f, // #ifdef USE_IBL
  
  // debugging flags used for shader output of intermediate PBR variables
  // #ifdef PBR_DEBUG
  scaleDiffBaseMR: vec4f,
  scaleFGDSpec: vec4f
  // #endif
} 
  
@binding(2) @group(0) var<uniform> material : pbrMaterialUniforms;

// Samplers
#ifdef HAS_BASECOLORMAP
uniform sampler2D pbr_baseColorSampler;
#endif
#ifdef HAS_NORMALMAP
uniform sampler2D pbr_normalSampler;
#endif
#ifdef HAS_EMISSIVEMAP
uniform sampler2D pbr_emissiveSampler;
#endif
#ifdef HAS_METALROUGHNESSMAP
uniform sampler2D pbr_metallicRoughnessSampler;
#endif
#ifdef HAS_OCCLUSIONMAP
uniform sampler2D pbr_occlusionSampler;
#endif
#ifdef USE_IBL
uniform samplerCube pbr_diffuseEnvSampler;
uniform samplerCube pbr_specularEnvSampler;
uniform sampler2D pbr_brdfLUT;
#endif

// Encapsulate the various inputs used by the various functions in the shading equation
// We store values in this struct to simplify the integration of alternative implementations
// of the shading terms, outlined in the Readme.MD Appendix.
struct PBRInfo {
  NdotL: f32,                  // cos angle between normal and light direction
  NdotV: f32,                  // cos angle between normal and view direction
  NdotH: f32,                  // cos angle between normal and half vector
  LdotH: f32,                  // cos angle between light direction and half vector
  VdotH: f32,                  // cos angle between view direction and half vector
  perceptualRoughness: f32,    // roughness value, as authored by the model creator (input to shader)
  metalness: f32,              // metallic value at the surface
  reflectance0: vec3f,            // full reflectance color (normal incidence angle)
  reflectance90: vec3f,           // reflectance color at grazing angle
  alphaRoughness: f32,         // roughness mapped to a more linear change in the roughness (proposed by [2])
  diffuseColor: vec3f,            // color contribution from diffuse lighting
  specularColor: vec3f,           // color contribution from specular lighting
  n: vec3f,                       // normal at surface point
  v: vec3f,                       // vector from surface point to camera
};

const M_PI = 3.141592653589793;
const c_MinRoughness = 0.04;

fn SRGBtoLINEAR(srgbIn: vec4f ) -> vec4f
{
#ifdef MANUAL_SRGB
#ifdef SRGB_FAST_APPROXIMATION
  var linOut: vec3f = pow(srgbIn.xyz,vec3(2.2));
#else // SRGB_FAST_APPROXIMATION
  var bLess: vec3f = step(vec3(0.04045),srgbIn.xyz);
  var linOut: vec3f = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );
#endif //SRGB_FAST_APPROXIMATION
  return vec4f(linOut,srgbIn.w);;
#else //MANUAL_SRGB
  return srgbIn;
#endif //MANUAL_SRGB
}

// Find the normal for this fragment, pulling either from a predefined normal map
// or from the interpolated mesh normal and tangent attributes.
fn getNormal() -> vec3f
{
  // Retrieve the tangent space matrix
#ifndef HAS_TANGENTS
  var pos_dx: vec3f = dFdx(pbr_vPosition);
  var pos_dy: vec3f = dFdy(pbr_vPosition);
  var tex_dx: vec3f = dFdx(vec3(pbr_vUV, 0.0));
  var tex_dy: vec3f = dFdy(vec3(pbr_vUV, 0.0));
  var t: vec3f = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);

#ifdef HAS_NORMALS
  var ng: vec3f = normalize(pbr_vNormal);
#else
  var ng: vec3f = cross(pos_dx, pos_dy);
#endif

  t = normalize(t - ng * dot(ng, t));
  var b: vec3f = normalize(cross(ng, t));
  var tbn: mat3f = mat3f(t, b, ng);
#else // HAS_TANGENTS
  var tbn: mat3f = pbr_vTBN;
#endif

#ifdef HAS_NORMALMAP
  vec3 n = texture(pbr_normalSampler, pbr_vUV).rgb;
  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(pbrMaterial.normalScale, pbrMaterial.normalScale, 1.0)));
#else
  // The tbn matrix is linearly interpolated, so we need to re-normalize
  vec3 n = normalize(tbn[2].xyz);
#endif

  return n;
}

// Calculation of the lighting contribution from an optional Image Based Light source.
// Precomputed Environment Maps are required uniform inputs and are computed as outlined in [1].
// See our README.md on Environment Maps [3] for additional discussion.
#ifdef USE_IBL
fn getIBLContribution(PBRInfo pbrInfo, vec3 n, vec3 reflection) -> vec3f
{
  float mipCount = 9.0; // resolution of 512x512
  float lod = (pbrInfo.perceptualRoughness * mipCount);
  // retrieve a scale and bias to F0. See [1], Figure 3
  vec3 brdf = SRGBtoLINEAR(texture(pbr_brdfLUT,
    vec2(pbrInfo.NdotV, 1.0 - pbrInfo.perceptualRoughness))).rgb;
  vec3 diffuseLight = SRGBtoLINEAR(texture(pbr_diffuseEnvSampler, n)).rgb;

#ifdef USE_TEX_LOD
  vec3 specularLight = SRGBtoLINEAR(texture(pbr_specularEnvSampler, reflection, lod)).rgb;
#else
  vec3 specularLight = SRGBtoLINEAR(texture(pbr_specularEnvSampler, reflection)).rgb;
#endif

  vec3 diffuse = diffuseLight * pbrInfo.diffuseColor;
  vec3 specular = specularLight * (pbrInfo.specularColor * brdf.x + brdf.y);

  // For presentation, this allows us to disable IBL terms
  diffuse *= pbrMaterial.scaleIBLAmbient.x;
  specular *= pbrMaterial.scaleIBLAmbient.y;

  return diffuse + specular;
}
#endif

// Basic Lambertian diffuse
// Implementation from Lambert's Photometria https://archive.org/details/lambertsphotome00lambgoog
// See also [1], Equation 1
fn diffuse(pbrInfo: PBRInfo) -> vec3<f32> {
  return pbrInfo.diffuseColor / PI;
}

// The following equation models the Fresnel reflectance term of the spec equation (aka F())
// Implementation of fresnel from [4], Equation 15
fn specularReflection(pbrInfo: PBRInfo) -> vec3<f32> {
  return pbrInfo.reflectance0 +
    (pbrInfo.reflectance90 - pbrInfo.reflectance0) *
    pow(clamp(1.0 - pbrInfo.VdotH, 0.0, 1.0), 5.0);
}

// This calculates the specular geometric attenuation (aka G()),
// where rougher material will reflect less light back to the viewer.
// This implementation is based on [1] Equation 4, and we adopt their modifications to
// alphaRoughness as input as originally proposed in [2].
fn geometricOcclusion(pbrInfo: PBRInfo) -> f32 {
  let NdotL: f32 = pbrInfo.NdotL;
  let NdotV: f32 = pbrInfo.NdotV;
  let r: f32 = pbrInfo.alphaRoughness;

  let attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));
  let attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));
  return attenuationL * attenuationV;
}

// The following equation(s) model the distribution of microfacet normals across
// the area being drawn (aka D())
// Implementation from "Average Irregularity Representation of a Roughened Surface
// for Ray Reflection" by T. S. Trowbridge, and K. P. Reitz
// Follows the distribution function recommended in the SIGGRAPH 2013 course notes
// from EPIC Games [1], Equation 3.
fn microfacetDistribution(pbrInfo: PBRInfo) -> f32 {
  let roughnessSq = pbrInfo.alphaRoughness * pbrInfo.alphaRoughness;
  let f = (pbrInfo.NdotH * roughnessSq - pbrInfo.NdotH) * pbrInfo.NdotH + 1.0;
  return roughnessSq / (PI * f * f);
}

fn PBRInfo_setAmbientLight(pbrInfo: ptr<function, PBRInfo>) {
  (*pbrInfo).NdotL = 1.0;
  (*pbrInfo).NdotH = 0.0;
  (*pbrInfo).LdotH = 0.0;
  (*pbrInfo).VdotH = 1.0;
}

fn PBRInfo_setDirectionalLight(pbrInfo: ptr<function, PBRInfo>, lightDirection: vec3<f32>) {
  let n = (*pbrInfo).n;
  let v = (*pbrInfo).v;
  let l = normalize(lightDirection);             // Vector from surface point to light
  let h = normalize(l + v);                      // Half vector between both l and v

  (*pbrInfo).NdotL = clamp(dot(n, l), 0.001, 1.0);
  (*pbrInfo).NdotH = clamp(dot(n, h), 0.0, 1.0);
  (*pbrInfo).LdotH = clamp(dot(l, h), 0.0, 1.0);
  (*pbrInfo).VdotH = clamp(dot(v, h), 0.0, 1.0);
}

fn PBRInfo_setPointLight(pbrInfo: ptr<function, PBRInfo>, pointLight: PointLight) {
  let light_direction = normalize(pointLight.position - pbr_vPosition);
  PBRInfo_setDirectionalLight(pbrInfo, light_direction);
}

fn calculateFinalColor(pbrInfo: PBRInfo, lightColor: vec3<f32>) -> vec3<f32> {
  // Calculate the shading terms for the microfacet specular shading model
  let F = specularReflection(pbrInfo);
  let G = geometricOcclusion(pbrInfo);
  let D = microfacetDistribution(pbrInfo);

  // Calculation of analytical lighting contribution
  let diffuseContrib = (1.0 - F) * diffuse(pbrInfo);
  let specContrib = F * G * D / (4.0 * pbrInfo.NdotL * pbrInfo.NdotV);
  // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)
  return pbrInfo.NdotL * lightColor * (diffuseContrib + specContrib);
}

fn pbr_filterColor(colorUnused: vec4<f32>) -> vec4<f32> {
  // The albedo may be defined from a base texture or a flat color
  var baseColor: vec4<f32>;
  #ifdef HAS_BASECOLORMAP
  baseColor = SRGBtoLINEAR(textureSample(pbr_baseColorSampler, pbr_baseColorSampler, pbr_vUV)) * pbrMaterial.baseColorFactor;
  #else
  baseColor = pbrMaterial.baseColorFactor;
  #endif

  #ifdef ALPHA_CUTOFF
  if (baseColor.a < pbrMaterial.alphaCutoff) {
    discard;
  }
  #endif

  var color = vec3<f32>(0.0, 0.0, 0.0);

  if (pbrMaterial.unlit) {
    color = baseColor.rgb;
  } else {
    // Metallic and Roughness material properties are packed together
    // In glTF, these factors can be specified by fixed scalar values
    // or from a metallic-roughness map
    var perceptualRoughness = pbrMaterial.metallicRoughnessValues.y;
    var metallic = pbrMaterial.metallicRoughnessValues.x;
    #ifdef HAS_METALROUGHNESSMAP
    // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.
    // This layout intentionally reserves the 'r' channel for (optional) occlusion map data
    let mrSample = textureSample(pbr_metallicRoughnessSampler, pbr_metallicRoughnessSampler, pbr_vUV);
    perceptualRoughness = mrSample.g * perceptualRoughness;
    metallic = mrSample.b * metallic;
    #endif
    perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);
    metallic = clamp(metallic, 0.0, 1.0);
    // Roughness is authored as perceptual roughness; as is convention,
    // convert to material roughness by squaring the perceptual roughness [2].
    let alphaRoughness = perceptualRoughness * perceptualRoughness;

    let f0 = vec3<f32>(0.04);
    var diffuseColor = baseColor.rgb * (vec3<f32>(1.0) - f0);
    diffuseColor *= 1.0 - metallic;
    let specularColor = mix(f0, baseColor.rgb, metallic);

    // Compute reflectance.
    let reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);

    // For typical incident reflectance range (between 4% to 100%) set the grazing
    // reflectance to 100% for typical fresnel effect.
    // For very low reflectance range on highly diffuse objects (below 4%),
    // incrementally reduce grazing reflectance to 0%.
    let reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);
    let specularEnvironmentR0 = specularColor;
    let specularEnvironmentR90 = vec3<f32>(1.0, 1.0, 1.0) * reflectance90;

    let n = getNormal();                          // normal at surface point
    let v = normalize(pbrProjection.camera - pbr_vPosition);  // Vector from surface point to camera

    let NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);
    let reflection = -normalize(reflect(v, n));

    var pbrInfo = PBRInfo(
      0.0, // NdotL
      NdotV,
      0.0, // NdotH
      0.0, // LdotH
      0.0, // VdotH
      perceptualRoughness,
      metallic,
      specularEnvironmentR0,
      specularEnvironmentR90,
      alphaRoughness,
      diffuseColor,
      specularColor,
      n,
      v
    );

    #ifdef USE_LIGHTS
    // Apply ambient light
    PBRInfo_setAmbientLight(&pbrInfo);
    color += calculateFinalColor(pbrInfo, lighting.ambientColor);

    // Apply directional light
    for (var i = 0; i < lighting.directionalLightCount; i++) {
      if (i < lighting.directionalLightCount) {
        PBRInfo_setDirectionalLight(&pbrInfo, lighting_getDirectionalLight(i).direction);
        color += calculateFinalColor(pbrInfo, lighting_getDirectionalLight(i).color);
      }
    }

    // Apply point light
    for (var i = 0; i < lighting.pointLightCount; i++) {
      if (i < lighting.pointLightCount) {
        PBRInfo_setPointLight(&pbrInfo, lighting_getPointLight(i));
        let attenuation = getPointLightAttenuation(lighting_getPointLight(i), distance(lighting_getPointLight(i).position, pbr_vPosition));
        color += calculateFinalColor(pbrInfo, lighting_getPointLight(i).color / attenuation);
      }
    }
    #endif

    // Calculate lighting contribution from image based lighting source (IBL)
    #ifdef USE_IBL
    if (pbrMaterial.IBLenabled) {
      color += getIBLContribution(pbrInfo, n, reflection);
    }
    #endif

    // Apply optional PBR terms for additional (optional) shading
    #ifdef HAS_OCCLUSIONMAP
    if (pbrMaterial.occlusionMapEnabled) {
      let ao = textureSample(pbr_occlusionSampler, pbr_occlusionSampler, pbr_vUV).r;
      color = mix(color, color * ao, pbrMaterial.occlusionStrength);
    }
    #endif

    #ifdef HAS_EMISSIVEMAP
    if (pbrMaterial.emissiveMapEnabled) {
      let emissive = SRGBtoLINEAR(textureSample(pbr_emissiveSampler, pbr_emissiveSampler, pbr_vUV)).rgb * pbrMaterial.emissiveFactor;
      color += emissive;
    }
    #endif

    // This section uses mix to override final color for reference app visualization
    // of various parameters in the lighting equation.
    #ifdef PBR_DEBUG
    // TODO: Figure out how to debug multiple lights

    // color = mix(color, F, pbr_scaleFGDSpec.x);
    // color = mix(color, vec3(G), pbr_scaleFGDSpec.y);
    // color = mix(color, vec3(D), pbr_scaleFGDSpec.z);
    // color = mix(color, specContrib, pbr_scaleFGDSpec.w);

    // color = mix(color, diffuseContrib, pbr_scaleDiffBaseMR.x);
    color = mix(color, baseColor.rgb, pbrMaterial.scaleDiffBaseMR.y);
    color = mix(color, vec3<f32>(metallic), pbrMaterial.scaleDiffBaseMR.z);
    color = mix(color, vec3<f32>(perceptualRoughness), pbrMaterial.scaleDiffBaseMR.w);
    #endif
  }

  return vec4<f32>(pow(color, vec3<f32>(1.0 / 2.2)), baseColor.a);
}
`
), fC = (
  /* glsl */
  `uniform pbrProjectionUniforms {
  mat4 modelViewProjectionMatrix;
  mat4 modelMatrix;
  mat4 normalMatrix;
  vec3 camera;
} pbrProjection;
`
), Uj = {
  name: "pbrProjection",
  vs: fC,
  fs: fC,
  // TODO why is this needed?
  getUniforms: (r) => r,
  uniformTypes: {
    modelViewProjectionMatrix: "mat4x4<f32>",
    modelMatrix: "mat4x4<f32>",
    normalMatrix: "mat4x4<f32>",
    camera: "vec3<i32>"
  }
}, Fx = {
  props: {},
  uniforms: {},
  name: "pbrMaterial",
  dependencies: [sp, Uj],
  source: Nj,
  vs: kj,
  fs: Fj,
  defines: {
    LIGHTING_FRAGMENT: !0,
    HAS_NORMALMAP: !1,
    HAS_EMISSIVEMAP: !1,
    HAS_OCCLUSIONMAP: !1,
    HAS_BASECOLORMAP: !1,
    HAS_METALROUGHNESSMAP: !1,
    ALPHA_CUTOFF: !1,
    USE_IBL: !1,
    PBR_DEBUG: !1
  },
  getUniforms: (r) => r,
  uniformTypes: {
    // Material is unlit
    unlit: "i32",
    // Base color map
    baseColorMapEnabled: "i32",
    baseColorFactor: "vec4<f32>",
    normalMapEnabled: "i32",
    normalScale: "f32",
    // #ifdef HAS_NORMALMAP
    emissiveMapEnabled: "i32",
    emissiveFactor: "vec3<f32>",
    // #ifdef HAS_EMISSIVEMAP
    metallicRoughnessValues: "vec2<f32>",
    metallicRoughnessMapEnabled: "i32",
    occlusionMapEnabled: "i32",
    occlusionStrength: "f32",
    // #ifdef HAS_OCCLUSIONMAP
    alphaCutoffEnabled: "i32",
    alphaCutoff: "f32",
    // #ifdef ALPHA_CUTOFF
    // IBL
    IBLenabled: "i32",
    scaleIBLAmbient: "vec2<f32>",
    // #ifdef USE_IBL
    // debugging flags used for shader output of intermediate PBR variables
    // #ifdef PBR_DEBUG
    scaleDiffBaseMR: "vec4<f32>",
    scaleFGDSpec: "vec4<f32>"
  }
}, hC = `uniform layerUniforms {
  uniform float opacity;
} layer;
`, zj = {
  name: "layer",
  vs: hC,
  fs: hC,
  getUniforms: (r) => ({
    // apply gamma to opacity to make it visually "linear"
    // TODO - v10: use raw opacity?
    opacity: Math.pow(r.opacity, 1 / 2.2)
  }),
  uniformTypes: {
    opacity: "f32"
  }
}, Vj = (
  /* WGSL */
  `

struct ColorUniforms {
  opacity: f32,
};

var<private> color: ColorUniforms = ColorUniforms(1.0);
// TODO (kaapp) avoiding binding index collisions to handle layer opacity 
// requires some thought.
// @group(0) @binding(0) var<uniform> color: ColorUniforms;

@must_use
fn deckgl_premultiplied_alpha(fragColor: vec4<f32>) -> vec4<f32> {
    return vec4(fragColor.rgb * fragColor.a, fragColor.a); 
};
`
), Nx = {
  name: "color",
  dependencies: [],
  source: Vj,
  getUniforms: (r) => ({}),
  uniformTypes: {
    opacity: "f32"
  }
  // @ts-ignore TODO v9.1
}, jj = (
  /* wgsl */
  `const SMOOTH_EDGE_RADIUS: f32 = 0.5;

struct VertexGeometry {
  position: vec4<f32>,
  worldPosition: vec3<f32>,
  worldPositionAlt: vec3<f32>,
  normal: vec3<f32>,
  uv: vec2<f32>,
  pickingColor: vec3<f32>,
};

var<private> geometry_: VertexGeometry = VertexGeometry(
  vec4<f32>(0.0, 0.0, 1.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0),
  vec2<f32>(0.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0)
);

struct FragmentGeometry {
  uv: vec2<f32>,
};

var<private> fragmentGeometry: FragmentGeometry;

fn smoothedge(edge: f32, x: f32) -> f32 {
  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);
}
`
), kO = "#define SMOOTH_EDGE_RADIUS 0.5", Hj = (
  /* glsl */
  `${kO}

struct VertexGeometry {
  vec4 position;
  vec3 worldPosition;
  vec3 worldPositionAlt;
  vec3 normal;
  vec2 uv;
  vec3 pickingColor;
} geometry = VertexGeometry(
  vec4(0.0, 0.0, 1.0, 0.0),
  vec3(0.0),
  vec3(0.0),
  vec3(0.0),
  vec2(0.0),
  vec3(0.0)
);
`
), Gj = (
  /* glsl */
  `${kO}

struct FragmentGeometry {
  vec2 uv;
} geometry;

float smoothedge(float edge, float x) {
  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);
}
`
), FO = {
  name: "geometry",
  source: jj,
  vs: Hj,
  fs: Gj
}, Wj = 25;
var As;
(function(r) {
  r[r.Start = 1] = "Start", r[r.Move = 2] = "Move", r[r.End = 4] = "End", r[r.Cancel = 8] = "Cancel";
})(As || (As = {}));
var Cs;
(function(r) {
  r[r.None = 0] = "None", r[r.Left = 1] = "Left", r[r.Right = 2] = "Right", r[r.Up = 4] = "Up", r[r.Down = 8] = "Down", r[r.Horizontal = 3] = "Horizontal", r[r.Vertical = 12] = "Vertical", r[r.All = 15] = "All";
})(Cs || (Cs = {}));
var En;
(function(r) {
  r[r.Possible = 1] = "Possible", r[r.Began = 2] = "Began", r[r.Changed = 4] = "Changed", r[r.Ended = 8] = "Ended", r[r.Recognized = 8] = "Recognized", r[r.Cancelled = 16] = "Cancelled", r[r.Failed = 32] = "Failed";
})(En || (En = {}));
const $j = "compute", qj = "auto", Bb = "manipulation", xm = "none", Ob = "pan-x", Db = "pan-y";
function Xj(r) {
  if (r.includes(xm))
    return xm;
  const e = r.includes(Ob), t = r.includes(Db);
  return e && t ? xm : e || t ? e ? Ob : Db : r.includes(Bb) ? Bb : qj;
}
class Zj {
  constructor(e, t) {
    this.actions = "", this.manager = e, this.set(t);
  }
  /**
   * set the touchAction value on the element or enable the polyfill
   */
  set(e) {
    e === $j && (e = this.compute()), this.manager.element && (this.manager.element.style.touchAction = e, this.actions = e);
  }
  /**
   * just re-set the touchAction value
   */
  update() {
    this.set(this.manager.options.touchAction);
  }
  /**
   * compute the value for the touchAction property based on the recognizer's settings
   */
  compute() {
    let e = [];
    for (const t of this.manager.recognizers)
      t.options.enable && (e = e.concat(t.getTouchAction()));
    return Xj(e.join(" "));
  }
}
function r_(r) {
  return r.trim().split(/\s+/g);
}
function Bv(r, e, t) {
  if (r)
    for (const n of r_(e))
      r.addEventListener(n, t, !1);
}
function Ov(r, e, t) {
  if (r)
    for (const n of r_(e))
      r.removeEventListener(n, t, !1);
}
function dC(r) {
  return (r.ownerDocument || r).defaultView;
}
function Yj(r, e) {
  let t = r;
  for (; t; ) {
    if (t === e)
      return !0;
    t = t.parentNode;
  }
  return !1;
}
function NO(r) {
  const e = r.length;
  if (e === 1)
    return {
      x: Math.round(r[0].clientX),
      y: Math.round(r[0].clientY)
    };
  let t = 0, n = 0, i = 0;
  for (; i < e; )
    t += r[i].clientX, n += r[i].clientY, i++;
  return {
    x: Math.round(t / e),
    y: Math.round(n / e)
  };
}
function pC(r) {
  const e = [];
  let t = 0;
  for (; t < r.pointers.length; )
    e[t] = {
      clientX: Math.round(r.pointers[t].clientX),
      clientY: Math.round(r.pointers[t].clientY)
    }, t++;
  return {
    timeStamp: Date.now(),
    pointers: e,
    center: NO(e),
    deltaX: r.deltaX,
    deltaY: r.deltaY
  };
}
function UO(r, e) {
  const t = e.x - r.x, n = e.y - r.y;
  return Math.sqrt(t * t + n * n);
}
function AC(r, e) {
  const t = e.clientX - r.clientX, n = e.clientY - r.clientY;
  return Math.sqrt(t * t + n * n);
}
function Kj(r, e) {
  const t = e.x - r.x, n = e.y - r.y;
  return Math.atan2(n, t) * 180 / Math.PI;
}
function gC(r, e) {
  const t = e.clientX - r.clientX, n = e.clientY - r.clientY;
  return Math.atan2(n, t) * 180 / Math.PI;
}
function zO(r, e) {
  return r === e ? Cs.None : Math.abs(r) >= Math.abs(e) ? r < 0 ? Cs.Left : Cs.Right : e < 0 ? Cs.Up : Cs.Down;
}
function Qj(r, e) {
  const t = e.center;
  let n = r.offsetDelta, i = r.prevDelta;
  const s = r.prevInput;
  return (e.eventType === As.Start || s?.eventType === As.End) && (i = r.prevDelta = {
    x: s?.deltaX || 0,
    y: s?.deltaY || 0
  }, n = r.offsetDelta = {
    x: t.x,
    y: t.y
  }), {
    deltaX: i.x + (t.x - n.x),
    deltaY: i.y + (t.y - n.y)
  };
}
function VO(r, e, t) {
  return {
    x: e / r || 0,
    y: t / r || 0
  };
}
function Jj(r, e) {
  return AC(e[0], e[1]) / AC(r[0], r[1]);
}
function eH(r, e) {
  return gC(e[1], e[0]) - gC(r[1], r[0]);
}
function tH(r, e) {
  const t = r.lastInterval || e, n = e.timeStamp - t.timeStamp;
  let i, s, o, l;
  if (e.eventType !== As.Cancel && (n > Wj || t.velocity === void 0)) {
    const u = e.deltaX - t.deltaX, m = e.deltaY - t.deltaY, y = VO(n, u, m);
    s = y.x, o = y.y, i = Math.abs(y.x) > Math.abs(y.y) ? y.x : y.y, l = zO(u, m), r.lastInterval = e;
  } else
    i = t.velocity, s = t.velocityX, o = t.velocityY, l = t.direction;
  e.velocity = i, e.velocityX = s, e.velocityY = o, e.direction = l;
}
function rH(r, e) {
  const { session: t } = r, { pointers: n } = e, { length: i } = n;
  t.firstInput || (t.firstInput = pC(e)), i > 1 && !t.firstMultiple ? t.firstMultiple = pC(e) : i === 1 && (t.firstMultiple = !1);
  const { firstInput: s, firstMultiple: o } = t, l = o ? o.center : s.center, u = e.center = NO(n);
  e.timeStamp = Date.now(), e.deltaTime = e.timeStamp - s.timeStamp, e.angle = Kj(l, u), e.distance = UO(l, u);
  const { deltaX: m, deltaY: y } = Qj(t, e);
  e.deltaX = m, e.deltaY = y, e.offsetDirection = zO(e.deltaX, e.deltaY);
  const E = VO(e.deltaTime, e.deltaX, e.deltaY);
  e.overallVelocityX = E.x, e.overallVelocityY = E.y, e.overallVelocity = Math.abs(E.x) > Math.abs(E.y) ? E.x : E.y, e.scale = o ? Jj(o.pointers, n) : 1, e.rotation = o ? eH(o.pointers, n) : 0, e.maxPointers = t.prevInput ? e.pointers.length > t.prevInput.maxPointers ? e.pointers.length : t.prevInput.maxPointers : e.pointers.length;
  let P = r.element;
  return Yj(e.srcEvent.target, P) && (P = e.srcEvent.target), e.target = P, tH(t, e), e;
}
function nH(r, e, t) {
  const n = t.pointers.length, i = t.changedPointers.length, s = e & As.Start && n - i === 0, o = e & (As.End | As.Cancel) && n - i === 0;
  t.isFirst = !!s, t.isFinal = !!o, s && (r.session = {}), t.eventType = e;
  const l = rH(r, t);
  r.emit("hammer.input", l), r.recognize(l), r.session.prevInput = l;
}
let iH = class {
  constructor(e) {
    this.evEl = "", this.evWin = "", this.evTarget = "", this.domHandler = (t) => {
      this.manager.options.enable && this.handler(t);
    }, this.manager = e, this.element = e.element, this.target = e.options.inputTarget || e.element;
  }
  callback(e, t) {
    nH(this.manager, e, t);
  }
  // eslint-disable @typescript-eslint/unbound-method
  /**
   * bind the events
   */
  init() {
    Bv(this.element, this.evEl, this.domHandler), Bv(this.target, this.evTarget, this.domHandler), Bv(dC(this.element), this.evWin, this.domHandler);
  }
  /**
   * unbind the events
   */
  destroy() {
    Ov(this.element, this.evEl, this.domHandler), Ov(this.target, this.evTarget, this.domHandler), Ov(dC(this.element), this.evWin, this.domHandler);
  }
};
const sH = {
  pointerdown: As.Start,
  pointermove: As.Move,
  pointerup: As.End,
  pointercancel: As.Cancel,
  pointerout: As.Cancel
}, oH = "pointerdown", aH = "pointermove pointerup pointercancel";
class lH extends iH {
  constructor(e) {
    super(e), this.evEl = oH, this.evWin = aH, this.store = this.manager.session.pointerEvents = [], this.init();
  }
  /**
   * handle mouse events
   */
  handler(e) {
    const { store: t } = this;
    let n = !1;
    const i = sH[e.type], s = e.pointerType, o = s === "touch";
    let l = t.findIndex((u) => u.pointerId === e.pointerId);
    i & As.Start && (e.buttons || o) ? l < 0 && (t.push(e), l = t.length - 1) : i & (As.End | As.Cancel) && (n = !0), !(l < 0) && (t[l] = e, this.callback(i, {
      pointers: t,
      changedPointers: [e],
      eventType: i,
      pointerType: s,
      srcEvent: e
    }), n && t.splice(l, 1));
  }
}
const cH = ["", "webkit", "Moz", "MS", "ms", "o"];
function uH(r, e) {
  const t = e[0].toUpperCase() + e.slice(1);
  for (const n of cH) {
    const i = n ? n + t : e;
    if (i in r)
      return i;
  }
}
const fH = 1, mC = 2, _C = {
  touchAction: "compute",
  enable: !0,
  inputTarget: null,
  cssProps: {
    /**
     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
     */
    userSelect: "none",
    /**
     * (Webkit) Disable default dragging behavior
     */
    // @ts-ignore
    userDrag: "none",
    /**
     * (iOS only) Disables the default callout shown when you touch and hold a touch target.
     * When you touch and hold a touch target such as a link, Safari displays
     * a callout containing information about the link. This property allows you to disable that callout.
     */
    // @ts-ignore
    touchCallout: "none",
    /**
     * (iOS only) Sets the color of the highlight that appears over a link while it's being tapped.
     */
    // @ts-ignore
    tapHighlightColor: "rgba(0,0,0,0)"
  }
};
let hH = class {
  constructor(e, t) {
    this.options = {
      ..._C,
      ...t,
      cssProps: { ..._C.cssProps, ...t.cssProps },
      inputTarget: t.inputTarget || e
    }, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = e, this.input = new lH(this), this.touchAction = new Zj(this, this.options.touchAction), this.toggleCssProps(!0);
  }
  /**
   * set options
   */
  set(e) {
    return Object.assign(this.options, e), e.touchAction && this.touchAction.update(), e.inputTarget && (this.input.destroy(), this.input.target = e.inputTarget, this.input.init()), this;
  }
  /**
   * stop recognizing for this session.
   * This session will be discarded, when a new [input]start event is fired.
   * When forced, the recognizer cycle is stopped immediately.
   */
  stop(e) {
    this.session.stopped = e ? mC : fH;
  }
  /**
   * run the recognizers!
   * called by the inputHandler function on every movement of the pointers (touches)
   * it walks through all the recognizers and tries to detect the gesture that is being made
   */
  recognize(e) {
    const { session: t } = this;
    if (t.stopped)
      return;
    this.session.prevented && e.srcEvent.preventDefault();
    let n;
    const { recognizers: i } = this;
    let { curRecognizer: s } = t;
    (!s || s && s.state & En.Recognized) && (s = t.curRecognizer = null);
    let o = 0;
    for (; o < i.length; )
      n = i[o], t.stopped !== mC && // 1
      (!s || n === s || // 2
      n.canRecognizeWith(s)) ? n.recognize(e) : n.reset(), !s && n.state & (En.Began | En.Changed | En.Ended) && (s = t.curRecognizer = n), o++;
  }
  /**
   * get a recognizer by its event name.
   */
  get(e) {
    const { recognizers: t } = this;
    for (let n = 0; n < t.length; n++)
      if (t[n].options.event === e)
        return t[n];
    return null;
  }
  /**
   * add a recognizer to the manager
   * existing recognizers with the same event name will be removed
   */
  add(e) {
    if (Array.isArray(e)) {
      for (const n of e)
        this.add(n);
      return this;
    }
    const t = this.get(e.options.event);
    return t && this.remove(t), this.recognizers.push(e), e.manager = this, this.touchAction.update(), e;
  }
  /**
   * remove a recognizer by name or instance
   */
  remove(e) {
    if (Array.isArray(e)) {
      for (const n of e)
        this.remove(n);
      return this;
    }
    const t = typeof e == "string" ? this.get(e) : e;
    if (t) {
      const { recognizers: n } = this, i = n.indexOf(t);
      i !== -1 && (n.splice(i, 1), this.touchAction.update());
    }
    return this;
  }
  /**
   * bind event
   */
  on(e, t) {
    if (!e || !t)
      return;
    const { handlers: n } = this;
    for (const i of r_(e))
      n[i] = n[i] || [], n[i].push(t);
  }
  /**
   * unbind event, leave hander blank to remove all handlers
   */
  off(e, t) {
    if (!e)
      return;
    const { handlers: n } = this;
    for (const i of r_(e))
      t ? n[i] && n[i].splice(n[i].indexOf(t), 1) : delete n[i];
  }
  /**
   * emit event to the listeners
   */
  emit(e, t) {
    const n = this.handlers[e] && this.handlers[e].slice();
    if (!n || !n.length)
      return;
    const i = t;
    i.type = e, i.preventDefault = function() {
      t.srcEvent.preventDefault();
    };
    let s = 0;
    for (; s < n.length; )
      n[s](i), s++;
  }
  /**
   * destroy the manager and unbinds all events
   * it doesn't unbind dom events, that is the user own responsibility
   */
  destroy() {
    this.toggleCssProps(!1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null;
  }
  /**
   * add/remove the css properties as defined in manager.options.cssProps
   */
  toggleCssProps(e) {
    const { element: t } = this;
    if (t) {
      for (const [n, i] of Object.entries(this.options.cssProps)) {
        const s = uH(t.style, n);
        e ? (this.oldCssProps[s] = t.style[s], t.style[s] = i) : t.style[s] = this.oldCssProps[s] || "";
      }
      e || (this.oldCssProps = {});
    }
  }
}, dH = 1;
function pH() {
  return dH++;
}
function yC(r) {
  return r & En.Cancelled ? "cancel" : r & En.Ended ? "end" : r & En.Changed ? "move" : r & En.Began ? "start" : "";
}
class jO {
  constructor(e) {
    this.options = e, this.id = pH(), this.state = En.Possible, this.simultaneous = {}, this.requireFail = [];
  }
  /**
   * set options
   */
  set(e) {
    return Object.assign(this.options, e), this.manager.touchAction.update(), this;
  }
  /**
   * recognize simultaneous with an other recognizer.
   */
  recognizeWith(e) {
    if (Array.isArray(e)) {
      for (const i of e)
        this.recognizeWith(i);
      return this;
    }
    let t;
    if (typeof e == "string") {
      if (t = this.manager.get(e), !t)
        throw new Error(`Cannot find recognizer ${e}`);
    } else
      t = e;
    const { simultaneous: n } = this;
    return n[t.id] || (n[t.id] = t, t.recognizeWith(this)), this;
  }
  /**
   * drop the simultaneous link. it doesnt remove the link on the other recognizer.
   */
  dropRecognizeWith(e) {
    if (Array.isArray(e)) {
      for (const n of e)
        this.dropRecognizeWith(n);
      return this;
    }
    let t;
    return typeof e == "string" ? t = this.manager.get(e) : t = e, t && delete this.simultaneous[t.id], this;
  }
  /**
   * recognizer can only run when an other is failing
   */
  requireFailure(e) {
    if (Array.isArray(e)) {
      for (const i of e)
        this.requireFailure(i);
      return this;
    }
    let t;
    if (typeof e == "string") {
      if (t = this.manager.get(e), !t)
        throw new Error(`Cannot find recognizer ${e}`);
    } else
      t = e;
    const { requireFail: n } = this;
    return n.indexOf(t) === -1 && (n.push(t), t.requireFailure(this)), this;
  }
  /**
   * drop the requireFailure link. it does not remove the link on the other recognizer.
   */
  dropRequireFailure(e) {
    if (Array.isArray(e)) {
      for (const n of e)
        this.dropRequireFailure(n);
      return this;
    }
    let t;
    if (typeof e == "string" ? t = this.manager.get(e) : t = e, t) {
      const n = this.requireFail.indexOf(t);
      n > -1 && this.requireFail.splice(n, 1);
    }
    return this;
  }
  /**
   * has require failures boolean
   */
  hasRequireFailures() {
    return !!this.requireFail.find((e) => e.options.enable);
  }
  /**
   * if the recognizer can recognize simultaneous with an other recognizer
   */
  canRecognizeWith(e) {
    return !!this.simultaneous[e.id];
  }
  /**
   * You should use `tryEmit` instead of `emit` directly to check
   * that all the needed recognizers has failed before emitting.
   */
  emit(e) {
    if (!e)
      return;
    const { state: t } = this;
    t < En.Ended && this.manager.emit(this.options.event + yC(t), e), this.manager.emit(this.options.event, e), e.additionalEvent && this.manager.emit(e.additionalEvent, e), t >= En.Ended && this.manager.emit(this.options.event + yC(t), e);
  }
  /**
   * Check that all the require failure recognizers has failed,
   * if true, it emits a gesture event,
   * otherwise, setup the state to FAILED.
   */
  tryEmit(e) {
    this.canEmit() ? this.emit(e) : this.state = En.Failed;
  }
  /**
   * can we emit?
   */
  canEmit() {
    let e = 0;
    for (; e < this.requireFail.length; ) {
      if (!(this.requireFail[e].state & (En.Failed | En.Possible)))
        return !1;
      e++;
    }
    return !0;
  }
  /**
   * update the recognizer
   */
  recognize(e) {
    const t = { ...e };
    if (!this.options.enable) {
      this.reset(), this.state = En.Failed;
      return;
    }
    this.state & (En.Recognized | En.Cancelled | En.Failed) && (this.state = En.Possible), this.state = this.process(t), this.state & (En.Began | En.Changed | En.Ended | En.Cancelled) && this.tryEmit(t);
  }
  /**
   * return the event names that are emitted by this recognizer
   */
  getEventNames() {
    return [this.options.event];
  }
  /**
   * called when the gesture isn't allowed to recognize
   * like when another is being recognized or it is disabled
   */
  reset() {
  }
}
class HO extends jO {
  /**
   * Used to check if it the recognizer receives valid input, like input.distance > 10.
   */
  attrTest(e) {
    const t = this.options.pointers;
    return t === 0 || e.pointers.length === t;
  }
  /**
   * Process the input and return the state for the recognizer
   */
  process(e) {
    const { state: t } = this, { eventType: n } = e, i = t & (En.Began | En.Changed), s = this.attrTest(e);
    return i && (n & As.Cancel || !s) ? t | En.Cancelled : i || s ? n & As.End ? t | En.Ended : t & En.Began ? t | En.Changed : En.Began : En.Failed;
  }
}
class vC extends jO {
  constructor(e = {}) {
    super({
      enable: !0,
      event: "tap",
      pointers: 1,
      taps: 1,
      interval: 300,
      time: 250,
      threshold: 9,
      posThreshold: 10,
      ...e
    }), this.pTime = null, this.pCenter = null, this._timer = null, this._input = null, this.count = 0;
  }
  getTouchAction() {
    return [Bb];
  }
  process(e) {
    const { options: t } = this, n = e.pointers.length === t.pointers, i = e.distance < t.threshold, s = e.deltaTime < t.time;
    if (this.reset(), e.eventType & As.Start && this.count === 0)
      return this.failTimeout();
    if (i && s && n) {
      if (e.eventType !== As.End)
        return this.failTimeout();
      const o = this.pTime ? e.timeStamp - this.pTime < t.interval : !0, l = !this.pCenter || UO(this.pCenter, e.center) < t.posThreshold;
      if (this.pTime = e.timeStamp, this.pCenter = e.center, !l || !o ? this.count = 1 : this.count += 1, this._input = e, this.count % t.taps === 0)
        return this.hasRequireFailures() ? (this._timer = setTimeout(() => {
          this.state = En.Recognized, this.tryEmit(this._input);
        }, t.interval), En.Began) : En.Recognized;
    }
    return En.Failed;
  }
  failTimeout() {
    return this._timer = setTimeout(() => {
      this.state = En.Failed;
    }, this.options.interval), En.Failed;
  }
  reset() {
    clearTimeout(this._timer);
  }
  emit(e) {
    this.state === En.Recognized && (e.tapCount = this.count, this.manager.emit(this.options.event, e));
  }
}
const AH = ["", "start", "move", "end", "cancel", "up", "down", "left", "right"];
class bC extends HO {
  constructor(e = {}) {
    super({
      enable: !0,
      pointers: 1,
      event: "pan",
      threshold: 10,
      direction: Cs.All,
      ...e
    }), this.pX = null, this.pY = null;
  }
  getTouchAction() {
    const { options: { direction: e } } = this, t = [];
    return e & Cs.Horizontal && t.push(Db), e & Cs.Vertical && t.push(Ob), t;
  }
  getEventNames() {
    return AH.map((e) => this.options.event + e);
  }
  directionTest(e) {
    const { options: t } = this;
    let n = !0, { distance: i } = e, { direction: s } = e;
    const o = e.deltaX, l = e.deltaY;
    return s & t.direction || (t.direction & Cs.Horizontal ? (s = o === 0 ? Cs.None : o < 0 ? Cs.Left : Cs.Right, n = o !== this.pX, i = Math.abs(e.deltaX)) : (s = l === 0 ? Cs.None : l < 0 ? Cs.Up : Cs.Down, n = l !== this.pY, i = Math.abs(e.deltaY))), e.direction = s, n && i > t.threshold && !!(s & t.direction);
  }
  attrTest(e) {
    return super.attrTest(e) && (!!(this.state & En.Began) || !(this.state & En.Began) && this.directionTest(e));
  }
  emit(e) {
    this.pX = e.deltaX, this.pY = e.deltaY;
    const t = Cs[e.direction].toLowerCase();
    t && (e.additionalEvent = this.options.event + t), super.emit(e);
  }
}
const gH = ["", "start", "move", "end", "cancel", "in", "out"];
class mH extends HO {
  constructor(e = {}) {
    super({
      enable: !0,
      event: "pinch",
      threshold: 0,
      pointers: 2,
      ...e
    });
  }
  getTouchAction() {
    return [xm];
  }
  getEventNames() {
    return gH.map((e) => this.options.event + e);
  }
  attrTest(e) {
    return super.attrTest(e) && (Math.abs(e.scale - 1) > this.options.threshold || !!(this.state & En.Began));
  }
  emit(e) {
    if (e.scale !== 1) {
      const t = e.scale < 1 ? "in" : "out";
      e.additionalEvent = this.options.event + t;
    }
    super.emit(e);
  }
}
let F_ = class {
  constructor(e, t, n) {
    this.element = e, this.callback = t, this.options = n;
  }
};
const _H = typeof navigator < "u" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "", yH = _H.indexOf("firefox") !== -1, xC = 4.000244140625, vH = 40, bH = 0.25;
let xH = class extends F_ {
  constructor(e, t, n) {
    super(e, t, { enable: !0, ...n }), this.handleEvent = (i) => {
      if (!this.options.enable)
        return;
      let s = i.deltaY;
      globalThis.WheelEvent && (yH && i.deltaMode === globalThis.WheelEvent.DOM_DELTA_PIXEL && (s /= globalThis.devicePixelRatio), i.deltaMode === globalThis.WheelEvent.DOM_DELTA_LINE && (s *= vH)), s !== 0 && s % xC === 0 && (s = Math.floor(s / xC)), i.shiftKey && s && (s = s * bH), this.callback({
        type: "wheel",
        center: {
          x: i.clientX,
          y: i.clientY
        },
        delta: -s,
        srcEvent: i,
        pointerType: "mouse",
        target: i.target
      });
    }, e.addEventListener("wheel", this.handleEvent, { passive: !1 });
  }
  destroy() {
    this.element.removeEventListener("wheel", this.handleEvent);
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, t) {
    e === "wheel" && (this.options.enable = t);
  }
};
const wC = [
  "mousedown",
  "mousemove",
  "mouseup",
  "mouseover",
  "mouseout",
  "mouseleave"
];
let wH = class extends F_ {
  constructor(e, t, n) {
    super(e, t, { enable: !0, ...n }), this.handleEvent = (s) => {
      this.handleOverEvent(s), this.handleOutEvent(s), this.handleEnterEvent(s), this.handleLeaveEvent(s), this.handleMoveEvent(s);
    }, this.pressed = !1;
    const { enable: i } = this.options;
    this.enableMoveEvent = i, this.enableLeaveEvent = i, this.enableEnterEvent = i, this.enableOutEvent = i, this.enableOverEvent = i, wC.forEach((s) => e.addEventListener(s, this.handleEvent));
  }
  destroy() {
    wC.forEach((e) => this.element.removeEventListener(e, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, t) {
    switch (e) {
      case "pointermove":
        this.enableMoveEvent = t;
        break;
      case "pointerover":
        this.enableOverEvent = t;
        break;
      case "pointerout":
        this.enableOutEvent = t;
        break;
      case "pointerenter":
        this.enableEnterEvent = t;
        break;
      case "pointerleave":
        this.enableLeaveEvent = t;
        break;
    }
  }
  handleOverEvent(e) {
    this.enableOverEvent && e.type === "mouseover" && this._emit("pointerover", e);
  }
  handleOutEvent(e) {
    this.enableOutEvent && e.type === "mouseout" && this._emit("pointerout", e);
  }
  handleEnterEvent(e) {
    this.enableEnterEvent && e.type === "mouseenter" && this._emit("pointerenter", e);
  }
  handleLeaveEvent(e) {
    this.enableLeaveEvent && e.type === "mouseleave" && this._emit("pointerleave", e);
  }
  handleMoveEvent(e) {
    if (this.enableMoveEvent)
      switch (e.type) {
        case "mousedown":
          e.button >= 0 && (this.pressed = !0);
          break;
        case "mousemove":
          e.buttons === 0 && (this.pressed = !1), this.pressed || this._emit("pointermove", e);
          break;
        case "mouseup":
          this.pressed = !1;
          break;
      }
  }
  _emit(e, t) {
    this.callback({
      type: e,
      center: {
        x: t.clientX,
        y: t.clientY
      },
      srcEvent: t,
      pointerType: "mouse",
      target: t.target
    });
  }
};
const TC = ["keydown", "keyup"];
let TH = class extends F_ {
  constructor(e, t, n) {
    super(e, t, { enable: !0, tabIndex: 0, ...n }), this.handleEvent = (i) => {
      const s = i.target || i.srcElement;
      s.tagName === "INPUT" && s.type === "text" || s.tagName === "TEXTAREA" || (this.enableDownEvent && i.type === "keydown" && this.callback({
        type: "keydown",
        srcEvent: i,
        key: i.key,
        target: i.target
      }), this.enableUpEvent && i.type === "keyup" && this.callback({
        type: "keyup",
        srcEvent: i,
        key: i.key,
        target: i.target
      }));
    }, this.enableDownEvent = this.options.enable, this.enableUpEvent = this.options.enable, e.tabIndex = this.options.tabIndex, e.style.outline = "none", TC.forEach((i) => e.addEventListener(i, this.handleEvent));
  }
  destroy() {
    TC.forEach((e) => this.element.removeEventListener(e, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, t) {
    e === "keydown" && (this.enableDownEvent = t), e === "keyup" && (this.enableUpEvent = t);
  }
}, EH = class extends F_ {
  constructor(e, t, n) {
    super(e, t, n), this.handleEvent = (i) => {
      this.options.enable && this.callback({
        type: "contextmenu",
        center: {
          x: i.clientX,
          y: i.clientY
        },
        srcEvent: i,
        pointerType: "mouse",
        target: i.target
      });
    }, e.addEventListener("contextmenu", this.handleEvent);
  }
  destroy() {
    this.element.removeEventListener("contextmenu", this.handleEvent);
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, t) {
    e === "contextmenu" && (this.options.enable = t);
  }
};
const EC = 1, Lb = 2, CC = 4, CH = {
  pointerdown: EC,
  pointermove: Lb,
  pointerup: CC,
  mousedown: EC,
  mousemove: Lb,
  mouseup: CC
}, SH = 0, IH = 1, PH = 2, MH = 1, RH = 2, BH = 4;
function OH(r) {
  const e = CH[r.srcEvent.type];
  if (!e)
    return null;
  const { buttons: t, button: n } = r.srcEvent;
  let i = !1, s = !1, o = !1;
  return e === Lb ? (i = !!(t & MH), s = !!(t & BH), o = !!(t & RH)) : (i = n === SH, s = n === IH, o = n === PH), { leftButton: i, middleButton: s, rightButton: o };
}
function DH(r, e) {
  const t = r.center;
  if (!t)
    return null;
  const n = e.getBoundingClientRect(), i = n.width / e.offsetWidth || 1, s = n.height / e.offsetHeight || 1, o = {
    x: (t.x - n.left - e.clientLeft) / i,
    y: (t.y - n.top - e.clientTop) / s
  };
  return { center: t, offsetCenter: o };
}
const LH = {
  srcElement: "root",
  priority: 0
};
let kH = class {
  constructor(e, t) {
    this.handleEvent = (n) => {
      if (this.isEmpty())
        return;
      const i = this._normalizeEvent(n);
      let s = n.srcEvent.target;
      for (; s && s !== i.rootElement; ) {
        if (this._emit(i, s), i.handled)
          return;
        s = s.parentNode;
      }
      this._emit(i, "root");
    }, this.eventManager = e, this.recognizerName = t, this.handlers = [], this.handlersByElement = /* @__PURE__ */ new Map(), this._active = !1;
  }
  // Returns true if there are no non-passive handlers
  isEmpty() {
    return !this._active;
  }
  add(e, t, n, i = !1, s = !1) {
    const { handlers: o, handlersByElement: l } = this, u = { ...LH, ...n };
    let m = l.get(u.srcElement);
    m || (m = [], l.set(u.srcElement, m));
    const y = {
      type: e,
      handler: t,
      srcElement: u.srcElement,
      priority: u.priority
    };
    i && (y.once = !0), s && (y.passive = !0), o.push(y), this._active = this._active || !y.passive;
    let E = m.length - 1;
    for (; E >= 0 && !(m[E].priority >= y.priority); )
      E--;
    m.splice(E + 1, 0, y);
  }
  remove(e, t) {
    const { handlers: n, handlersByElement: i } = this;
    for (let s = n.length - 1; s >= 0; s--) {
      const o = n[s];
      if (o.type === e && o.handler === t) {
        n.splice(s, 1);
        const l = i.get(o.srcElement);
        l.splice(l.indexOf(o), 1), l.length === 0 && i.delete(o.srcElement);
      }
    }
    this._active = n.some((s) => !s.passive);
  }
  /**
   * Invoke handlers on a particular element
   */
  _emit(e, t) {
    const n = this.handlersByElement.get(t);
    if (n) {
      let i = !1;
      const s = () => {
        e.handled = !0;
      }, o = () => {
        e.handled = !0, i = !0;
      }, l = [];
      for (let u = 0; u < n.length; u++) {
        const { type: m, handler: y, once: E } = n[u];
        if (y({
          ...e,
          type: m,
          stopPropagation: s,
          stopImmediatePropagation: o
        }), E && l.push(n[u]), i)
          break;
      }
      for (let u = 0; u < l.length; u++) {
        const { type: m, handler: y } = l[u];
        this.remove(m, y);
      }
    }
  }
  /**
   * Normalizes hammerjs and custom events to have predictable fields.
   */
  _normalizeEvent(e) {
    const t = this.eventManager.getElement();
    return {
      ...e,
      ...OH(e),
      ...DH(e, t),
      preventDefault: () => {
        e.srcEvent.preventDefault();
      },
      stopImmediatePropagation: null,
      stopPropagation: null,
      handled: !1,
      rootElement: t
    };
  }
};
function FH(r) {
  if ("recognizer" in r)
    return r;
  let e;
  const t = Array.isArray(r) ? [...r] : [r];
  if (typeof t[0] == "function") {
    const n = t.shift(), i = t.shift() || {};
    e = new n(i);
  } else
    e = t.shift();
  return {
    recognizer: e,
    recognizeWith: typeof t[0] == "string" ? [t[0]] : t[0],
    requireFailure: typeof t[1] == "string" ? [t[1]] : t[1]
  };
}
let NH = class {
  constructor(e = null, t = {}) {
    if (this._onBasicInput = (n) => {
      this.manager.emit(n.srcEvent.type, n);
    }, this._onOtherEvent = (n) => {
      this.manager.emit(n.type, n);
    }, this.options = {
      recognizers: [],
      events: {},
      touchAction: "compute",
      tabIndex: 0,
      cssProps: {},
      ...t
    }, this.events = /* @__PURE__ */ new Map(), this.element = e, !!e) {
      this.manager = new hH(e, this.options);
      for (const n of this.options.recognizers) {
        const { recognizer: i, recognizeWith: s, requireFailure: o } = FH(n);
        this.manager.add(i), s && i.recognizeWith(s), o && i.requireFailure(o);
      }
      this.manager.on("hammer.input", this._onBasicInput), this.wheelInput = new xH(e, this._onOtherEvent, {
        enable: !1
      }), this.moveInput = new wH(e, this._onOtherEvent, {
        enable: !1
      }), this.keyInput = new TH(e, this._onOtherEvent, {
        enable: !1,
        tabIndex: t.tabIndex
      }), this.contextmenuInput = new EH(e, this._onOtherEvent, {
        enable: !1
      }), this.on(this.options.events);
    }
  }
  getElement() {
    return this.element;
  }
  // Tear down internal event management implementations.
  destroy() {
    this.element && (this.wheelInput.destroy(), this.moveInput.destroy(), this.keyInput.destroy(), this.contextmenuInput.destroy(), this.manager.destroy());
  }
  /** Register an event handler function to be called on `event` */
  on(e, t, n) {
    this._addEventHandler(e, t, n, !1);
  }
  once(e, t, n) {
    this._addEventHandler(e, t, n, !0);
  }
  watch(e, t, n) {
    this._addEventHandler(e, t, n, !1, !0);
  }
  off(e, t) {
    this._removeEventHandler(e, t);
  }
  /*
   * Enable/disable recognizer for the given event
   */
  _toggleRecognizer(e, t) {
    const { manager: n } = this;
    if (!n)
      return;
    const i = n.get(e);
    i && (i.set({ enable: t }), n.touchAction.update()), this.wheelInput?.enableEventType(e, t), this.moveInput?.enableEventType(e, t), this.keyInput?.enableEventType(e, t), this.contextmenuInput?.enableEventType(e, t);
  }
  /**
   * Process the event registration for a single event + handler.
   */
  _addEventHandler(e, t, n, i, s) {
    if (typeof e != "string") {
      n = t;
      for (const [m, y] of Object.entries(e))
        this._addEventHandler(m, y, n, i, s);
      return;
    }
    const { manager: o, events: l } = this;
    if (!o)
      return;
    let u = l.get(e);
    if (!u) {
      const m = this._getRecognizerName(e) || e;
      u = new kH(this, m), l.set(e, u), o && o.on(e, u.handleEvent);
    }
    u.add(e, t, n, i, s), u.isEmpty() || this._toggleRecognizer(u.recognizerName, !0);
  }
  /**
   * Process the event deregistration for a single event + handler.
   */
  _removeEventHandler(e, t) {
    if (typeof e != "string") {
      for (const [s, o] of Object.entries(e))
        this._removeEventHandler(s, o);
      return;
    }
    const { events: n } = this, i = n.get(e);
    if (i && (i.remove(e, t), i.isEmpty())) {
      const { recognizerName: s } = i;
      let o = !1;
      for (const l of n.values())
        if (l.recognizerName === s && !l.isEmpty()) {
          o = !0;
          break;
        }
      o || this._toggleRecognizer(s, !1);
    }
  }
  _getRecognizerName(e) {
    return this.manager.recognizers.find((t) => t.getEventNames().includes(e))?.options.event;
  }
};
const rn = {
  /**
   * `LNGLAT` if rendering into a geospatial viewport, `CARTESIAN` otherwise
   */
  DEFAULT: -1,
  /**
   * Positions are interpreted as [longitude, latitude, elevation]
   * longitude/latitude are in degrees, elevation is in meters.
   * Dimensions are in meters.
   */
  LNGLAT: 1,
  /**
   * Positions are interpreted as [x, y, z] in meter offsets from the coordinate origin.
   * Dimensions are in meters.
   */
  METER_OFFSETS: 2,
  /**
   * Positions are interpreted as [deltaLng, deltaLat, elevation] from the coordinate origin.
   * deltaLng/deltaLat are in degrees, elevation is in meters.
   * Dimensions are in meters.
   */
  LNGLAT_OFFSETS: 3,
  /**
   * Positions and dimensions are in the common units of the viewport.
   */
  CARTESIAN: 0
};
Object.defineProperty(rn, "IDENTITY", {
  get: () => (Jr.deprecated("COORDINATE_SYSTEM.IDENTITY", "COORDINATE_SYSTEM.CARTESIAN")(), 0)
});
const ha = {
  /**
   * Render geospatial data in Web Mercator projection
   */
  WEB_MERCATOR: 1,
  /**
   * Render geospatial data as a 3D globe
   */
  GLOBE: 2,
  /**
   * (Internal use only) Web Mercator projection at high zoom
   */
  WEB_MERCATOR_AUTO_OFFSET: 4,
  /**
   * No transformation
   */
  IDENTITY: 0
}, ko = {
  common: 0,
  meters: 1,
  pixels: 2
}, kb = {
  click: "onClick",
  dblclick: "onClick",
  panstart: "onDragStart",
  panmove: "onDrag",
  panend: "onDragEnd"
}, SC = {
  multipan: [bC, { threshold: 10, direction: Cs.Vertical, pointers: 2 }],
  pinch: [mH, {}, null, ["multipan"]],
  pan: [bC, { threshold: 1 }, ["pinch"], ["multipan"]],
  dblclick: [vC, { event: "dblclick", taps: 2 }],
  click: [vC, { event: "click" }, null, ["dblclick"]]
};
function UH(r, e) {
  if (r === e)
    return !0;
  if (Array.isArray(r)) {
    const t = r.length;
    if (!e || e.length !== t)
      return !1;
    for (let n = 0; n < t; n++)
      if (r[n] !== e[n])
        return !1;
    return !0;
  }
  return !1;
}
function v0(r) {
  let e = {}, t;
  return (n) => {
    for (const i in n)
      if (!UH(n[i], e[i])) {
        t = r(n), e = n;
        break;
      }
    return t;
  };
}
const IC = [0, 0, 0, 0], zH = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], GO = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], VH = [0, 0, 0], WO = [0, 0, 0], jH = v0(WH);
function $O(r, e, t = WO) {
  t.length < 3 && (t = [t[0], t[1], 0]);
  let n = t, i, s = !0;
  switch (e === rn.LNGLAT_OFFSETS || e === rn.METER_OFFSETS ? i = t : i = r.isGeospatial ? (
    // @ts-expect-error longitude and latitude are not defined on the base Viewport, but is expected on geospatial viewports
    [Math.fround(r.longitude), Math.fround(r.latitude), 0]
  ) : null, r.projectionMode) {
    case ha.WEB_MERCATOR:
      (e === rn.LNGLAT || e === rn.CARTESIAN) && (i = [0, 0, 0], s = !1);
      break;
    case ha.WEB_MERCATOR_AUTO_OFFSET:
      e === rn.LNGLAT ? n = i : e === rn.CARTESIAN && (n = [
        Math.fround(r.center[0]),
        Math.fround(r.center[1]),
        0
      ], i = r.unprojectPosition(n), n[0] -= t[0], n[1] -= t[1], n[2] -= t[2]);
      break;
    case ha.IDENTITY:
      n = r.position.map(Math.fround), n[2] = n[2] || 0;
      break;
    case ha.GLOBE:
      s = !1, i = null;
      break;
    default:
      s = !1;
  }
  return { geospatialOrigin: i, shaderCoordinateOrigin: n, offsetMode: s };
}
function HH(r, e, t) {
  const { viewMatrixUncentered: n, projectionMatrix: i } = r;
  let { viewMatrix: s, viewProjectionMatrix: o } = r, l = IC, u = IC, m = r.cameraPosition;
  const { geospatialOrigin: y, shaderCoordinateOrigin: E, offsetMode: P } = $O(r, e, t);
  return P && (u = r.projectPosition(y || E), m = [
    m[0] - u[0],
    m[1] - u[1],
    m[2] - u[2]
  ], u[3] = 1, l = Dp([], u, o), s = n || s, o = Yf([], i, s), o = Yf([], o, zH)), {
    viewMatrix: s,
    viewProjectionMatrix: o,
    projectionCenter: l,
    originCommon: u,
    cameraPosCommon: m,
    shaderCoordinateOrigin: E,
    geospatialOrigin: y
  };
}
function GH({
  viewport: r,
  devicePixelRatio: e = 1,
  modelMatrix: t = null,
  // Match Layer.defaultProps
  coordinateSystem: n = rn.DEFAULT,
  coordinateOrigin: i = WO,
  autoWrapLongitude: s = !1
}) {
  n === rn.DEFAULT && (n = r.isGeospatial ? rn.LNGLAT : rn.CARTESIAN);
  const o = jH({
    viewport: r,
    devicePixelRatio: e,
    coordinateSystem: n,
    coordinateOrigin: i
  });
  return o.wrapLongitude = s, o.modelMatrix = t || GO, o;
}
function WH({ viewport: r, devicePixelRatio: e, coordinateSystem: t, coordinateOrigin: n }) {
  const { projectionCenter: i, viewProjectionMatrix: s, originCommon: o, cameraPosCommon: l, shaderCoordinateOrigin: u, geospatialOrigin: m } = HH(r, t, n), y = r.getDistanceScales(), E = [
    r.width * e,
    r.height * e
  ], P = Dp([], [0, 0, -r.focalDistance, 1], r.projectionMatrix)[3] || 1, L = {
    // Projection mode values
    coordinateSystem: t,
    projectionMode: r.projectionMode,
    coordinateOrigin: u,
    commonOrigin: o.slice(0, 3),
    center: i,
    // Backward compatibility
    // TODO: remove in v9
    // @ts-expect-error _pseudoMeters is only defined on WebMercator viewport
    pseudoMeters: !!r._pseudoMeters,
    // Screen size
    viewportSize: E,
    devicePixelRatio: e,
    focalDistance: P,
    commonUnitsPerMeter: y.unitsPerMeter,
    commonUnitsPerWorldUnit: y.unitsPerMeter,
    commonUnitsPerWorldUnit2: VH,
    scale: r.scale,
    // This is the mercator scale (2 ** zoom)
    wrapLongitude: !1,
    viewProjectionMatrix: s,
    modelMatrix: GO,
    // This is for lighting calculations
    cameraPosition: l
  };
  if (m) {
    const U = r.getDistanceScales(m);
    switch (t) {
      case rn.METER_OFFSETS:
        L.commonUnitsPerWorldUnit = U.unitsPerMeter, L.commonUnitsPerWorldUnit2 = U.unitsPerMeter2;
        break;
      case rn.LNGLAT:
      case rn.LNGLAT_OFFSETS:
        r._pseudoMeters || (L.commonUnitsPerMeter = U.unitsPerMeter), L.commonUnitsPerWorldUnit = U.unitsPerDegree, L.commonUnitsPerWorldUnit2 = U.unitsPerDegree2;
        break;
      // a.k.a "preprojected" positions
      case rn.CARTESIAN:
        L.commonUnitsPerWorldUnit = [1, 1, U.unitsPerMeter[2]], L.commonUnitsPerWorldUnit2 = [0, 0, U.unitsPerMeter2[2]];
        break;
    }
  }
  return L;
}
const $H = Object.keys(rn).map((r) => `const COORDINATE_SYSTEM_${r}: i32 = ${rn[r]};`).join(""), qH = Object.keys(ha).map((r) => `const PROJECTION_MODE_${r}: i32 = ${ha[r]};`).join(""), XH = Object.keys(ko).map((r) => `const UNIT_${r.toUpperCase()}: i32 = ${ko[r]};`).join(""), ZH = (
  /* wgsl */
  `${$H}
${qH}
${XH}

const TILE_SIZE: f32 = 512.0;
const PI: f32 = 3.1415926536;
const WORLD_SCALE: f32 = TILE_SIZE / (PI * 2.0);
const ZERO_64_LOW: vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);
const EARTH_RADIUS: f32 = 6370972.0; // meters
const GLOBE_RADIUS: f32 = 256.0;

// -----------------------------------------------------------------------------
// Uniform block (converted from GLSL uniform block)
// -----------------------------------------------------------------------------
struct ProjectUniforms {
  wrapLongitude: i32,
  coordinateSystem: i32,
  commonUnitsPerMeter: vec3<f32>,
  projectionMode: i32,
  scale: f32,
  commonUnitsPerWorldUnit: vec3<f32>,
  commonUnitsPerWorldUnit2: vec3<f32>,
  center: vec4<f32>,
  modelMatrix: mat4x4<f32>,
  viewProjectionMatrix: mat4x4<f32>,
  viewportSize: vec2<f32>,
  devicePixelRatio: f32,
  focalDistance: f32,
  cameraPosition: vec3<f32>,
  coordinateOrigin: vec3<f32>,
  commonOrigin: vec3<f32>,
  pseudoMeters: i32,
};

@group(0) @binding(0)
var<uniform> project: ProjectUniforms;

// -----------------------------------------------------------------------------
// Geometry data
// (In your GLSL code, "geometry" was assumed to be available globally. In WGSL,
// you might supply this via vertex attributes or a uniform. Here we define a
// uniform struct for demonstration.)
// -----------------------------------------------------------------------------

// Structure to carry additional geometry data used by deck.gl filters.
struct Geometry {
  worldPosition: vec3<f32>,
  worldPositionAlt: vec3<f32>,
  position: vec4<f32>,
  normal: vec3<f32>,
  uv: vec2<f32>,
  pickingColor: vec3<f32>,
};

// @group(0) @binding(1)
var<private> geometry: Geometry;
`
), YH = (
  /* wgsl */
  `${ZH}

// -----------------------------------------------------------------------------
// Functions
// -----------------------------------------------------------------------------

// Returns an adjustment factor for commonUnitsPerMeter
fn _project_size_at_latitude(lat: f32) -> f32 {
  let y = clamp(lat, -89.9, 89.9);
  return 1.0 / cos(radians(y));
}

// Overloaded version: scales a value in meters at a given latitude.
fn _project_size_at_latitude_m(meters: f32, lat: f32) -> f32 {
  return meters * project.commonUnitsPerMeter.z * _project_size_at_latitude(lat);
}

// Computes a non-linear scale factor based on geometry.
// (Note: This function relies on "geometry" being provided.)
fn project_size() -> f32 {
  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR &&
      project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT &&
      project.pseudoMeters == 0) {
    if (geometry.position.w == 0.0) {
      return _project_size_at_latitude(geometry.worldPosition.y);
    }
    let y: f32 = geometry.position.y / TILE_SIZE * 2.0 - 1.0;
    let y2 = y * y;
    let y4 = y2 * y2;
    let y6 = y4 * y2;
    return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;
  }
  return 1.0;
}

// Overloads to scale offsets (meters to world units)
fn project_size_float(meters: f32) -> f32 {
  return meters * project.commonUnitsPerMeter.z * project_size();
}

fn project_size_vec2(meters: vec2<f32>) -> vec2<f32> {
  return meters * project.commonUnitsPerMeter.xy * project_size();
}

fn project_size_vec3(meters: vec3<f32>) -> vec3<f32> {
  return meters * project.commonUnitsPerMeter * project_size();
}

fn project_size_vec4(meters: vec4<f32>) -> vec4<f32> {
  return vec4<f32>(meters.xyz * project.commonUnitsPerMeter, meters.w);
}

// Returns a rotation matrix aligning the zaxis with the given up vector.
fn project_get_orientation_matrix(up: vec3<f32>) -> mat3x3<f32> {
  let uz = normalize(up);
  let ux = select(
    vec3<f32>(1.0, 0.0, 0.0),
    normalize(vec3<f32>(uz.y, -uz.x, 0.0)),
    abs(uz.z) == 1.0
  );
  let uy = cross(uz, ux);
  return mat3x3<f32>(ux, uy, uz);
}

// Since WGSL does not support "out" parameters, we return a struct.
struct RotationResult {
  needsRotation: bool,
  transform: mat3x3<f32>,
};

fn project_needs_rotation(commonPosition: vec3<f32>) -> RotationResult {
  if (project.projectionMode == PROJECTION_MODE_GLOBE) {
    return RotationResult(true, project_get_orientation_matrix(commonPosition));
  } else {
    return RotationResult(false, mat3x3<f32>());  // identity alternative if needed
  };
}

// Projects a normal vector from the current coordinate system to world space.
fn project_normal(vector: vec3<f32>) -> vec3<f32> {
  let normal_modelspace = project.modelMatrix * vec4<f32>(vector, 0.0);
  var n = normalize(normal_modelspace.xyz * project.commonUnitsPerMeter);
  let rotResult = project_needs_rotation(geometry.position.xyz);
  if (rotResult.needsRotation) {
    n = rotResult.transform * n;
  }
  return n;
}

// Applies a scale offset based on y-offset (dy)
fn project_offset_(offset: vec4<f32>) -> vec4<f32> {
  let dy: f32 = offset.y;
  let commonUnitsPerWorldUnit = project.commonUnitsPerWorldUnit + project.commonUnitsPerWorldUnit2 * dy;
  return vec4<f32>(offset.xyz * commonUnitsPerWorldUnit, offset.w);
}

// Projects lng/lat coordinates to a unit tile [0,1]
fn project_mercator_(lnglat: vec2<f32>) -> vec2<f32> {
  var x = lnglat.x;
  if (project.wrapLongitude != 0) {
    x = ((x + 180.0) % 360.0) - 180.0;
  }
  let y = clamp(lnglat.y, -89.9, 89.9);
  return vec2<f32>(
    radians(x) + PI,
    PI + log(tan(PI * 0.25 + radians(y) * 0.5))
  ) * WORLD_SCALE;
}

// Projects lng/lat/z coordinates for a globe projection.
fn project_globe_(lnglatz: vec3<f32>) -> vec3<f32> {
  let lambda = radians(lnglatz.x);
  let phi = radians(lnglatz.y);
  let cosPhi = cos(phi);
  let D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;
  return vec3<f32>(
    sin(lambda) * cosPhi,
    -cos(lambda) * cosPhi,
    sin(phi)
  ) * D;
}

// Projects positions (with an optional 64-bit low part) from the input
// coordinate system to the common space.
fn project_position_vec4_f64(position: vec4<f32>, position64Low: vec3<f32>) -> vec4<f32> {
  var position_world = project.modelMatrix * position;

  // Work around for a Mac+NVIDIA bug:
  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR) {
    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      return vec4<f32>(
        project_mercator_(position_world.xy),
        _project_size_at_latitude_m(position_world.z, position_world.y),
        position_world.w
      );
    }
    if (project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {
      position_world = vec4f(position_world.xyz + project.coordinateOrigin, position_world.w);
    }
  }
  if (project.projectionMode == PROJECTION_MODE_GLOBE) {
    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      return vec4<f32>(
        project_globe_(position_world.xyz),
        position_world.w
      );
    }
  }
  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      if (abs(position_world.y - project.coordinateOrigin.y) > 0.25) {
        return vec4<f32>(
          project_mercator_(position_world.xy) - project.commonOrigin.xy,
          project_size_float(position_world.z),
          position_world.w
        );
      }
    }
  }
  if (project.projectionMode == PROJECTION_MODE_IDENTITY ||
      (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&
       (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
        project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {
    position_world = vec4f(position_world.xyz - project.coordinateOrigin, position_world.w);
  }

  return project_offset_(position_world) +
         project_offset_(project.modelMatrix * vec4<f32>(position64Low, 0.0));
}

// Overloaded versions for different input types.
fn project_position_vec4_f32(position: vec4<f32>) -> vec4<f32> {
  return project_position_vec4_f64(position, ZERO_64_LOW);
}

fn project_position_vec3_f64(position: vec3<f32>, position64Low: vec3<f32>) -> vec3<f32> {
  let projected_position = project_position_vec4_f64(vec4<f32>(position, 1.0), position64Low);
  return projected_position.xyz;
}

fn project_position_vec3_f32(position: vec3<f32>) -> vec3<f32> {
  let projected_position = project_position_vec4_f64(vec4<f32>(position, 1.0), ZERO_64_LOW);
  return projected_position.xyz;
}

fn project_position_vec2_f32(position: vec2<f32>) -> vec2<f32> {
  let projected_position = project_position_vec4_f64(vec4<f32>(position, 0.0, 1.0), ZERO_64_LOW);
  return projected_position.xy;
}

// Transforms a common space position to clip space.
fn project_common_position_to_clipspace_with_projection(position: vec4<f32>, viewProjectionMatrix: mat4x4<f32>, center: vec4<f32>) -> vec4<f32> {
  return viewProjectionMatrix * position + center;
}

// Uses the project viewProjectionMatrix and center.
fn project_common_position_to_clipspace(position: vec4<f32>) -> vec4<f32> {
  return project_common_position_to_clipspace_with_projection(position, project.viewProjectionMatrix, project.center);
}

// Returns a clip space offset corresponding to a given number of screen pixels.
fn project_pixel_size_to_clipspace(pixels: vec2<f32>) -> vec2<f32> {
  let offset = pixels / project.viewportSize * project.devicePixelRatio * 2.0;
  return offset * project.focalDistance;
}

fn project_meter_size_to_pixel(meters: f32) -> f32 {
  return project_size_float(meters) * project.scale;
}

fn project_unit_size_to_pixel(size: f32, unit: i32) -> f32 {
  if (unit == UNIT_METERS) {
    return project_meter_size_to_pixel(size);
  } else if (unit == UNIT_COMMON) {
    return size * project.scale;
  }
  // UNIT_PIXELS: no scaling applied.
  return size;
}

fn project_pixel_size_float(pixels: f32) -> f32 {
  return pixels / project.scale;
}

fn project_pixel_size_vec2(pixels: vec2<f32>) -> vec2<f32> {
  return pixels / project.scale;
}
`
), KH = Object.keys(rn).map((r) => `const int COORDINATE_SYSTEM_${r} = ${rn[r]};`).join(""), QH = Object.keys(ha).map((r) => `const int PROJECTION_MODE_${r} = ${ha[r]};`).join(""), JH = Object.keys(ko).map((r) => `const int UNIT_${r.toUpperCase()} = ${ko[r]};`).join(""), eG = (
  /* glsl */
  `${KH}
${QH}
${JH}
uniform projectUniforms {
bool wrapLongitude;
int coordinateSystem;
vec3 commonUnitsPerMeter;
int projectionMode;
float scale;
vec3 commonUnitsPerWorldUnit;
vec3 commonUnitsPerWorldUnit2;
vec4 center;
mat4 modelMatrix;
mat4 viewProjectionMatrix;
vec2 viewportSize;
float devicePixelRatio;
float focalDistance;
vec3 cameraPosition;
vec3 coordinateOrigin;
vec3 commonOrigin;
bool pseudoMeters;
} project;
const float TILE_SIZE = 512.0;
const float PI = 3.1415926536;
const float WORLD_SCALE = TILE_SIZE / (PI * 2.0);
const vec3 ZERO_64_LOW = vec3(0.0);
const float EARTH_RADIUS = 6370972.0;
const float GLOBE_RADIUS = 256.0;
float project_size_at_latitude(float lat) {
float y = clamp(lat, -89.9, 89.9);
return 1.0 / cos(radians(y));
}
float project_size() {
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR &&
project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT &&
project.pseudoMeters == false) {
if (geometry.position.w == 0.0) {
return project_size_at_latitude(geometry.worldPosition.y);
}
float y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;
float y2 = y * y;
float y4 = y2 * y2;
float y6 = y4 * y2;
return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;
}
return 1.0;
}
float project_size_at_latitude(float meters, float lat) {
return meters * project.commonUnitsPerMeter.z * project_size_at_latitude(lat);
}
float project_size(float meters) {
return meters * project.commonUnitsPerMeter.z * project_size();
}
vec2 project_size(vec2 meters) {
return meters * project.commonUnitsPerMeter.xy * project_size();
}
vec3 project_size(vec3 meters) {
return meters * project.commonUnitsPerMeter * project_size();
}
vec4 project_size(vec4 meters) {
return vec4(meters.xyz * project.commonUnitsPerMeter, meters.w);
}
mat3 project_get_orientation_matrix(vec3 up) {
vec3 uz = normalize(up);
vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));
vec3 uy = cross(uz, ux);
return mat3(ux, uy, uz);
}
bool project_needs_rotation(vec3 commonPosition, out mat3 transform) {
if (project.projectionMode == PROJECTION_MODE_GLOBE) {
transform = project_get_orientation_matrix(commonPosition);
return true;
}
return false;
}
vec3 project_normal(vec3 vector) {
vec4 normal_modelspace = project.modelMatrix * vec4(vector, 0.0);
vec3 n = normalize(normal_modelspace.xyz * project.commonUnitsPerMeter);
mat3 rotation;
if (project_needs_rotation(geometry.position.xyz, rotation)) {
n = rotation * n;
}
return n;
}
vec4 project_offset_(vec4 offset) {
float dy = offset.y;
vec3 commonUnitsPerWorldUnit = project.commonUnitsPerWorldUnit + project.commonUnitsPerWorldUnit2 * dy;
return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);
}
vec2 project_mercator_(vec2 lnglat) {
float x = lnglat.x;
if (project.wrapLongitude) {
x = mod(x + 180., 360.0) - 180.;
}
float y = clamp(lnglat.y, -89.9, 89.9);
return vec2(
radians(x) + PI,
PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))
) * WORLD_SCALE;
}
vec3 project_globe_(vec3 lnglatz) {
float lambda = radians(lnglatz.x);
float phi = radians(lnglatz.y);
float cosPhi = cos(phi);
float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;
return vec3(
sin(lambda) * cosPhi,
-cos(lambda) * cosPhi,
sin(phi)
) * D;
}
vec4 project_position(vec4 position, vec3 position64Low) {
vec4 position_world = project.modelMatrix * position;
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
return vec4(
project_mercator_(position_world.xy),
project_size_at_latitude(position_world.z, position_world.y),
position_world.w
);
}
if (project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {
position_world.xyz += project.coordinateOrigin;
}
}
if (project.projectionMode == PROJECTION_MODE_GLOBE) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
return vec4(
project_globe_(position_world.xyz),
position_world.w
);
}
}
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
if (abs(position_world.y - project.coordinateOrigin.y) > 0.25) {
return vec4(
project_mercator_(position_world.xy) - project.commonOrigin.xy,
project_size(position_world.z),
position_world.w
);
}
}
}
if (project.projectionMode == PROJECTION_MODE_IDENTITY ||
(project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&
(project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {
position_world.xyz -= project.coordinateOrigin;
}
return project_offset_(position_world) + project_offset_(project.modelMatrix * vec4(position64Low, 0.0));
}
vec4 project_position(vec4 position) {
return project_position(position, ZERO_64_LOW);
}
vec3 project_position(vec3 position, vec3 position64Low) {
vec4 projected_position = project_position(vec4(position, 1.0), position64Low);
return projected_position.xyz;
}
vec3 project_position(vec3 position) {
vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);
return projected_position.xyz;
}
vec2 project_position(vec2 position) {
vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);
return projected_position.xy;
}
vec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {
return viewProjectionMatrix * position + center;
}
vec4 project_common_position_to_clipspace(vec4 position) {
return project_common_position_to_clipspace(position, project.viewProjectionMatrix, project.center);
}
vec2 project_pixel_size_to_clipspace(vec2 pixels) {
vec2 offset = pixels / project.viewportSize * project.devicePixelRatio * 2.0;
return offset * project.focalDistance;
}
float project_size_to_pixel(float meters) {
return project_size(meters) * project.scale;
}
float project_size_to_pixel(float size, int unit) {
if (unit == UNIT_METERS) return project_size_to_pixel(size);
if (unit == UNIT_COMMON) return size * project.scale;
return size;
}
float project_pixel_size(float pixels) {
return pixels / project.scale;
}
vec2 project_pixel_size(vec2 pixels) {
return pixels / project.scale;
}
`
), tG = {};
function rG(r = tG) {
  return "viewport" in r ? GH(r) : {};
}
const N_ = {
  name: "project",
  dependencies: [xj, FO],
  source: YH,
  vs: eG,
  getUniforms: rG,
  uniformTypes: {
    wrapLongitude: "f32",
    coordinateSystem: "i32",
    commonUnitsPerMeter: "vec3<f32>",
    projectionMode: "i32",
    scale: "f32",
    commonUnitsPerWorldUnit: "vec3<f32>",
    commonUnitsPerWorldUnit2: "vec3<f32>",
    center: "vec4<f32>",
    modelMatrix: "mat4x4<f32>",
    viewProjectionMatrix: "mat4x4<f32>",
    viewportSize: "vec2<f32>",
    devicePixelRatio: "f32",
    focalDistance: "f32",
    cameraPosition: "vec3<f32>",
    coordinateOrigin: "vec3<f32>",
    commonOrigin: "vec3<f32>",
    pseudoMeters: "f32"
  }
  // @ts-ignore TODO v9.1
}, nG = (
  /* wgsl */
  `// Define a structure to hold both the clip-space position and the common position.
struct ProjectResult {
  clipPosition: vec4<f32>,
  commonPosition: vec4<f32>,
};

// This function mimics the GLSL version with the 'out' parameter by returning both values.
fn project_position_to_clipspace_and_commonspace(
    position: vec3<f32>,
    position64Low: vec3<f32>,
    offset: vec3<f32>
) -> ProjectResult {
  // Compute the projected position.
  let projectedPosition: vec3<f32> = project_position_vec3_f64(position, position64Low);

  // Start with the provided offset.
  var finalOffset: vec3<f32> = offset;

  // Get whether a rotation is needed and the rotation matrix.
  let rotationResult = project_needs_rotation(projectedPosition);

  // If rotation is needed, update the offset.
  if (rotationResult.needsRotation) {
    finalOffset = rotationResult.transform * offset;
  }

  // Compute the common position.
  let commonPosition: vec4<f32> = vec4<f32>(projectedPosition + finalOffset, 1.0);

  // Convert to clip-space.
  let clipPosition: vec4<f32> = project_common_position_to_clipspace(commonPosition);

  return ProjectResult(clipPosition, commonPosition);
}

// A convenience overload that returns only the clip-space position.
fn project_position_to_clipspace(
    position: vec3<f32>,
    position64Low: vec3<f32>,
    offset: vec3<f32>
) -> vec4<f32> {
  return project_position_to_clipspace_and_commonspace(position, position64Low, offset).clipPosition;
}
`
), iG = (
  /* glsl */
  `vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition
) {
  vec3 projectedPosition = project_position(position, position64Low);
  mat3 rotation;
  if (project_needs_rotation(projectedPosition, rotation)) {
    // offset is specified as ENU
    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe
    offset = rotation * offset;
  }
  commonPosition = vec4(projectedPosition + offset, 1.0);
  return project_common_position_to_clipspace(commonPosition);
}

vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset
) {
  vec4 commonPosition;
  return project_position_to_clipspace(position, position64Low, offset, commonPosition);
}
`
), Ws = {
  name: "project32",
  dependencies: [N_],
  source: nG,
  vs: iG
};
function sG() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function op(r, e) {
  const t = Dp([], e, r);
  return Lx(t, t, 1 / t[3]), t;
}
function PC(r, e) {
  const t = r % e;
  return t < 0 ? e + t : t;
}
function Fb(r, e, t) {
  return r < e ? e : r > t ? t : r;
}
function oG(r) {
  return Math.log(r) * Math.LOG2E;
}
const Ux = Math.log2 || oG;
function Qc(r, e) {
  if (!r)
    throw new Error(e || "@math.gl/web-mercator: assertion failed.");
}
const hl = Math.PI, qO = hl / 4, Na = hl / 180, Nb = 180 / hl, _p = 512, n_ = 4003e4, $d = 85.051129, aG = 1.5;
function lG(r) {
  return Ux(r);
}
function Jc(r) {
  const [e, t] = r;
  Qc(Number.isFinite(e)), Qc(Number.isFinite(t) && t >= -90 && t <= 90, "invalid latitude");
  const n = e * Na, i = t * Na, s = _p * (n + hl) / (2 * hl), o = _p * (hl + Math.log(Math.tan(qO + i * 0.5))) / (2 * hl);
  return [s, o];
}
function lc(r) {
  const [e, t] = r, n = e / _p * (2 * hl) - hl, i = 2 * (Math.atan(Math.exp(t / _p * (2 * hl) - hl)) - qO);
  return [n * Nb, i * Nb];
}
function cG(r) {
  const { latitude: e } = r;
  Qc(Number.isFinite(e));
  const t = Math.cos(e * Na);
  return lG(n_ * t) - 9;
}
function Dv(r) {
  const e = Math.cos(r * Na);
  return _p / n_ / e;
}
function Ub(r) {
  const { latitude: e, longitude: t, highPrecision: n = !1 } = r;
  Qc(Number.isFinite(e) && Number.isFinite(t));
  const i = _p, s = Math.cos(e * Na), o = i / 360, l = o / s, u = i / n_ / s, m = {
    unitsPerMeter: [u, u, u],
    metersPerUnit: [1 / u, 1 / u, 1 / u],
    unitsPerDegree: [o, l, u],
    degreesPerUnit: [1 / o, 1 / l, 1 / u]
  };
  if (n) {
    const y = Na * Math.tan(e * Na) / s, E = o * y / 2, P = i / n_ * y, L = P / l * u;
    m.unitsPerDegree2 = [0, E, P], m.unitsPerMeter2 = [L, 0, L];
  }
  return m;
}
function XO(r, e) {
  const [t, n, i] = r, [s, o, l] = e, { unitsPerMeter: u, unitsPerMeter2: m } = Ub({
    longitude: t,
    latitude: n,
    highPrecision: !0
  }), y = Jc(r);
  y[0] += s * (u[0] + m[0] * o), y[1] += o * (u[1] + m[1] * o);
  const E = lc(y), P = (i || 0) + (l || 0);
  return Number.isFinite(i) || Number.isFinite(l) ? [E[0], E[1], P] : E;
}
function uG(r) {
  const {
    // Viewport props
    height: e,
    pitch: t,
    bearing: n,
    altitude: i,
    // Pre-calculated parameters
    scale: s,
    center: o
  } = r, l = sG();
  t_(l, l, [0, 0, -i]), CO(l, l, -t * Na), SO(l, l, n * Na);
  const u = s / e;
  return Dx(l, l, [u, u, u]), o && t_(l, l, fV([], o)), l;
}
function fG(r) {
  const { width: e, height: t, altitude: n, pitch: i = 0, offset: s, center: o, scale: l, nearZMultiplier: u = 1, farZMultiplier: m = 1 } = r;
  let { fovy: y = i0(aG) } = r;
  n !== void 0 && (y = i0(n));
  const E = y * Na, P = i * Na, L = zx(y);
  let U = L;
  o && (U += o[2] * l / Math.cos(P) / t);
  const V = E * (0.5 + (s ? s[1] : 0) / t), q = Math.sin(V) * U / Math.sin(Fb(Math.PI / 2 - P - V, 0.01, Math.PI - 0.01)), j = Math.sin(P) * q + U, K = U * 10, Y = Math.min(j * m, K);
  return {
    fov: E,
    aspect: e / t,
    focalDistance: L,
    near: u,
    far: Y
  };
}
function i0(r) {
  return 2 * Math.atan(0.5 / r) * Nb;
}
function zx(r) {
  return 0.5 / Math.tan(0.5 * r * Na);
}
function ZO(r, e) {
  const [t, n, i = 0] = r;
  return Qc(Number.isFinite(t) && Number.isFinite(n) && Number.isFinite(i)), op(e, [t, n, i, 1]);
}
function Vx(r, e, t = 0) {
  const [n, i, s] = r;
  if (Qc(Number.isFinite(n) && Number.isFinite(i), "invalid pixel coordinate"), Number.isFinite(s))
    return op(e, [n, i, s, 1]);
  const o = op(e, [n, i, 0, 1]), l = op(e, [n, i, 1, 1]), u = o[2], m = l[2], y = u === m ? 0 : ((t || 0) - u) / (m - u);
  return dO([], o, l, y);
}
function hG(r) {
  const {
    width: e,
    height: t,
    bounds: n,
    minExtent: i = 0,
    // 0.01 would be about 1000 meters (degree is ~110KM)
    maxZoom: s = 24,
    // ~x4,000,000 => About 10 meter extents
    offset: o = [0, 0]
  } = r, [[l, u], [m, y]] = n, E = dG(r.padding), P = Jc([l, Fb(y, -$d, $d)]), L = Jc([m, Fb(u, -$d, $d)]), U = [
    Math.max(Math.abs(L[0] - P[0]), i),
    Math.max(Math.abs(L[1] - P[1]), i)
  ], V = [
    e - E.left - E.right - Math.abs(o[0]) * 2,
    t - E.top - E.bottom - Math.abs(o[1]) * 2
  ];
  Qc(V[0] > 0 && V[1] > 0);
  const q = V[0] / U[0], j = V[1] / U[1], K = (E.right - E.left) / 2 / q, Y = (E.top - E.bottom) / 2 / j, de = [(L[0] + P[0]) / 2 + K, (L[1] + P[1]) / 2 + Y], ne = lc(de), ae = Math.min(s, Ux(Math.abs(Math.min(q, j))));
  return Qc(Number.isFinite(ae)), {
    longitude: ne[0],
    latitude: ne[1],
    zoom: ae
  };
}
function dG(r = 0) {
  return typeof r == "number" ? {
    top: r,
    bottom: r,
    left: r,
    right: r
  } : (Qc(Number.isFinite(r.top) && Number.isFinite(r.bottom) && Number.isFinite(r.left) && Number.isFinite(r.right)), r);
}
const MC = Math.PI / 180;
function pG(r, e = 0) {
  const { width: t, height: n, unproject: i } = r, s = { targetZ: e }, o = i([0, n], s), l = i([t, n], s);
  let u, m;
  const y = r.fovy ? 0.5 * r.fovy * MC : Math.atan(0.5 / r.altitude), E = (90 - r.pitch) * MC;
  return y > E - 0.01 ? (u = RC(r, 0, e), m = RC(r, t, e)) : (u = i([0, 0], s), m = i([t, 0], s)), [o, l, m, u];
}
function RC(r, e, t) {
  const { pixelUnprojectionMatrix: n } = r, i = op(n, [e, 0, 1, 1]), s = op(n, [e, r.height, 1, 1]), l = (t * r.distanceScales.unitsPerMeter[2] - i[2]) / (s[2] - i[2]), u = dO([], i, s, l), m = lc(u);
  return m.push(t), m;
}
const BC = 512;
function AG(r) {
  const { width: e, height: t, pitch: n = 0 } = r;
  let { longitude: i, latitude: s, zoom: o, bearing: l = 0 } = r;
  (i < -180 || i > 180) && (i = PC(i + 180, 360) - 180), (l < -180 || l > 180) && (l = PC(l + 180, 360) - 180);
  const u = Ux(t / BC);
  if (o <= u)
    o = u, s = 0;
  else {
    const m = t / 2 / Math.pow(2, o), y = lc([0, m])[1];
    if (s < y)
      s = y;
    else {
      const E = lc([0, BC - m])[1];
      s > E && (s = E);
    }
  }
  return { width: e, height: t, longitude: i, latitude: s, zoom: o, pitch: n, bearing: l };
}
const YO = (
  /* glsl */
  `
uniform shadowUniforms {
  bool drawShadowMap;
  bool useShadowMap;
  vec4 color;
  highp int lightId;
  float lightCount;
  mat4 viewProjectionMatrix0;
  mat4 viewProjectionMatrix1;
  vec4 projectCenter0;
  vec4 projectCenter1;
} shadow;
`
), gG = (
  /* glsl */
  `
const int max_lights = 2;

out vec3 shadow_vPosition[max_lights];

vec4 shadow_setVertexPosition(vec4 position_commonspace) {
  mat4 viewProjectionMatrices[max_lights];
  viewProjectionMatrices[0] = shadow.viewProjectionMatrix0;
  viewProjectionMatrices[1] = shadow.viewProjectionMatrix1;
  vec4 projectCenters[max_lights];
  projectCenters[0] = shadow.projectCenter0;
  projectCenters[1] = shadow.projectCenter1;

  if (shadow.drawShadowMap) {
    return project_common_position_to_clipspace(position_commonspace, viewProjectionMatrices[shadow.lightId], projectCenters[shadow.lightId]);
  }
  if (shadow.useShadowMap) {
    for (int i = 0; i < max_lights; i++) {
      if(i < int(shadow.lightCount)) {
        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, viewProjectionMatrices[i], projectCenters[i]);
        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;
      }
    }
  }
  return gl_Position;
}
`
), mG = `
${YO}
${gG}
`, _G = (
  /* glsl */
  `
const int max_lights = 2;
uniform sampler2D shadow_uShadowMap0;
uniform sampler2D shadow_uShadowMap1;

in vec3 shadow_vPosition[max_lights];

const vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);
const vec4 bitUnpackShift = 1.0 / bitPackShift;
const vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);

float shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {
  vec4 rgbaDepth = texture(shadowMap, position.xy);

  float z = dot(rgbaDepth, bitUnpackShift);
  return smoothstep(0.001, 0.01, position.z - z);
}

vec4 shadow_filterShadowColor(vec4 color) {
  if (shadow.drawShadowMap) {
    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);
    rgbaDepth -= rgbaDepth.gbaa * bitMask;
    return rgbaDepth;
  }
  if (shadow.useShadowMap) {
    float shadowAlpha = 0.0;
    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);
    if(shadow.lightCount > 1.0) {
      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);
    }
    shadowAlpha *= shadow.color.a / shadow.lightCount;
    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);

    return vec4(
      mix(color.rgb, shadow.color.rgb, shadowAlpha / blendedAlpha),
      blendedAlpha
    );
  }
  return color;
}
`
), yG = `
${YO}
${_G}
`, vG = v0(EG), bG = v0(CG), xG = [0, 0, 0, 1], wG = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
function TG(r, e) {
  const [t, n, i] = r, s = Vx([t, n, i], e);
  return Number.isFinite(i) ? s : [s[0], s[1], 0];
}
function EG({ viewport: r, center: e }) {
  return new xn(r.viewProjectionMatrix).invert().transform(e);
}
function CG({ viewport: r, shadowMatrices: e }) {
  const t = [], n = r.pixelUnprojectionMatrix, i = r.isGeospatial ? void 0 : 1, s = [
    [0, 0, i],
    // top left ground
    [r.width, 0, i],
    // top right ground
    [0, r.height, i],
    // bottom left ground
    [r.width, r.height, i],
    // bottom right ground
    [0, 0, -1],
    // top left near
    [r.width, 0, -1],
    // top right near
    [0, r.height, -1],
    // bottom left near
    [r.width, r.height, -1]
    // bottom right near
  ].map((o) => (
    // @ts-expect-error z may be undefined
    TG(o, n)
  ));
  for (const o of e) {
    const l = o.clone().translate(new yt(r.center).negate()), u = s.map((y) => l.transform(y)), m = new xn().ortho({
      left: Math.min(...u.map((y) => y[0])),
      right: Math.max(...u.map((y) => y[0])),
      bottom: Math.min(...u.map((y) => y[1])),
      top: Math.max(...u.map((y) => y[1])),
      near: Math.min(...u.map((y) => -y[2])),
      far: Math.max(...u.map((y) => -y[2]))
    });
    t.push(m.multiplyRight(o));
  }
  return t;
}
function SG(r) {
  const { shadowEnabled: e = !0, project: t } = r;
  if (!e || !t || !r.shadowMatrices || !r.shadowMatrices.length)
    return {
      drawShadowMap: !1,
      useShadowMap: !1,
      shadow_uShadowMap0: r.dummyShadowMap,
      shadow_uShadowMap1: r.dummyShadowMap
    };
  const n = N_.getUniforms(t), i = vG({
    viewport: t.viewport,
    center: n.center
  }), s = [], o = bG({
    shadowMatrices: r.shadowMatrices,
    viewport: t.viewport
  }).slice();
  for (let u = 0; u < r.shadowMatrices.length; u++) {
    const m = o[u], y = m.clone().translate(new yt(t.viewport.center).negate());
    n.coordinateSystem === rn.LNGLAT && n.projectionMode === ha.WEB_MERCATOR ? (o[u] = y, s[u] = i) : (o[u] = m.clone().multiplyRight(wG), s[u] = y.transform(i));
  }
  const l = {
    drawShadowMap: !!r.drawToShadowMap,
    useShadowMap: r.shadowMaps ? r.shadowMaps.length > 0 : !1,
    color: r.shadowColor || xG,
    lightId: r.shadowLightId || 0,
    lightCount: r.shadowMatrices.length,
    shadow_uShadowMap0: r.dummyShadowMap,
    shadow_uShadowMap1: r.dummyShadowMap
  };
  for (let u = 0; u < o.length; u++)
    l[`viewProjectionMatrix${u}`] = o[u], l[`projectCenter${u}`] = s[u];
  for (let u = 0; u < 2; u++)
    l[`shadow_uShadowMap${u}`] = r.shadowMaps && r.shadowMaps[u] || r.dummyShadowMap;
  return l;
}
const OC = {
  name: "shadow",
  dependencies: [N_],
  vs: mG,
  fs: yG,
  inject: {
    "vs:DECKGL_FILTER_GL_POSITION": `
    position = shadow_setVertexPosition(geometry.position);
    `,
    "fs:DECKGL_FILTER_COLOR": `
    color = shadow_filterShadowColor(color);
    `
  },
  getUniforms: SG,
  uniformTypes: {
    drawShadowMap: "f32",
    useShadowMap: "f32",
    color: "vec4<f32>",
    lightId: "i32",
    lightCount: "f32",
    viewProjectionMatrix0: "mat4x4<f32>",
    viewProjectionMatrix1: "mat4x4<f32>",
    projectCenter0: "vec4<f32>",
    projectCenter1: "vec4<f32>"
  }
}, ga = {
  ...cC,
  defaultUniforms: { ...cC.defaultUniforms, useFloatColors: !1 },
  inject: {
    "vs:DECKGL_FILTER_GL_POSITION": `
    // for picking depth values
    picking_setPickingAttribute(position.z / position.w);
  `,
    "vs:DECKGL_FILTER_COLOR": `
  picking_setPickingColor(geometry.pickingColor);
  `,
    "fs:DECKGL_FILTER_COLOR": {
      order: 99,
      injection: `
  // use highlight color if this fragment belongs to the selected object.
  color = picking_filterHighlightColor(color);

  // use picking color if rendering to picking FBO.
  color = picking_filterPickingColor(color);
    `
    }
  }
}, IG = [FO], PG = [
  "vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)",
  "vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)",
  "vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)",
  "fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"
], MG = [
  // Not yet supported
];
function RG(r) {
  const e = Hf.getDefaultShaderAssembler();
  for (const n of IG)
    e.addDefaultModule(n);
  e._hookFunctions.length = 0;
  const t = r === "glsl" ? PG : MG;
  for (const n of t)
    e.addShaderHook(n);
  return e;
}
const BG = [255, 255, 255], OG = 1;
let DG = 0;
class LG {
  constructor(e = {}) {
    this.type = "ambient";
    const { color: t = BG } = e, { intensity: n = OG } = e;
    this.id = e.id || `ambient-${DG++}`, this.color = t, this.intensity = n;
  }
}
const kG = [255, 255, 255], FG = 1, NG = [0, 0, -1];
let UG = 0;
class DC {
  constructor(e = {}) {
    this.type = "directional";
    const { color: t = kG } = e, { intensity: n = FG } = e, { direction: i = NG } = e, { _shadow: s = !1 } = e;
    this.id = e.id || `directional-${UG++}`, this.color = t, this.intensity = n, this.type = "directional", this.direction = new yt(i).normalize().toArray(), this.shadow = s;
  }
  getProjectedLight(e) {
    return this;
  }
}
class KO {
  /** Create a new Pass instance */
  constructor(e, t = { id: "pass" }) {
    const { id: n } = t;
    this.id = n, this.device = e, this.props = { ...t };
  }
  setProps(e) {
    Object.assign(this.props, e);
  }
  render(e) {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
  cleanup() {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
}
class U_ extends KO {
  constructor() {
    super(...arguments), this._lastRenderIndex = -1;
  }
  render(e) {
    const [t, n] = this.device.canvasContext.getDrawingBufferSize(), i = e.clearCanvas ?? !0, s = e.clearColor ?? (i ? [0, 0, 0, 0] : !1), o = i ? 1 : !1, l = i ? 0 : !1, u = e.colorMask ?? 15, m = { viewport: [0, 0, t, n] };
    e.colorMask && (m.colorMask = u), e.scissorRect && (m.scissorRect = e.scissorRect);
    const y = this.device.beginRenderPass({
      framebuffer: e.target,
      parameters: m,
      clearColor: s,
      clearDepth: o,
      clearStencil: l
    });
    try {
      return this._drawLayers(y, e);
    } finally {
      y.end(), this.device.submit();
    }
  }
  /** Draw a list of layers in a list of viewports */
  _drawLayers(e, t) {
    const { target: n, shaderModuleProps: i, viewports: s, views: o, onViewportActive: l, clearStack: u = !0 } = t;
    t.pass = t.pass || "unknown", u && (this._lastRenderIndex = -1);
    const m = [];
    for (const y of s) {
      const E = o && o[y.id];
      l?.(y);
      const P = this._getDrawLayerParams(y, t), L = y.subViewports || [y];
      for (const U of L) {
        const V = this._drawLayersInViewport(e, {
          target: n,
          shaderModuleProps: i,
          viewport: U,
          view: E,
          pass: t.pass,
          layers: t.layers
        }, P);
        m.push(V);
      }
    }
    return m;
  }
  // When a viewport contains multiple subviewports (e.g. repeated web mercator map),
  // this is only done once for the parent viewport
  /* Resolve the parameters needed to draw each layer */
  _getDrawLayerParams(e, { layers: t, pass: n, isPicking: i = !1, layerFilter: s, cullRect: o, effects: l, shaderModuleProps: u }, m = !1) {
    const y = [], E = QO(this._lastRenderIndex + 1), P = {
      layer: t[0],
      viewport: e,
      isPicking: i,
      renderPass: n,
      cullRect: o
    }, L = {};
    for (let U = 0; U < t.length; U++) {
      const V = t[U], q = this._shouldDrawLayer(V, P, s, L), j = { shouldDrawLayer: q };
      q && !m && (j.shouldDrawLayer = !0, j.layerRenderIndex = E(V, q), j.shaderModuleProps = this._getShaderModuleProps(V, l, n, u), j.layerParameters = {
        ...V.context.deck?.props.parameters,
        ...this.getLayerParameters(V, U, e)
      }), y[U] = j;
    }
    return y;
  }
  // Draws a list of layers in one viewport
  // TODO - when picking we could completely skip rendering viewports that dont
  // intersect with the picking rect
  /* eslint-disable max-depth, max-statements, complexity */
  _drawLayersInViewport(e, { layers: t, shaderModuleProps: n, pass: i, target: s, viewport: o, view: l }, u) {
    const m = zG(this.device, {
      shaderModuleProps: n,
      target: s,
      viewport: o
    });
    if (l) {
      const { clear: E, clearColor: P, clearDepth: L, clearStencil: U } = l.props;
      if (E) {
        let V = [0, 0, 0, 0], q = 1, j = 0;
        Array.isArray(P) ? V = [...P.slice(0, 3), P[3] || 255].map((Y) => Y / 255) : P === !1 && (V = !1), L !== void 0 && (q = L), U !== void 0 && (j = U), this.device.beginRenderPass({
          framebuffer: s,
          parameters: {
            viewport: m,
            scissorRect: m
          },
          clearColor: V,
          clearDepth: q,
          clearStencil: j
        }).end();
      }
    }
    const y = {
      totalCount: t.length,
      visibleCount: 0,
      compositeCount: 0,
      pickableCount: 0
    };
    e.setParameters({ viewport: m });
    for (let E = 0; E < t.length; E++) {
      const P = t[E], L = u[E], { shouldDrawLayer: U } = L;
      if (U && P.props.pickable && y.pickableCount++, P.isComposite && y.compositeCount++, P.isDrawable && L.shouldDrawLayer) {
        const { layerRenderIndex: V, shaderModuleProps: q, layerParameters: j } = L;
        y.visibleCount++, this._lastRenderIndex = Math.max(this._lastRenderIndex, V), q.project && (q.project.viewport = o), P.context.renderPass = e;
        try {
          P._drawLayer({
            renderPass: e,
            shaderModuleProps: q,
            uniforms: { layerIndex: V },
            parameters: j
          });
        } catch (K) {
          P.raiseError(K, `drawing ${P} to ${i}`);
        }
      }
    }
    return y;
  }
  /* eslint-enable max-depth, max-statements */
  /* Methods for subclass overrides */
  shouldDrawLayer(e) {
    return !0;
  }
  getShaderModuleProps(e, t, n) {
    return null;
  }
  getLayerParameters(e, t, n) {
    return e.props.parameters;
  }
  /* Private */
  _shouldDrawLayer(e, t, n, i) {
    if (!(e.props.visible && this.shouldDrawLayer(e)))
      return !1;
    t.layer = e;
    let o = e.parent;
    for (; o; ) {
      if (!o.props.visible || !o.filterSubLayer(t))
        return !1;
      t.layer = o, o = o.parent;
    }
    if (n) {
      const l = t.layer.id;
      if (l in i || (i[l] = n(t)), !i[l])
        return !1;
    }
    return e.activateViewport(t.viewport), !0;
  }
  _getShaderModuleProps(e, t, n, i) {
    const s = this.device.canvasContext.cssToDeviceRatio(), o = e.internalState?.propsInTransition || e.props, l = {
      layer: o,
      picking: {
        isActive: !1
      },
      project: {
        viewport: e.context.viewport,
        devicePixelRatio: s,
        modelMatrix: o.modelMatrix,
        coordinateSystem: o.coordinateSystem,
        coordinateOrigin: o.coordinateOrigin,
        autoWrapLongitude: e.wrapLongitude
      }
    };
    if (t)
      for (const u of t)
        LC(l, u.getShaderModuleProps?.(e, l));
    return LC(l, this.getShaderModuleProps(e, t, l), i);
  }
}
function QO(r = 0, e = {}) {
  const t = {}, n = (i, s) => {
    const o = i.props._offset, l = i.id, u = i.parent && i.parent.id;
    let m;
    if (u && !(u in e) && n(i.parent, !1), u in t) {
      const y = t[u] = t[u] || QO(e[u], e);
      m = y(i, s), t[l] = y;
    } else Number.isFinite(o) ? (m = o + (e[u] || 0), t[l] = null) : m = r;
    return s && m >= r && (r = m + 1), e[l] = m, m;
  };
  return n;
}
function zG(r, { shaderModuleProps: e, target: t, viewport: n }) {
  const i = e?.project?.devicePixelRatio ?? // @ts-expect-error TODO - assuming WebGL context
  r.canvasContext.cssToDeviceRatio(), [, s] = r.canvasContext.getDrawingBufferSize(), o = t ? t.height : s, l = n;
  return [
    l.x * i,
    o - (l.y + l.height) * i,
    l.width * i,
    l.height * i
  ];
}
function LC(r, ...e) {
  for (const t of e)
    if (t)
      for (const n in t)
        r[n] ? Object.assign(r[n], t[n]) : r[n] = t[n];
  return r;
}
class VG extends U_ {
  constructor(e, t) {
    super(e, t);
    const n = e.createTexture({
      format: "rgba8unorm",
      width: 1,
      height: 1,
      sampler: {
        minFilter: "linear",
        magFilter: "linear",
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
      }
      // TODO - texture API change in luma.gl v9.2
      // mipmaps: true
    }), i = e.createTexture({ format: "depth16unorm", width: 1, height: 1 });
    this.fbo = e.createFramebuffer({
      id: "shadowmap",
      width: 1,
      height: 1,
      colorAttachments: [n],
      // Depth attachment has to be specified for depth test to work
      depthStencilAttachment: i
    });
  }
  delete() {
    this.fbo && (this.fbo.destroy(), this.fbo = null);
  }
  getShadowMap() {
    return this.fbo.colorAttachments[0].texture;
  }
  render(e) {
    const t = this.fbo, n = this.device.canvasContext.cssToDeviceRatio(), i = e.viewports[0], s = i.width * n, o = i.height * n, l = [1, 1, 1, 1];
    (s !== t.width || o !== t.height) && t.resize({ width: s, height: o }), super.render({ ...e, clearColor: l, target: t, pass: "shadow" });
  }
  getLayerParameters(e, t, n) {
    return {
      ...e.props.parameters,
      blend: !1,
      depthWriteEnabled: !0,
      depthCompare: "less-equal"
    };
  }
  shouldDrawLayer(e) {
    return e.props.shadowEnabled !== !1;
  }
  getShaderModuleProps(e, t, n) {
    return {
      shadow: {
        project: n.project,
        drawToShadowMap: !0
      }
    };
  }
}
const jG = {
  color: [255, 255, 255],
  intensity: 1
}, kC = [
  {
    color: [255, 255, 255],
    intensity: 1,
    direction: [-1, 3, -1]
  },
  {
    color: [255, 255, 255],
    intensity: 0.9,
    direction: [1, -8, -2.5]
  }
], HG = [0, 0, 0, 200 / 255];
class JO {
  constructor(e = {}) {
    this.id = "lighting-effect", this.shadowColor = HG, this.shadow = !1, this.directionalLights = [], this.pointLights = [], this.shadowPasses = [], this.dummyShadowMap = null, this.setProps(e);
  }
  setup(e) {
    this.context = e;
    const { device: t, deck: n } = e;
    this.shadow && !this.dummyShadowMap && (this._createShadowPasses(t), n._addDefaultShaderModule(OC), this.dummyShadowMap = t.createTexture({
      width: 1,
      height: 1
    }));
  }
  setProps(e) {
    this.ambientLight = void 0, this.directionalLights = [], this.pointLights = [];
    for (const t in e) {
      const n = e[t];
      switch (n.type) {
        case "ambient":
          this.ambientLight = n;
          break;
        case "directional":
          this.directionalLights.push(n);
          break;
        case "point":
          this.pointLights.push(n);
          break;
      }
    }
    this._applyDefaultLights(), this.shadow = this.directionalLights.some((t) => t.shadow), this.context && this.setup(this.context), this.props = e;
  }
  preRender({ layers: e, layerFilter: t, viewports: n, onViewportActive: i, views: s }) {
    if (this.shadow) {
      this.shadowMatrices = this._calculateMatrices();
      for (let o = 0; o < this.shadowPasses.length; o++)
        this.shadowPasses[o].render({
          layers: e,
          layerFilter: t,
          viewports: n,
          onViewportActive: i,
          views: s,
          shaderModuleProps: {
            shadow: {
              shadowLightId: o,
              dummyShadowMap: this.dummyShadowMap,
              shadowMatrices: this.shadowMatrices
            }
          }
        });
    }
  }
  getShaderModuleProps(e, t) {
    const n = this.shadow ? {
      project: t.project,
      shadowMaps: this.shadowPasses.map((o) => o.getShadowMap()),
      dummyShadowMap: this.dummyShadowMap,
      shadowColor: this.shadowColor,
      shadowMatrices: this.shadowMatrices
    } : {}, i = {
      enabled: !0,
      ambientLight: this.ambientLight,
      directionalLights: this.directionalLights.map((o) => o.getProjectedLight({ layer: e })),
      pointLights: this.pointLights.map((o) => o.getProjectedLight({ layer: e }))
    }, s = e.props.material;
    return {
      shadow: n,
      lighting: i,
      phongMaterial: s,
      gouraudMaterial: s
    };
  }
  cleanup(e) {
    for (const t of this.shadowPasses)
      t.delete();
    this.shadowPasses.length = 0, this.dummyShadowMap && (this.dummyShadowMap.destroy(), this.dummyShadowMap = null, e.deck._removeDefaultShaderModule(OC));
  }
  _calculateMatrices() {
    const e = [];
    for (const t of this.directionalLights) {
      const n = new xn().lookAt({
        eye: new yt(t.direction).negate()
      });
      e.push(n);
    }
    return e;
  }
  _createShadowPasses(e) {
    for (let t = 0; t < this.directionalLights.length; t++) {
      const n = new VG(e);
      this.shadowPasses[t] = n;
    }
  }
  _applyDefaultLights() {
    const { ambientLight: e, pointLights: t, directionalLights: n } = this;
    !e && t.length === 0 && n.length === 0 && (this.ambientLight = new LG(jG), this.directionalLights.push(new DC(kC[0]), new DC(kC[1])));
  }
}
class GG {
  constructor(e = {}) {
    this._pool = [], this.opts = { overAlloc: 2, poolSize: 100 }, this.setOptions(e);
  }
  setOptions(e) {
    Object.assign(this.opts, e);
  }
  allocate(e, t, { size: n = 1, type: i, padding: s = 0, copy: o = !1, initialize: l = !1, maxCount: u }) {
    const m = i || e && e.constructor || Float32Array, y = t * n + s;
    if (ArrayBuffer.isView(e)) {
      if (y <= e.length)
        return e;
      if (y * e.BYTES_PER_ELEMENT <= e.buffer.byteLength)
        return new m(e.buffer, 0, y);
    }
    let E = 1 / 0;
    u && (E = u * n + s);
    const P = this._allocate(m, y, l, E);
    return e && o ? P.set(e) : l || P.fill(0, 0, 4), this._release(e), P;
  }
  release(e) {
    this._release(e);
  }
  _allocate(e, t, n, i) {
    let s = Math.max(Math.ceil(t * this.opts.overAlloc), 1);
    s > i && (s = i);
    const o = this._pool, l = e.BYTES_PER_ELEMENT * s, u = o.findIndex((m) => m.byteLength >= l);
    if (u >= 0) {
      const m = new e(o.splice(u, 1)[0], 0, s);
      return n && m.fill(0), m;
    }
    return new e(s);
  }
  _release(e) {
    if (!ArrayBuffer.isView(e))
      return;
    const t = this._pool, { buffer: n } = e, { byteLength: i } = n, s = t.findIndex((o) => o.byteLength >= i);
    s < 0 ? t.push(n) : (s > 0 || t.length < this.opts.poolSize) && t.splice(s, 0, n), t.length > this.opts.poolSize && t.shift();
  }
}
const yp = new GG();
function RA() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function WG(r) {
  return [r[12], r[13], r[14]];
}
function $G(r) {
  return {
    left: vd(r[3] + r[0], r[7] + r[4], r[11] + r[8], r[15] + r[12]),
    right: vd(r[3] - r[0], r[7] - r[4], r[11] - r[8], r[15] - r[12]),
    bottom: vd(r[3] + r[1], r[7] + r[5], r[11] + r[9], r[15] + r[13]),
    top: vd(r[3] - r[1], r[7] - r[5], r[11] - r[9], r[15] - r[13]),
    near: vd(r[3] + r[2], r[7] + r[6], r[11] + r[10], r[15] + r[14]),
    far: vd(r[3] - r[2], r[7] - r[6], r[11] - r[10], r[15] - r[14])
  };
}
const FC = new yt();
function vd(r, e, t, n) {
  FC.set(r, e, t);
  const i = FC.len();
  return { distance: n / i, normal: new yt(-r / i, -e / i, -t / i) };
}
function qG(r) {
  return r - Math.fround(r);
}
let _A;
function Lv(r, e) {
  const { size: t = 1, startIndex: n = 0 } = e, i = e.endIndex !== void 0 ? e.endIndex : r.length, s = (i - n) / t;
  _A = yp.allocate(_A, s, {
    type: Float32Array,
    size: t * 2
  });
  let o = n, l = 0;
  for (; o < i; ) {
    for (let u = 0; u < t; u++) {
      const m = r[o++];
      _A[l + u] = m, _A[l + u + t] = qG(m);
    }
    l += t * 2;
  }
  return _A.subarray(0, s * t * 2);
}
function XG(r) {
  let e = null, t = !1;
  for (const n of r)
    n && (e ? (t || (e = [
      [e[0][0], e[0][1]],
      [e[1][0], e[1][1]]
    ], t = !0), e[0][0] = Math.min(e[0][0], n[0][0]), e[0][1] = Math.min(e[0][1], n[0][1]), e[1][0] = Math.max(e[1][0], n[1][0]), e[1][1] = Math.max(e[1][1], n[1][1])) : e = n);
  return e;
}
const ZG = Math.PI / 180, YG = RA(), NC = [0, 0, 0], KG = {
  unitsPerMeter: [1, 1, 1],
  metersPerUnit: [1, 1, 1]
};
function QG({ width: r, height: e, orthographic: t, fovyRadians: n, focalDistance: i, padding: s, near: o, far: l }) {
  const u = r / e, m = t ? new xn().orthographic({ fovy: n, aspect: u, focalDistance: i, near: o, far: l }) : new xn().perspective({ fovy: n, aspect: u, near: o, far: l });
  if (s) {
    const { left: y = 0, right: E = 0, top: P = 0, bottom: L = 0 } = s, U = $c((y + r - E) / 2, 0, r) - r / 2, V = $c((P + e - L) / 2, 0, e) - e / 2;
    m[8] -= U * 2 / r, m[9] += V * 2 / e;
  }
  return m;
}
class tu {
  // eslint-disable-next-line complexity
  constructor(e = {}) {
    this._frustumPlanes = {}, this.id = e.id || this.constructor.displayName || "viewport", this.x = e.x || 0, this.y = e.y || 0, this.width = e.width || 1, this.height = e.height || 1, this.zoom = e.zoom || 0, this.padding = e.padding, this.distanceScales = e.distanceScales || KG, this.focalDistance = e.focalDistance || 1, this.position = e.position || NC, this.modelMatrix = e.modelMatrix || null;
    const { longitude: t, latitude: n } = e;
    this.isGeospatial = Number.isFinite(n) && Number.isFinite(t), this._initProps(e), this._initMatrices(e), this.equals = this.equals.bind(this), this.project = this.project.bind(this), this.unproject = this.unproject.bind(this), this.projectPosition = this.projectPosition.bind(this), this.unprojectPosition = this.unprojectPosition.bind(this), this.projectFlat = this.projectFlat.bind(this), this.unprojectFlat = this.unprojectFlat.bind(this);
  }
  get subViewports() {
    return null;
  }
  get metersPerPixel() {
    return this.distanceScales.metersPerUnit[2] / this.scale;
  }
  get projectionMode() {
    return this.isGeospatial ? this.zoom < 12 ? ha.WEB_MERCATOR : ha.WEB_MERCATOR_AUTO_OFFSET : ha.IDENTITY;
  }
  // Two viewports are equal if width and height are identical, and if
  // their view and projection matrices are (approximately) equal.
  equals(e) {
    return e instanceof tu ? this === e ? !0 : e.width === this.width && e.height === this.height && e.scale === this.scale && Aa(e.projectionMatrix, this.projectionMatrix) && Aa(e.viewMatrix, this.viewMatrix) : !1;
  }
  /**
   * Projects xyz (possibly latitude and longitude) to pixel coordinates in window
   * using viewport projection parameters
   * - [longitude, latitude] to [x, y]
   * - [longitude, latitude, Z] => [x, y, z]
   * Note: By default, returns top-left coordinates for canvas/SVG type render
   *
   * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]
   * @param {Object} opts - options
   * @param {Object} opts.topLeft=true - Whether projected coords are top left
   * @return {Array} - [x, y] or [x, y, z] in top left coords
   */
  project(e, { topLeft: t = !0 } = {}) {
    const n = this.projectPosition(e), i = ZO(n, this.pixelProjectionMatrix), [s, o] = i, l = t ? o : this.height - o;
    return e.length === 2 ? [s, l] : [s, l, i[2]];
  }
  /**
   * Unproject pixel coordinates on screen onto world coordinates,
   * (possibly [lon, lat]) on map.
   * - [x, y] => [lng, lat]
   * - [x, y, z] => [lng, lat, Z]
   * @param {Array} xyz -
   * @param {Object} opts - options
   * @param {Object} opts.topLeft=true - Whether origin is top left
   * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]
   */
  unproject(e, { topLeft: t = !0, targetZ: n } = {}) {
    const [i, s, o] = e, l = t ? s : this.height - s, u = n && n * this.distanceScales.unitsPerMeter[2], m = Vx([i, l, o], this.pixelUnprojectionMatrix, u), [y, E, P] = this.unprojectPosition(m);
    return Number.isFinite(o) ? [y, E, P] : Number.isFinite(n) ? [y, E, n] : [y, E];
  }
  // NON_LINEAR PROJECTION HOOKS
  // Used for web meractor projection
  projectPosition(e) {
    const [t, n] = this.projectFlat(e), i = (e[2] || 0) * this.distanceScales.unitsPerMeter[2];
    return [t, n, i];
  }
  unprojectPosition(e) {
    const [t, n] = this.unprojectFlat(e), i = (e[2] || 0) * this.distanceScales.metersPerUnit[2];
    return [t, n, i];
  }
  /**
   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
   * Performs the nonlinear part of the web mercator projection.
   * Remaining projection is done with 4x4 matrices which also handles
   * perspective.
   * @param {Array} lngLat - [lng, lat] coordinates
   *   Specifies a point on the sphere to project onto the map.
   * @return {Array} [x,y] coordinates.
   */
  projectFlat(e) {
    if (this.isGeospatial) {
      const t = Jc(e);
      return t[1] = $c(t[1], -318, 830), t;
    }
    return e;
  }
  /**
   * Unproject world point [x,y] on map onto {lat, lon} on sphere
   * @param {object|Vector} xy - object with {x,y} members
   *  representing point on projected map plane
   * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
   *   Has toArray method if you need a GeoJSON Array.
   *   Per cartographic tradition, lat and lon are specified as degrees.
   */
  unprojectFlat(e) {
    return this.isGeospatial ? lc(e) : e;
  }
  /**
   * Get bounds of the current viewport
   * @return {Array} - [minX, minY, maxX, maxY]
   */
  getBounds(e = {}) {
    const t = { targetZ: e.z || 0 }, n = this.unproject([0, 0], t), i = this.unproject([this.width, 0], t), s = this.unproject([0, this.height], t), o = this.unproject([this.width, this.height], t);
    return [
      Math.min(n[0], i[0], s[0], o[0]),
      Math.min(n[1], i[1], s[1], o[1]),
      Math.max(n[0], i[0], s[0], o[0]),
      Math.max(n[1], i[1], s[1], o[1])
    ];
  }
  getDistanceScales(e) {
    return e && this.isGeospatial ? Ub({
      longitude: e[0],
      latitude: e[1],
      highPrecision: !0
    }) : this.distanceScales;
  }
  containsPixel({ x: e, y: t, width: n = 1, height: i = 1 }) {
    return e < this.x + this.width && this.x < e + n && t < this.y + this.height && this.y < t + i;
  }
  // Extract frustum planes in common space
  getFrustumPlanes() {
    return this._frustumPlanes.near ? this._frustumPlanes : (Object.assign(this._frustumPlanes, $G(this.viewProjectionMatrix)), this._frustumPlanes);
  }
  // EXPERIMENTAL METHODS
  /**
   * Needed by panning and linear transition
   * Pan the viewport to place a given world coordinate at screen point [x, y]
   *
   * @param {Array} coords - world coordinates
   * @param {Array} pixel - [x,y] coordinates on screen
   * @return {Object} props of the new viewport
   */
  panByPosition(e, t) {
    return null;
  }
  // INTERNAL METHODS
  /* eslint-disable complexity, max-statements */
  _initProps(e) {
    const t = e.longitude, n = e.latitude;
    this.isGeospatial && (Number.isFinite(e.zoom) || (this.zoom = cG({ latitude: n }) + Math.log2(this.focalDistance)), this.distanceScales = e.distanceScales || Ub({ latitude: n, longitude: t }));
    const i = Math.pow(2, this.zoom);
    this.scale = i;
    const { position: s, modelMatrix: o } = e;
    let l = NC;
    if (s && (l = o ? new xn(o).transformAsVector(s, []) : s), this.isGeospatial) {
      const u = this.projectPosition([t, n, 0]);
      this.center = new yt(l).scale(this.distanceScales.unitsPerMeter).add(u);
    } else
      this.center = this.projectPosition(l);
  }
  /* eslint-enable complexity, max-statements */
  _initMatrices(e) {
    const {
      // View matrix
      viewMatrix: t = YG,
      // Projection matrix
      projectionMatrix: n = null,
      // Projection matrix parameters, used if projectionMatrix not supplied
      orthographic: i = !1,
      fovyRadians: s,
      fovy: o = 75,
      near: l = 0.1,
      // Distance of near clipping plane
      far: u = 1e3,
      // Distance of far clipping plane
      padding: m = null,
      // Center offset in pixels
      focalDistance: y = 1
    } = e;
    this.viewMatrixUncentered = t, this.viewMatrix = new xn().multiplyRight(t).translate(new yt(this.center).negate()), this.projectionMatrix = n || QG({
      width: this.width,
      height: this.height,
      orthographic: i,
      fovyRadians: s || o * ZG,
      focalDistance: y,
      padding: m,
      near: l,
      far: u
    });
    const E = RA();
    Yf(E, E, this.projectionMatrix), Yf(E, E, this.viewMatrix), this.viewProjectionMatrix = E, this.viewMatrixInverse = Mb([], this.viewMatrix) || this.viewMatrix, this.cameraPosition = WG(this.viewMatrixInverse);
    const P = RA(), L = RA();
    Dx(P, P, [this.width / 2, -this.height / 2, 1]), t_(P, P, [1, -1, 0]), Yf(L, P, this.viewProjectionMatrix), this.pixelProjectionMatrix = L, this.pixelUnprojectionMatrix = Mb(RA(), this.pixelProjectionMatrix), this.pixelUnprojectionMatrix || Jr.warn("Pixel project matrix not invertible")();
  }
}
tu.displayName = "Viewport";
let s0 = class zb extends tu {
  /* eslint-disable complexity, max-statements */
  constructor(e = {}) {
    const {
      latitude: t = 0,
      longitude: n = 0,
      zoom: i = 0,
      pitch: s = 0,
      bearing: o = 0,
      nearZMultiplier: l = 0.1,
      farZMultiplier: u = 1.01,
      nearZ: m,
      farZ: y,
      orthographic: E = !1,
      projectionMatrix: P,
      repeat: L = !1,
      worldOffset: U = 0,
      position: V,
      padding: q,
      // backward compatibility
      // TODO: remove in v9
      legacyMeterSizes: j = !1
    } = e;
    let { width: K, height: Y, altitude: de = 1.5 } = e;
    const ne = Math.pow(2, i);
    K = K || 1, Y = Y || 1;
    let ae, De = null;
    if (P)
      de = P[5] / 2, ae = i0(de);
    else {
      e.fovy ? (ae = e.fovy, de = zx(ae)) : ae = i0(de);
      let fe;
      if (q) {
        const { top: ve = 0, bottom: me = 0 } = q;
        fe = [0, $c((ve + Y - me) / 2, 0, Y) - Y / 2];
      }
      De = fG({
        width: K,
        height: Y,
        scale: ne,
        center: V && [0, 0, V[2] * Dv(t)],
        offset: fe,
        pitch: s,
        fovy: ae,
        nearZMultiplier: l,
        farZMultiplier: u
      }), Number.isFinite(m) && (De.near = m), Number.isFinite(y) && (De.far = y);
    }
    let Ge = uG({
      height: Y,
      pitch: s,
      bearing: o,
      scale: ne,
      altitude: de
    });
    U && (Ge = new xn().translate([512 * U, 0, 0]).multiplyLeft(Ge)), super({
      ...e,
      // x, y,
      width: K,
      height: Y,
      // view matrix
      viewMatrix: Ge,
      longitude: n,
      latitude: t,
      zoom: i,
      // projection matrix parameters
      ...De,
      fovy: ae,
      focalDistance: de
    }), this.latitude = t, this.longitude = n, this.zoom = i, this.pitch = s, this.bearing = o, this.altitude = de, this.fovy = ae, this.orthographic = E, this._subViewports = L ? [] : null, this._pseudoMeters = j, Object.freeze(this);
  }
  /* eslint-enable complexity, max-statements */
  get subViewports() {
    if (this._subViewports && !this._subViewports.length) {
      const e = this.getBounds(), t = Math.floor((e[0] + 180) / 360), n = Math.ceil((e[2] - 180) / 360);
      for (let i = t; i <= n; i++) {
        const s = i ? new zb({
          ...this,
          worldOffset: i
        }) : this;
        this._subViewports.push(s);
      }
    }
    return this._subViewports;
  }
  projectPosition(e) {
    if (this._pseudoMeters)
      return super.projectPosition(e);
    const [t, n] = this.projectFlat(e), i = (e[2] || 0) * Dv(e[1]);
    return [t, n, i];
  }
  unprojectPosition(e) {
    if (this._pseudoMeters)
      return super.unprojectPosition(e);
    const [t, n] = this.unprojectFlat(e), i = (e[2] || 0) / Dv(n);
    return [t, n, i];
  }
  /**
   * Add a meter delta to a base lnglat coordinate, returning a new lnglat array
   *
   * Note: Uses simple linear approximation around the viewport center
   * Error increases with size of offset (roughly 1% per 100km)
   *
   * @param {[Number,Number]|[Number,Number,Number]) lngLatZ - base coordinate
   * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas
   * @return {[Number,Number]|[Number,Number,Number]) array of [lng,lat,z] deltas
   */
  addMetersToLngLat(e, t) {
    return XO(e, t);
  }
  panByPosition(e, t) {
    const n = Vx(t, this.pixelUnprojectionMatrix), i = this.projectFlat(e), s = rC([], i, iV([], n)), o = rC([], this.center, s), [l, u] = this.unprojectFlat(o);
    return { longitude: l, latitude: u };
  }
  getBounds(e = {}) {
    const t = pG(this, e.z || 0);
    return [
      Math.min(t[0][0], t[1][0], t[2][0], t[3][0]),
      Math.min(t[0][1], t[1][1], t[2][1], t[3][1]),
      Math.max(t[0][0], t[1][0], t[2][0], t[3][0]),
      Math.max(t[0][1], t[1][1], t[2][1], t[3][1])
    ];
  }
  /**
   * Returns a new viewport that fit around the given rectangle.
   * Only supports non-perspective mode.
   */
  fitBounds(e, t = {}) {
    const { width: n, height: i } = this, { longitude: s, latitude: o, zoom: l } = hG({ width: n, height: i, bounds: e, ...t });
    return new zb({ width: n, height: i, longitude: s, latitude: o, zoom: l });
  }
};
s0.displayName = "WebMercatorViewport";
const UC = [0, 0, 0];
function kv(r, e, t = !1) {
  const n = e.projectPosition(r);
  if (t && e instanceof s0) {
    const [i, s, o = 0] = r, l = e.getDistanceScales([i, s]);
    n[2] = o * l.unitsPerMeter[2];
  }
  return n;
}
function JG(r) {
  const { viewport: e, modelMatrix: t, coordinateOrigin: n } = r;
  let { coordinateSystem: i, fromCoordinateSystem: s, fromCoordinateOrigin: o } = r;
  return i === rn.DEFAULT && (i = e.isGeospatial ? rn.LNGLAT : rn.CARTESIAN), s === void 0 && (s = i), o === void 0 && (o = n), {
    viewport: e,
    coordinateSystem: i,
    coordinateOrigin: n,
    modelMatrix: t,
    fromCoordinateSystem: s,
    fromCoordinateOrigin: o
  };
}
function e6(r, { viewport: e, modelMatrix: t, coordinateSystem: n, coordinateOrigin: i, offsetMode: s }) {
  let [o, l, u = 0] = r;
  switch (t && ([o, l, u] = Dp([], [o, l, u, 1], t)), n) {
    case rn.LNGLAT:
      return kv([o, l, u], e, s);
    case rn.LNGLAT_OFFSETS:
      return kv([o + i[0], l + i[1], u + (i[2] || 0)], e, s);
    case rn.METER_OFFSETS:
      return kv(XO(i, [o, l, u]), e, s);
    case rn.CARTESIAN:
    default:
      return e.isGeospatial ? [o + i[0], l + i[1], u + i[2]] : e.projectPosition([o, l, u]);
  }
}
function eW(r, e) {
  const { viewport: t, coordinateSystem: n, coordinateOrigin: i, modelMatrix: s, fromCoordinateSystem: o, fromCoordinateOrigin: l } = JG(e), { autoOffset: u = !0 } = e, { geospatialOrigin: m = UC, shaderCoordinateOrigin: y = UC, offsetMode: E = !1 } = u ? $O(t, n, i) : {}, P = e6(r, {
    viewport: t,
    modelMatrix: s,
    coordinateSystem: o,
    coordinateOrigin: l,
    offsetMode: E
  });
  if (E) {
    const L = t.projectPosition(m || y);
    wO(P, P, L);
  }
  return P;
}
let tW = 1, rW = 1;
class t6 {
  time = 0;
  channels = /* @__PURE__ */ new Map();
  animations = /* @__PURE__ */ new Map();
  playing = !1;
  lastEngineTime = -1;
  constructor() {
  }
  addChannel(e) {
    const { delay: t = 0, duration: n = Number.POSITIVE_INFINITY, rate: i = 1, repeat: s = 1 } = e, o = tW++, l = {
      time: 0,
      delay: t,
      duration: n,
      rate: i,
      repeat: s
    };
    return this._setChannelTime(l, this.time), this.channels.set(o, l), o;
  }
  removeChannel(e) {
    this.channels.delete(e);
    for (const [t, n] of this.animations)
      n.channel === e && this.detachAnimation(t);
  }
  isFinished(e) {
    const t = this.channels.get(e);
    return t === void 0 ? !1 : this.time >= t.delay + t.duration * t.repeat;
  }
  getTime(e) {
    if (e === void 0)
      return this.time;
    const t = this.channels.get(e);
    return t === void 0 ? -1 : t.time;
  }
  setTime(e) {
    this.time = Math.max(0, e);
    const t = this.channels.values();
    for (const i of t)
      this._setChannelTime(i, this.time);
    const n = this.animations.values();
    for (const i of n) {
      const { animation: s, channel: o } = i;
      s.setTime(this.getTime(o));
    }
  }
  play() {
    this.playing = !0;
  }
  pause() {
    this.playing = !1, this.lastEngineTime = -1;
  }
  reset() {
    this.setTime(0);
  }
  attachAnimation(e, t) {
    const n = rW++;
    return this.animations.set(n, {
      animation: e,
      channel: t
    }), e.setTime(this.getTime(t)), n;
  }
  detachAnimation(e) {
    this.animations.delete(e);
  }
  update(e) {
    this.playing && (this.lastEngineTime === -1 && (this.lastEngineTime = e), this.setTime(this.time + (e - this.lastEngineTime)), this.lastEngineTime = e);
  }
  _setChannelTime(e, t) {
    const n = t - e.delay, i = e.duration * e.repeat;
    n >= i ? e.time = e.duration * e.rate : (e.time = Math.max(0, n) % e.duration, e.time *= e.rate);
  }
}
function nW(r) {
  return typeof window < "u" && window.requestAnimationFrame ? window.requestAnimationFrame(r) : setTimeout(r, 1e3 / 60);
}
function iW(r) {
  return typeof window < "u" && window.cancelAnimationFrame ? window.cancelAnimationFrame(r) : clearTimeout(r);
}
let sW = 0;
class jx {
  static defaultAnimationLoopProps = {
    device: null,
    onAddHTML: () => "",
    onInitialize: async () => null,
    onRender: () => {
    },
    onFinalize: () => {
    },
    onError: (e) => console.error(e),
    // eslint-disable-line no-console
    stats: Eb.stats.get(`animation-loop-${sW++}`),
    // view parameters
    autoResizeViewport: !1
  };
  device = null;
  canvas = null;
  props;
  animationProps = null;
  timeline = null;
  stats;
  cpuTime;
  gpuTime;
  frameRate;
  display;
  needsRedraw = "initialized";
  _initialized = !1;
  _running = !1;
  _animationFrameId = null;
  _nextFramePromise = null;
  _resolveNextFrame = null;
  _cpuStartTime = 0;
  _error = null;
  // _gpuTimeQuery: Query | null = null;
  /*
   * @param {HTMLCanvasElement} canvas - if provided, width and height will be passed to context
   */
  constructor(e) {
    if (this.props = { ...jx.defaultAnimationLoopProps, ...e }, e = this.props, !e.device)
      throw new Error("No device provided");
    this.stats = e.stats || new Bp({ id: "animation-loop-stats" }), this.cpuTime = this.stats.get("CPU Time"), this.gpuTime = this.stats.get("GPU Time"), this.frameRate = this.stats.get("Frame Rate"), this.setProps({ autoResizeViewport: e.autoResizeViewport }), this.start = this.start.bind(this), this.stop = this.stop.bind(this), this._onMousemove = this._onMousemove.bind(this), this._onMouseleave = this._onMouseleave.bind(this);
  }
  destroy() {
    this.stop(), this._setDisplay(null);
  }
  /** @deprecated Use .destroy() */
  delete() {
    this.destroy();
  }
  reportError(e) {
    this.props.onError(e), this._error = e;
  }
  /** Flags this animation loop as needing redraw */
  setNeedsRedraw(e) {
    return this.needsRedraw = this.needsRedraw || e, this;
  }
  setProps(e) {
    return "autoResizeViewport" in e && (this.props.autoResizeViewport = e.autoResizeViewport || !1), this;
  }
  /** Starts a render loop if not already running */
  async start() {
    if (this._running)
      return this;
    this._running = !0;
    try {
      let e;
      return this._initialized || (this._initialized = !0, await this._initDevice(), this._initialize(), await this.props.onInitialize(this._getAnimationProps())), this._running ? (e !== !1 && (this._cancelAnimationFrame(), this._requestAnimationFrame()), this) : null;
    } catch (e) {
      const t = e instanceof Error ? e : new Error("Unknown error");
      throw this.props.onError(t), t;
    }
  }
  /** Stops a render loop if already running, finalizing */
  stop() {
    return this._running && (this.animationProps && !this._error && this.props.onFinalize(this.animationProps), this._cancelAnimationFrame(), this._nextFramePromise = null, this._resolveNextFrame = null, this._running = !1), this;
  }
  /** Explicitly draw a frame */
  redraw() {
    return this.device?.isLost || this._error ? this : (this._beginFrameTimers(), this._setupFrame(), this._updateAnimationProps(), this._renderFrame(this._getAnimationProps()), this._clearNeedsRedraw(), this._resolveNextFrame && (this._resolveNextFrame(this), this._nextFramePromise = null, this._resolveNextFrame = null), this._endFrameTimers(), this);
  }
  /** Add a timeline, it will be automatically updated by the animation loop. */
  attachTimeline(e) {
    return this.timeline = e, this.timeline;
  }
  /** Remove a timeline */
  detachTimeline() {
    this.timeline = null;
  }
  /** Wait until a render completes */
  waitForRender() {
    return this.setNeedsRedraw("waitForRender"), this._nextFramePromise || (this._nextFramePromise = new Promise((e) => {
      this._resolveNextFrame = e;
    })), this._nextFramePromise;
  }
  /** TODO - should use device.deviceContext */
  async toDataURL() {
    if (this.setNeedsRedraw("toDataURL"), await this.waitForRender(), this.canvas instanceof HTMLCanvasElement)
      return this.canvas.toDataURL();
    throw new Error("OffscreenCanvas");
  }
  // PRIVATE METHODS
  _initialize() {
    this._startEventHandling(), this._initializeAnimationProps(), this._updateAnimationProps(), this._resizeViewport();
  }
  _setDisplay(e) {
    this.display && (this.display.destroy(), this.display.animationLoop = null), e && (e.animationLoop = this), this.display = e;
  }
  _requestAnimationFrame() {
    this._running && (this._animationFrameId = nW(this._animationFrame.bind(this)));
  }
  _cancelAnimationFrame() {
    this._animationFrameId !== null && (iW(this._animationFrameId), this._animationFrameId = null);
  }
  _animationFrame() {
    this._running && (this.redraw(), this._requestAnimationFrame());
  }
  // Called on each frame, can be overridden to call onRender multiple times
  // to support e.g. stereoscopic rendering
  _renderFrame(e) {
    if (this.display) {
      this.display._renderFrame(e);
      return;
    }
    this.props.onRender(this._getAnimationProps()), this.device?.submit();
  }
  _clearNeedsRedraw() {
    this.needsRedraw = !1;
  }
  _setupFrame() {
    this._resizeViewport();
  }
  // Initialize the  object that will be passed to app callbacks
  _initializeAnimationProps() {
    const e = this.device?.getDefaultCanvasContext();
    if (!this.device || !e)
      throw new Error("loop");
    const t = e?.canvas, n = e.props.useDevicePixels;
    this.animationProps = {
      animationLoop: this,
      device: this.device,
      canvasContext: e,
      canvas: t,
      // @ts-expect-error Deprecated
      useDevicePixels: n,
      timeline: this.timeline,
      needsRedraw: !1,
      // Placeholders
      width: 1,
      height: 1,
      aspect: 1,
      // Animation props
      time: 0,
      startTime: Date.now(),
      engineTime: 0,
      tick: 0,
      tock: 0,
      // Experimental
      _mousePosition: null
      // Event props
    };
  }
  _getAnimationProps() {
    if (!this.animationProps)
      throw new Error("animationProps");
    return this.animationProps;
  }
  // Update the context object that will be passed to app callbacks
  _updateAnimationProps() {
    if (!this.animationProps)
      return;
    const { width: e, height: t, aspect: n } = this._getSizeAndAspect();
    (e !== this.animationProps.width || t !== this.animationProps.height) && this.setNeedsRedraw("drawing buffer resized"), n !== this.animationProps.aspect && this.setNeedsRedraw("drawing buffer aspect changed"), this.animationProps.width = e, this.animationProps.height = t, this.animationProps.aspect = n, this.animationProps.needsRedraw = this.needsRedraw, this.animationProps.engineTime = Date.now() - this.animationProps.startTime, this.timeline && this.timeline.update(this.animationProps.engineTime), this.animationProps.tick = Math.floor(this.animationProps.time / 1e3 * 60), this.animationProps.tock++, this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;
  }
  /** Wait for supplied device */
  async _initDevice() {
    if (this.device = await this.props.device, !this.device)
      throw new Error("No device provided");
    this.canvas = this.device.getDefaultCanvasContext().canvas || null;
  }
  _createInfoDiv() {
    if (this.canvas && this.props.onAddHTML) {
      const e = document.createElement("div");
      document.body.appendChild(e), e.style.position = "relative";
      const t = document.createElement("div");
      t.style.position = "absolute", t.style.left = "10px", t.style.bottom = "10px", t.style.width = "300px", t.style.background = "white", this.canvas instanceof HTMLCanvasElement && e.appendChild(this.canvas), e.appendChild(t);
      const n = this.props.onAddHTML(t);
      n && (t.innerHTML = n);
    }
  }
  _getSizeAndAspect() {
    if (!this.device)
      return { width: 1, height: 1, aspect: 1 };
    const [e, t] = this.device?.getDefaultCanvasContext().getDevicePixelSize() || [1, 1];
    let n = 1;
    const i = this.device?.getDefaultCanvasContext().canvas;
    return i && i.clientHeight ? n = i.clientWidth / i.clientHeight : e > 0 && t > 0 && (n = e / t), { width: e, height: t, aspect: n };
  }
  /** @deprecated Default viewport setup */
  _resizeViewport() {
    this.props.autoResizeViewport && this.device.gl && this.device.gl.viewport(
      0,
      0,
      // @ts-expect-error Expose canvasContext
      this.device.gl.drawingBufferWidth,
      // @ts-expect-error Expose canvasContext
      this.device.gl.drawingBufferHeight
    );
  }
  _beginFrameTimers() {
    this.frameRate.timeEnd(), this.frameRate.timeStart(), this.cpuTime.timeStart();
  }
  _endFrameTimers() {
    this.cpuTime.timeEnd();
  }
  // Event handling
  _startEventHandling() {
    this.canvas && (this.canvas.addEventListener("mousemove", this._onMousemove.bind(this)), this.canvas.addEventListener("mouseleave", this._onMouseleave.bind(this)));
  }
  _onMousemove(e) {
    e instanceof MouseEvent && (this._getAnimationProps()._mousePosition = [e.offsetX, e.offsetY]);
  }
  _onMouseleave(e) {
    this._getAnimationProps()._mousePosition = null;
  }
}
const Fv = {};
function ru(r = "id") {
  Fv[r] = Fv[r] || 1;
  const e = Fv[r]++;
  return `${r}-${e}`;
}
class zC {
  id;
  userData = {};
  /** Determines how vertices are read from the 'vertex' attributes */
  topology;
  bufferLayout = [];
  vertexCount;
  indices;
  attributes;
  constructor(e) {
    if (this.id = e.id || ru("geometry"), this.topology = e.topology, this.indices = e.indices || null, this.attributes = e.attributes, this.vertexCount = e.vertexCount, this.bufferLayout = e.bufferLayout || [], this.indices && !(this.indices.usage & vi.INDEX))
      throw new Error("Index buffer must have INDEX usage");
  }
  destroy() {
    this.indices?.destroy();
    for (const e of Object.values(this.attributes))
      e.destroy();
  }
  getVertexCount() {
    return this.vertexCount;
  }
  getAttributes() {
    return this.attributes;
  }
  getIndexes() {
    return this.indices || null;
  }
  _calculateVertexCount(e) {
    return e.byteLength / 12;
  }
}
function oW(r, e) {
  if (e instanceof zC)
    return e;
  const t = aW(r, e), { attributes: n, bufferLayout: i } = lW(r, e);
  return new zC({
    topology: e.topology || "triangle-list",
    bufferLayout: i,
    vertexCount: e.vertexCount,
    indices: t,
    attributes: n
  });
}
function aW(r, e) {
  if (!e.indices)
    return;
  const t = e.indices.value;
  return r.createBuffer({ usage: vi.INDEX, data: t });
}
function lW(r, e) {
  const t = [], n = {};
  for (const [s, o] of Object.entries(e.attributes)) {
    let l = s;
    switch (s) {
      case "POSITION":
        l = "positions";
        break;
      case "NORMAL":
        l = "normals";
        break;
      case "TEXCOORD_0":
        l = "texCoords";
        break;
      case "COLOR_0":
        l = "colors";
        break;
    }
    if (o) {
      n[l] = r.createBuffer({
        data: o.value,
        id: `${s}-buffer`
      });
      const { value: u, size: m, normalized: y } = o;
      t.push({ name: l, format: _9(u, m, y) });
    }
  }
  const i = e._calculateVertexCount(e.attributes, e.indices);
  return { attributes: n, bufferLayout: t, vertexCount: i };
}
class Hx {
  static defaultProps = { ...Zf.defaultProps };
  /** Get the singleton default pipeline factory for the specified device */
  static getDefaultPipelineFactory(e) {
    return e._lumaData.defaultPipelineFactory = e._lumaData.defaultPipelineFactory || new Hx(e), e._lumaData.defaultPipelineFactory;
  }
  device;
  cachingEnabled;
  destroyPolicy;
  debug;
  _hashCounter = 0;
  _hashes = {};
  _renderPipelineCache = {};
  _computePipelineCache = {};
  get [Symbol.toStringTag]() {
    return "PipelineFactory";
  }
  toString() {
    return `PipelineFactory(${this.device.id})`;
  }
  constructor(e) {
    this.device = e, this.cachingEnabled = e.props._cachePipelines, this.destroyPolicy = e.props._cacheDestroyPolicy, this.debug = e.props.debugFactories;
  }
  /** Return a RenderPipeline matching supplied props. Reuses an equivalent pipeline if already created. */
  createRenderPipeline(e) {
    if (!this.cachingEnabled)
      return this.device.createRenderPipeline(e);
    const t = { ...Zf.defaultProps, ...e }, n = this._renderPipelineCache, i = this._hashRenderPipeline(t);
    let s = n[i]?.pipeline;
    return s ? (n[i].useCount++, this.debug && qt.warn(`${this}: ${n[i].pipeline} reused, count=${n[i].useCount}, (id=${e.id})`)()) : (s = this.device.createRenderPipeline({
      ...t,
      id: t.id ? `${t.id}-cached` : ru("unnamed-cached")
    }), s.hash = i, n[i] = { pipeline: s, useCount: 1 }, this.debug && qt.warn(`${this}: ${s} created, count=${n[i].useCount}`)()), s;
  }
  /** Return a ComputePipeline matching supplied props. Reuses an equivalent pipeline if already created. */
  createComputePipeline(e) {
    if (!this.cachingEnabled)
      return this.device.createComputePipeline(e);
    const t = { ...Xm.defaultProps, ...e }, n = this._computePipelineCache, i = this._hashComputePipeline(t);
    let s = n[i]?.pipeline;
    return s ? (n[i].useCount++, this.debug && qt.warn(`${this}: ${n[i].pipeline} reused, count=${n[i].useCount}, (id=${e.id})`)()) : (s = this.device.createComputePipeline({
      ...t,
      id: t.id ? `${t.id}-cached` : void 0
    }), s.hash = i, n[i] = { pipeline: s, useCount: 1 }, this.debug && qt.warn(`${this}: ${s} created, count=${n[i].useCount}`)()), s;
  }
  release(e) {
    if (!this.cachingEnabled) {
      e.destroy();
      return;
    }
    const t = this._getCache(e), n = e.hash;
    t[n].useCount--, t[n].useCount === 0 ? (this._destroyPipeline(e), this.debug && qt.warn(`${this}: ${e} released and destroyed`)()) : t[n].useCount < 0 ? (qt.error(`${this}: ${e} released, useCount < 0, resetting`)(), t[n].useCount = 0) : this.debug && qt.warn(`${this}: ${e} released, count=${t[n].useCount}`)();
  }
  // PRIVATE
  /** Destroy a cached pipeline, removing it from the cache (depending on destroy policy) */
  _destroyPipeline(e) {
    const t = this._getCache(e);
    switch (this.destroyPolicy) {
      case "never":
        return !1;
      case "unused":
        return delete t[e.hash], e.destroy(), !0;
    }
  }
  /** Get the appropriate cache for the type of pipeline */
  _getCache(e) {
    let t;
    if (e instanceof Xm && (t = this._computePipelineCache), e instanceof Zf && (t = this._renderPipelineCache), !t)
      throw new Error(`${this}`);
    if (!t[e.hash])
      throw new Error(`${this}: ${e} matched incorrect entry`);
    return t;
  }
  /** Calculate a hash based on all the inputs for a compute pipeline */
  _hashComputePipeline(e) {
    const { type: t } = this.device, n = this._getHash(e.shader.source);
    return `${t}/C/${n}`;
  }
  /** Calculate a hash based on all the inputs for a render pipeline */
  _hashRenderPipeline(e) {
    const t = e.vs ? this._getHash(e.vs.source) : 0, n = e.fs ? this._getHash(e.fs.source) : 0, i = "-", s = this._getHash(JSON.stringify(e.bufferLayout)), { type: o } = this.device;
    switch (o) {
      case "webgl":
        return `${o}/R/${t}/${n}V${i}BL${s}`;
      case "webgpu":
      default:
        const l = this._getHash(JSON.stringify(e.parameters));
        return `${o}/R/${t}/${n}V${i}T${e.topology}P${l}BL${s}`;
    }
  }
  _getHash(e) {
    return this._hashes[e] === void 0 && (this._hashes[e] = this._hashCounter++), this._hashes[e];
  }
}
class Gx {
  static defaultProps = { ...D_.defaultProps };
  /** Returns the default ShaderFactory for the given {@link Device}, creating one if necessary. */
  static getDefaultShaderFactory(e) {
    return e._lumaData.defaultShaderFactory ||= new Gx(e), e._lumaData.defaultShaderFactory;
  }
  device;
  cachingEnabled;
  destroyPolicy;
  debug;
  _cache = {};
  get [Symbol.toStringTag]() {
    return "ShaderFactory";
  }
  toString() {
    return `${this[Symbol.toStringTag]}(${this.device.id})`;
  }
  /** @internal */
  constructor(e) {
    this.device = e, this.cachingEnabled = e.props._cacheShaders, this.destroyPolicy = e.props._cacheDestroyPolicy, this.debug = !0;
  }
  /** Requests a {@link Shader} from the cache, creating a new Shader only if necessary. */
  createShader(e) {
    if (!this.cachingEnabled)
      return this.device.createShader(e);
    const t = this._hashShader(e);
    let n = this._cache[t];
    if (n)
      n.useCount++, this.debug && qt.warn(`${this}: Reusing shader ${n.shader.id} count=${n.useCount}`)();
    else {
      const i = this.device.createShader({
        ...e,
        id: e.id ? `${e.id}-cached` : void 0
      });
      this._cache[t] = n = { shader: i, useCount: 1 }, this.debug && qt.warn(`${this}: Created new shader ${i.id}`)();
    }
    return n.shader;
  }
  /** Releases a previously-requested {@link Shader}, destroying it if no users remain. */
  release(e) {
    if (!this.cachingEnabled) {
      e.destroy();
      return;
    }
    const t = this._hashShader(e), n = this._cache[t];
    if (n)
      if (n.useCount--, n.useCount === 0)
        this.destroyPolicy === "unused" && (delete this._cache[t], n.shader.destroy(), this.debug && qt.warn(`${this}: Releasing shader ${e.id}, destroyed`)());
      else {
        if (n.useCount < 0)
          throw new Error(`ShaderFactory: Shader ${e.id} released too many times`);
        this.debug && qt.warn(`${this}: Releasing shader ${e.id} count=${n.useCount}`)();
      }
  }
  // PRIVATE
  _hashShader(e) {
    return `${e.stage}:${e.source}`;
  }
}
function cW(r, e) {
  const t = {}, n = "Values";
  if (r.attributes.length === 0 && !r.varyings?.length)
    return { "No attributes or varyings": { [n]: "N/A" } };
  for (const i of r.attributes)
    if (i) {
      const s = `${i.location} ${i.name}: ${i.type}`;
      t[`in ${s}`] = { [n]: i.stepMode || "vertex" };
    }
  for (const i of r.varyings || []) {
    const s = `${i.location} ${i.name}`;
    t[`out ${s}`] = { [n]: JSON.stringify(i) };
  }
  return t;
}
let Hs = null, Nv = null;
function uW(r, { id: e, minimap: t, opaque: n, top: i = "0", left: s = "0", rgbaScale: o = 1 }) {
  Hs || (Hs = document.createElement("canvas"), Hs.id = e, Hs.title = e, Hs.style.zIndex = "100", Hs.style.position = "absolute", Hs.style.top = i, Hs.style.left = s, Hs.style.border = "blue 5px solid", Hs.style.transform = "scaleY(-1)", document.body.appendChild(Hs), Nv = Hs.getContext("2d")), (Hs.width !== r.width || Hs.height !== r.height) && (Hs.width = r.width / 2, Hs.height = r.height / 2, Hs.style.width = "400px", Hs.style.height = "400px");
  const l = r.device.readPixelsToArrayWebGL(r), u = Nv?.createImageData(r.width, r.height);
  if (u) {
    for (let y = 0; y < l.length; y += 4)
      u.data[0 + y + 0] = l[y + 0] * o, u.data[0 + y + 1] = l[y + 1] * o, u.data[0 + y + 2] = l[y + 2] * o, u.data[0 + y + 3] = n ? 255 : l[y + 3] * o;
    Nv?.putImageData(u, 0, 0);
  }
}
function Vb(r, e, t) {
  if (r === e)
    return !0;
  if (!t || !r || !e)
    return !1;
  if (Array.isArray(r)) {
    if (!Array.isArray(e) || r.length !== e.length)
      return !1;
    for (let n = 0; n < r.length; n++)
      if (!Vb(r[n], e[n], t - 1))
        return !1;
    return !0;
  }
  if (Array.isArray(e))
    return !1;
  if (typeof r == "object" && typeof e == "object") {
    const n = Object.keys(r), i = Object.keys(e);
    if (n.length !== i.length)
      return !1;
    for (const s of n)
      if (!e.hasOwnProperty(s) || !Vb(r[s], e[s], t - 1))
        return !1;
    return !0;
  }
  return !1;
}
class Uv {
  bufferLayouts;
  constructor(e) {
    this.bufferLayouts = e;
  }
  getBufferLayout(e) {
    return this.bufferLayouts.find((t) => t.name === e) || null;
  }
  /** Get attribute names from a BufferLayout */
  getAttributeNamesForBuffer(e) {
    return e.attributes ? e.attributes?.map((t) => t.attribute) : [e.name];
  }
  mergeBufferLayouts(e, t) {
    const n = [...e];
    for (const i of t) {
      const s = n.findIndex((o) => o.name === i.name);
      s < 0 ? n.push(i) : n[s] = i;
    }
    return n;
  }
  getBufferIndex(e) {
    const t = this.bufferLayouts.findIndex((n) => n.name === e);
    return t === -1 && qt.warn(`BufferLayout: Missing buffer for "${e}".`)(), t;
  }
}
function fW(r, e) {
  const t = Object.fromEntries(r.attributes.map((i) => [i.name, i.location])), n = e.slice();
  return n.sort((i, s) => {
    const o = i.attributes ? i.attributes.map((y) => y.attribute) : [i.name], l = s.attributes ? s.attributes.map((y) => y.attribute) : [s.name], u = Math.min(...o.map((y) => t[y])), m = Math.min(...l.map((y) => t[y]));
    return u - m;
  }), n;
}
function hW(r) {
  return ArrayBuffer.isView(r) && !(r instanceof DataView);
}
function dW(r) {
  return Array.isArray(r) ? r.length === 0 || typeof r[0] == "number" : !1;
}
function pW(r) {
  return hW(r) || dW(r);
}
function AW(r) {
  return pW(r) || typeof r == "number" || typeof r == "boolean";
}
function gW(r) {
  const e = { bindings: {}, uniforms: {} };
  return Object.keys(r).forEach((t) => {
    const n = r[t];
    AW(n) ? e.uniforms[t] = n : e.bindings[t] = n;
  }), e;
}
class mW {
  options = {
    disableWarnings: !1
  };
  /**
   * The map of modules
   * @todo should should this include the resolved dependencies?
   */
  // @ts-ignore Fix typings
  modules;
  /** Stores the uniform values for each module */
  moduleUniforms;
  /** Stores the uniform bindings for each module  */
  moduleBindings;
  /** Tracks if uniforms have changed */
  // moduleUniformsChanged: Record<keyof ShaderPropsT, false | string>;
  /**
   * Create a new UniformStore instance
   * @param modules
   */
  constructor(e, t) {
    Object.assign(this.options, t);
    const n = lx(Object.values(e).filter((i) => i.dependencies));
    for (const i of n)
      e[i.name] = i;
    qt.log(1, "Creating ShaderInputs with modules", Object.keys(e))(), this.modules = e, this.moduleUniforms = {}, this.moduleBindings = {};
    for (const [i, s] of Object.entries(e))
      this._addModule(s), s.name && i !== s.name && !this.options.disableWarnings && qt.warn(`Module name: ${i} vs ${s.name}`)();
  }
  /** Destroy */
  destroy() {
  }
  /**
   * Set module props
   */
  setProps(e) {
    for (const t of Object.keys(e)) {
      const n = t, i = e[n] || {}, s = this.modules[n];
      if (!s) {
        this.options.disableWarnings || qt.warn(`Module ${t} not found`)();
        continue;
      }
      const o = this.moduleUniforms[n], l = this.moduleBindings[n], u = s.getUniforms?.(i, o) || i, { uniforms: m, bindings: y } = gW(u);
      this.moduleUniforms[n] = { ...o, ...m }, this.moduleBindings[n] = { ...l, ...y };
    }
  }
  /**
   * Return the map of modules
   * @todo should should this include the resolved dependencies?
   */
  getModules() {
    return Object.values(this.modules);
  }
  /** Get all uniform values for all modules */
  getUniformValues() {
    return this.moduleUniforms;
  }
  /** Merges all bindings for the shader (from the various modules) */
  getBindingValues() {
    const e = {};
    for (const t of Object.values(this.moduleBindings))
      Object.assign(e, t);
    return e;
  }
  // INTERNAL
  /** Return a debug table that can be used for console.table() or log.table() */
  getDebugTable() {
    const e = {};
    for (const [t, n] of Object.entries(this.moduleUniforms))
      for (const [i, s] of Object.entries(n))
        e[`${t}.${i}`] = {
          type: this.modules[t].uniformTypes?.[i],
          value: String(s)
        };
    return e;
  }
  _addModule(e) {
    const t = e.name;
    this.moduleUniforms[t] = e.defaultUniforms || {}, this.moduleBindings[t] = {};
  }
}
let _W = "";
async function yW(r, e) {
  const t = new Image();
  return t.crossOrigin = "anonymous", t.src = r.startsWith("http") ? r : _W + r, await t.decode(), e ? await createImageBitmap(t, e) : await createImageBitmap(t);
}
const vW = ["+X", "-X", "+Y", "-Y", "+Z", "-Z"], bW = ["+X", "-X", "+Y", "-Y", "+Z", "-Z"];
class HA {
  device;
  id;
  props;
  // TODO - should we type these as possibly `null`? It will make usage harder?
  // @ts-expect-error
  texture;
  // @ts-expect-error
  sampler;
  // @ts-expect-error
  view;
  ready;
  isReady = !1;
  destroyed = !1;
  resolveReady = () => {
  };
  rejectReady = () => {
  };
  get [Symbol.toStringTag]() {
    return "AsyncTexture";
  }
  toString() {
    return `AsyncTexture:"${this.id}"(${this.isReady ? "ready" : "loading"})`;
  }
  constructor(e, t) {
    this.device = e;
    const n = ru("async-texture");
    this.props = { ...HA.defaultProps, id: n, ...t }, this.id = this.props.id, t = { ...t }, typeof t?.data == "string" && t.dimension === "2d" && (t.data = yW(t.data)), t.mipmaps && (t.mipLevels = "auto"), this.ready = new Promise((i, s) => {
      this.resolveReady = () => {
        this.isReady = !0, i();
      }, this.rejectReady = s;
    }), this.initAsync(t);
  }
  async initAsync(e) {
    const t = e.data, n = await r6(t).then(void 0, this.rejectReady);
    if (this.destroyed)
      return;
    const i = this.props.width && this.props.height ? { width: this.props.width, height: this.props.height } : this.getTextureDataSize(n);
    if (!i)
      throw new Error("Texture size could not be determined");
    const s = { ...i, ...e, data: void 0, mipLevels: 1 }, o = this.device.getMipLevelCount(s.width, s.height);
    if (s.mipLevels = this.props.mipLevels === "auto" ? o : Math.min(o, this.props.mipLevels), this.texture = this.device.createTexture(s), this.sampler = this.texture.sampler, this.view = this.texture.view, e.data)
      switch (this.props.dimension) {
        case "1d":
          this._setTexture1DData(this.texture, n);
          break;
        case "2d":
          this._setTexture2DData(n);
          break;
        case "3d":
          this._setTexture3DData(this.texture, n);
          break;
        case "2d-array":
          this._setTextureArrayData(this.texture, n);
          break;
        case "cube":
          this._setTextureCubeData(this.texture, n);
          break;
        case "cube-array":
          this._setTextureCubeArrayData(this.texture, n);
          break;
      }
    this.props.mipmaps && this.generateMipmaps(), qt.info(1, `${this} loaded`), this.resolveReady();
  }
  destroy() {
    this.texture && (this.texture.destroy(), this.texture = null), this.destroyed = !0;
  }
  generateMipmaps() {
    this.texture.generateMipmapsWebGL();
  }
  /** Set sampler or create and set new Sampler from SamplerProps */
  setSampler(e = {}) {
    this.texture.setSampler(e instanceof th ? e : this.device.createSampler(e));
  }
  /**
   * Textures are immutable and cannot be resized after creation,
   * but we can create a similar texture with the same parameters but a new size.
   * @note Does not copy contents of the texture
   * @note Mipmaps may need to be regenerated after resizing / setting new data
   * @todo Abort pending promise and create a texture with the new size?
   */
  resize(e) {
    if (!this.isReady)
      throw new Error("Cannot resize texture before it is ready");
    if (e.width === this.texture.width && e.height === this.texture.height)
      return !1;
    if (this.texture) {
      const t = this.texture;
      this.texture = t.clone(e), t.destroy();
    }
    return !0;
  }
  /** Check if texture data is a typed array */
  isTextureLevelData(e) {
    const t = e?.data;
    return ArrayBuffer.isView(t);
  }
  /** Get the size of the texture described by the provided TextureData */
  getTextureDataSize(e) {
    if (!e || ArrayBuffer.isView(e))
      return null;
    if (Array.isArray(e))
      return this.getTextureDataSize(e[0]);
    if (this.device.isExternalImage(e))
      return this.device.getExternalImageSize(e);
    if (e && typeof e == "object" && e.constructor === Object) {
      const n = Object.values(e)[0];
      return { width: n.width, height: n.height };
    }
    throw new Error("texture size deduction failed");
  }
  /** Convert luma.gl cubemap face constants to depth index */
  getCubeFaceDepth(e) {
    switch (e) {
      case "+X":
        return 0;
      case "-X":
        return 1;
      case "+Y":
        return 2;
      case "-Y":
        return 3;
      case "+Z":
        return 4;
      case "-Z":
        return 5;
      default:
        throw new Error(e);
    }
  }
  // EXPERIMENTAL
  setTextureData(e) {
  }
  /** Experimental: Set multiple mip levels */
  _setTexture1DData(e, t) {
    throw new Error("setTexture1DData not supported in WebGL.");
  }
  /** Experimental: Set multiple mip levels */
  _setTexture2DData(e, t = 0) {
    if (!this.texture)
      throw new Error("Texture not initialized");
    const n = this._normalizeTextureData(e);
    n.length > 1 && this.props.mipmaps !== !1 && qt.warn(`Texture ${this.id} mipmap and multiple LODs.`)();
    for (let i = 0; i < n.length; i++) {
      const s = n[i];
      this.device.isExternalImage(s) ? this.texture.copyExternalImage({ image: s, depth: t, mipLevel: i, flipY: !0 }) : this.texture.copyImageData({ data: s.data, mipLevel: i });
    }
  }
  /**
   * Experimental: Sets 3D texture data: multiple depth slices, multiple mip levels
   * @param data
   */
  _setTexture3DData(e, t) {
    if (this.texture?.props.dimension !== "3d")
      throw new Error(this.id);
    for (let n = 0; n < t.length; n++)
      this._setTexture2DData(t[n], n);
  }
  /**
   * Experimental: Set Cube texture data, multiple faces, multiple mip levels
   * @todo - could support TextureCubeArray with depth
   * @param data
   * @param index
   */
  _setTextureCubeData(e, t) {
    if (this.texture?.props.dimension !== "cube")
      throw new Error(this.id);
    for (const [n, i] of Object.entries(t)) {
      const s = bW.indexOf(n);
      this._setTexture2DData(i, s);
    }
  }
  /**
   * Experimental: Sets texture array data, multiple levels, multiple depth slices
   * @param data
   */
  _setTextureArrayData(e, t) {
    if (this.texture?.props.dimension !== "2d-array")
      throw new Error(this.id);
    for (let n = 0; n < t.length; n++)
      this._setTexture2DData(t[n], n);
  }
  /**
   * Experimental: Sets texture cube array, multiple faces, multiple levels, multiple mip levels
   * @param data
   */
  _setTextureCubeArrayData(e, t) {
    throw new Error("setTextureCubeArrayData not supported in WebGL2.");
  }
  /** Experimental */
  _setTextureCubeFaceData(e, t, n, i = 0) {
    Array.isArray(t) && t.length > 1 && this.props.mipmaps !== !1 && qt.warn(`${this.id} has mipmap and multiple LODs.`)();
    const s = vW.indexOf(n);
    this._setTexture2DData(t, s);
  }
  /**
   * Normalize TextureData to an array of TextureImageData / ExternalImages
   * @param data
   * @param options
   * @returns array of TextureImageData / ExternalImages
   */
  _normalizeTextureData(e) {
    const t = this.texture;
    let n;
    return ArrayBuffer.isView(e) ? n = [
      {
        // ts-expect-error does data really need to be Uint8ClampedArray?
        data: e,
        width: t.width,
        height: t.height
        // depth: options.depth
      }
    ] : Array.isArray(e) ? n = e : n = [e], n;
  }
  static defaultProps = {
    ...ps.defaultProps,
    data: null,
    mipmaps: !1
  };
}
async function r6(r) {
  if (r = await r, Array.isArray(r))
    return await Promise.all(r.map(r6));
  if (r && typeof r == "object" && r.constructor === Object) {
    const e = r, t = await Promise.all(Object.values(e)), n = Object.keys(e), i = {};
    for (let s = 0; s < n.length; s++)
      i[n[s]] = t[s];
    return i;
  }
  return r;
}
const Df = 2, xW = 1e4;
class Bi {
  static defaultProps = {
    ...Zf.defaultProps,
    source: void 0,
    vs: null,
    fs: null,
    id: "unnamed",
    handle: void 0,
    userData: {},
    defines: {},
    modules: [],
    geometry: null,
    indexBuffer: null,
    attributes: {},
    constantAttributes: {},
    varyings: [],
    isInstanced: void 0,
    instanceCount: 0,
    vertexCount: 0,
    shaderInputs: void 0,
    pipelineFactory: void 0,
    shaderFactory: void 0,
    transformFeedback: void 0,
    shaderAssembler: Hf.getDefaultShaderAssembler(),
    debugShaders: void 0,
    disableWarnings: void 0
  };
  device;
  id;
  // @ts-expect-error assigned in function called from constructor
  source;
  // @ts-expect-error assigned in function called from constructor
  vs;
  // @ts-expect-error assigned in function called from constructor
  fs;
  pipelineFactory;
  shaderFactory;
  userData = {};
  // Fixed properties (change can trigger pipeline rebuild)
  /** The render pipeline GPU parameters, depth testing etc */
  parameters;
  /** The primitive topology */
  topology;
  /** Buffer layout */
  bufferLayout;
  // Dynamic properties
  /** Use instanced rendering */
  isInstanced = void 0;
  /** instance count. `undefined` means not instanced */
  instanceCount = 0;
  /** Vertex count */
  vertexCount;
  /** Index buffer */
  indexBuffer = null;
  /** Buffer-valued attributes */
  bufferAttributes = {};
  /** Constant-valued attributes */
  constantAttributes = {};
  /** Bindings (textures, samplers, uniform buffers) */
  bindings = {};
  /**
   * VertexArray
   * @note not implemented: if bufferLayout is updated, vertex array has to be rebuilt!
   * @todo - allow application to define multiple vertex arrays?
   * */
  vertexArray;
  /** TransformFeedback, WebGL 2 only. */
  transformFeedback = null;
  /** The underlying GPU "program". @note May be recreated if parameters change */
  pipeline;
  /** ShaderInputs instance */
  // @ts-expect-error Assigned in function called by constructor
  shaderInputs;
  // @ts-expect-error Assigned in function called by constructor
  _uniformStore;
  _attributeInfos = {};
  _gpuGeometry = null;
  props;
  _pipelineNeedsUpdate = "newly created";
  _needsRedraw = "initializing";
  _destroyed = !1;
  /** "Time" of last draw. Monotonically increasing timestamp */
  _lastDrawTimestamp = -1;
  get [Symbol.toStringTag]() {
    return "Model";
  }
  toString() {
    return `Model(${this.id})`;
  }
  constructor(e, t) {
    this.props = { ...Bi.defaultProps, ...t }, t = this.props, this.id = t.id || ru("model"), this.device = e, Object.assign(this.userData, t.userData);
    const n = Object.fromEntries(this.props.modules?.map((u) => [u.name, u]) || []), i = t.shaderInputs || new mW(n, { disableWarnings: this.props.disableWarnings });
    this.setShaderInputs(i);
    const s = TW(e), o = (
      // @ts-ignore shaderInputs is assigned in setShaderInputs above.
      (this.props.modules?.length > 0 ? this.props.modules : this.shaderInputs?.getModules()) || []
    );
    if (this.device.type === "webgpu" && this.props.source) {
      const { source: u, getUniforms: m } = this.props.shaderAssembler.assembleWGSLShader({
        platformInfo: s,
        ...this.props,
        modules: o
      });
      this.source = u, this._getModuleUniforms = m, this.props.shaderLayout ||= W7(this.source);
    } else {
      const { vs: u, fs: m, getUniforms: y } = this.props.shaderAssembler.assembleGLSLShaderPair({
        platformInfo: s,
        ...this.props,
        modules: o
      });
      this.vs = u, this.fs = m, this._getModuleUniforms = y;
    }
    this.vertexCount = this.props.vertexCount, this.instanceCount = this.props.instanceCount, this.topology = this.props.topology, this.bufferLayout = this.props.bufferLayout, this.parameters = this.props.parameters, t.geometry && this.setGeometry(t.geometry), this.pipelineFactory = t.pipelineFactory || Hx.getDefaultPipelineFactory(this.device), this.shaderFactory = t.shaderFactory || Gx.getDefaultShaderFactory(this.device), this.pipeline = this._updatePipeline(), this.vertexArray = e.createVertexArray({
      shaderLayout: this.pipeline.shaderLayout,
      bufferLayout: this.pipeline.bufferLayout
    }), this._gpuGeometry && this._setGeometryAttributes(this._gpuGeometry), "isInstanced" in t && (this.isInstanced = t.isInstanced), t.instanceCount && this.setInstanceCount(t.instanceCount), t.vertexCount && this.setVertexCount(t.vertexCount), t.indexBuffer && this.setIndexBuffer(t.indexBuffer), t.attributes && this.setAttributes(t.attributes), t.constantAttributes && this.setConstantAttributes(t.constantAttributes), t.bindings && this.setBindings(t.bindings), t.transformFeedback && (this.transformFeedback = t.transformFeedback), Object.seal(this);
  }
  destroy() {
    this._destroyed || (this.pipelineFactory.release(this.pipeline), this.shaderFactory.release(this.pipeline.vs), this.pipeline.fs && this.shaderFactory.release(this.pipeline.fs), this._uniformStore.destroy(), this._gpuGeometry?.destroy(), this._destroyed = !0);
  }
  // Draw call
  /** Query redraw status. Clears the status. */
  needsRedraw() {
    this._getBindingsUpdateTimestamp() > this._lastDrawTimestamp && this.setNeedsRedraw("contents of bound textures or buffers updated");
    const e = this._needsRedraw;
    return this._needsRedraw = !1, e;
  }
  /** Mark the model as needing a redraw */
  setNeedsRedraw(e) {
    this._needsRedraw ||= e;
  }
  predraw() {
    this.updateShaderInputs(), this.pipeline = this._updatePipeline();
  }
  draw(e) {
    const t = this._areBindingsLoading();
    if (t)
      return qt.info(Df, `>>> DRAWING ABORTED ${this.id}: ${t} not loaded`)(), !1;
    try {
      e.pushDebugGroup(`${this}.predraw(${e})`), this.predraw();
    } finally {
      e.popDebugGroup();
    }
    let n;
    try {
      e.pushDebugGroup(`${this}.draw(${e})`), this._logDrawCallStart(), this.pipeline = this._updatePipeline();
      const i = this._getBindings();
      this.pipeline.setBindings(i, {
        disableWarnings: this.props.disableWarnings
      });
      const { indexBuffer: s } = this.vertexArray, o = s ? s.byteLength / (s.indexType === "uint32" ? 4 : 2) : void 0;
      n = this.pipeline.draw({
        renderPass: e,
        vertexArray: this.vertexArray,
        isInstanced: this.isInstanced,
        vertexCount: this.vertexCount,
        instanceCount: this.instanceCount,
        indexCount: o,
        transformFeedback: this.transformFeedback || void 0,
        // WebGL shares underlying cached pipelines even for models that have different parameters and topology,
        // so we must provide our unique parameters to each draw
        // (In WebGPU most parameters are encoded in the pipeline and cannot be changed per draw call)
        parameters: this.parameters,
        topology: this.topology
      });
    } finally {
      e.popDebugGroup(), this._logDrawCallEnd();
    }
    return this._logFramebuffer(e), n ? (this._lastDrawTimestamp = this.device.timestamp, this._needsRedraw = !1) : this._needsRedraw = "waiting for resource initialization", n;
  }
  // Update fixed fields (can trigger pipeline rebuild)
  /**
   * Updates the optional geometry
   * Geometry, set topology and bufferLayout
   * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU
   */
  setGeometry(e) {
    this._gpuGeometry?.destroy();
    const t = e && oW(this.device, e);
    if (t) {
      this.setTopology(t.topology || "triangle-list");
      const n = new Uv(this.bufferLayout);
      this.bufferLayout = n.mergeBufferLayouts(t.bufferLayout, this.bufferLayout), this.vertexArray && this._setGeometryAttributes(t);
    }
    this._gpuGeometry = t;
  }
  /**
   * Updates the primitive topology ('triangle-list', 'triangle-strip' etc).
   * @note Triggers a pipeline rebuild / pipeline cache fetch on WebGPU
   */
  setTopology(e) {
    e !== this.topology && (this.topology = e, this._setPipelineNeedsUpdate("topology"));
  }
  /**
   * Updates the buffer layout.
   * @note Triggers a pipeline rebuild / pipeline cache fetch
   */
  setBufferLayout(e) {
    const t = new Uv(this.bufferLayout);
    this.bufferLayout = this._gpuGeometry ? t.mergeBufferLayouts(e, this._gpuGeometry.bufferLayout) : e, this._setPipelineNeedsUpdate("bufferLayout"), this.pipeline = this._updatePipeline(), this.vertexArray = this.device.createVertexArray({
      shaderLayout: this.pipeline.shaderLayout,
      bufferLayout: this.pipeline.bufferLayout
    }), this._gpuGeometry && this._setGeometryAttributes(this._gpuGeometry);
  }
  /**
   * Set GPU parameters.
   * @note Can trigger a pipeline rebuild / pipeline cache fetch.
   * @param parameters
   */
  setParameters(e) {
    Vb(e, this.parameters, 2) || (this.parameters = e, this._setPipelineNeedsUpdate("parameters"));
  }
  // Update dynamic fields
  /**
   * Updates the instance count (used in draw calls)
   * @note Any attributes with stepMode=instance need to be at least this big
   */
  setInstanceCount(e) {
    this.instanceCount = e, this.isInstanced === void 0 && e > 0 && (this.isInstanced = !0), this.setNeedsRedraw("instanceCount");
  }
  /**
   * Updates the vertex count (used in draw calls)
   * @note Any attributes with stepMode=vertex need to be at least this big
   */
  setVertexCount(e) {
    this.vertexCount = e, this.setNeedsRedraw("vertexCount");
  }
  /** Set the shader inputs */
  setShaderInputs(e) {
    this.shaderInputs = e, this._uniformStore = new A7(this.shaderInputs.modules);
    for (const [t, n] of Object.entries(this.shaderInputs.modules))
      if (wW(n)) {
        const i = this._uniformStore.getManagedUniformBuffer(this.device, t);
        this.bindings[`${t}Uniforms`] = i;
      }
    this.setNeedsRedraw("shaderInputs");
  }
  /** Update uniform buffers from the model's shader inputs */
  updateShaderInputs() {
    this._uniformStore.setUniforms(this.shaderInputs.getUniformValues()), this.setBindings(this.shaderInputs.getBindingValues()), this.setNeedsRedraw("shaderInputs");
  }
  /**
   * Sets bindings (textures, samplers, uniform buffers)
   */
  setBindings(e) {
    Object.assign(this.bindings, e), this.setNeedsRedraw("bindings");
  }
  /**
   * Updates optional transform feedback. WebGL only.
   */
  setTransformFeedback(e) {
    this.transformFeedback = e, this.setNeedsRedraw("transformFeedback");
  }
  /**
   * Sets the index buffer
   * @todo - how to unset it if we change geometry?
   */
  setIndexBuffer(e) {
    this.vertexArray.setIndexBuffer(e), this.setNeedsRedraw("indexBuffer");
  }
  /**
   * Sets attributes (buffers)
   * @note Overrides any attributes previously set with the same name
   */
  setAttributes(e, t) {
    const n = t?.disableWarnings ?? this.props.disableWarnings;
    e.indices && qt.warn(`Model:${this.id} setAttributes() - indexBuffer should be set using setIndexBuffer()`)(), this.bufferLayout = fW(this.pipeline.shaderLayout, this.bufferLayout);
    const i = new Uv(this.bufferLayout);
    for (const [s, o] of Object.entries(e)) {
      const l = i.getBufferLayout(s);
      if (!l) {
        n || qt.warn(`Model(${this.id}): Missing layout for buffer "${s}".`)();
        continue;
      }
      const u = i.getAttributeNamesForBuffer(l);
      let m = !1;
      for (const y of u) {
        const E = this._attributeInfos[y];
        if (E) {
          const P = this.device.type === "webgpu" ? i.getBufferIndex(E.bufferName) : E.location;
          this.vertexArray.setBuffer(P, o), m = !0;
        }
      }
      !m && !n && qt.warn(`Model(${this.id}): Ignoring buffer "${o.id}" for unknown attribute "${s}"`)();
    }
    this.setNeedsRedraw("attributes");
  }
  /**
   * Sets constant attributes
   * @note Overrides any attributes previously set with the same name
   * Constant attributes are only supported in WebGL, not in WebGPU
   * Any attribute that is disabled in the current vertex array object
   * is read from the context's global constant value for that attribute location.
   * @param constantAttributes
   */
  setConstantAttributes(e, t) {
    for (const [n, i] of Object.entries(e)) {
      const s = this._attributeInfos[n];
      s ? this.vertexArray.setConstantWebGL(s.location, i) : (t?.disableWarnings ?? this.props.disableWarnings) || qt.warn(`Model "${this.id}: Ignoring constant supplied for unknown attribute "${n}"`)();
    }
    this.setNeedsRedraw("constants");
  }
  // INTERNAL METHODS
  /** Check that bindings are loaded. Returns id of first binding that is still loading. */
  _areBindingsLoading() {
    for (const e of Object.values(this.bindings))
      if (e instanceof HA && !e.isReady)
        return e.id;
    return !1;
  }
  /** Extracts texture view from loaded async textures. Returns null if any textures have not yet been loaded. */
  _getBindings() {
    const e = {};
    for (const [t, n] of Object.entries(this.bindings))
      n instanceof HA ? n.isReady && (e[t] = n.texture) : e[t] = n;
    return e;
  }
  /** Get the timestamp of the latest updated bound GPU memory resource (buffer/texture). */
  _getBindingsUpdateTimestamp() {
    let e = 0;
    for (const t of Object.values(this.bindings))
      t instanceof O_ ? e = Math.max(e, t.texture.updateTimestamp) : t instanceof vi || t instanceof ps ? e = Math.max(e, t.updateTimestamp) : t instanceof HA ? e = t.texture ? Math.max(e, t.texture.updateTimestamp) : (
        // The texture will become available in the future
        1 / 0
      ) : t instanceof th || (e = Math.max(e, t.buffer.updateTimestamp));
    return e;
  }
  /**
   * Updates the optional geometry attributes
   * Geometry, sets several attributes, indexBuffer, and also vertex count
   * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU
   */
  _setGeometryAttributes(e) {
    const t = { ...e.attributes };
    for (const [n] of Object.entries(t))
      !this.pipeline.shaderLayout.attributes.find((i) => i.name === n) && n !== "positions" && delete t[n];
    this.vertexCount = e.vertexCount, this.setIndexBuffer(e.indices || null), this.setAttributes(e.attributes, { disableWarnings: !0 }), this.setAttributes(t, { disableWarnings: this.props.disableWarnings }), this.setNeedsRedraw("geometry attributes");
  }
  /** Mark pipeline as needing update */
  _setPipelineNeedsUpdate(e) {
    this._pipelineNeedsUpdate ||= e, this.setNeedsRedraw(e);
  }
  /** Update pipeline if needed */
  _updatePipeline() {
    if (this._pipelineNeedsUpdate) {
      let e = null, t = null;
      this.pipeline && (qt.log(1, `Model ${this.id}: Recreating pipeline because "${this._pipelineNeedsUpdate}".`)(), e = this.pipeline.vs, t = this.pipeline.fs), this._pipelineNeedsUpdate = !1;
      const n = this.shaderFactory.createShader({
        id: `${this.id}-vertex`,
        stage: "vertex",
        source: this.source || this.vs,
        debugShaders: this.props.debugShaders
      });
      let i = null;
      this.source ? i = n : this.fs && (i = this.shaderFactory.createShader({
        id: `${this.id}-fragment`,
        stage: "fragment",
        source: this.source || this.fs,
        debugShaders: this.props.debugShaders
      })), this.pipeline = this.pipelineFactory.createRenderPipeline({
        ...this.props,
        bufferLayout: this.bufferLayout,
        topology: this.topology,
        parameters: this.parameters,
        // TODO - why set bindings here when we reset them every frame?
        // Should we expose a BindGroup abstraction?
        bindings: this._getBindings(),
        vs: n,
        fs: i
      }), this._attributeInfos = HB(this.pipeline.shaderLayout, this.bufferLayout), e && this.shaderFactory.release(e), t && this.shaderFactory.release(t);
    }
    return this.pipeline;
  }
  /** Throttle draw call logging */
  _lastLogTime = 0;
  _logOpen = !1;
  _logDrawCallStart() {
    const e = qt.level > 3 ? 0 : xW;
    qt.level < 2 || Date.now() - this._lastLogTime < e || (this._lastLogTime = Date.now(), this._logOpen = !0, qt.group(Df, `>>> DRAWING MODEL ${this.id}`, { collapsed: qt.level <= 2 })());
  }
  _logDrawCallEnd() {
    if (this._logOpen) {
      const e = cW(this.pipeline.shaderLayout, this.id);
      qt.table(Df, e)();
      const t = this.shaderInputs.getDebugTable();
      qt.table(Df, t)();
      const n = this._getAttributeDebugTable();
      qt.table(Df, this._attributeInfos)(), qt.table(Df, n)(), qt.groupEnd(Df)(), this._logOpen = !1;
    }
  }
  _drawCount = 0;
  _logFramebuffer(e) {
    const t = this.device.props.debugFramebuffers;
    if (this._drawCount++, !t)
      return;
    const n = e.props.framebuffer;
    n && uW(n, { id: n.id, minimap: !0 });
  }
  _getAttributeDebugTable() {
    const e = {};
    for (const [t, n] of Object.entries(this._attributeInfos)) {
      const i = this.vertexArray.attributes[n.location];
      e[n.location] = {
        name: t,
        type: n.shaderType,
        values: i ? this._getBufferOrConstantValues(i, n.bufferDataType) : "null"
      };
    }
    if (this.vertexArray.indexBuffer) {
      const { indexBuffer: t } = this.vertexArray, n = t.indexType === "uint32" ? new Uint32Array(t.debugData) : new Uint16Array(t.debugData);
      e.indices = {
        name: "indices",
        type: t.indexType,
        values: n.toString()
      };
    }
    return e;
  }
  // TODO - fix typing of luma data types
  _getBufferOrConstantValues(e, t) {
    const n = ux(t);
    return (e instanceof vi ? new n(e.debugData) : e).toString();
  }
}
function wW(r) {
  return !!(r.uniformTypes && !EW(r.uniformTypes));
}
function TW(r) {
  return {
    type: r.type,
    shaderLanguage: r.info.shadingLanguage,
    shaderLanguageVersion: r.info.shadingLanguageVersion,
    gpu: r.info.gpu,
    // HACK - we pretend that the DeviceFeatures is a Set, it has a similar API
    features: r.features
  };
}
function EW(r) {
  for (const e in r)
    return !1;
  return !0;
}
class ih {
  device;
  model;
  transformFeedback;
  static defaultProps = {
    ...Bi.defaultProps,
    outputs: void 0,
    feedbackBuffers: void 0
  };
  static isSupported(e) {
    return e?.info?.type === "webgl";
  }
  constructor(e, t = ih.defaultProps) {
    if (!ih.isSupported(e))
      throw new Error("BufferTransform not yet implemented on WebGPU");
    this.device = e, this.model = new Bi(this.device, {
      id: t.id || "buffer-transform-model",
      fs: t.fs || FB(),
      topology: t.topology || "point-list",
      varyings: t.outputs || t.varyings,
      ...t
    }), this.transformFeedback = this.device.createTransformFeedback({
      layout: this.model.pipeline.shaderLayout,
      // @ts-expect-error TODO
      buffers: t.feedbackBuffers
    }), this.model.setTransformFeedback(this.transformFeedback), Object.seal(this);
  }
  /** Destroy owned resources. */
  destroy() {
    this.model && this.model.destroy();
  }
  /** @deprecated Use {@link destroy}. */
  delete() {
    this.destroy();
  }
  /** Run one transform loop. */
  run(e) {
    e?.inputBuffers && this.model.setAttributes(e.inputBuffers), e?.outputBuffers && this.transformFeedback.setBuffers(e.outputBuffers);
    const t = this.device.beginRenderPass(e);
    this.model.draw(t), t.end();
  }
  // DEPRECATED METHODS
  /** @deprecated App knows what buffers it is passing in - Returns the {@link Buffer} or {@link BufferRange} for given varying name. */
  getBuffer(e) {
    return this.transformFeedback.getBuffer(e);
  }
  /** @deprecated App knows what buffers it is passing in - Reads the {@link Buffer} or {@link BufferRange} for given varying name. */
  readAsync(e) {
    const t = this.getBuffer(e);
    if (!t)
      throw new Error("BufferTransform#getBuffer");
    if (t instanceof vi)
      return t.readAsync();
    const { buffer: n, byteOffset: i = 0, byteLength: s = n.byteLength } = t;
    return n.readAsync(i, s);
  }
}
const CW = "transform_output";
class VC {
  device;
  model;
  sampler;
  currentIndex = 0;
  samplerTextureMap = null;
  bindings = [];
  // each element is an object : {sourceTextures, targetTexture, framebuffer}
  resources = {};
  // resources to be deleted
  constructor(e, t) {
    this.device = e, this.sampler = e.createSampler({
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge",
      minFilter: "nearest",
      magFilter: "nearest",
      mipmapFilter: "nearest"
    }), this.model = new Bi(this.device, {
      id: t.id || ru("texture-transform-model"),
      fs: t.fs || FB({
        input: t.targetTextureVarying,
        inputChannels: t.targetTextureChannels,
        output: CW
      }),
      vertexCount: t.vertexCount,
      // TODO(donmccurdy): Naming?
      ...t
    }), this._initialize(t), Object.seal(this);
  }
  // Delete owned resources.
  destroy() {
    this.model.destroy();
    for (const e of this.bindings)
      e.framebuffer?.destroy();
  }
  /** @deprecated Use {@link destroy}. */
  delete() {
    this.destroy();
  }
  run(e) {
    const { framebuffer: t } = this.bindings[this.currentIndex], n = this.device.beginRenderPass({ framebuffer: t, ...e });
    this.model.draw(n), n.end(), this.device.submit();
  }
  getTargetTexture() {
    const { targetTexture: e } = this.bindings[this.currentIndex];
    return e;
  }
  getFramebuffer() {
    return this.bindings[this.currentIndex].framebuffer;
  }
  // Private
  _initialize(e) {
    this._updateBindings(e);
  }
  _updateBindings(e) {
    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], e);
  }
  _updateBinding(e, { sourceBuffers: t, sourceTextures: n, targetTexture: i }) {
    if (e || (e = {
      sourceBuffers: {},
      sourceTextures: {},
      // @ts-expect-error
      targetTexture: null
    }), Object.assign(e.sourceTextures, n), Object.assign(e.sourceBuffers, t), i) {
      e.targetTexture = i;
      const { width: s, height: o } = i;
      e.framebuffer && e.framebuffer.destroy(), e.framebuffer = this.device.createFramebuffer({
        id: "transform-framebuffer",
        width: s,
        height: o,
        colorAttachments: [i]
      }), e.framebuffer.resize({ width: s, height: o });
    }
    return e;
  }
  // set texture filtering parameters on source textures.
  _setSourceTextureParameters() {
    const e = this.currentIndex, { sourceTextures: t } = this.bindings[e];
    for (const n in t)
      t[n].sampler = this.sampler;
  }
}
class no {
  id;
  /** Determines how vertices are read from the 'vertex' attributes */
  topology;
  vertexCount;
  indices;
  attributes;
  userData = {};
  constructor(e) {
    const { attributes: t = {}, indices: n = null, vertexCount: i = null } = e;
    this.id = e.id || ru("geometry"), this.topology = e.topology, n && (this.indices = ArrayBuffer.isView(n) ? { value: n, size: 1 } : n), this.attributes = {};
    for (const [s, o] of Object.entries(t)) {
      const l = ArrayBuffer.isView(o) ? { value: o } : o;
      if (!ArrayBuffer.isView(l.value))
        throw new Error(`${this._print(s)}: must be typed array or object with value as typed array`);
      if ((s === "POSITION" || s === "positions") && !l.size && (l.size = 3), s === "indices") {
        if (this.indices)
          throw new Error("Multiple indices detected");
        this.indices = l;
      } else
        this.attributes[s] = l;
    }
    this.indices && this.indices.isIndexed !== void 0 && (this.indices = Object.assign({}, this.indices), delete this.indices.isIndexed), this.vertexCount = i || this._calculateVertexCount(this.attributes, this.indices);
  }
  getVertexCount() {
    return this.vertexCount;
  }
  /**
   * Return an object with all attributes plus indices added as a field.
   * TODO Geometry types are a mess
   */
  getAttributes() {
    return this.indices ? { indices: this.indices, ...this.attributes } : this.attributes;
  }
  // PRIVATE
  _print(e) {
    return `Geometry ${this.id} attribute ${e}`;
  }
  /**
   * GeometryAttribute
   * value: typed array
   * type: indices, vertices, uvs
   * size: elements per vertex
   * target: WebGL buffer type (string or constant)
   *
   * @param attributes
   * @param indices
   * @returns
   */
  _setAttributes(e, t) {
    return this;
  }
  _calculateVertexCount(e, t) {
    if (t)
      return t.value.length;
    let n = 1 / 0;
    for (const i of Object.values(e)) {
      const { value: s, size: o, constant: l } = i;
      !l && s && o !== void 0 && o >= 1 && (n = Math.min(n, s.length / o));
    }
    return n;
  }
}
const SW = (
  /* wgsl */
  `struct VertexInputs {
  @location(0) clipSpacePosition: vec2<f32>,
  @location(1) texCoord: vec2<f32>,
  @location(2) coordinate: vec2<f32>  
}

struct FragmentInputs {
  @builtin(position) Position : vec4<f32>,
  @location(0) position : vec2<f32>,
  @location(1) coordinate : vec2<f32>,
  @location(2) uv : vec2<f32>
};

@vertex
fn vertexMain(inputs: VertexInputs) -> FragmentInputs {
  var outputs: FragmentInputs;
  outputs.Position = vec4(inputs.clipSpacePosition, 0., 1.);
  outputs.position = inputs.clipSpacePosition;
  outputs.coordinate = inputs.coordinate;
  outputs.uv = inputs.texCoord;
  return outputs;
}
`
), IW = (
  /* glsl */
  `#version 300 es
in vec2 clipSpacePositions;
in vec2 texCoords;
in vec2 coordinates;

out vec2 position;
out vec2 coordinate;
out vec2 uv;

void main(void) {
  gl_Position = vec4(clipSpacePositions, 0., 1.);
  position = clipSpacePositions;
  coordinate = coordinates;
  uv = texCoords;
}
`
), jC = [-1, -1, 1, -1, -1, 1, 1, 1];
class PW extends Bi {
  constructor(e, t) {
    const n = jC.map((i) => i === -1 ? 0 : i);
    t.source && (t = { ...t, source: `${SW}
${t.source}` }), super(e, {
      id: t.id || ru("clip-space"),
      ...t,
      vs: IW,
      vertexCount: 4,
      geometry: new no({
        topology: "triangle-strip",
        vertexCount: 4,
        attributes: {
          clipSpacePositions: { size: 2, value: new Float32Array(jC) },
          texCoords: { size: 2, value: new Float32Array(n) },
          coordinates: { size: 2, value: new Float32Array(n) }
        }
      })
    });
  }
}
class i_ {
  id;
  matrix = new xn();
  display = !0;
  position = new yt();
  rotation = new yt();
  scale = new yt(1, 1, 1);
  userData = {};
  props = {};
  constructor(e = {}) {
    const { id: t } = e;
    this.id = t || ru(this.constructor.name), this._setScenegraphNodeProps(e);
  }
  getBounds() {
    return null;
  }
  destroy() {
  }
  /** @deprecated use .destroy() */
  delete() {
    this.destroy();
  }
  setProps(e) {
    return this._setScenegraphNodeProps(e), this;
  }
  toString() {
    return `{type: ScenegraphNode, id: ${this.id})}`;
  }
  setPosition(e) {
    return this.position = e, this;
  }
  setRotation(e) {
    return this.rotation = e, this;
  }
  setScale(e) {
    return this.scale = e, this;
  }
  setMatrix(e, t = !0) {
    t ? this.matrix.copy(e) : this.matrix = e;
  }
  setMatrixComponents(e) {
    const { position: t, rotation: n, scale: i, update: s = !0 } = e;
    return t && this.setPosition(t), n && this.setRotation(n), i && this.setScale(i), s && this.updateMatrix(), this;
  }
  updateMatrix() {
    const e = this.position, t = this.rotation, n = this.scale;
    return this.matrix.identity(), this.matrix.translate(e), this.matrix.rotateXYZ(t), this.matrix.scale(n), this;
  }
  update(e = {}) {
    const { position: t, rotation: n, scale: i } = e;
    return t && this.setPosition(t), n && this.setRotation(n), i && this.setScale(i), this.updateMatrix(), this;
  }
  getCoordinateUniforms(e, t) {
    t = t || this.matrix;
    const n = new xn(e).multiplyRight(t), i = n.invert(), s = i.transpose();
    return {
      viewMatrix: e,
      modelMatrix: t,
      objectMatrix: t,
      worldMatrix: n,
      worldInverseMatrix: i,
      worldInverseTransposeMatrix: s
    };
  }
  // TODO - copied code, not yet vetted
  /*
    transform() {
      if (!this.parent) {
        this.endPosition.set(this.position);
        this.endRotation.set(this.rotation);
        this.endScale.set(this.scale);
      } else {
        const parent = this.parent;
        this.endPosition.set(this.position.add(parent.endPosition));
        this.endRotation.set(this.rotation.add(parent.endRotation));
        this.endScale.set(this.scale.add(parent.endScale));
      }
  
      const ch = this.children;
      for (let i = 0; i < ch.length; ++i) {
        ch[i].transform();
      }
  
      return this;
    }
    */
  _setScenegraphNodeProps(e) {
    "position" in e && this.setPosition(e.position), "rotation" in e && this.setRotation(e.rotation), "scale" in e && this.setScale(e.scale), "matrix" in e && this.setMatrix(e.matrix), Object.assign(this.props, e);
  }
}
class Lp extends i_ {
  children;
  constructor(e = {}) {
    e = Array.isArray(e) ? { children: e } : e;
    const { children: t = [] } = e;
    qt.assert(t.every((n) => n instanceof i_), "every child must an instance of ScenegraphNode"), super(e), this.children = t;
  }
  getBounds() {
    const e = [
      [1 / 0, 1 / 0, 1 / 0],
      [-1 / 0, -1 / 0, -1 / 0]
    ];
    return this.traverse((t, { worldMatrix: n }) => {
      const i = t.getBounds();
      if (!i)
        return;
      const [s, o] = i, l = new yt(s).add(o).divide([2, 2, 2]);
      n.transformAsPoint(l, l);
      const u = new yt(o).subtract(s).divide([2, 2, 2]);
      n.transformAsVector(u, u);
      for (let m = 0; m < 8; m++) {
        const y = new yt(m & 1 ? -1 : 1, m & 2 ? -1 : 1, m & 4 ? -1 : 1).multiply(u).add(l);
        for (let E = 0; E < 3; E++)
          e[0][E] = Math.min(e[0][E], y[E]), e[1][E] = Math.max(e[1][E], y[E]);
      }
    }), Number.isFinite(e[0][0]) ? e : null;
  }
  destroy() {
    this.children.forEach((e) => e.destroy()), this.removeAll(), super.destroy();
  }
  // Unpacks arrays and nested arrays of children
  add(...e) {
    for (const t of e)
      Array.isArray(t) ? this.add(...t) : this.children.push(t);
    return this;
  }
  remove(e) {
    const t = this.children, n = t.indexOf(e);
    return n > -1 && t.splice(n, 1), this;
  }
  removeAll() {
    return this.children = [], this;
  }
  traverse(e, { worldMatrix: t = new xn() } = {}) {
    const n = new xn(t).multiplyRight(this.matrix);
    for (const i of this.children)
      i instanceof Lp ? i.traverse(e, { worldMatrix: n }) : e(i, { worldMatrix: n });
  }
}
class jb extends i_ {
  model;
  bounds = null;
  managedResources;
  // TODO - is this used? override callbacks to make sure we call them with this
  // onBeforeRender = null;
  // onAfterRender = null;
  // AfterRender = null;
  constructor(e) {
    super(e), this.model = e.model, this.managedResources = e.managedResources || [], this.bounds = e.bounds || null, this.setProps(e);
  }
  destroy() {
    this.model && (this.model.destroy(), this.model = null), this.managedResources.forEach((e) => e.destroy()), this.managedResources = [];
  }
  getBounds() {
    return this.bounds;
  }
  // Expose model methods
  draw(e) {
    return this.model.draw(e);
  }
}
class n6 extends no {
  constructor(e = {}) {
    const { id: t = ru("cube-geometry"), indices: n = !0 } = e;
    super(n ? {
      ...e,
      id: t,
      topology: "triangle-list",
      indices: { size: 1, value: MW },
      attributes: { ...FW, ...e.attributes }
    } : {
      ...e,
      id: t,
      topology: "triangle-list",
      indices: void 0,
      attributes: { ...NW, ...e.attributes }
    });
  }
}
const MW = new Uint16Array([
  0,
  1,
  2,
  0,
  2,
  3,
  4,
  5,
  6,
  4,
  6,
  7,
  8,
  9,
  10,
  8,
  10,
  11,
  12,
  13,
  14,
  12,
  14,
  15,
  16,
  17,
  18,
  16,
  18,
  19,
  20,
  21,
  22,
  20,
  22,
  23
]), RW = new Float32Array([
  -1,
  -1,
  1,
  1,
  -1,
  1,
  1,
  1,
  1,
  -1,
  1,
  1,
  -1,
  -1,
  -1,
  -1,
  1,
  -1,
  1,
  1,
  -1,
  1,
  -1,
  -1,
  -1,
  1,
  -1,
  -1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  -1,
  -1,
  -1,
  -1,
  1,
  -1,
  -1,
  1,
  -1,
  1,
  -1,
  -1,
  1,
  1,
  -1,
  -1,
  1,
  1,
  -1,
  1,
  1,
  1,
  1,
  -1,
  1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  -1,
  1,
  1,
  -1,
  1,
  -1
]), BW = new Float32Array([
  // Front face
  0,
  0,
  1,
  0,
  0,
  1,
  0,
  0,
  1,
  0,
  0,
  1,
  // Back face
  0,
  0,
  -1,
  0,
  0,
  -1,
  0,
  0,
  -1,
  0,
  0,
  -1,
  // Top face
  0,
  1,
  0,
  0,
  1,
  0,
  0,
  1,
  0,
  0,
  1,
  0,
  // Bottom face
  0,
  -1,
  0,
  0,
  -1,
  0,
  0,
  -1,
  0,
  0,
  -1,
  0,
  // Right face
  1,
  0,
  0,
  1,
  0,
  0,
  1,
  0,
  0,
  1,
  0,
  0,
  // Left face
  -1,
  0,
  0,
  -1,
  0,
  0,
  -1,
  0,
  0,
  -1,
  0,
  0
]), OW = new Float32Array([
  // Front face
  0,
  0,
  1,
  0,
  1,
  1,
  0,
  1,
  // Back face
  1,
  0,
  1,
  1,
  0,
  1,
  0,
  0,
  // Top face
  0,
  1,
  0,
  0,
  1,
  0,
  1,
  1,
  // Bottom face
  1,
  1,
  0,
  1,
  0,
  0,
  1,
  0,
  // Right face
  1,
  0,
  1,
  1,
  0,
  1,
  0,
  0,
  // Left face
  0,
  0,
  1,
  0,
  1,
  1,
  0,
  1
]), DW = new Float32Array([
  1,
  -1,
  1,
  -1,
  -1,
  1,
  -1,
  -1,
  -1,
  1,
  -1,
  -1,
  1,
  -1,
  1,
  -1,
  -1,
  -1,
  1,
  1,
  1,
  1,
  -1,
  1,
  1,
  -1,
  -1,
  1,
  1,
  -1,
  1,
  1,
  1,
  1,
  -1,
  -1,
  -1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  -1,
  -1,
  1,
  -1,
  -1,
  1,
  1,
  1,
  1,
  -1,
  -1,
  -1,
  1,
  -1,
  1,
  1,
  -1,
  1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  -1,
  1,
  -1,
  1,
  1,
  1,
  -1,
  1,
  1,
  -1,
  -1,
  1,
  -1,
  -1,
  1,
  1,
  -1,
  1,
  1,
  1,
  1,
  1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1,
  -1,
  1,
  1,
  -1,
  1,
  -1,
  -1,
  -1,
  1,
  -1
]), LW = new Float32Array([
  1,
  1,
  0,
  1,
  0,
  0,
  1,
  0,
  1,
  1,
  0,
  0,
  1,
  1,
  0,
  1,
  0,
  0,
  1,
  0,
  1,
  1,
  0,
  0,
  1,
  1,
  0,
  1,
  0,
  0,
  1,
  0,
  1,
  1,
  0,
  0,
  1,
  1,
  0,
  1,
  0,
  0,
  1,
  0,
  1,
  1,
  0,
  0,
  1,
  1,
  0,
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  1,
  0,
  0,
  1,
  0,
  1,
  1,
  0,
  0
]), kW = new Float32Array([
  1,
  0,
  1,
  1,
  0,
  0,
  1,
  1,
  0,
  0,
  0,
  1,
  1,
  0,
  0,
  1,
  1,
  0,
  1,
  1,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  0,
  0,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  0,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  0,
  1,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  1,
  1,
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  0,
  0,
  1,
  1,
  0,
  0,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  1,
  0,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  0,
  1,
  0,
  1,
  0,
  1
]), FW = {
  POSITION: { size: 3, value: RW },
  NORMAL: { size: 3, value: BW },
  TEXCOORD_0: { size: 2, value: OW }
}, NW = {
  POSITION: { size: 3, value: DW },
  // NORMAL: {size: 3, value: CUBE_NON_INDEXED_NORMALS},
  TEXCOORD_0: { size: 2, value: LW },
  COLOR_0: { size: 3, value: kW }
}, UW = `uniform screenUniforms {
  vec2 texSize;
} screen;
`, zW = {
  name: "screen",
  fs: UW,
  uniformTypes: {
    texSize: "vec2<f32>"
  }
};
class VW extends KO {
  constructor(e, t) {
    super(e, t);
    const { module: n, fs: i, id: s } = t, o = {
      depthWriteEnabled: !1,
      depthCompare: "always",
      depthBias: 0,
      blend: !0,
      blendColorSrcFactor: "one",
      blendColorDstFactor: "one-minus-src-alpha",
      blendAlphaSrcFactor: "one",
      blendAlphaDstFactor: "one-minus-src-alpha",
      blendColorOperation: "add",
      blendAlphaOperation: "add"
    };
    this.model = new PW(e, { id: s, fs: i, modules: [n, zW], parameters: o });
  }
  render(e) {
    this._renderPass(this.device, e);
  }
  delete() {
    this.model.destroy(), this.model = null;
  }
  // Private methods
  /**
   * Renders the pass.
   * This is an abstract method that should be overridden.
   * @param inputBuffer - Frame buffer that contains the result of the previous pass
   * @param outputBuffer - Frame buffer that serves as the output render target
   */
  _renderPass(e, t) {
    const { clearCanvas: n, inputBuffer: i, outputBuffer: s } = t, o = [i.width, i.height], l = {
      texSrc: i.colorAttachments[0],
      texSize: o
    };
    this.model.shaderInputs.setProps({
      screen: l,
      ...t.moduleProps
    });
    const u = this.device.beginRenderPass({
      framebuffer: s,
      parameters: { viewport: [0, 0, ...o] },
      clearColor: n ? [0, 0, 0, 0] : !1,
      clearDepth: 1,
      clearStencil: !1
    });
    this.model.draw(u), u.end();
  }
}
class jW {
  constructor(e, t) {
    this.id = `${e.name}-pass`, this.props = t, IB(e), this.module = e;
  }
  setup({ device: e }) {
    this.passes = HW(e, this.module, this.id);
  }
  setProps(e) {
    this.props = e;
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  preRender() {
  }
  postRender(e) {
    const t = this.passes, { target: n } = e;
    let i = e.inputBuffer, s = e.swapBuffer;
    for (let o = 0; o < t.length; o++) {
      const l = o === t.length - 1, u = n !== void 0 && l;
      u && (s = n);
      const m = !u || !!e.clearCanvas, y = {}, E = this.module.passes[o].uniforms;
      y[this.module.name] = { ...this.props, ...E }, t[o].render({ clearCanvas: m, inputBuffer: i, outputBuffer: s, moduleProps: y });
      const P = s;
      s = i, i = P;
    }
    return i;
  }
  cleanup() {
    if (this.passes) {
      for (const e of this.passes)
        e.delete();
      this.passes = void 0;
    }
  }
}
function HW(r, e, t) {
  return e.passes.map((n, i) => {
    const s = $W(e, n), o = `${t}-${i}`;
    return new VW(r, { id: o, module: e, fs: s });
  });
}
const i6 = `#version 300 es
uniform sampler2D texSrc;

in vec2 position;
in vec2 coordinate;
in vec2 uv;

out vec4 fragColor;
`, GW = (r) => `${i6}
void main() {
  fragColor = texture(texSrc, coordinate);
  fragColor = ${r}(fragColor, screen.texSize, coordinate);
}
`, WW = (r) => `${i6}
void main() {
  fragColor = ${r}(texSrc, screen.texSize, coordinate);
}
`;
function $W(r, e) {
  if (e.filter) {
    const t = typeof e.filter == "string" ? e.filter : `${r.name}_filterColor_ext`;
    return GW(t);
  }
  if (e.sampler) {
    const t = typeof e.sampler == "string" ? e.sampler : `${r.name}_sampleColor`;
    return WW(t);
  }
  return "";
}
const qW = {
  blendColorOperation: "add",
  blendColorSrcFactor: "one",
  blendColorDstFactor: "zero",
  blendAlphaOperation: "add",
  blendAlphaSrcFactor: "constant",
  blendAlphaDstFactor: "zero"
};
class s6 extends U_ {
  constructor() {
    super(...arguments), this._colorEncoderState = null;
  }
  render(e) {
    return "pickingFBO" in e ? this._drawPickingBuffer(e) : super.render(e);
  }
  // Private
  // Draws list of layers and viewports into the picking buffer
  // Note: does not sample the buffer, that has to be done by the caller
  _drawPickingBuffer({ layers: e, layerFilter: t, views: n, viewports: i, onViewportActive: s, pickingFBO: o, deviceRect: { x: l, y: u, width: m, height: y }, cullRect: E, effects: P, pass: L = "picking", pickZ: U, shaderModuleProps: V }) {
    this.pickZ = U;
    const q = this._resetColorEncoder(U), j = [l, u, m, y], K = super.render({
      target: o,
      layers: e,
      layerFilter: t,
      views: n,
      viewports: i,
      onViewportActive: s,
      cullRect: E,
      effects: P?.filter((de) => de.useInPicking),
      pass: L,
      isPicking: !0,
      shaderModuleProps: V,
      clearColor: [0, 0, 0, 0],
      colorMask: 15,
      scissorRect: j
    });
    return this._colorEncoderState = null, { decodePickingColor: q && ZW.bind(null, q), stats: K };
  }
  shouldDrawLayer(e) {
    const { pickable: t, operation: n } = e.props;
    return t && n.includes("draw") || n.includes("terrain") || n.includes("mask");
  }
  getShaderModuleProps(e, t, n) {
    return {
      picking: {
        isActive: 1,
        isAttribute: this.pickZ
      },
      lighting: { enabled: !1 }
    };
  }
  getLayerParameters(e, t, n) {
    const i = {
      ...e.props.parameters
    }, { pickable: s, operation: o } = e.props;
    return !this._colorEncoderState || o.includes("terrain") ? i.blend = !1 : s && o.includes("draw") && (Object.assign(i, qW), i.blend = !0, i.blendColor = XW(this._colorEncoderState, e, n)), i;
  }
  _resetColorEncoder(e) {
    return this._colorEncoderState = e ? null : {
      byLayer: /* @__PURE__ */ new Map(),
      byAlpha: []
    }, this._colorEncoderState;
  }
}
function XW(r, e, t) {
  const { byLayer: n, byAlpha: i } = r;
  let s, o = n.get(e);
  return o ? (o.viewports.push(t), s = o.a) : (s = n.size + 1, s <= 255 ? (o = { a: s, layer: e, viewports: [t] }, n.set(e, o), i[s] = o) : (Jr.warn("Too many pickable layers, only picking the first 255")(), s = 0)), [0, 0, 0, s / 255];
}
function ZW(r, e) {
  const t = r.byAlpha[e[3]];
  return t && {
    pickedLayer: t.layer,
    pickedViewports: t.viewports,
    pickedObjectIndex: t.layer.decodePickingColor(e)
  };
}
const Hd = {
  NO_STATE: "Awaiting state",
  MATCHED: "Matched. State transferred from previous layer",
  INITIALIZED: "Initialized",
  AWAITING_GC: "Discarded. Awaiting garbage collection",
  AWAITING_FINALIZATION: "No longer matched. Awaiting garbage collection",
  FINALIZED: "Finalized! Awaiting garbage collection"
}, s_ = Symbol.for("component"), qu = Symbol.for("propTypes"), zv = Symbol.for("deprecatedProps"), ap = Symbol.for("asyncPropDefaults"), sh = Symbol.for("asyncPropOriginal"), Hu = Symbol.for("asyncPropResolved");
function z_(r, e = () => !0) {
  return Array.isArray(r) ? o6(r, e, []) : e(r) ? [r] : [];
}
function o6(r, e, t) {
  let n = -1;
  for (; ++n < r.length; ) {
    const i = r[n];
    Array.isArray(i) ? o6(i, e, t) : e(i) && t.push(i);
  }
  return t;
}
function YW({ target: r, source: e, start: t = 0, count: n = 1 }) {
  const i = e.length, s = n * i;
  let o = 0;
  for (let l = t; o < i; o++)
    r[l++] = e[o];
  for (; o < s; )
    o < s - o ? (r.copyWithin(t + o, t, t + o), o *= 2) : (r.copyWithin(t + o, t, t + s - o), o = s);
  return r;
}
class KW {
  constructor(e, t, n) {
    this._loadCount = 0, this._subscribers = /* @__PURE__ */ new Set(), this.id = e, this.context = n, this.setData(t);
  }
  // consumer: {onChange: Function}
  subscribe(e) {
    this._subscribers.add(e);
  }
  unsubscribe(e) {
    this._subscribers.delete(e);
  }
  inUse() {
    return this._subscribers.size > 0;
  }
  delete() {
  }
  getData() {
    return this.isLoaded ? this._error ? Promise.reject(this._error) : this._content : this._loader.then(() => this.getData());
  }
  setData(e, t) {
    if (e === this._data && !t)
      return;
    this._data = e;
    const n = ++this._loadCount;
    let i = e;
    typeof e == "string" && (i = Kc(e)), i instanceof Promise ? (this.isLoaded = !1, this._loader = i.then((s) => {
      this._loadCount === n && (this.isLoaded = !0, this._error = void 0, this._content = s);
    }).catch((s) => {
      this._loadCount === n && (this.isLoaded = !0, this._error = s || !0);
    })) : (this.isLoaded = !0, this._error = void 0, this._content = e);
    for (const s of this._subscribers)
      s.onChange(this.getData());
  }
}
class QW {
  constructor(e) {
    this.protocol = e.protocol || "resource://", this._context = {
      device: e.device,
      // @ts-expect-error
      gl: e.device?.gl,
      resourceManager: this
    }, this._resources = {}, this._consumers = {}, this._pruneRequest = null;
  }
  contains(e) {
    return e.startsWith(this.protocol) ? !0 : e in this._resources;
  }
  add({ resourceId: e, data: t, forceUpdate: n = !1, persistent: i = !0 }) {
    let s = this._resources[e];
    s ? s.setData(t, n) : (s = new KW(e, t, this._context), this._resources[e] = s), s.persistent = i;
  }
  remove(e) {
    const t = this._resources[e];
    t && (t.delete(), delete this._resources[e]);
  }
  unsubscribe({ consumerId: e }) {
    const t = this._consumers[e];
    if (t) {
      for (const n in t) {
        const i = t[n], s = this._resources[i.resourceId];
        s && s.unsubscribe(i);
      }
      delete this._consumers[e], this.prune();
    }
  }
  subscribe({ resourceId: e, onChange: t, consumerId: n, requestId: i = "default" }) {
    const { _resources: s, protocol: o } = this;
    e.startsWith(o) && (e = e.replace(o, ""), s[e] || this.add({ resourceId: e, data: null, persistent: !1 }));
    const l = s[e];
    if (this._track(n, i, l, t), l)
      return l.getData();
  }
  prune() {
    this._pruneRequest || (this._pruneRequest = setTimeout(() => this._prune(), 0));
  }
  finalize() {
    for (const e in this._resources)
      this._resources[e].delete();
  }
  _track(e, t, n, i) {
    const s = this._consumers, o = s[e] = s[e] || {};
    let l = o[t];
    const u = l && l.resourceId && this._resources[l.resourceId];
    u && (u.unsubscribe(l), this.prune()), n && (l ? (l.onChange = i, l.resourceId = n.id) : l = {
      onChange: i,
      resourceId: n.id
    }, o[t] = l, n.subscribe(l));
  }
  _prune() {
    this._pruneRequest = null;
    for (const e of Object.keys(this._resources)) {
      const t = this._resources[e];
      !t.persistent && !t.inUse() && (t.delete(), delete this._resources[e]);
    }
  }
}
const JW = "layerManager.setLayers", e$ = "layerManager.activateViewport";
class t$ {
  /**
   * @param device
   * @param param1
   */
  // eslint-disable-next-line
  constructor(e, t) {
    this._lastRenderedLayers = [], this._needsRedraw = !1, this._needsUpdate = !1, this._nextLayers = null, this._debug = !1, this._defaultShaderModulesChanged = !1, this.activateViewport = (l) => {
      go(e$, this, l), l && (this.context.viewport = l);
    };
    const { deck: n, stats: i, viewport: s, timeline: o } = t || {};
    this.layers = [], this.resourceManager = new QW({ device: e, protocol: "deck://" }), this.context = {
      mousePosition: null,
      userData: {},
      layerManager: this,
      device: e,
      // @ts-expect-error
      gl: e?.gl,
      deck: n,
      shaderAssembler: RG(e?.info?.shadingLanguage || "glsl"),
      defaultShaderModules: [zj],
      renderPass: void 0,
      stats: i || new Bp({ id: "deck.gl" }),
      // Make sure context.viewport is not empty on the first layer initialization
      viewport: s || new tu({ id: "DEFAULT-INITIAL-VIEWPORT" }),
      // Current viewport, exposed to layers for project* function
      timeline: o || new t6(),
      resourceManager: this.resourceManager,
      onError: void 0
    }, Object.seal(this);
  }
  /** Method to call when the layer manager is not needed anymore. */
  finalize() {
    this.resourceManager.finalize();
    for (const e of this.layers)
      this._finalizeLayer(e);
  }
  /** Check if a redraw is needed */
  needsRedraw(e = { clearRedrawFlags: !1 }) {
    let t = this._needsRedraw;
    e.clearRedrawFlags && (this._needsRedraw = !1);
    for (const n of this.layers) {
      const i = n.getNeedsRedraw(e);
      t = t || i;
    }
    return t;
  }
  /** Check if a deep update of all layers is needed */
  needsUpdate() {
    return this._nextLayers && this._nextLayers !== this._lastRenderedLayers ? "layers changed" : this._defaultShaderModulesChanged ? "shader modules changed" : this._needsUpdate;
  }
  /** Layers will be redrawn (in next animation frame) */
  setNeedsRedraw(e) {
    this._needsRedraw = this._needsRedraw || e;
  }
  /** Layers will be updated deeply (in next animation frame)
    Potentially regenerating attributes and sub layers */
  setNeedsUpdate(e) {
    this._needsUpdate = this._needsUpdate || e;
  }
  /** Gets a list of currently rendered layers. Optionally filter by id. */
  getLayers({ layerIds: e } = {}) {
    return e ? this.layers.filter((t) => e.find((n) => t.id.indexOf(n) === 0)) : this.layers;
  }
  /** Set props needed for layer rendering and picking. */
  setProps(e) {
    "debug" in e && (this._debug = e.debug), "userData" in e && (this.context.userData = e.userData), "layers" in e && (this._nextLayers = e.layers), "onError" in e && (this.context.onError = e.onError);
  }
  /** Supply a new layer list, initiating sublayer generation and layer matching */
  setLayers(e, t) {
    go(JW, this, t, e), this._lastRenderedLayers = e;
    const n = z_(e, Boolean);
    for (const i of n)
      i.context = this.context;
    this._updateLayers(this.layers, n);
  }
  /** Update layers from last cycle if `setNeedsUpdate()` has been called */
  updateLayers() {
    const e = this.needsUpdate();
    e && (this.setNeedsRedraw(`updating layers: ${e}`), this.setLayers(this._nextLayers || this._lastRenderedLayers, e)), this._nextLayers = null;
  }
  /** Register a default shader module */
  addDefaultShaderModule(e) {
    const { defaultShaderModules: t } = this.context;
    t.find((n) => n.name === e.name) || (t.push(e), this._defaultShaderModulesChanged = !0);
  }
  /** Deregister a default shader module */
  removeDefaultShaderModule(e) {
    const { defaultShaderModules: t } = this.context, n = t.findIndex((i) => i.name === e.name);
    n >= 0 && (t.splice(n, 1), this._defaultShaderModulesChanged = !0);
  }
  _handleError(e, t, n) {
    n.raiseError(t, `${e} of ${n}`);
  }
  // TODO - mark layers with exceptions as bad and remove from rendering cycle?
  /** Match all layers, checking for caught errors
    to avoid having an exception in one layer disrupt other layers */
  _updateLayers(e, t) {
    const n = {};
    for (const o of e)
      n[o.id] ? Jr.warn(`Multiple old layers with same id ${o.id}`)() : n[o.id] = o;
    if (this._defaultShaderModulesChanged) {
      for (const o of e)
        o.setNeedsUpdate(), o.setChangeFlags({ extensionsChanged: !0 });
      this._defaultShaderModulesChanged = !1;
    }
    const i = [];
    this._updateSublayersRecursively(t, n, i), this._finalizeOldLayers(n);
    let s = !1;
    for (const o of i)
      if (o.hasUniformTransition()) {
        s = `Uniform transition in ${o}`;
        break;
      }
    this._needsUpdate = s, this.layers = i;
  }
  /* eslint-disable complexity,max-statements */
  // Note: adds generated layers to `generatedLayers` array parameter
  _updateSublayersRecursively(e, t, n) {
    for (const i of e) {
      i.context = this.context;
      const s = t[i.id];
      s === null && Jr.warn(`Multiple new layers with same id ${i.id}`)(), t[i.id] = null;
      let o = null;
      try {
        this._debug && s !== i && i.validateProps(), s ? (this._transferLayerState(s, i), this._updateLayer(i)) : this._initializeLayer(i), n.push(i), o = i.isComposite ? i.getSubLayers() : null;
      } catch (l) {
        this._handleError("matching", l, i);
      }
      o && this._updateSublayersRecursively(o, t, n);
    }
  }
  /* eslint-enable complexity,max-statements */
  // Finalize any old layers that were not matched
  _finalizeOldLayers(e) {
    for (const t in e) {
      const n = e[t];
      n && this._finalizeLayer(n);
    }
  }
  // / EXCEPTION SAFE LAYER ACCESS
  /** Safely initializes a single layer, calling layer methods */
  _initializeLayer(e) {
    try {
      e._initialize(), e.lifecycle = Hd.INITIALIZED;
    } catch (t) {
      this._handleError("initialization", t, e);
    }
  }
  /** Transfer state from one layer to a newer version */
  _transferLayerState(e, t) {
    t._transferState(e), t.lifecycle = Hd.MATCHED, t !== e && (e.lifecycle = Hd.AWAITING_GC);
  }
  /** Safely updates a single layer, cleaning all flags */
  _updateLayer(e) {
    try {
      e._update();
    } catch (t) {
      this._handleError("update", t, e);
    }
  }
  /** Safely finalizes a single layer, removing all resources */
  _finalizeLayer(e) {
    this._needsRedraw = this._needsRedraw || `finalized ${e}`, e.lifecycle = Hd.AWAITING_FINALIZATION;
    try {
      e._finalize(), e.lifecycle = Hd.FINALIZED;
    } catch (t) {
      this._handleError("finalization", t, e);
    }
  }
}
function Fi(r, e, t) {
  if (r === e)
    return !0;
  if (!t || !r || !e)
    return !1;
  if (Array.isArray(r)) {
    if (!Array.isArray(e) || r.length !== e.length)
      return !1;
    for (let n = 0; n < r.length; n++)
      if (!Fi(r[n], e[n], t - 1))
        return !1;
    return !0;
  }
  if (Array.isArray(e))
    return !1;
  if (typeof r == "object" && typeof e == "object") {
    const n = Object.keys(r), i = Object.keys(e);
    if (n.length !== i.length)
      return !1;
    for (const s of n)
      if (!e.hasOwnProperty(s) || !Fi(r[s], e[s], t - 1))
        return !1;
    return !0;
  }
  return !1;
}
class r$ {
  constructor(e) {
    this.views = [], this.width = 100, this.height = 100, this.viewState = {}, this.controllers = {}, this.timeline = e.timeline, this._viewports = [], this._viewportMap = {}, this._isUpdating = !1, this._needsRedraw = "First render", this._needsUpdate = "Initialize", this._eventManager = e.eventManager, this._eventCallbacks = {
      onViewStateChange: e.onViewStateChange,
      onInteractionStateChange: e.onInteractionStateChange
    }, Object.seal(this), this.setProps(e);
  }
  /** Remove all resources and event listeners */
  finalize() {
    for (const e in this.controllers) {
      const t = this.controllers[e];
      t && t.finalize();
    }
    this.controllers = {};
  }
  /** Check if a redraw is needed */
  needsRedraw(e = { clearRedrawFlags: !1 }) {
    const t = this._needsRedraw;
    return e.clearRedrawFlags && (this._needsRedraw = !1), t;
  }
  /** Mark the manager as dirty. Will rebuild all viewports and update controllers. */
  setNeedsUpdate(e) {
    this._needsUpdate = this._needsUpdate || e, this._needsRedraw = this._needsRedraw || e;
  }
  /** Checks each viewport for transition updates */
  updateViewStates() {
    for (const e in this.controllers) {
      const t = this.controllers[e];
      t && t.updateTransition();
    }
  }
  /** Get a set of viewports for a given width and height
   * TODO - Intention is for deck.gl to autodeduce width and height and drop the need for props
   * @param rect (object, optional) - filter the viewports
   *   + not provided - return all viewports
   *   + {x, y} - only return viewports that contain this pixel
   *   + {x, y, width, height} - only return viewports that overlap with this rectangle
   */
  getViewports(e) {
    return e ? this._viewports.filter((t) => t.containsPixel(e)) : this._viewports;
  }
  /** Get a map of all views */
  getViews() {
    const e = {};
    return this.views.forEach((t) => {
      e[t.id] = t;
    }), e;
  }
  /** Resolves a viewId string to a View */
  getView(e) {
    return this.views.find((t) => t.id === e);
  }
  /** Returns the viewState for a specific viewId. Matches the viewState by
    1. view.viewStateId
    2. view.id
    3. root viewState
    then applies the view's filter if any */
  getViewState(e) {
    const t = typeof e == "string" ? this.getView(e) : e, n = t && this.viewState[t.getViewStateId()] || this.viewState;
    return t ? t.filterViewState(n) : n;
  }
  getViewport(e) {
    return this._viewportMap[e];
  }
  /**
   * Unproject pixel coordinates on screen onto world coordinates,
   * (possibly [lon, lat]) on map.
   * - [x, y] => [lng, lat]
   * - [x, y, z] => [lng, lat, Z]
   * @param {Array} xyz -
   * @param {Object} opts - options
   * @param {Object} opts.topLeft=true - Whether origin is top left
   * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]
   */
  unproject(e, t) {
    const n = this.getViewports(), i = { x: e[0], y: e[1] };
    for (let s = n.length - 1; s >= 0; --s) {
      const o = n[s];
      if (o.containsPixel(i)) {
        const l = e.slice();
        return l[0] -= o.x, l[1] -= o.y, o.unproject(l, t);
      }
    }
    return null;
  }
  /** Update the manager with new Deck props */
  setProps(e) {
    e.views && this._setViews(e.views), e.viewState && this._setViewState(e.viewState), ("width" in e || "height" in e) && this._setSize(e.width, e.height), this._isUpdating || this._update();
  }
  //
  // PRIVATE METHODS
  //
  _update() {
    this._isUpdating = !0, this._needsUpdate && (this._needsUpdate = !1, this._rebuildViewports()), this._needsUpdate && (this._needsUpdate = !1, this._rebuildViewports()), this._isUpdating = !1;
  }
  _setSize(e, t) {
    (e !== this.width || t !== this.height) && (this.width = e, this.height = t, this.setNeedsUpdate("Size changed"));
  }
  // Update the view descriptor list and set change flag if needed
  // Does not actually rebuild the `Viewport`s until `getViewports` is called
  _setViews(e) {
    e = z_(e, Boolean), this._diffViews(e, this.views) && this.setNeedsUpdate("views changed"), this.views = e;
  }
  _setViewState(e) {
    e ? (!Fi(e, this.viewState, 3) && this.setNeedsUpdate("viewState changed"), this.viewState = e) : Jr.warn("missing `viewState` or `initialViewState`")();
  }
  _createController(e, t) {
    const n = t.type;
    return new n({
      timeline: this.timeline,
      eventManager: this._eventManager,
      // Set an internal callback that calls the prop callback if provided
      onViewStateChange: this._eventCallbacks.onViewStateChange,
      onStateChange: this._eventCallbacks.onInteractionStateChange,
      makeViewport: (s) => this.getView(e.id)?.makeViewport({
        viewState: s,
        width: this.width,
        height: this.height
      })
    });
  }
  _updateController(e, t, n, i) {
    const s = e.controller;
    if (s && n) {
      const o = {
        ...t,
        ...s,
        id: e.id,
        x: n.x,
        y: n.y,
        width: n.width,
        height: n.height
      };
      return (!i || i.constructor !== s.type) && (i = this._createController(e, o)), i && i.setProps(o), i;
    }
    return null;
  }
  // Rebuilds viewports from descriptors towards a certain window size
  _rebuildViewports() {
    const { views: e } = this, t = this.controllers;
    this._viewports = [], this.controllers = {};
    let n = !1;
    for (let i = e.length; i--; ) {
      const s = e[i], o = this.getViewState(s), l = s.makeViewport({ viewState: o, width: this.width, height: this.height });
      let u = t[s.id];
      const m = !!s.controller;
      m && !u && (n = !0), (n || !m) && u && (u.finalize(), u = null), this.controllers[s.id] = this._updateController(s, o, l, u), l && this._viewports.unshift(l);
    }
    for (const i in t) {
      const s = t[i];
      s && !this.controllers[i] && s.finalize();
    }
    this._buildViewportMap();
  }
  _buildViewportMap() {
    this._viewportMap = {}, this._viewports.forEach((e) => {
      e.id && (this._viewportMap[e.id] = this._viewportMap[e.id] || e);
    });
  }
  // Check if viewport array has changed, returns true if any change
  // Note that descriptors can be the same
  _diffViews(e, t) {
    return e.length !== t.length ? !0 : e.some((n, i) => !e[i].equals(t[i]));
  }
}
const n$ = /([0-9]+\.?[0-9]*)(%|px)/;
function Du(r) {
  switch (typeof r) {
    case "number":
      return {
        position: r,
        relative: !1
      };
    case "string":
      const e = n$.exec(r);
      if (e && e.length >= 3) {
        const t = e[2] === "%", n = parseFloat(e[1]);
        return {
          position: t ? n / 100 : n,
          relative: t
        };
      }
    // fallthrough
    default:
      throw new Error(`Could not parse position string ${r}`);
  }
}
function Lu(r, e) {
  return r.relative ? Math.round(r.position * e) : r.position;
}
class vp {
  constructor(e) {
    const { id: t, x: n = 0, y: i = 0, width: s = "100%", height: o = "100%", padding: l = null } = e;
    this.id = t || this.constructor.displayName || "view", this.props = { ...e, id: this.id }, this._x = Du(n), this._y = Du(i), this._width = Du(s), this._height = Du(o), this._padding = l && {
      left: Du(l.left || 0),
      right: Du(l.right || 0),
      top: Du(l.top || 0),
      bottom: Du(l.bottom || 0)
    }, this.equals = this.equals.bind(this), Object.seal(this);
  }
  equals(e) {
    return this === e ? !0 : this.constructor === e.constructor && Fi(this.props, e.props, 2);
  }
  /** Clone this view with modified props */
  clone(e) {
    const t = this.constructor;
    return new t({ ...this.props, ...e });
  }
  /** Make viewport from canvas dimensions and view state */
  makeViewport({ width: e, height: t, viewState: n }) {
    n = this.filterViewState(n);
    const i = this.getDimensions({ width: e, height: t });
    if (!i.height || !i.width)
      return null;
    const s = this.getViewportType(n);
    return new s({ ...n, ...this.props, ...i });
  }
  getViewStateId() {
    const { viewState: e } = this.props;
    return typeof e == "string" ? e : e?.id || this.id;
  }
  // Allows view to override (or completely define) viewState
  filterViewState(e) {
    if (this.props.viewState && typeof this.props.viewState == "object") {
      if (!this.props.viewState.id)
        return this.props.viewState;
      const t = { ...e };
      for (const n in this.props.viewState)
        n !== "id" && (t[n] = this.props.viewState[n]);
      return t;
    }
    return e;
  }
  /** Resolve the dimensions of the view from overall canvas dimensions */
  getDimensions({ width: e, height: t }) {
    const n = {
      x: Lu(this._x, e),
      y: Lu(this._y, t),
      width: Lu(this._width, e),
      height: Lu(this._height, t)
    };
    return this._padding && (n.padding = {
      left: Lu(this._padding.left, e),
      top: Lu(this._padding.top, t),
      right: Lu(this._padding.right, e),
      bottom: Lu(this._padding.bottom, t)
    }), n;
  }
  // Used by sub classes to resolve controller props
  get controller() {
    const e = this.props.controller;
    return e ? e === !0 ? { type: this.ControllerType } : typeof e == "function" ? { type: e } : { type: this.ControllerType, ...e } : null;
  }
}
class V_ {
  /**
   * @params timeline {Timeline}
   */
  constructor(e) {
    this._inProgress = !1, this._handle = null, this.time = 0, this.settings = {
      duration: 0
    }, this._timeline = e;
  }
  /* Public API */
  get inProgress() {
    return this._inProgress;
  }
  /**
   * (re)start this transition.
   * @params props {object} - optional overriding props. see constructor
   */
  start(e) {
    this.cancel(), this.settings = e, this._inProgress = !0, this.settings.onStart?.(this);
  }
  /**
   * end this transition if it is in progress.
   */
  end() {
    this._inProgress && (this._timeline.removeChannel(this._handle), this._handle = null, this._inProgress = !1, this.settings.onEnd?.(this));
  }
  /**
   * cancel this transition if it is in progress.
   */
  cancel() {
    this._inProgress && (this.settings.onInterrupt?.(this), this._timeline.removeChannel(this._handle), this._handle = null, this._inProgress = !1);
  }
  /**
   * update this transition. Returns `true` if updated.
   */
  update() {
    if (!this._inProgress)
      return !1;
    if (this._handle === null) {
      const { _timeline: e, settings: t } = this;
      this._handle = e.addChannel({
        delay: e.getTime(),
        duration: t.duration
      });
    }
    return this.time = this._timeline.getTime(this._handle), this._onUpdate(), this.settings.onUpdate?.(this), this._timeline.isFinished(this._handle) && this.end(), !0;
  }
  /* Private API */
  _onUpdate() {
  }
}
const HC = () => {
}, Hb = {
  BREAK: 1,
  SNAP_TO_END: 2,
  IGNORE: 3
}, i$ = (r) => r, s$ = Hb.BREAK;
let o$ = class {
  constructor(e) {
    this._onTransitionUpdate = (t) => {
      const { time: n, settings: { interpolator: i, startProps: s, endProps: o, duration: l, easing: u } } = t, m = u(n / l), y = i.interpolateProps(s, o, m);
      this.propsInTransition = this.getControllerState({
        ...this.props,
        ...y
      }).getViewportProps(), this.onViewStateChange({
        viewState: this.propsInTransition,
        oldViewState: this.props
      });
    }, this.getControllerState = e.getControllerState, this.propsInTransition = null, this.transition = new V_(e.timeline), this.onViewStateChange = e.onViewStateChange || HC, this.onStateChange = e.onStateChange || HC;
  }
  finalize() {
    this.transition.cancel();
  }
  // Returns current transitioned viewport.
  getViewportInTransition() {
    return this.propsInTransition;
  }
  // Process the vewiport change, either ignore or trigger a new transition.
  // Return true if a new transition is triggered, false otherwise.
  processViewStateChange(e) {
    let t = !1;
    const n = this.props;
    if (this.props = e, !n || this._shouldIgnoreViewportChange(n, e))
      return !1;
    if (this._isTransitionEnabled(e)) {
      let i = n;
      if (this.transition.inProgress) {
        const { interruption: s, endProps: o } = this.transition.settings;
        i = {
          ...n,
          ...s === Hb.SNAP_TO_END ? o : this.propsInTransition || n
        };
      }
      this._triggerTransition(i, e), t = !0;
    } else
      this.transition.cancel();
    return t;
  }
  updateTransition() {
    this.transition.update();
  }
  // Helper methods
  _isTransitionEnabled(e) {
    const { transitionDuration: t, transitionInterpolator: n } = e;
    return (t > 0 || t === "auto") && !!n;
  }
  _isUpdateDueToCurrentTransition(e) {
    return this.transition.inProgress && this.propsInTransition ? this.transition.settings.interpolator.arePropsEqual(e, this.propsInTransition) : !1;
  }
  _shouldIgnoreViewportChange(e, t) {
    return this.transition.inProgress ? this.transition.settings.interruption === Hb.IGNORE || // Ignore update if it is due to current active transition.
    this._isUpdateDueToCurrentTransition(t) : this._isTransitionEnabled(t) ? t.transitionInterpolator.arePropsEqual(e, t) : !0;
  }
  _triggerTransition(e, t) {
    const n = this.getControllerState(e), i = this.getControllerState(t).shortestPathFrom(n), s = t.transitionInterpolator, o = s.getDuration ? s.getDuration(e, t) : t.transitionDuration;
    if (o === 0)
      return;
    const l = s.initializeProps(e, i);
    this.propsInTransition = {};
    const u = {
      duration: o,
      easing: t.transitionEasing || i$,
      interpolator: s,
      interruption: t.transitionInterruption || s$,
      startProps: l.start,
      endProps: l.end,
      onStart: t.onTransitionStart,
      onUpdate: this._onTransitionUpdate,
      onInterrupt: this._onTransitionEnd(t.onTransitionInterrupt),
      onEnd: this._onTransitionEnd(t.onTransitionEnd)
    };
    this.transition.start(u), this.onStateChange({ inTransition: !0 }), this.updateTransition();
  }
  _onTransitionEnd(e) {
    return (t) => {
      this.propsInTransition = null, this.onStateChange({
        inTransition: !1,
        isZooming: !1,
        isPanning: !1,
        isRotating: !1
      }), e?.(t);
    };
  }
};
function to(r, e) {
  if (!r)
    throw new Error(e || "deck.gl: assertion failed.");
}
let a$ = class {
  /**
   * @param opts {array|object}
   * @param opts.compare {array} - prop names used in equality check
   * @param opts.extract {array} - prop names needed for interpolation
   * @param opts.required {array} - prop names that must be supplied
   * alternatively, supply one list of prop names as `opts` if all of the above are the same.
   */
  constructor(e) {
    const { compare: t, extract: n, required: i } = e;
    this._propsToCompare = t, this._propsToExtract = n || t, this._requiredProps = i;
  }
  /**
   * Checks if two sets of props need transition in between
   * @param currentProps {object} - a list of viewport props
   * @param nextProps {object} - a list of viewport props
   * @returns {bool} - true if two props are equivalent
   */
  arePropsEqual(e, t) {
    for (const n of this._propsToCompare)
      if (!(n in e) || !(n in t) || !Aa(e[n], t[n]))
        return !1;
    return !0;
  }
  /**
   * Called before transition starts to validate/pre-process start and end props
   * @param startProps {object} - a list of starting viewport props
   * @param endProps {object} - a list of target viewport props
   * @returns {Object} {start, end} - start and end props to be passed
   *   to `interpolateProps`
   */
  initializeProps(e, t) {
    const n = {}, i = {};
    for (const s of this._propsToExtract)
      (s in e || s in t) && (n[s] = e[s], i[s] = t[s]);
    return this._checkRequiredProps(n), this._checkRequiredProps(i), { start: n, end: i };
  }
  /**
   * Returns transition duration
   * @param startProps {object} - a list of starting viewport props
   * @param endProps {object} - a list of target viewport props
   * @returns {Number} - transition duration in milliseconds
   */
  getDuration(e, t) {
    return t.transitionDuration;
  }
  _checkRequiredProps(e) {
    this._requiredProps && this._requiredProps.forEach((t) => {
      const n = e[t];
      to(Number.isFinite(n) || Array.isArray(n), `${t} is required for transition`);
    });
  }
};
const l$ = ["longitude", "latitude", "zoom", "bearing", "pitch"], c$ = ["longitude", "latitude", "zoom"];
let a6 = class extends a$ {
  /**
   * @param {Object} opts
   * @param {Array} opts.transitionProps - list of props to apply linear transition to.
   * @param {Array} opts.around - a screen point to zoom/rotate around.
   * @param {Function} opts.makeViewport - construct a viewport instance with given props.
   */
  constructor(e = {}) {
    const t = Array.isArray(e) ? e : e.transitionProps, n = Array.isArray(e) ? {} : e;
    n.transitionProps = Array.isArray(t) ? {
      compare: t,
      required: t
    } : t || {
      compare: l$,
      required: c$
    }, super(n.transitionProps), this.opts = n;
  }
  initializeProps(e, t) {
    const n = super.initializeProps(e, t), { makeViewport: i, around: s } = this.opts;
    if (i && s) {
      const o = i(e), l = i(t), u = o.unproject(s);
      n.start.around = s, Object.assign(n.end, {
        around: l.project(u),
        aroundPosition: u,
        width: t.width,
        height: t.height
      });
    }
    return n;
  }
  interpolateProps(e, t, n) {
    const i = {};
    for (const s of this._propsToExtract)
      i[s] = ml(e[s] || 0, t[s] || 0, n);
    if (t.aroundPosition && this.opts.makeViewport) {
      const s = this.opts.makeViewport({ ...t, ...i });
      Object.assign(i, s.panByPosition(
        t.aroundPosition,
        // anchor point in current screen coordinates
        ml(e.around, t.around, n)
      ));
    }
    return i;
  }
};
const Nc = {
  transitionDuration: 0
}, u$ = 300, Tg = (r) => 1 - (1 - r) * (1 - r), bd = {
  WHEEL: ["wheel"],
  PAN: ["panstart", "panmove", "panend"],
  PINCH: ["pinchstart", "pinchmove", "pinchend"],
  MULTI_PAN: ["multipanstart", "multipanmove", "multipanend"],
  DOUBLE_CLICK: ["dblclick"],
  KEYBOARD: ["keydown"]
}, Lf = {};
class f$ {
  constructor(e) {
    this.state = {}, this._events = {}, this._interactionState = {
      isDragging: !1
    }, this._customEvents = [], this._eventStartBlocked = null, this._panMove = !1, this.invertPan = !1, this.dragMode = "rotate", this.inertia = 0, this.scrollZoom = !0, this.dragPan = !0, this.dragRotate = !0, this.doubleClickZoom = !0, this.touchZoom = !0, this.touchRotate = !1, this.keyboard = !0, this.transitionManager = new o$({
      ...e,
      getControllerState: (t) => new this.ControllerState(t),
      onViewStateChange: this._onTransition.bind(this),
      onStateChange: this._setInteractionState.bind(this)
    }), this.handleEvent = this.handleEvent.bind(this), this.eventManager = e.eventManager, this.onViewStateChange = e.onViewStateChange || (() => {
    }), this.onStateChange = e.onStateChange || (() => {
    }), this.makeViewport = e.makeViewport;
  }
  set events(e) {
    this.toggleEvents(this._customEvents, !1), this.toggleEvents(e, !0), this._customEvents = e, this.props && this.setProps(this.props);
  }
  finalize() {
    for (const e in this._events)
      this._events[e] && this.eventManager?.off(e, this.handleEvent);
    this.transitionManager.finalize();
  }
  /**
   * Callback for events
   */
  handleEvent(e) {
    this._controllerState = void 0;
    const t = this._eventStartBlocked;
    switch (e.type) {
      case "panstart":
        return t ? !1 : this._onPanStart(e);
      case "panmove":
        return this._onPan(e);
      case "panend":
        return this._onPanEnd(e);
      case "pinchstart":
        return t ? !1 : this._onPinchStart(e);
      case "pinchmove":
        return this._onPinch(e);
      case "pinchend":
        return this._onPinchEnd(e);
      case "multipanstart":
        return t ? !1 : this._onMultiPanStart(e);
      case "multipanmove":
        return this._onMultiPan(e);
      case "multipanend":
        return this._onMultiPanEnd(e);
      case "dblclick":
        return this._onDoubleClick(e);
      case "wheel":
        return this._onWheel(e);
      case "keydown":
        return this._onKeyDown(e);
      default:
        return !1;
    }
  }
  /* Event utils */
  // Event object: http://hammerjs.github.io/api/#event-object
  get controllerState() {
    return this._controllerState = this._controllerState || new this.ControllerState({
      makeViewport: this.makeViewport,
      ...this.props,
      ...this.state
    }), this._controllerState;
  }
  getCenter(e) {
    const { x: t, y: n } = this.props, { offsetCenter: i } = e;
    return [i.x - t, i.y - n];
  }
  isPointInBounds(e, t) {
    const { width: n, height: i } = this.props;
    if (t && t.handled)
      return !1;
    const s = e[0] >= 0 && e[0] <= n && e[1] >= 0 && e[1] <= i;
    return s && t && t.stopPropagation(), s;
  }
  isFunctionKeyPressed(e) {
    const { srcEvent: t } = e;
    return !!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey);
  }
  isDragging() {
    return this._interactionState.isDragging || !1;
  }
  // When a multi-touch event ends, e.g. pinch, not all pointers are lifted at the same time.
  // This triggers a brief `pan` event.
  // Calling this method will temporarily disable *start events to avoid conflicting transitions.
  blockEvents(e) {
    const t = setTimeout(() => {
      this._eventStartBlocked === t && (this._eventStartBlocked = null);
    }, e);
    this._eventStartBlocked = t;
  }
  /**
   * Extract interactivity options
   */
  setProps(e) {
    e.dragMode && (this.dragMode = e.dragMode), this.props = e, "transitionInterpolator" in e || (e.transitionInterpolator = this._getTransitionProps().transitionInterpolator), this.transitionManager.processViewStateChange(e);
    const { inertia: t } = e;
    this.inertia = Number.isFinite(t) ? t : t === !0 ? u$ : 0;
    const { scrollZoom: n = !0, dragPan: i = !0, dragRotate: s = !0, doubleClickZoom: o = !0, touchZoom: l = !0, touchRotate: u = !1, keyboard: m = !0 } = e, y = !!this.onViewStateChange;
    this.toggleEvents(bd.WHEEL, y && n), this.toggleEvents(bd.PAN, y), this.toggleEvents(bd.PINCH, y && (l || u)), this.toggleEvents(bd.MULTI_PAN, y && u), this.toggleEvents(bd.DOUBLE_CLICK, y && o), this.toggleEvents(bd.KEYBOARD, y && m), this.scrollZoom = n, this.dragPan = i, this.dragRotate = s, this.doubleClickZoom = o, this.touchZoom = l, this.touchRotate = u, this.keyboard = m;
  }
  updateTransition() {
    this.transitionManager.updateTransition();
  }
  toggleEvents(e, t) {
    this.eventManager && e.forEach((n) => {
      this._events[n] !== t && (this._events[n] = t, t ? this.eventManager.on(n, this.handleEvent) : this.eventManager.off(n, this.handleEvent));
    });
  }
  // Private Methods
  /* Callback util */
  // formats map state and invokes callback function
  updateViewport(e, t = null, n = {}) {
    const i = { ...e.getViewportProps(), ...t }, s = this.controllerState !== e;
    if (this.state = e.getState(), this._setInteractionState(n), s) {
      const o = this.controllerState && this.controllerState.getViewportProps();
      this.onViewStateChange && this.onViewStateChange({ viewState: i, interactionState: this._interactionState, oldViewState: o, viewId: this.props.id });
    }
  }
  _onTransition(e) {
    this.onViewStateChange({ ...e, interactionState: this._interactionState, viewId: this.props.id });
  }
  _setInteractionState(e) {
    Object.assign(this._interactionState, e), this.onStateChange(this._interactionState);
  }
  /* Event handlers */
  // Default handler for the `panstart` event.
  _onPanStart(e) {
    const t = this.getCenter(e);
    if (!this.isPointInBounds(t, e))
      return !1;
    let n = this.isFunctionKeyPressed(e) || e.rightButton || !1;
    (this.invertPan || this.dragMode === "pan") && (n = !n);
    const i = this.controllerState[n ? "panStart" : "rotateStart"]({
      pos: t
    });
    return this._panMove = n, this.updateViewport(i, Nc, { isDragging: !0 }), !0;
  }
  // Default handler for the `panmove` and `panend` event.
  _onPan(e) {
    return this.isDragging() ? this._panMove ? this._onPanMove(e) : this._onPanRotate(e) : !1;
  }
  _onPanEnd(e) {
    return this.isDragging() ? this._panMove ? this._onPanMoveEnd(e) : this._onPanRotateEnd(e) : !1;
  }
  // Default handler for panning to move.
  // Called by `_onPan` when panning without function key pressed.
  _onPanMove(e) {
    if (!this.dragPan)
      return !1;
    const t = this.getCenter(e), n = this.controllerState.pan({ pos: t });
    return this.updateViewport(n, Nc, {
      isDragging: !0,
      isPanning: !0
    }), !0;
  }
  _onPanMoveEnd(e) {
    const { inertia: t } = this;
    if (this.dragPan && t && e.velocity) {
      const n = this.getCenter(e), i = [
        n[0] + e.velocityX * t / 2,
        n[1] + e.velocityY * t / 2
      ], s = this.controllerState.pan({ pos: i }).panEnd();
      this.updateViewport(s, {
        ...this._getTransitionProps(),
        transitionDuration: t,
        transitionEasing: Tg
      }, {
        isDragging: !1,
        isPanning: !0
      });
    } else {
      const n = this.controllerState.panEnd();
      this.updateViewport(n, null, {
        isDragging: !1,
        isPanning: !1
      });
    }
    return !0;
  }
  // Default handler for panning to rotate.
  // Called by `_onPan` when panning with function key pressed.
  _onPanRotate(e) {
    if (!this.dragRotate)
      return !1;
    const t = this.getCenter(e), n = this.controllerState.rotate({ pos: t });
    return this.updateViewport(n, Nc, {
      isDragging: !0,
      isRotating: !0
    }), !0;
  }
  _onPanRotateEnd(e) {
    const { inertia: t } = this;
    if (this.dragRotate && t && e.velocity) {
      const n = this.getCenter(e), i = [
        n[0] + e.velocityX * t / 2,
        n[1] + e.velocityY * t / 2
      ], s = this.controllerState.rotate({ pos: i }).rotateEnd();
      this.updateViewport(s, {
        ...this._getTransitionProps(),
        transitionDuration: t,
        transitionEasing: Tg
      }, {
        isDragging: !1,
        isRotating: !0
      });
    } else {
      const n = this.controllerState.rotateEnd();
      this.updateViewport(n, null, {
        isDragging: !1,
        isRotating: !1
      });
    }
    return !0;
  }
  // Default handler for the `wheel` event.
  _onWheel(e) {
    if (!this.scrollZoom)
      return !1;
    const t = this.getCenter(e);
    if (!this.isPointInBounds(t, e))
      return !1;
    e.srcEvent.preventDefault();
    const { speed: n = 0.01, smooth: i = !1 } = this.scrollZoom === !0 ? {} : this.scrollZoom, { delta: s } = e;
    let o = 2 / (1 + Math.exp(-Math.abs(s * n)));
    s < 0 && o !== 0 && (o = 1 / o);
    const l = i ? { ...this._getTransitionProps({ around: t }), transitionDuration: 250 } : Nc, u = this.controllerState.zoom({ pos: t, scale: o });
    return this.updateViewport(u, l, {
      isZooming: !0,
      isPanning: !0
    }), !0;
  }
  _onMultiPanStart(e) {
    const t = this.getCenter(e);
    if (!this.isPointInBounds(t, e))
      return !1;
    const n = this.controllerState.rotateStart({ pos: t });
    return this.updateViewport(n, Nc, { isDragging: !0 }), !0;
  }
  _onMultiPan(e) {
    if (!this.touchRotate || !this.isDragging())
      return !1;
    const t = this.getCenter(e);
    t[0] -= e.deltaX;
    const n = this.controllerState.rotate({ pos: t });
    return this.updateViewport(n, Nc, {
      isDragging: !0,
      isRotating: !0
    }), !0;
  }
  _onMultiPanEnd(e) {
    if (!this.isDragging())
      return !1;
    const { inertia: t } = this;
    if (this.touchRotate && t && e.velocityY) {
      const n = this.getCenter(e), i = [n[0], n[1] += e.velocityY * t / 2], s = this.controllerState.rotate({ pos: i });
      this.updateViewport(s, {
        ...this._getTransitionProps(),
        transitionDuration: t,
        transitionEasing: Tg
      }, {
        isDragging: !1,
        isRotating: !0
      }), this.blockEvents(t);
    } else {
      const n = this.controllerState.rotateEnd();
      this.updateViewport(n, null, {
        isDragging: !1,
        isRotating: !1
      });
    }
    return !0;
  }
  // Default handler for the `pinchstart` event.
  _onPinchStart(e) {
    const t = this.getCenter(e);
    if (!this.isPointInBounds(t, e))
      return !1;
    const n = this.controllerState.zoomStart({ pos: t }).rotateStart({ pos: t });
    return Lf._startPinchRotation = e.rotation, Lf._lastPinchEvent = e, this.updateViewport(n, Nc, { isDragging: !0 }), !0;
  }
  // Default handler for the `pinchmove` and `pinchend` events.
  _onPinch(e) {
    if (!this.touchZoom && !this.touchRotate || !this.isDragging())
      return !1;
    let t = this.controllerState;
    if (this.touchZoom) {
      const { scale: n } = e, i = this.getCenter(e);
      t = t.zoom({ pos: i, scale: n });
    }
    if (this.touchRotate) {
      const { rotation: n } = e;
      t = t.rotate({
        deltaAngleX: Lf._startPinchRotation - n
      });
    }
    return this.updateViewport(t, Nc, {
      isDragging: !0,
      isPanning: this.touchZoom,
      isZooming: this.touchZoom,
      isRotating: this.touchRotate
    }), Lf._lastPinchEvent = e, !0;
  }
  _onPinchEnd(e) {
    if (!this.isDragging())
      return !1;
    const { inertia: t } = this, { _lastPinchEvent: n } = Lf;
    if (this.touchZoom && t && n && e.scale !== n.scale) {
      const i = this.getCenter(e);
      let s = this.controllerState.rotateEnd();
      const o = Math.log2(e.scale), l = (o - Math.log2(n.scale)) / (e.deltaTime - n.deltaTime), u = Math.pow(2, o + l * t / 2);
      s = s.zoom({ pos: i, scale: u }).zoomEnd(), this.updateViewport(s, {
        ...this._getTransitionProps({ around: i }),
        transitionDuration: t,
        transitionEasing: Tg
      }, {
        isDragging: !1,
        isPanning: this.touchZoom,
        isZooming: this.touchZoom,
        isRotating: !1
      }), this.blockEvents(t);
    } else {
      const i = this.controllerState.zoomEnd().rotateEnd();
      this.updateViewport(i, null, {
        isDragging: !1,
        isPanning: !1,
        isZooming: !1,
        isRotating: !1
      });
    }
    return Lf._startPinchRotation = null, Lf._lastPinchEvent = null, !0;
  }
  // Default handler for the `dblclick` event.
  _onDoubleClick(e) {
    if (!this.doubleClickZoom)
      return !1;
    const t = this.getCenter(e);
    if (!this.isPointInBounds(t, e))
      return !1;
    const n = this.isFunctionKeyPressed(e), i = this.controllerState.zoom({ pos: t, scale: n ? 0.5 : 2 });
    return this.updateViewport(i, this._getTransitionProps({ around: t }), {
      isZooming: !0,
      isPanning: !0
    }), this.blockEvents(100), !0;
  }
  // Default handler for the `keydown` event
  _onKeyDown(e) {
    if (!this.keyboard)
      return !1;
    const t = this.isFunctionKeyPressed(e), { zoomSpeed: n, moveSpeed: i, rotateSpeedX: s, rotateSpeedY: o } = this.keyboard === !0 ? {} : this.keyboard, { controllerState: l } = this;
    let u;
    const m = {};
    switch (e.srcEvent.code) {
      case "Minus":
        u = t ? l.zoomOut(n).zoomOut(n) : l.zoomOut(n), m.isZooming = !0;
        break;
      case "Equal":
        u = t ? l.zoomIn(n).zoomIn(n) : l.zoomIn(n), m.isZooming = !0;
        break;
      case "ArrowLeft":
        t ? (u = l.rotateLeft(s), m.isRotating = !0) : (u = l.moveLeft(i), m.isPanning = !0);
        break;
      case "ArrowRight":
        t ? (u = l.rotateRight(s), m.isRotating = !0) : (u = l.moveRight(i), m.isPanning = !0);
        break;
      case "ArrowUp":
        t ? (u = l.rotateUp(o), m.isRotating = !0) : (u = l.moveUp(i), m.isPanning = !0);
        break;
      case "ArrowDown":
        t ? (u = l.rotateDown(o), m.isRotating = !0) : (u = l.moveDown(i), m.isPanning = !0);
        break;
      default:
        return !1;
    }
    return this.updateViewport(u, this._getTransitionProps(), m), !0;
  }
  _getTransitionProps(e) {
    const { transition: t } = this;
    return !t || !t.transitionInterpolator ? Nc : e ? {
      ...t,
      transitionInterpolator: new a6({
        ...e,
        ...t.transitionInterpolator.opts,
        makeViewport: this.controllerState.makeViewport
      })
    } : t;
  }
}
class h$ {
  constructor(e, t) {
    this._viewportProps = this.applyConstraints(e), this._state = t;
  }
  getViewportProps() {
    return this._viewportProps;
  }
  getState() {
    return this._state;
  }
}
const GC = 5, d$ = 1.2;
let p$ = class extends h$ {
  constructor(e) {
    const {
      /** Mapbox viewport properties */
      /** The width of the viewport */
      width: t,
      /** The height of the viewport */
      height: n,
      /** The latitude at the center of the viewport */
      latitude: i,
      /** The longitude at the center of the viewport */
      longitude: s,
      /** The tile zoom level of the map. */
      zoom: o,
      /** The bearing of the viewport in degrees */
      bearing: l = 0,
      /** The pitch of the viewport in degrees */
      pitch: u = 0,
      /**
       * Specify the altitude of the viewport camera
       * Unit: map heights, default 1.5
       * Non-public API, see https://github.com/mapbox/mapbox-gl-js/issues/1137
       */
      altitude: m = 1.5,
      /** Viewport position */
      position: y = [0, 0, 0],
      /** Viewport constraints */
      maxZoom: E = 20,
      minZoom: P = 0,
      maxPitch: L = 60,
      minPitch: U = 0,
      /** Interaction states, required to calculate change during transform */
      /* The point on map being grabbed when the operation first started */
      startPanLngLat: V,
      /* Center of the zoom when the operation first started */
      startZoomLngLat: q,
      /* Pointer position when rotation started */
      startRotatePos: j,
      /** Bearing when current perspective rotate operation started */
      startBearing: K,
      /** Pitch when current perspective rotate operation started */
      startPitch: Y,
      /** Zoom when current zoom operation started */
      startZoom: de,
      /** Normalize viewport props to fit map height into viewport */
      normalize: ne = !0
    } = e;
    to(Number.isFinite(s)), to(Number.isFinite(i)), to(Number.isFinite(o)), super({
      width: t,
      height: n,
      latitude: i,
      longitude: s,
      zoom: o,
      bearing: l,
      pitch: u,
      altitude: m,
      maxZoom: E,
      minZoom: P,
      maxPitch: L,
      minPitch: U,
      normalize: ne,
      position: y
    }, {
      startPanLngLat: V,
      startZoomLngLat: q,
      startRotatePos: j,
      startBearing: K,
      startPitch: Y,
      startZoom: de
    }), this.makeViewport = e.makeViewport;
  }
  /**
   * Start panning
   * @param {[Number, Number]} pos - position on screen where the pointer grabs
   */
  panStart({ pos: e }) {
    return this._getUpdatedState({
      startPanLngLat: this._unproject(e)
    });
  }
  /**
   * Pan
   * @param {[Number, Number]} pos - position on screen where the pointer is
   * @param {[Number, Number], optional} startPos - where the pointer grabbed at
   *   the start of the operation. Must be supplied of `panStart()` was not called
   */
  pan({ pos: e, startPos: t }) {
    const n = this.getState().startPanLngLat || this._unproject(t);
    if (!n)
      return this;
    const s = this.makeViewport(this.getViewportProps()).panByPosition(n, e);
    return this._getUpdatedState(s);
  }
  /**
   * End panning
   * Must call if `panStart()` was called
   */
  panEnd() {
    return this._getUpdatedState({
      startPanLngLat: null
    });
  }
  /**
   * Start rotating
   * @param {[Number, Number]} pos - position on screen where the center is
   */
  rotateStart({ pos: e }) {
    return this._getUpdatedState({
      startRotatePos: e,
      startBearing: this.getViewportProps().bearing,
      startPitch: this.getViewportProps().pitch
    });
  }
  /**
   * Rotate
   * @param {[Number, Number]} pos - position on screen where the center is
   */
  rotate({ pos: e, deltaAngleX: t = 0, deltaAngleY: n = 0 }) {
    const { startRotatePos: i, startBearing: s, startPitch: o } = this.getState();
    if (!i || s === void 0 || o === void 0)
      return this;
    let l;
    return e ? l = this._getNewRotation(e, i, o, s) : l = {
      bearing: s + t,
      pitch: o + n
    }, this._getUpdatedState(l);
  }
  /**
   * End rotating
   * Must call if `rotateStart()` was called
   */
  rotateEnd() {
    return this._getUpdatedState({
      startBearing: null,
      startPitch: null
    });
  }
  /**
   * Start zooming
   * @param {[Number, Number]} pos - position on screen where the center is
   */
  zoomStart({ pos: e }) {
    return this._getUpdatedState({
      startZoomLngLat: this._unproject(e),
      startZoom: this.getViewportProps().zoom
    });
  }
  /**
   * Zoom
   * @param {[Number, Number]} pos - position on screen where the current center is
   * @param {[Number, Number]} startPos - the center position at
   *   the start of the operation. Must be supplied of `zoomStart()` was not called
   * @param {Number} scale - a number between [0, 1] specifying the accumulated
   *   relative scale.
   */
  zoom({ pos: e, startPos: t, scale: n }) {
    let { startZoom: i, startZoomLngLat: s } = this.getState();
    if (s || (i = this.getViewportProps().zoom, s = this._unproject(t) || this._unproject(e)), !s)
      return this;
    const { maxZoom: o, minZoom: l } = this.getViewportProps();
    let u = i + Math.log2(n);
    u = $c(u, l, o);
    const m = this.makeViewport({ ...this.getViewportProps(), zoom: u });
    return this._getUpdatedState({
      zoom: u,
      ...m.panByPosition(s, e)
    });
  }
  /**
   * End zooming
   * Must call if `zoomStart()` was called
   */
  zoomEnd() {
    return this._getUpdatedState({
      startZoomLngLat: null,
      startZoom: null
    });
  }
  zoomIn(e = 2) {
    return this._zoomFromCenter(e);
  }
  zoomOut(e = 2) {
    return this._zoomFromCenter(1 / e);
  }
  moveLeft(e = 100) {
    return this._panFromCenter([e, 0]);
  }
  moveRight(e = 100) {
    return this._panFromCenter([-e, 0]);
  }
  moveUp(e = 100) {
    return this._panFromCenter([0, e]);
  }
  moveDown(e = 100) {
    return this._panFromCenter([0, -e]);
  }
  rotateLeft(e = 15) {
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing - e
    });
  }
  rotateRight(e = 15) {
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing + e
    });
  }
  rotateUp(e = 10) {
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch + e
    });
  }
  rotateDown(e = 10) {
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch - e
    });
  }
  shortestPathFrom(e) {
    const t = e.getViewportProps(), n = { ...this.getViewportProps() }, { bearing: i, longitude: s } = n;
    return Math.abs(i - t.bearing) > 180 && (n.bearing = i < 0 ? i + 360 : i - 360), Math.abs(s - t.longitude) > 180 && (n.longitude = s < 0 ? s + 360 : s - 360), n;
  }
  // Apply any constraints (mathematical or defined by _viewportProps) to map state
  applyConstraints(e) {
    const { maxZoom: t, minZoom: n, zoom: i } = e;
    e.zoom = $c(i, n, t);
    const { maxPitch: s, minPitch: o, pitch: l } = e;
    e.pitch = $c(l, o, s);
    const { normalize: u = !0 } = e;
    return u && Object.assign(e, AG(e)), e;
  }
  /* Private methods */
  _zoomFromCenter(e) {
    const { width: t, height: n } = this.getViewportProps();
    return this.zoom({
      pos: [t / 2, n / 2],
      scale: e
    });
  }
  _panFromCenter(e) {
    const { width: t, height: n } = this.getViewportProps();
    return this.pan({
      startPos: [t / 2, n / 2],
      pos: [t / 2 + e[0], n / 2 + e[1]]
    });
  }
  _getUpdatedState(e) {
    return new this.constructor({
      makeViewport: this.makeViewport,
      ...this.getViewportProps(),
      ...this.getState(),
      ...e
    });
  }
  _unproject(e) {
    const t = this.makeViewport(this.getViewportProps());
    return e && t.unproject(e);
  }
  _getNewRotation(e, t, n, i) {
    const s = e[0] - t[0], o = e[1] - t[1], l = e[1], u = t[1], { width: m, height: y } = this.getViewportProps(), E = s / m;
    let P = 0;
    o > 0 ? Math.abs(y - u) > GC && (P = o / (u - y) * d$) : o < 0 && u > GC && (P = 1 - l / u), P = $c(P, -1, 1);
    const { minPitch: L, maxPitch: U } = this.getViewportProps(), V = i + 180 * E;
    let q = n;
    return P > 0 ? q = n + P * (U - n) : P < 0 && (q = n - P * (L - n)), {
      pitch: q,
      bearing: V
    };
  }
}, A$ = class extends f$ {
  constructor() {
    super(...arguments), this.ControllerState = p$, this.transition = {
      transitionDuration: 300,
      transitionInterpolator: new a6({
        transitionProps: {
          compare: ["longitude", "latitude", "zoom", "bearing", "pitch", "position"],
          required: ["longitude", "latitude", "zoom"]
        }
      })
    }, this.dragMode = "pan";
  }
  setProps(e) {
    e.position = e.position || [0, 0, 0];
    const t = this.props;
    super.setProps(e), (!t || t.height !== e.height) && this.updateViewport(new this.ControllerState({
      makeViewport: this.makeViewport,
      ...e,
      ...this.state
    }));
  }
};
class l6 extends vp {
  constructor(e = {}) {
    super(e);
  }
  getViewportType() {
    return s0;
  }
  get ControllerType() {
    return A$;
  }
}
l6.displayName = "MapView";
const g$ = new JO();
function m$(r, e) {
  const t = r.order ?? 1 / 0, n = e.order ?? 1 / 0;
  return t - n;
}
class _$ {
  constructor(e) {
    this._resolvedEffects = [], this._defaultEffects = [], this.effects = [], this._context = e, this._needsRedraw = "Initial render", this._setEffects([]);
  }
  /**
   * Register a new default effect, i.e. an effect presents regardless of user supplied props.effects
   */
  addDefaultEffect(e) {
    const t = this._defaultEffects;
    if (!t.find((n) => n.id === e.id)) {
      const n = t.findIndex((i) => m$(i, e) > 0);
      n < 0 ? t.push(e) : t.splice(n, 0, e), e.setup(this._context), this._setEffects(this.effects);
    }
  }
  setProps(e) {
    "effects" in e && (Fi(e.effects, this.effects, 1) || this._setEffects(e.effects));
  }
  needsRedraw(e = { clearRedrawFlags: !1 }) {
    const t = this._needsRedraw;
    return e.clearRedrawFlags && (this._needsRedraw = !1), t;
  }
  getEffects() {
    return this._resolvedEffects;
  }
  _setEffects(e) {
    const t = {};
    for (const i of this.effects)
      t[i.id] = i;
    const n = [];
    for (const i of e) {
      const s = t[i.id];
      let o = i;
      s && s !== i ? s.setProps ? (s.setProps(i.props), o = s) : s.cleanup(this._context) : s || i.setup(this._context), n.push(o), delete t[i.id];
    }
    for (const i in t)
      t[i].cleanup(this._context);
    this.effects = n, this._resolvedEffects = n.concat(this._defaultEffects), e.some((i) => i instanceof JO) || this._resolvedEffects.push(g$), this._needsRedraw = "effects changed";
  }
  finalize() {
    for (const e of this._resolvedEffects)
      e.cleanup(this._context);
    this.effects.length = 0, this._resolvedEffects.length = 0, this._defaultEffects.length = 0;
  }
}
class y$ extends U_ {
  shouldDrawLayer(e) {
    const { operation: t } = e.props;
    return t.includes("draw") || t.includes("terrain");
  }
}
const v$ = "deckRenderer.renderLayers";
class b$ {
  constructor(e) {
    this.device = e, this.layerFilter = null, this.drawPickingColors = !1, this.drawLayersPass = new y$(e), this.pickLayersPass = new s6(e), this.renderCount = 0, this._needsRedraw = "Initial render", this.renderBuffers = [], this.lastPostProcessEffect = null;
  }
  setProps(e) {
    this.layerFilter !== e.layerFilter && (this.layerFilter = e.layerFilter, this._needsRedraw = "layerFilter changed"), this.drawPickingColors !== e.drawPickingColors && (this.drawPickingColors = e.drawPickingColors, this._needsRedraw = "drawPickingColors changed");
  }
  renderLayers(e) {
    if (!e.viewports.length)
      return;
    const t = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass, n = {
      layerFilter: this.layerFilter,
      isPicking: this.drawPickingColors,
      ...e
    };
    n.effects && this._preRender(n.effects, n);
    const i = this.lastPostProcessEffect ? this.renderBuffers[0] : n.target;
    this.lastPostProcessEffect && (n.clearColor = [0, 0, 0, 0], n.clearCanvas = !0);
    const s = t.render({ ...n, target: i });
    n.effects && (this.lastPostProcessEffect && (n.clearCanvas = e.clearCanvas === void 0 ? !0 : e.clearCanvas), this._postRender(n.effects, n)), this.renderCount++, go(v$, this, s, e);
  }
  needsRedraw(e = { clearRedrawFlags: !1 }) {
    const t = this._needsRedraw;
    return e.clearRedrawFlags && (this._needsRedraw = !1), t;
  }
  finalize() {
    const { renderBuffers: e } = this;
    for (const t of e)
      t.delete();
    e.length = 0;
  }
  _preRender(e, t) {
    this.lastPostProcessEffect = null, t.preRenderStats = t.preRenderStats || {};
    for (const n of e)
      t.preRenderStats[n.id] = n.preRender(t), n.postRender && (this.lastPostProcessEffect = n.id);
    this.lastPostProcessEffect && this._resizeRenderBuffers();
  }
  _resizeRenderBuffers() {
    const { renderBuffers: e } = this, t = this.device.canvasContext.getDrawingBufferSize(), [n, i] = t;
    e.length === 0 && [0, 1].map((s) => {
      const o = this.device.createTexture({
        sampler: { minFilter: "linear", magFilter: "linear" },
        width: n,
        height: i
      });
      e.push(this.device.createFramebuffer({
        id: `deck-renderbuffer-${s}`,
        colorAttachments: [o]
      }));
    });
    for (const s of e)
      s.resize(t);
  }
  _postRender(e, t) {
    const { renderBuffers: n } = this, i = {
      ...t,
      inputBuffer: n[0],
      swapBuffer: n[1]
    };
    for (const s of e)
      if (s.postRender) {
        i.target = s.id === this.lastPostProcessEffect ? t.target : void 0;
        const o = s.postRender(i);
        i.inputBuffer = o, i.swapBuffer = o === n[0] ? n[1] : n[0];
      }
  }
}
const x$ = {
  pickedColor: null,
  pickedObjectIndex: -1
};
function WC({ pickedColors: r, decodePickingColor: e, deviceX: t, deviceY: n, deviceRadius: i, deviceRect: s }) {
  const { x: o, y: l, width: u, height: m } = s;
  let y = i * i, E = -1, P = 0;
  for (let L = 0; L < m; L++) {
    const U = L + l - n, V = U * U;
    if (V > y)
      P += 4 * u;
    else
      for (let q = 0; q < u; q++) {
        if (r[P + 3] - 1 >= 0) {
          const K = q + o - t, Y = K * K + V;
          Y <= y && (y = Y, E = P);
        }
        P += 4;
      }
  }
  if (E >= 0) {
    const L = r.slice(E, E + 4), U = e(L);
    if (U) {
      const V = Math.floor(E / 4 / u), q = E / 4 - V * u;
      return {
        ...U,
        pickedColor: L,
        pickedX: o + q,
        pickedY: l + V
      };
    }
    Jr.error("Picked non-existent layer. Is picking buffer corrupt?")();
  }
  return x$;
}
function $C({ pickedColors: r, decodePickingColor: e }) {
  const t = /* @__PURE__ */ new Map();
  if (r) {
    for (let n = 0; n < r.length; n += 4)
      if (r[n + 3] - 1 >= 0) {
        const s = r.slice(n, n + 4), o = s.join(",");
        if (!t.has(o)) {
          const l = e(s);
          l ? t.set(o, {
            ...l,
            color: s
          }) : Jr.error("Picked non-existent layer. Is picking buffer corrupt?")();
        }
      }
  }
  return Array.from(t.values());
}
function Gb({ pickInfo: r, viewports: e, pixelRatio: t, x: n, y: i, z: s }) {
  let o = e[0];
  e.length > 1 && (o = w$(r?.pickedViewports || e, { x: n, y: i }));
  let l;
  if (o) {
    const u = [n - o.x, i - o.y];
    s !== void 0 && (u[2] = s), l = o.unproject(u);
  }
  return {
    color: null,
    layer: null,
    viewport: o,
    index: -1,
    picked: !1,
    x: n,
    y: i,
    pixel: [n, i],
    coordinate: l,
    devicePixel: r && "pickedX" in r ? [r.pickedX, r.pickedY] : void 0,
    pixelRatio: t
  };
}
function qC(r) {
  const { pickInfo: e, lastPickedInfo: t, mode: n, layers: i } = r, { pickedColor: s, pickedLayer: o, pickedObjectIndex: l } = e, u = o ? [o] : [];
  if (n === "hover") {
    const E = t.index, P = t.layerId, L = o ? o.props.id : null;
    if (L !== P || l !== E) {
      if (L !== P) {
        const U = i.find((V) => V.props.id === P);
        U && u.unshift(U);
      }
      t.layerId = L, t.index = l, t.info = null;
    }
  }
  const m = Gb(r), y = /* @__PURE__ */ new Map();
  return y.set(null, m), u.forEach((E) => {
    let P = { ...m };
    E === o && (P.color = s, P.index = l, P.picked = !0), P = Wb({ layer: E, info: P, mode: n });
    const L = P.layer;
    E === o && n === "hover" && (t.info = P), y.set(L.id, P), n === "hover" && L.updateAutoHighlight(P);
  }), y;
}
function Wb({ layer: r, info: e, mode: t }) {
  for (; r && e; ) {
    const n = e.layer || null;
    e.sourceLayer = n, e.layer = r, e = r.getPickingInfo({ info: e, mode: t, sourceLayer: n }), r = r.parent;
  }
  return e;
}
function w$(r, e) {
  for (let t = r.length - 1; t >= 0; t--) {
    const n = r[t];
    if (n.containsPixel(e))
      return n;
  }
  return r[0];
}
class T$ {
  constructor(e) {
    this._pickable = !0, this.device = e, this.pickLayersPass = new s6(e), this.lastPickedInfo = {
      index: -1,
      layerId: null,
      info: null
    };
  }
  setProps(e) {
    "layerFilter" in e && (this.layerFilter = e.layerFilter), "_pickable" in e && (this._pickable = e._pickable);
  }
  finalize() {
    this.pickingFBO && this.pickingFBO.destroy(), this.depthFBO && this.depthFBO.destroy();
  }
  /**
   * Pick the closest info at given coordinate
   * @returns Promise that resolves with picking info
   */
  pickObjectAsync(e) {
    return this._pickClosestObjectAsync(e);
  }
  /**
   * Picks a list of unique infos within a bounding box
   * @returns Promise that resolves to all unique infos within a bounding box
   */
  pickObjectsAsync(e) {
    return this._pickVisibleObjectsAsync(e);
  }
  /**
   * Pick the closest info at given coordinate
   * @returns picking info
   * @deprecated WebGL only - use pickObjectAsync instead
   */
  pickObject(e) {
    return this._pickClosestObject(e);
  }
  /**
   * Get all unique infos within a bounding box
   * @returns all unique infos within a bounding box
   * @deprecated WebGL only - use pickObjectAsync instead
   */
  pickObjects(e) {
    return this._pickVisibleObjects(e);
  }
  // Returns a new picking info object by assuming the last picked object is still picked
  getLastPickedObject({ x: e, y: t, layers: n, viewports: i }, s = this.lastPickedInfo.info) {
    const o = s && s.layer && s.layer.id, l = s && s.viewport && s.viewport.id, u = o ? n.find((P) => P.id === o) : null, m = l && i.find((P) => P.id === l) || i[0], y = m && m.unproject([e - m.x, t - m.y]);
    return { ...s, ...{
      x: e,
      y: t,
      viewport: m,
      coordinate: y,
      layer: u
    } };
  }
  // Private
  /** Ensures that picking framebuffer exists and matches the canvas size */
  _resizeBuffer() {
    if (!this.pickingFBO && (this.pickingFBO = this.device.createFramebuffer({
      colorAttachments: ["rgba8unorm"],
      depthStencilAttachment: "depth16unorm"
    }), this.device.isTextureFormatRenderable("rgba32float"))) {
      const t = this.device.createFramebuffer({
        colorAttachments: ["rgba32float"],
        depthStencilAttachment: "depth16unorm"
      });
      this.depthFBO = t;
    }
    const { canvas: e } = this.device.getDefaultCanvasContext();
    this.pickingFBO?.resize({ width: e.width, height: e.height }), this.depthFBO?.resize({ width: e.width, height: e.height });
  }
  /** Preliminary filtering of the layers list. Skid picking pass if no layer is pickable. */
  _getPickable(e) {
    if (this._pickable === !1)
      return null;
    const t = e.filter((n) => this.pickLayersPass.shouldDrawLayer(n) && !n.isComposite);
    return t.length ? t : null;
  }
  /**
   * Pick the closest object at the given coordinate
   */
  // eslint-disable-next-line max-statements,complexity
  async _pickClosestObjectAsync({ layers: e, views: t, viewports: n, x: i, y: s, radius: o = 0, depth: l = 1, mode: u = "query", unproject3D: m, onViewportActive: y, effects: E }) {
    const P = this.device.canvasContext.cssToDeviceRatio(), L = this._getPickable(e);
    if (!L || n.length === 0)
      return {
        result: [],
        emptyInfo: Gb({ viewports: n, x: i, y: s, pixelRatio: P })
      };
    this._resizeBuffer();
    const U = this.device.canvasContext.cssToDevicePixels([i, s], !0), V = [
      U.x + Math.floor(U.width / 2),
      U.y + Math.floor(U.height / 2)
    ], q = Math.round(o * P), { width: j, height: K } = this.pickingFBO, Y = this._getPickingRect({
      deviceX: V[0],
      deviceY: V[1],
      deviceRadius: q,
      deviceWidth: j,
      deviceHeight: K
    }), de = {
      x: i - o,
      y: s - o,
      width: o * 2 + 1,
      height: o * 2 + 1
    };
    let ne;
    const ae = [], De = /* @__PURE__ */ new Set();
    for (let Ge = 0; Ge < l; Ge++) {
      let fe;
      if (Y) {
        const me = this._drawAndSample({
          layers: L,
          views: t,
          viewports: n,
          onViewportActive: y,
          deviceRect: Y,
          cullRect: de,
          effects: E,
          pass: `picking:${u}`
        });
        fe = WC({
          ...me,
          deviceX: V[0],
          deviceY: V[1],
          deviceRadius: q,
          deviceRect: Y
        });
      } else
        fe = {
          pickedColor: null,
          pickedObjectIndex: -1
        };
      let ve;
      if (fe.pickedLayer && m && this.depthFBO) {
        const { pickedColors: me } = this._drawAndSample({
          layers: [fe.pickedLayer],
          views: t,
          viewports: n,
          onViewportActive: y,
          deviceRect: {
            x: fe.pickedX,
            y: fe.pickedY,
            width: 1,
            height: 1
          },
          cullRect: de,
          effects: E,
          pass: `picking:${u}:z`
        }, !0);
        me[3] && (ve = me[0]);
      }
      fe.pickedLayer && Ge + 1 < l && (De.add(fe.pickedLayer), fe.pickedLayer.disablePickingIndex(fe.pickedObjectIndex)), ne = qC({
        pickInfo: fe,
        lastPickedInfo: this.lastPickedInfo,
        mode: u,
        layers: L,
        viewports: n,
        x: i,
        y: s,
        z: ve,
        pixelRatio: P
      });
      for (const me of ne.values())
        me.layer && ae.push(me);
      if (!fe.pickedColor)
        break;
    }
    for (const Ge of De)
      Ge.restorePickingColors();
    return { result: ae, emptyInfo: ne.get(null) };
  }
  /**
   * Pick the closest object at the given coordinate
   * @deprecated WebGL only
   */
  // eslint-disable-next-line max-statements,complexity
  _pickClosestObject({ layers: e, views: t, viewports: n, x: i, y: s, radius: o = 0, depth: l = 1, mode: u = "query", unproject3D: m, onViewportActive: y, effects: E }) {
    const P = this.device.canvasContext.cssToDeviceRatio(), L = this._getPickable(e);
    if (!L || n.length === 0)
      return {
        result: [],
        emptyInfo: Gb({ viewports: n, x: i, y: s, pixelRatio: P })
      };
    this._resizeBuffer();
    const U = this.device.canvasContext.cssToDevicePixels([i, s], !0), V = [
      U.x + Math.floor(U.width / 2),
      U.y + Math.floor(U.height / 2)
    ], q = Math.round(o * P), { width: j, height: K } = this.pickingFBO, Y = this._getPickingRect({
      deviceX: V[0],
      deviceY: V[1],
      deviceRadius: q,
      deviceWidth: j,
      deviceHeight: K
    }), de = {
      x: i - o,
      y: s - o,
      width: o * 2 + 1,
      height: o * 2 + 1
    };
    let ne;
    const ae = [], De = /* @__PURE__ */ new Set();
    for (let Ge = 0; Ge < l; Ge++) {
      let fe;
      if (Y) {
        const me = this._drawAndSample({
          layers: L,
          views: t,
          viewports: n,
          onViewportActive: y,
          deviceRect: Y,
          cullRect: de,
          effects: E,
          pass: `picking:${u}`
        });
        fe = WC({
          ...me,
          deviceX: V[0],
          deviceY: V[1],
          deviceRadius: q,
          deviceRect: Y
        });
      } else
        fe = {
          pickedColor: null,
          pickedObjectIndex: -1
        };
      let ve;
      if (fe.pickedLayer && m && this.depthFBO) {
        const { pickedColors: me } = this._drawAndSample({
          layers: [fe.pickedLayer],
          views: t,
          viewports: n,
          onViewportActive: y,
          deviceRect: {
            x: fe.pickedX,
            y: fe.pickedY,
            width: 1,
            height: 1
          },
          cullRect: de,
          effects: E,
          pass: `picking:${u}:z`
        }, !0);
        me[3] && (ve = me[0]);
      }
      fe.pickedLayer && Ge + 1 < l && (De.add(fe.pickedLayer), fe.pickedLayer.disablePickingIndex(fe.pickedObjectIndex)), ne = qC({
        pickInfo: fe,
        lastPickedInfo: this.lastPickedInfo,
        mode: u,
        layers: L,
        viewports: n,
        x: i,
        y: s,
        z: ve,
        pixelRatio: P
      });
      for (const me of ne.values())
        me.layer && ae.push(me);
      if (!fe.pickedColor)
        break;
    }
    for (const Ge of De)
      Ge.restorePickingColors();
    return { result: ae, emptyInfo: ne.get(null) };
  }
  /**
   * Pick all objects within the given bounding box
   */
  // eslint-disable-next-line max-statements
  async _pickVisibleObjectsAsync({ layers: e, views: t, viewports: n, x: i, y: s, width: o = 1, height: l = 1, mode: u = "query", maxObjects: m = null, onViewportActive: y, effects: E }) {
    const P = this._getPickable(e);
    if (!P || n.length === 0)
      return [];
    this._resizeBuffer();
    const L = this.device.canvasContext.cssToDeviceRatio(), U = this.device.canvasContext.cssToDevicePixels([i, s], !0), V = U.x, q = U.y + U.height, j = this.device.canvasContext.cssToDevicePixels([i + o, s + l], !0), K = j.x + j.width, Y = j.y, de = {
      x: V,
      y: Y,
      // deviceTop and deviceRight represent the first pixel outside the desired rect
      width: K - V,
      height: q - Y
    }, ne = this._drawAndSample({
      layers: P,
      views: t,
      viewports: n,
      onViewportActive: y,
      deviceRect: de,
      cullRect: { x: i, y: s, width: o, height: l },
      effects: E,
      pass: `picking:${u}`
    }), ae = $C(ne), De = /* @__PURE__ */ new Map(), Ge = [], fe = Number.isFinite(m);
    for (let ve = 0; ve < ae.length && !(fe && Ge.length >= m); ve++) {
      const me = ae[ve];
      let X = {
        color: me.pickedColor,
        layer: null,
        index: me.pickedObjectIndex,
        picked: !0,
        x: i,
        y: s,
        pixelRatio: L
      };
      X = Wb({ layer: me.pickedLayer, info: X, mode: u });
      const re = X.layer.id;
      De.has(re) || De.set(re, /* @__PURE__ */ new Set());
      const Me = De.get(re), ot = X.object ?? X.index;
      Me.has(ot) || (Me.add(ot), Ge.push(X));
    }
    return Ge;
  }
  /**
   * Pick all objects within the given bounding box
   * @deprecated WebGL only
   */
  // eslint-disable-next-line max-statements
  _pickVisibleObjects({ layers: e, views: t, viewports: n, x: i, y: s, width: o = 1, height: l = 1, mode: u = "query", maxObjects: m = null, onViewportActive: y, effects: E }) {
    const P = this._getPickable(e);
    if (!P || n.length === 0)
      return [];
    this._resizeBuffer();
    const L = this.device.canvasContext.cssToDeviceRatio(), U = this.device.canvasContext.cssToDevicePixels([i, s], !0), V = U.x, q = U.y + U.height, j = this.device.canvasContext.cssToDevicePixels([i + o, s + l], !0), K = j.x + j.width, Y = j.y, de = {
      x: V,
      y: Y,
      // deviceTop and deviceRight represent the first pixel outside the desired rect
      width: K - V,
      height: q - Y
    }, ne = this._drawAndSample({
      layers: P,
      views: t,
      viewports: n,
      onViewportActive: y,
      deviceRect: de,
      cullRect: { x: i, y: s, width: o, height: l },
      effects: E,
      pass: `picking:${u}`
    }), ae = $C(ne), De = /* @__PURE__ */ new Map(), Ge = [], fe = Number.isFinite(m);
    for (let ve = 0; ve < ae.length && !(fe && Ge.length >= m); ve++) {
      const me = ae[ve];
      let X = {
        color: me.pickedColor,
        layer: null,
        index: me.pickedObjectIndex,
        picked: !0,
        x: i,
        y: s,
        pixelRatio: L
      };
      X = Wb({ layer: me.pickedLayer, info: X, mode: u });
      const re = X.layer.id;
      De.has(re) || De.set(re, /* @__PURE__ */ new Set());
      const Me = De.get(re), ot = X.object ?? X.index;
      Me.has(ot) || (Me.add(ot), Ge.push(X));
    }
    return Ge;
  }
  // Note: Implementation of the overloaded signatures above, TSDoc is on the signatures
  async _drawAndSampleAsync({ layers: e, views: t, viewports: n, onViewportActive: i, deviceRect: s, cullRect: o, effects: l, pass: u }, m = !1) {
    const y = m ? this.depthFBO : this.pickingFBO, E = {
      layers: e,
      layerFilter: this.layerFilter,
      views: t,
      viewports: n,
      onViewportActive: i,
      pickingFBO: y,
      deviceRect: s,
      cullRect: o,
      effects: l,
      pass: u,
      pickZ: m,
      preRenderStats: {},
      isPicking: !0
    };
    for (const K of l)
      K.useInPicking && (E.preRenderStats[K.id] = K.preRender(E));
    const { decodePickingColor: P } = this.pickLayersPass.render(E), { x: L, y: U, width: V, height: q } = s, j = new (m ? Float32Array : Uint8Array)(V * q * 4);
    return this.device.readPixelsToArrayWebGL(y, {
      sourceX: L,
      sourceY: U,
      sourceWidth: V,
      sourceHeight: q,
      target: j
    }), { pickedColors: j, decodePickingColor: P };
  }
  // Note: Implementation of the overloaded signatures above, TSDoc is on the signatures
  _drawAndSample({ layers: e, views: t, viewports: n, onViewportActive: i, deviceRect: s, cullRect: o, effects: l, pass: u }, m = !1) {
    const y = m ? this.depthFBO : this.pickingFBO, E = {
      layers: e,
      layerFilter: this.layerFilter,
      views: t,
      viewports: n,
      onViewportActive: i,
      pickingFBO: y,
      deviceRect: s,
      cullRect: o,
      effects: l,
      pass: u,
      pickZ: m,
      preRenderStats: {},
      isPicking: !0
    };
    for (const K of l)
      K.useInPicking && (E.preRenderStats[K.id] = K.preRender(E));
    const { decodePickingColor: P } = this.pickLayersPass.render(E), { x: L, y: U, width: V, height: q } = s, j = new (m ? Float32Array : Uint8Array)(V * q * 4);
    return this.device.readPixelsToArrayWebGL(y, {
      sourceX: L,
      sourceY: U,
      sourceWidth: V,
      sourceHeight: q,
      target: j
    }), { pickedColors: j, decodePickingColor: P };
  }
  /**
   * Calculate a picking rect centered on deviceX and deviceY and clipped to device
   * @returns null if pixel is outside of device
   */
  _getPickingRect({ deviceX: e, deviceY: t, deviceRadius: n, deviceWidth: i, deviceHeight: s }) {
    const o = Math.max(0, e - n), l = Math.max(0, t - n), u = Math.min(i, e + n + 1) - o, m = Math.min(s, t + n + 1) - l;
    return u <= 0 || m <= 0 ? null : { x: o, y: l, width: u, height: m };
  }
}
const E$ = {
  "top-left": { top: 0, left: 0 },
  "top-right": { top: 0, right: 0 },
  "bottom-left": { bottom: 0, left: 0 },
  "bottom-right": { bottom: 0, right: 0 },
  fill: { top: 0, left: 0, bottom: 0, right: 0 }
}, C$ = "top-left", XC = "__root";
class S$ {
  constructor({ deck: e, parentElement: t }) {
    this.defaultWidgets = [], this.widgets = [], this.resolvedWidgets = [], this.containers = {}, this.lastViewports = {}, this.deck = e, t?.classList.add("deck-widget-container"), this.parentElement = t;
  }
  getWidgets() {
    return this.resolvedWidgets;
  }
  /** Declarative API to configure widgets */
  setProps(e) {
    if (e.widgets && !Fi(e.widgets, this.widgets, 1)) {
      const t = e.widgets.filter(Boolean);
      this._setWidgets(t);
    }
  }
  finalize() {
    for (const e of this.getWidgets())
      this._removeWidget(e);
    this.defaultWidgets.length = 0, this.resolvedWidgets.length = 0;
    for (const e in this.containers)
      this.containers[e].remove();
  }
  /** Imperative API. Widgets added this way are not affected by the declarative prop. */
  addDefault(e) {
    this.defaultWidgets.find((t) => t.id === e.id) || (this._addWidget(e), this.defaultWidgets.push(e), this._setWidgets(this.widgets));
  }
  onRedraw({ viewports: e, layers: t }) {
    const n = e.reduce((i, s) => (i[s.id] = s, i), {});
    for (const i of this.getWidgets()) {
      const { viewId: s } = i;
      if (s) {
        const o = n[s];
        o && (i.onViewportChange && i.onViewportChange(o), i.onRedraw?.({ viewports: [o], layers: t }));
      } else {
        if (i.onViewportChange)
          for (const o of e)
            i.onViewportChange(o);
        i.onRedraw?.({ viewports: e, layers: t });
      }
    }
    this.lastViewports = n, this._updateContainers();
  }
  onHover(e, t) {
    for (const n of this.getWidgets()) {
      const { viewId: i } = n;
      (!i || i === e.viewport?.id) && n.onHover?.(e, t);
    }
  }
  onEvent(e, t) {
    const n = kb[t.type];
    if (n)
      for (const i of this.getWidgets()) {
        const { viewId: s } = i;
        (!s || s === e.viewport?.id) && i[n]?.(e, t);
      }
  }
  // INTERNAL METHODS
  /**
   * Resolve widgets from the declarative prop
   * Initialize new widgets and remove old ones
   * Update props of existing widgets
   */
  _setWidgets(e) {
    const t = {};
    for (const n of this.resolvedWidgets)
      t[n.id] = n;
    this.resolvedWidgets.length = 0;
    for (const n of this.defaultWidgets)
      t[n.id] = null, this.resolvedWidgets.push(n);
    for (let n of e) {
      const i = t[n.id];
      i ? /* Widget placement changed */ i.viewId !== n.viewId || i.placement !== n.placement ? (this._removeWidget(i), this._addWidget(n)) : n !== i && (i.setProps(n.props), n = i) : this._addWidget(n), t[n.id] = null, this.resolvedWidgets.push(n);
    }
    for (const n in t) {
      const i = t[n];
      i && this._removeWidget(i);
    }
    this.widgets = e;
  }
  /** Initialize new widget */
  _addWidget(e) {
    const { viewId: t = null, placement: n = C$ } = e;
    e.widgetManager = this, e.deck = this.deck, e.rootElement = e._onAdd({ deck: this.deck, viewId: t }), e.rootElement && this._getContainer(t, n).append(e.rootElement), e.updateHTML();
  }
  /** Destroy an old widget */
  _removeWidget(e) {
    e.onRemove?.(), e.rootElement && e.rootElement.remove(), e.rootElement = void 0, e.deck = void 0, e.widgetManager = void 0;
  }
  /** Get a container element based on view and placement */
  _getContainer(e, t) {
    const n = e || XC;
    let i = this.containers[n];
    i || (i = document.createElement("div"), i.style.pointerEvents = "none", i.style.position = "absolute", i.style.overflow = "hidden", this.parentElement?.append(i), this.containers[n] = i);
    let s = i.querySelector(`.${t}`);
    return s || (s = globalThis.document.createElement("div"), s.className = t, s.style.position = "absolute", s.style.zIndex = "2", Object.assign(s.style, E$[t]), i.append(s)), s;
  }
  _updateContainers() {
    const e = this.deck.width, t = this.deck.height;
    for (const n in this.containers) {
      const i = this.lastViewports[n] || null, s = n === XC || i, o = this.containers[n];
      s ? (o.style.display = "block", o.style.left = `${i ? i.x : 0}px`, o.style.top = `${i ? i.y : 0}px`, o.style.width = `${i ? i.width : e}px`, o.style.height = `${i ? i.height : t}px`) : o.style.display = "none";
    }
  }
}
function ZC(r, e) {
  e && Object.entries(e).map(([t, n]) => {
    t.startsWith("--") ? r.style.setProperty(t, n) : r.style[t] = n;
  });
}
function I$(r, e) {
  e && Object.keys(e).map((t) => {
    t.startsWith("--") ? r.style.removeProperty(t) : r.style[t] = "";
  });
}
class Wx {
  constructor(e) {
    this.viewId = null, this.props = {
      // @ts-expect-error `defaultProps` may not exist on constructor
      ...this.constructor.defaultProps,
      ...e
    }, this.id = this.props.id;
  }
  /** Called to update widget options */
  setProps(e) {
    const t = this.props, n = this.rootElement;
    n && t.className !== e.className && (t.className && n.classList.remove(t.className), e.className && n.classList.add(e.className)), n && !Fi(t.style, e.style, 1) && (I$(n, t.style), ZC(n, e.style)), Object.assign(this.props, e), this.updateHTML();
  }
  /** Update the HTML to reflect latest props and state */
  updateHTML() {
    this.rootElement && this.onRenderHTML(this.rootElement);
  }
  // @note empty method calls have an overhead in V8 but it is very low, ~1ns
  /**
   * Common utility to create the root DOM element for this widget
   * Configures the top-level styles and adds basic class names for theming
   * @returns an UI element that should be appended to the Deck container
   */
  onCreateRootElement() {
    const e = [
      // Add class names for theming
      "deck-widget",
      this.className,
      // plus any app-supplied class name
      this.props.className
    ], t = document.createElement("div");
    return e.filter((n) => typeof n == "string" && n.length > 0).forEach((n) => t.classList.add(n)), ZC(t, this.props.style), t;
  }
  /** Internal API called by Deck when the widget is first added to a Deck instance */
  _onAdd(e) {
    return this.onAdd(e) ?? this.onCreateRootElement();
  }
  /** Overridable by subclass - called when the widget is first added to a Deck instance
   * @returns an optional UI element that should be appended to the Deck container
   */
  onAdd(e) {
  }
  /** Called when the widget is removed */
  onRemove() {
  }
  // deck integration - Event hooks
  /** Called when the containing view is changed */
  onViewportChange(e) {
  }
  /** Called when the containing view is redrawn */
  onRedraw(e) {
  }
  /** Called when a hover event occurs */
  onHover(e, t) {
  }
  /** Called when a click event occurs */
  onClick(e, t) {
  }
  /** Called when a drag event occurs */
  onDrag(e, t) {
  }
  /** Called when a dragstart event occurs */
  onDragStart(e, t) {
  }
  /** Called when a dragend event occurs */
  onDragEnd(e, t) {
  }
}
Wx.defaultProps = {
  id: "widget",
  style: {},
  className: ""
};
const P$ = {
  zIndex: "1",
  position: "absolute",
  pointerEvents: "none",
  color: "#a0a7b4",
  backgroundColor: "#29323c",
  padding: "10px",
  top: "0",
  left: "0",
  display: "none"
};
class c6 extends Wx {
  constructor(e = {}) {
    super(e), this.id = "default-tooltip", this.placement = "fill", this.className = "deck-tooltip", this.isVisible = !1, this.setProps(e);
  }
  // TODO(ib) - does this really need to be overridden?
  onCreateRootElement() {
    const e = document.createElement("div");
    return e.className = this.className, Object.assign(e.style, P$), e;
  }
  onRenderHTML(e) {
  }
  onViewportChange(e) {
    this.isVisible && e.id === this.lastViewport?.id && e !== this.lastViewport && this.setTooltip(null);
  }
  onHover(e) {
    const { deck: t } = this, n = t && t.props.getTooltip;
    if (!n)
      return;
    const i = n(e);
    this.lastViewport = e.viewport, this.setTooltip(i, e.x, e.y);
  }
  setTooltip(e, t, n) {
    const i = this.rootElement;
    if (i) {
      if (typeof e == "string")
        i.innerText = e;
      else if (e)
        e.text && (i.innerText = e.text), e.html && (i.innerHTML = e.html), e.className && (i.className = e.className);
      else {
        this.isVisible = !1, i.style.display = "none";
        return;
      }
      this.isVisible = !0, i.style.display = "block", i.style.transform = `translate(${t}px, ${n}px)`, e && typeof e == "object" && "style" in e && Object.assign(i.style, e.style);
    }
  }
}
c6.defaultProps = {
  ...Wx.defaultProps
};
var qd;
(function(r) {
  r[r.DEPTH_BUFFER_BIT = 256] = "DEPTH_BUFFER_BIT", r[r.STENCIL_BUFFER_BIT = 1024] = "STENCIL_BUFFER_BIT", r[r.COLOR_BUFFER_BIT = 16384] = "COLOR_BUFFER_BIT", r[r.POINTS = 0] = "POINTS", r[r.LINES = 1] = "LINES", r[r.LINE_LOOP = 2] = "LINE_LOOP", r[r.LINE_STRIP = 3] = "LINE_STRIP", r[r.TRIANGLES = 4] = "TRIANGLES", r[r.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", r[r.TRIANGLE_FAN = 6] = "TRIANGLE_FAN", r[r.ZERO = 0] = "ZERO", r[r.ONE = 1] = "ONE", r[r.SRC_COLOR = 768] = "SRC_COLOR", r[r.ONE_MINUS_SRC_COLOR = 769] = "ONE_MINUS_SRC_COLOR", r[r.SRC_ALPHA = 770] = "SRC_ALPHA", r[r.ONE_MINUS_SRC_ALPHA = 771] = "ONE_MINUS_SRC_ALPHA", r[r.DST_ALPHA = 772] = "DST_ALPHA", r[r.ONE_MINUS_DST_ALPHA = 773] = "ONE_MINUS_DST_ALPHA", r[r.DST_COLOR = 774] = "DST_COLOR", r[r.ONE_MINUS_DST_COLOR = 775] = "ONE_MINUS_DST_COLOR", r[r.SRC_ALPHA_SATURATE = 776] = "SRC_ALPHA_SATURATE", r[r.CONSTANT_COLOR = 32769] = "CONSTANT_COLOR", r[r.ONE_MINUS_CONSTANT_COLOR = 32770] = "ONE_MINUS_CONSTANT_COLOR", r[r.CONSTANT_ALPHA = 32771] = "CONSTANT_ALPHA", r[r.ONE_MINUS_CONSTANT_ALPHA = 32772] = "ONE_MINUS_CONSTANT_ALPHA", r[r.FUNC_ADD = 32774] = "FUNC_ADD", r[r.FUNC_SUBTRACT = 32778] = "FUNC_SUBTRACT", r[r.FUNC_REVERSE_SUBTRACT = 32779] = "FUNC_REVERSE_SUBTRACT", r[r.BLEND_EQUATION = 32777] = "BLEND_EQUATION", r[r.BLEND_EQUATION_RGB = 32777] = "BLEND_EQUATION_RGB", r[r.BLEND_EQUATION_ALPHA = 34877] = "BLEND_EQUATION_ALPHA", r[r.BLEND_DST_RGB = 32968] = "BLEND_DST_RGB", r[r.BLEND_SRC_RGB = 32969] = "BLEND_SRC_RGB", r[r.BLEND_DST_ALPHA = 32970] = "BLEND_DST_ALPHA", r[r.BLEND_SRC_ALPHA = 32971] = "BLEND_SRC_ALPHA", r[r.BLEND_COLOR = 32773] = "BLEND_COLOR", r[r.ARRAY_BUFFER_BINDING = 34964] = "ARRAY_BUFFER_BINDING", r[r.ELEMENT_ARRAY_BUFFER_BINDING = 34965] = "ELEMENT_ARRAY_BUFFER_BINDING", r[r.LINE_WIDTH = 2849] = "LINE_WIDTH", r[r.ALIASED_POINT_SIZE_RANGE = 33901] = "ALIASED_POINT_SIZE_RANGE", r[r.ALIASED_LINE_WIDTH_RANGE = 33902] = "ALIASED_LINE_WIDTH_RANGE", r[r.CULL_FACE_MODE = 2885] = "CULL_FACE_MODE", r[r.FRONT_FACE = 2886] = "FRONT_FACE", r[r.DEPTH_RANGE = 2928] = "DEPTH_RANGE", r[r.DEPTH_WRITEMASK = 2930] = "DEPTH_WRITEMASK", r[r.DEPTH_CLEAR_VALUE = 2931] = "DEPTH_CLEAR_VALUE", r[r.DEPTH_FUNC = 2932] = "DEPTH_FUNC", r[r.STENCIL_CLEAR_VALUE = 2961] = "STENCIL_CLEAR_VALUE", r[r.STENCIL_FUNC = 2962] = "STENCIL_FUNC", r[r.STENCIL_FAIL = 2964] = "STENCIL_FAIL", r[r.STENCIL_PASS_DEPTH_FAIL = 2965] = "STENCIL_PASS_DEPTH_FAIL", r[r.STENCIL_PASS_DEPTH_PASS = 2966] = "STENCIL_PASS_DEPTH_PASS", r[r.STENCIL_REF = 2967] = "STENCIL_REF", r[r.STENCIL_VALUE_MASK = 2963] = "STENCIL_VALUE_MASK", r[r.STENCIL_WRITEMASK = 2968] = "STENCIL_WRITEMASK", r[r.STENCIL_BACK_FUNC = 34816] = "STENCIL_BACK_FUNC", r[r.STENCIL_BACK_FAIL = 34817] = "STENCIL_BACK_FAIL", r[r.STENCIL_BACK_PASS_DEPTH_FAIL = 34818] = "STENCIL_BACK_PASS_DEPTH_FAIL", r[r.STENCIL_BACK_PASS_DEPTH_PASS = 34819] = "STENCIL_BACK_PASS_DEPTH_PASS", r[r.STENCIL_BACK_REF = 36003] = "STENCIL_BACK_REF", r[r.STENCIL_BACK_VALUE_MASK = 36004] = "STENCIL_BACK_VALUE_MASK", r[r.STENCIL_BACK_WRITEMASK = 36005] = "STENCIL_BACK_WRITEMASK", r[r.VIEWPORT = 2978] = "VIEWPORT", r[r.SCISSOR_BOX = 3088] = "SCISSOR_BOX", r[r.COLOR_CLEAR_VALUE = 3106] = "COLOR_CLEAR_VALUE", r[r.COLOR_WRITEMASK = 3107] = "COLOR_WRITEMASK", r[r.UNPACK_ALIGNMENT = 3317] = "UNPACK_ALIGNMENT", r[r.PACK_ALIGNMENT = 3333] = "PACK_ALIGNMENT", r[r.MAX_TEXTURE_SIZE = 3379] = "MAX_TEXTURE_SIZE", r[r.MAX_VIEWPORT_DIMS = 3386] = "MAX_VIEWPORT_DIMS", r[r.SUBPIXEL_BITS = 3408] = "SUBPIXEL_BITS", r[r.RED_BITS = 3410] = "RED_BITS", r[r.GREEN_BITS = 3411] = "GREEN_BITS", r[r.BLUE_BITS = 3412] = "BLUE_BITS", r[r.ALPHA_BITS = 3413] = "ALPHA_BITS", r[r.DEPTH_BITS = 3414] = "DEPTH_BITS", r[r.STENCIL_BITS = 3415] = "STENCIL_BITS", r[r.POLYGON_OFFSET_UNITS = 10752] = "POLYGON_OFFSET_UNITS", r[r.POLYGON_OFFSET_FACTOR = 32824] = "POLYGON_OFFSET_FACTOR", r[r.TEXTURE_BINDING_2D = 32873] = "TEXTURE_BINDING_2D", r[r.SAMPLE_BUFFERS = 32936] = "SAMPLE_BUFFERS", r[r.SAMPLES = 32937] = "SAMPLES", r[r.SAMPLE_COVERAGE_VALUE = 32938] = "SAMPLE_COVERAGE_VALUE", r[r.SAMPLE_COVERAGE_INVERT = 32939] = "SAMPLE_COVERAGE_INVERT", r[r.COMPRESSED_TEXTURE_FORMATS = 34467] = "COMPRESSED_TEXTURE_FORMATS", r[r.VENDOR = 7936] = "VENDOR", r[r.RENDERER = 7937] = "RENDERER", r[r.VERSION = 7938] = "VERSION", r[r.IMPLEMENTATION_COLOR_READ_TYPE = 35738] = "IMPLEMENTATION_COLOR_READ_TYPE", r[r.IMPLEMENTATION_COLOR_READ_FORMAT = 35739] = "IMPLEMENTATION_COLOR_READ_FORMAT", r[r.BROWSER_DEFAULT_WEBGL = 37444] = "BROWSER_DEFAULT_WEBGL", r[r.STATIC_DRAW = 35044] = "STATIC_DRAW", r[r.STREAM_DRAW = 35040] = "STREAM_DRAW", r[r.DYNAMIC_DRAW = 35048] = "DYNAMIC_DRAW", r[r.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", r[r.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", r[r.BUFFER_SIZE = 34660] = "BUFFER_SIZE", r[r.BUFFER_USAGE = 34661] = "BUFFER_USAGE", r[r.CURRENT_VERTEX_ATTRIB = 34342] = "CURRENT_VERTEX_ATTRIB", r[r.VERTEX_ATTRIB_ARRAY_ENABLED = 34338] = "VERTEX_ATTRIB_ARRAY_ENABLED", r[r.VERTEX_ATTRIB_ARRAY_SIZE = 34339] = "VERTEX_ATTRIB_ARRAY_SIZE", r[r.VERTEX_ATTRIB_ARRAY_STRIDE = 34340] = "VERTEX_ATTRIB_ARRAY_STRIDE", r[r.VERTEX_ATTRIB_ARRAY_TYPE = 34341] = "VERTEX_ATTRIB_ARRAY_TYPE", r[r.VERTEX_ATTRIB_ARRAY_NORMALIZED = 34922] = "VERTEX_ATTRIB_ARRAY_NORMALIZED", r[r.VERTEX_ATTRIB_ARRAY_POINTER = 34373] = "VERTEX_ATTRIB_ARRAY_POINTER", r[r.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 34975] = "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING", r[r.CULL_FACE = 2884] = "CULL_FACE", r[r.FRONT = 1028] = "FRONT", r[r.BACK = 1029] = "BACK", r[r.FRONT_AND_BACK = 1032] = "FRONT_AND_BACK", r[r.BLEND = 3042] = "BLEND", r[r.DEPTH_TEST = 2929] = "DEPTH_TEST", r[r.DITHER = 3024] = "DITHER", r[r.POLYGON_OFFSET_FILL = 32823] = "POLYGON_OFFSET_FILL", r[r.SAMPLE_ALPHA_TO_COVERAGE = 32926] = "SAMPLE_ALPHA_TO_COVERAGE", r[r.SAMPLE_COVERAGE = 32928] = "SAMPLE_COVERAGE", r[r.SCISSOR_TEST = 3089] = "SCISSOR_TEST", r[r.STENCIL_TEST = 2960] = "STENCIL_TEST", r[r.NO_ERROR = 0] = "NO_ERROR", r[r.INVALID_ENUM = 1280] = "INVALID_ENUM", r[r.INVALID_VALUE = 1281] = "INVALID_VALUE", r[r.INVALID_OPERATION = 1282] = "INVALID_OPERATION", r[r.OUT_OF_MEMORY = 1285] = "OUT_OF_MEMORY", r[r.CONTEXT_LOST_WEBGL = 37442] = "CONTEXT_LOST_WEBGL", r[r.CW = 2304] = "CW", r[r.CCW = 2305] = "CCW", r[r.DONT_CARE = 4352] = "DONT_CARE", r[r.FASTEST = 4353] = "FASTEST", r[r.NICEST = 4354] = "NICEST", r[r.GENERATE_MIPMAP_HINT = 33170] = "GENERATE_MIPMAP_HINT", r[r.BYTE = 5120] = "BYTE", r[r.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", r[r.SHORT = 5122] = "SHORT", r[r.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", r[r.INT = 5124] = "INT", r[r.UNSIGNED_INT = 5125] = "UNSIGNED_INT", r[r.FLOAT = 5126] = "FLOAT", r[r.DOUBLE = 5130] = "DOUBLE", r[r.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", r[r.ALPHA = 6406] = "ALPHA", r[r.RGB = 6407] = "RGB", r[r.RGBA = 6408] = "RGBA", r[r.LUMINANCE = 6409] = "LUMINANCE", r[r.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", r[r.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", r[r.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", r[r.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", r[r.FRAGMENT_SHADER = 35632] = "FRAGMENT_SHADER", r[r.VERTEX_SHADER = 35633] = "VERTEX_SHADER", r[r.COMPILE_STATUS = 35713] = "COMPILE_STATUS", r[r.DELETE_STATUS = 35712] = "DELETE_STATUS", r[r.LINK_STATUS = 35714] = "LINK_STATUS", r[r.VALIDATE_STATUS = 35715] = "VALIDATE_STATUS", r[r.ATTACHED_SHADERS = 35717] = "ATTACHED_SHADERS", r[r.ACTIVE_ATTRIBUTES = 35721] = "ACTIVE_ATTRIBUTES", r[r.ACTIVE_UNIFORMS = 35718] = "ACTIVE_UNIFORMS", r[r.MAX_VERTEX_ATTRIBS = 34921] = "MAX_VERTEX_ATTRIBS", r[r.MAX_VERTEX_UNIFORM_VECTORS = 36347] = "MAX_VERTEX_UNIFORM_VECTORS", r[r.MAX_VARYING_VECTORS = 36348] = "MAX_VARYING_VECTORS", r[r.MAX_COMBINED_TEXTURE_IMAGE_UNITS = 35661] = "MAX_COMBINED_TEXTURE_IMAGE_UNITS", r[r.MAX_VERTEX_TEXTURE_IMAGE_UNITS = 35660] = "MAX_VERTEX_TEXTURE_IMAGE_UNITS", r[r.MAX_TEXTURE_IMAGE_UNITS = 34930] = "MAX_TEXTURE_IMAGE_UNITS", r[r.MAX_FRAGMENT_UNIFORM_VECTORS = 36349] = "MAX_FRAGMENT_UNIFORM_VECTORS", r[r.SHADER_TYPE = 35663] = "SHADER_TYPE", r[r.SHADING_LANGUAGE_VERSION = 35724] = "SHADING_LANGUAGE_VERSION", r[r.CURRENT_PROGRAM = 35725] = "CURRENT_PROGRAM", r[r.NEVER = 512] = "NEVER", r[r.LESS = 513] = "LESS", r[r.EQUAL = 514] = "EQUAL", r[r.LEQUAL = 515] = "LEQUAL", r[r.GREATER = 516] = "GREATER", r[r.NOTEQUAL = 517] = "NOTEQUAL", r[r.GEQUAL = 518] = "GEQUAL", r[r.ALWAYS = 519] = "ALWAYS", r[r.KEEP = 7680] = "KEEP", r[r.REPLACE = 7681] = "REPLACE", r[r.INCR = 7682] = "INCR", r[r.DECR = 7683] = "DECR", r[r.INVERT = 5386] = "INVERT", r[r.INCR_WRAP = 34055] = "INCR_WRAP", r[r.DECR_WRAP = 34056] = "DECR_WRAP", r[r.NEAREST = 9728] = "NEAREST", r[r.LINEAR = 9729] = "LINEAR", r[r.NEAREST_MIPMAP_NEAREST = 9984] = "NEAREST_MIPMAP_NEAREST", r[r.LINEAR_MIPMAP_NEAREST = 9985] = "LINEAR_MIPMAP_NEAREST", r[r.NEAREST_MIPMAP_LINEAR = 9986] = "NEAREST_MIPMAP_LINEAR", r[r.LINEAR_MIPMAP_LINEAR = 9987] = "LINEAR_MIPMAP_LINEAR", r[r.TEXTURE_MAG_FILTER = 10240] = "TEXTURE_MAG_FILTER", r[r.TEXTURE_MIN_FILTER = 10241] = "TEXTURE_MIN_FILTER", r[r.TEXTURE_WRAP_S = 10242] = "TEXTURE_WRAP_S", r[r.TEXTURE_WRAP_T = 10243] = "TEXTURE_WRAP_T", r[r.TEXTURE_2D = 3553] = "TEXTURE_2D", r[r.TEXTURE = 5890] = "TEXTURE", r[r.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", r[r.TEXTURE_BINDING_CUBE_MAP = 34068] = "TEXTURE_BINDING_CUBE_MAP", r[r.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", r[r.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", r[r.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", r[r.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", r[r.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", r[r.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", r[r.MAX_CUBE_MAP_TEXTURE_SIZE = 34076] = "MAX_CUBE_MAP_TEXTURE_SIZE", r[r.TEXTURE0 = 33984] = "TEXTURE0", r[r.ACTIVE_TEXTURE = 34016] = "ACTIVE_TEXTURE", r[r.REPEAT = 10497] = "REPEAT", r[r.CLAMP_TO_EDGE = 33071] = "CLAMP_TO_EDGE", r[r.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT", r[r.TEXTURE_WIDTH = 4096] = "TEXTURE_WIDTH", r[r.TEXTURE_HEIGHT = 4097] = "TEXTURE_HEIGHT", r[r.FLOAT_VEC2 = 35664] = "FLOAT_VEC2", r[r.FLOAT_VEC3 = 35665] = "FLOAT_VEC3", r[r.FLOAT_VEC4 = 35666] = "FLOAT_VEC4", r[r.INT_VEC2 = 35667] = "INT_VEC2", r[r.INT_VEC3 = 35668] = "INT_VEC3", r[r.INT_VEC4 = 35669] = "INT_VEC4", r[r.BOOL = 35670] = "BOOL", r[r.BOOL_VEC2 = 35671] = "BOOL_VEC2", r[r.BOOL_VEC3 = 35672] = "BOOL_VEC3", r[r.BOOL_VEC4 = 35673] = "BOOL_VEC4", r[r.FLOAT_MAT2 = 35674] = "FLOAT_MAT2", r[r.FLOAT_MAT3 = 35675] = "FLOAT_MAT3", r[r.FLOAT_MAT4 = 35676] = "FLOAT_MAT4", r[r.SAMPLER_2D = 35678] = "SAMPLER_2D", r[r.SAMPLER_CUBE = 35680] = "SAMPLER_CUBE", r[r.LOW_FLOAT = 36336] = "LOW_FLOAT", r[r.MEDIUM_FLOAT = 36337] = "MEDIUM_FLOAT", r[r.HIGH_FLOAT = 36338] = "HIGH_FLOAT", r[r.LOW_INT = 36339] = "LOW_INT", r[r.MEDIUM_INT = 36340] = "MEDIUM_INT", r[r.HIGH_INT = 36341] = "HIGH_INT", r[r.FRAMEBUFFER = 36160] = "FRAMEBUFFER", r[r.RENDERBUFFER = 36161] = "RENDERBUFFER", r[r.RGBA4 = 32854] = "RGBA4", r[r.RGB5_A1 = 32855] = "RGB5_A1", r[r.RGB565 = 36194] = "RGB565", r[r.DEPTH_COMPONENT16 = 33189] = "DEPTH_COMPONENT16", r[r.STENCIL_INDEX = 6401] = "STENCIL_INDEX", r[r.STENCIL_INDEX8 = 36168] = "STENCIL_INDEX8", r[r.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", r[r.RENDERBUFFER_WIDTH = 36162] = "RENDERBUFFER_WIDTH", r[r.RENDERBUFFER_HEIGHT = 36163] = "RENDERBUFFER_HEIGHT", r[r.RENDERBUFFER_INTERNAL_FORMAT = 36164] = "RENDERBUFFER_INTERNAL_FORMAT", r[r.RENDERBUFFER_RED_SIZE = 36176] = "RENDERBUFFER_RED_SIZE", r[r.RENDERBUFFER_GREEN_SIZE = 36177] = "RENDERBUFFER_GREEN_SIZE", r[r.RENDERBUFFER_BLUE_SIZE = 36178] = "RENDERBUFFER_BLUE_SIZE", r[r.RENDERBUFFER_ALPHA_SIZE = 36179] = "RENDERBUFFER_ALPHA_SIZE", r[r.RENDERBUFFER_DEPTH_SIZE = 36180] = "RENDERBUFFER_DEPTH_SIZE", r[r.RENDERBUFFER_STENCIL_SIZE = 36181] = "RENDERBUFFER_STENCIL_SIZE", r[r.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 36048] = "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE", r[r.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 36049] = "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME", r[r.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 36050] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL", r[r.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 36051] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE", r[r.COLOR_ATTACHMENT0 = 36064] = "COLOR_ATTACHMENT0", r[r.DEPTH_ATTACHMENT = 36096] = "DEPTH_ATTACHMENT", r[r.STENCIL_ATTACHMENT = 36128] = "STENCIL_ATTACHMENT", r[r.DEPTH_STENCIL_ATTACHMENT = 33306] = "DEPTH_STENCIL_ATTACHMENT", r[r.NONE = 0] = "NONE", r[r.FRAMEBUFFER_COMPLETE = 36053] = "FRAMEBUFFER_COMPLETE", r[r.FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 36054] = "FRAMEBUFFER_INCOMPLETE_ATTACHMENT", r[r.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 36055] = "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT", r[r.FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 36057] = "FRAMEBUFFER_INCOMPLETE_DIMENSIONS", r[r.FRAMEBUFFER_UNSUPPORTED = 36061] = "FRAMEBUFFER_UNSUPPORTED", r[r.FRAMEBUFFER_BINDING = 36006] = "FRAMEBUFFER_BINDING", r[r.RENDERBUFFER_BINDING = 36007] = "RENDERBUFFER_BINDING", r[r.READ_FRAMEBUFFER = 36008] = "READ_FRAMEBUFFER", r[r.DRAW_FRAMEBUFFER = 36009] = "DRAW_FRAMEBUFFER", r[r.MAX_RENDERBUFFER_SIZE = 34024] = "MAX_RENDERBUFFER_SIZE", r[r.INVALID_FRAMEBUFFER_OPERATION = 1286] = "INVALID_FRAMEBUFFER_OPERATION", r[r.UNPACK_FLIP_Y_WEBGL = 37440] = "UNPACK_FLIP_Y_WEBGL", r[r.UNPACK_PREMULTIPLY_ALPHA_WEBGL = 37441] = "UNPACK_PREMULTIPLY_ALPHA_WEBGL", r[r.UNPACK_COLORSPACE_CONVERSION_WEBGL = 37443] = "UNPACK_COLORSPACE_CONVERSION_WEBGL", r[r.READ_BUFFER = 3074] = "READ_BUFFER", r[r.UNPACK_ROW_LENGTH = 3314] = "UNPACK_ROW_LENGTH", r[r.UNPACK_SKIP_ROWS = 3315] = "UNPACK_SKIP_ROWS", r[r.UNPACK_SKIP_PIXELS = 3316] = "UNPACK_SKIP_PIXELS", r[r.PACK_ROW_LENGTH = 3330] = "PACK_ROW_LENGTH", r[r.PACK_SKIP_ROWS = 3331] = "PACK_SKIP_ROWS", r[r.PACK_SKIP_PIXELS = 3332] = "PACK_SKIP_PIXELS", r[r.TEXTURE_BINDING_3D = 32874] = "TEXTURE_BINDING_3D", r[r.UNPACK_SKIP_IMAGES = 32877] = "UNPACK_SKIP_IMAGES", r[r.UNPACK_IMAGE_HEIGHT = 32878] = "UNPACK_IMAGE_HEIGHT", r[r.MAX_3D_TEXTURE_SIZE = 32883] = "MAX_3D_TEXTURE_SIZE", r[r.MAX_ELEMENTS_VERTICES = 33e3] = "MAX_ELEMENTS_VERTICES", r[r.MAX_ELEMENTS_INDICES = 33001] = "MAX_ELEMENTS_INDICES", r[r.MAX_TEXTURE_LOD_BIAS = 34045] = "MAX_TEXTURE_LOD_BIAS", r[r.MAX_FRAGMENT_UNIFORM_COMPONENTS = 35657] = "MAX_FRAGMENT_UNIFORM_COMPONENTS", r[r.MAX_VERTEX_UNIFORM_COMPONENTS = 35658] = "MAX_VERTEX_UNIFORM_COMPONENTS", r[r.MAX_ARRAY_TEXTURE_LAYERS = 35071] = "MAX_ARRAY_TEXTURE_LAYERS", r[r.MIN_PROGRAM_TEXEL_OFFSET = 35076] = "MIN_PROGRAM_TEXEL_OFFSET", r[r.MAX_PROGRAM_TEXEL_OFFSET = 35077] = "MAX_PROGRAM_TEXEL_OFFSET", r[r.MAX_VARYING_COMPONENTS = 35659] = "MAX_VARYING_COMPONENTS", r[r.FRAGMENT_SHADER_DERIVATIVE_HINT = 35723] = "FRAGMENT_SHADER_DERIVATIVE_HINT", r[r.RASTERIZER_DISCARD = 35977] = "RASTERIZER_DISCARD", r[r.VERTEX_ARRAY_BINDING = 34229] = "VERTEX_ARRAY_BINDING", r[r.MAX_VERTEX_OUTPUT_COMPONENTS = 37154] = "MAX_VERTEX_OUTPUT_COMPONENTS", r[r.MAX_FRAGMENT_INPUT_COMPONENTS = 37157] = "MAX_FRAGMENT_INPUT_COMPONENTS", r[r.MAX_SERVER_WAIT_TIMEOUT = 37137] = "MAX_SERVER_WAIT_TIMEOUT", r[r.MAX_ELEMENT_INDEX = 36203] = "MAX_ELEMENT_INDEX", r[r.RED = 6403] = "RED", r[r.RGB8 = 32849] = "RGB8", r[r.RGBA8 = 32856] = "RGBA8", r[r.RGB10_A2 = 32857] = "RGB10_A2", r[r.TEXTURE_3D = 32879] = "TEXTURE_3D", r[r.TEXTURE_WRAP_R = 32882] = "TEXTURE_WRAP_R", r[r.TEXTURE_MIN_LOD = 33082] = "TEXTURE_MIN_LOD", r[r.TEXTURE_MAX_LOD = 33083] = "TEXTURE_MAX_LOD", r[r.TEXTURE_BASE_LEVEL = 33084] = "TEXTURE_BASE_LEVEL", r[r.TEXTURE_MAX_LEVEL = 33085] = "TEXTURE_MAX_LEVEL", r[r.TEXTURE_COMPARE_MODE = 34892] = "TEXTURE_COMPARE_MODE", r[r.TEXTURE_COMPARE_FUNC = 34893] = "TEXTURE_COMPARE_FUNC", r[r.SRGB = 35904] = "SRGB", r[r.SRGB8 = 35905] = "SRGB8", r[r.SRGB8_ALPHA8 = 35907] = "SRGB8_ALPHA8", r[r.COMPARE_REF_TO_TEXTURE = 34894] = "COMPARE_REF_TO_TEXTURE", r[r.RGBA32F = 34836] = "RGBA32F", r[r.RGB32F = 34837] = "RGB32F", r[r.RGBA16F = 34842] = "RGBA16F", r[r.RGB16F = 34843] = "RGB16F", r[r.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", r[r.TEXTURE_BINDING_2D_ARRAY = 35869] = "TEXTURE_BINDING_2D_ARRAY", r[r.R11F_G11F_B10F = 35898] = "R11F_G11F_B10F", r[r.RGB9_E5 = 35901] = "RGB9_E5", r[r.RGBA32UI = 36208] = "RGBA32UI", r[r.RGB32UI = 36209] = "RGB32UI", r[r.RGBA16UI = 36214] = "RGBA16UI", r[r.RGB16UI = 36215] = "RGB16UI", r[r.RGBA8UI = 36220] = "RGBA8UI", r[r.RGB8UI = 36221] = "RGB8UI", r[r.RGBA32I = 36226] = "RGBA32I", r[r.RGB32I = 36227] = "RGB32I", r[r.RGBA16I = 36232] = "RGBA16I", r[r.RGB16I = 36233] = "RGB16I", r[r.RGBA8I = 36238] = "RGBA8I", r[r.RGB8I = 36239] = "RGB8I", r[r.RED_INTEGER = 36244] = "RED_INTEGER", r[r.RGB_INTEGER = 36248] = "RGB_INTEGER", r[r.RGBA_INTEGER = 36249] = "RGBA_INTEGER", r[r.R8 = 33321] = "R8", r[r.RG8 = 33323] = "RG8", r[r.R16F = 33325] = "R16F", r[r.R32F = 33326] = "R32F", r[r.RG16F = 33327] = "RG16F", r[r.RG32F = 33328] = "RG32F", r[r.R8I = 33329] = "R8I", r[r.R8UI = 33330] = "R8UI", r[r.R16I = 33331] = "R16I", r[r.R16UI = 33332] = "R16UI", r[r.R32I = 33333] = "R32I", r[r.R32UI = 33334] = "R32UI", r[r.RG8I = 33335] = "RG8I", r[r.RG8UI = 33336] = "RG8UI", r[r.RG16I = 33337] = "RG16I", r[r.RG16UI = 33338] = "RG16UI", r[r.RG32I = 33339] = "RG32I", r[r.RG32UI = 33340] = "RG32UI", r[r.R8_SNORM = 36756] = "R8_SNORM", r[r.RG8_SNORM = 36757] = "RG8_SNORM", r[r.RGB8_SNORM = 36758] = "RGB8_SNORM", r[r.RGBA8_SNORM = 36759] = "RGBA8_SNORM", r[r.RGB10_A2UI = 36975] = "RGB10_A2UI", r[r.TEXTURE_IMMUTABLE_FORMAT = 37167] = "TEXTURE_IMMUTABLE_FORMAT", r[r.TEXTURE_IMMUTABLE_LEVELS = 33503] = "TEXTURE_IMMUTABLE_LEVELS", r[r.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", r[r.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", r[r.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", r[r.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", r[r.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", r[r.HALF_FLOAT = 5131] = "HALF_FLOAT", r[r.RG = 33319] = "RG", r[r.RG_INTEGER = 33320] = "RG_INTEGER", r[r.INT_2_10_10_10_REV = 36255] = "INT_2_10_10_10_REV", r[r.CURRENT_QUERY = 34917] = "CURRENT_QUERY", r[r.QUERY_RESULT = 34918] = "QUERY_RESULT", r[r.QUERY_RESULT_AVAILABLE = 34919] = "QUERY_RESULT_AVAILABLE", r[r.ANY_SAMPLES_PASSED = 35887] = "ANY_SAMPLES_PASSED", r[r.ANY_SAMPLES_PASSED_CONSERVATIVE = 36202] = "ANY_SAMPLES_PASSED_CONSERVATIVE", r[r.MAX_DRAW_BUFFERS = 34852] = "MAX_DRAW_BUFFERS", r[r.DRAW_BUFFER0 = 34853] = "DRAW_BUFFER0", r[r.DRAW_BUFFER1 = 34854] = "DRAW_BUFFER1", r[r.DRAW_BUFFER2 = 34855] = "DRAW_BUFFER2", r[r.DRAW_BUFFER3 = 34856] = "DRAW_BUFFER3", r[r.DRAW_BUFFER4 = 34857] = "DRAW_BUFFER4", r[r.DRAW_BUFFER5 = 34858] = "DRAW_BUFFER5", r[r.DRAW_BUFFER6 = 34859] = "DRAW_BUFFER6", r[r.DRAW_BUFFER7 = 34860] = "DRAW_BUFFER7", r[r.DRAW_BUFFER8 = 34861] = "DRAW_BUFFER8", r[r.DRAW_BUFFER9 = 34862] = "DRAW_BUFFER9", r[r.DRAW_BUFFER10 = 34863] = "DRAW_BUFFER10", r[r.DRAW_BUFFER11 = 34864] = "DRAW_BUFFER11", r[r.DRAW_BUFFER12 = 34865] = "DRAW_BUFFER12", r[r.DRAW_BUFFER13 = 34866] = "DRAW_BUFFER13", r[r.DRAW_BUFFER14 = 34867] = "DRAW_BUFFER14", r[r.DRAW_BUFFER15 = 34868] = "DRAW_BUFFER15", r[r.MAX_COLOR_ATTACHMENTS = 36063] = "MAX_COLOR_ATTACHMENTS", r[r.COLOR_ATTACHMENT1 = 36065] = "COLOR_ATTACHMENT1", r[r.COLOR_ATTACHMENT2 = 36066] = "COLOR_ATTACHMENT2", r[r.COLOR_ATTACHMENT3 = 36067] = "COLOR_ATTACHMENT3", r[r.COLOR_ATTACHMENT4 = 36068] = "COLOR_ATTACHMENT4", r[r.COLOR_ATTACHMENT5 = 36069] = "COLOR_ATTACHMENT5", r[r.COLOR_ATTACHMENT6 = 36070] = "COLOR_ATTACHMENT6", r[r.COLOR_ATTACHMENT7 = 36071] = "COLOR_ATTACHMENT7", r[r.COLOR_ATTACHMENT8 = 36072] = "COLOR_ATTACHMENT8", r[r.COLOR_ATTACHMENT9 = 36073] = "COLOR_ATTACHMENT9", r[r.COLOR_ATTACHMENT10 = 36074] = "COLOR_ATTACHMENT10", r[r.COLOR_ATTACHMENT11 = 36075] = "COLOR_ATTACHMENT11", r[r.COLOR_ATTACHMENT12 = 36076] = "COLOR_ATTACHMENT12", r[r.COLOR_ATTACHMENT13 = 36077] = "COLOR_ATTACHMENT13", r[r.COLOR_ATTACHMENT14 = 36078] = "COLOR_ATTACHMENT14", r[r.COLOR_ATTACHMENT15 = 36079] = "COLOR_ATTACHMENT15", r[r.SAMPLER_3D = 35679] = "SAMPLER_3D", r[r.SAMPLER_2D_SHADOW = 35682] = "SAMPLER_2D_SHADOW", r[r.SAMPLER_2D_ARRAY = 36289] = "SAMPLER_2D_ARRAY", r[r.SAMPLER_2D_ARRAY_SHADOW = 36292] = "SAMPLER_2D_ARRAY_SHADOW", r[r.SAMPLER_CUBE_SHADOW = 36293] = "SAMPLER_CUBE_SHADOW", r[r.INT_SAMPLER_2D = 36298] = "INT_SAMPLER_2D", r[r.INT_SAMPLER_3D = 36299] = "INT_SAMPLER_3D", r[r.INT_SAMPLER_CUBE = 36300] = "INT_SAMPLER_CUBE", r[r.INT_SAMPLER_2D_ARRAY = 36303] = "INT_SAMPLER_2D_ARRAY", r[r.UNSIGNED_INT_SAMPLER_2D = 36306] = "UNSIGNED_INT_SAMPLER_2D", r[r.UNSIGNED_INT_SAMPLER_3D = 36307] = "UNSIGNED_INT_SAMPLER_3D", r[r.UNSIGNED_INT_SAMPLER_CUBE = 36308] = "UNSIGNED_INT_SAMPLER_CUBE", r[r.UNSIGNED_INT_SAMPLER_2D_ARRAY = 36311] = "UNSIGNED_INT_SAMPLER_2D_ARRAY", r[r.MAX_SAMPLES = 36183] = "MAX_SAMPLES", r[r.SAMPLER_BINDING = 35097] = "SAMPLER_BINDING", r[r.PIXEL_PACK_BUFFER = 35051] = "PIXEL_PACK_BUFFER", r[r.PIXEL_UNPACK_BUFFER = 35052] = "PIXEL_UNPACK_BUFFER", r[r.PIXEL_PACK_BUFFER_BINDING = 35053] = "PIXEL_PACK_BUFFER_BINDING", r[r.PIXEL_UNPACK_BUFFER_BINDING = 35055] = "PIXEL_UNPACK_BUFFER_BINDING", r[r.COPY_READ_BUFFER = 36662] = "COPY_READ_BUFFER", r[r.COPY_WRITE_BUFFER = 36663] = "COPY_WRITE_BUFFER", r[r.COPY_READ_BUFFER_BINDING = 36662] = "COPY_READ_BUFFER_BINDING", r[r.COPY_WRITE_BUFFER_BINDING = 36663] = "COPY_WRITE_BUFFER_BINDING", r[r.FLOAT_MAT2x3 = 35685] = "FLOAT_MAT2x3", r[r.FLOAT_MAT2x4 = 35686] = "FLOAT_MAT2x4", r[r.FLOAT_MAT3x2 = 35687] = "FLOAT_MAT3x2", r[r.FLOAT_MAT3x4 = 35688] = "FLOAT_MAT3x4", r[r.FLOAT_MAT4x2 = 35689] = "FLOAT_MAT4x2", r[r.FLOAT_MAT4x3 = 35690] = "FLOAT_MAT4x3", r[r.UNSIGNED_INT_VEC2 = 36294] = "UNSIGNED_INT_VEC2", r[r.UNSIGNED_INT_VEC3 = 36295] = "UNSIGNED_INT_VEC3", r[r.UNSIGNED_INT_VEC4 = 36296] = "UNSIGNED_INT_VEC4", r[r.UNSIGNED_NORMALIZED = 35863] = "UNSIGNED_NORMALIZED", r[r.SIGNED_NORMALIZED = 36764] = "SIGNED_NORMALIZED", r[r.VERTEX_ATTRIB_ARRAY_INTEGER = 35069] = "VERTEX_ATTRIB_ARRAY_INTEGER", r[r.VERTEX_ATTRIB_ARRAY_DIVISOR = 35070] = "VERTEX_ATTRIB_ARRAY_DIVISOR", r[r.TRANSFORM_FEEDBACK_BUFFER_MODE = 35967] = "TRANSFORM_FEEDBACK_BUFFER_MODE", r[r.MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS = 35968] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS", r[r.TRANSFORM_FEEDBACK_VARYINGS = 35971] = "TRANSFORM_FEEDBACK_VARYINGS", r[r.TRANSFORM_FEEDBACK_BUFFER_START = 35972] = "TRANSFORM_FEEDBACK_BUFFER_START", r[r.TRANSFORM_FEEDBACK_BUFFER_SIZE = 35973] = "TRANSFORM_FEEDBACK_BUFFER_SIZE", r[r.TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 35976] = "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN", r[r.MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 35978] = "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS", r[r.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS = 35979] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS", r[r.INTERLEAVED_ATTRIBS = 35980] = "INTERLEAVED_ATTRIBS", r[r.SEPARATE_ATTRIBS = 35981] = "SEPARATE_ATTRIBS", r[r.TRANSFORM_FEEDBACK_BUFFER = 35982] = "TRANSFORM_FEEDBACK_BUFFER", r[r.TRANSFORM_FEEDBACK_BUFFER_BINDING = 35983] = "TRANSFORM_FEEDBACK_BUFFER_BINDING", r[r.TRANSFORM_FEEDBACK = 36386] = "TRANSFORM_FEEDBACK", r[r.TRANSFORM_FEEDBACK_PAUSED = 36387] = "TRANSFORM_FEEDBACK_PAUSED", r[r.TRANSFORM_FEEDBACK_ACTIVE = 36388] = "TRANSFORM_FEEDBACK_ACTIVE", r[r.TRANSFORM_FEEDBACK_BINDING = 36389] = "TRANSFORM_FEEDBACK_BINDING", r[r.FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 33296] = "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING", r[r.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE", r[r.FRAMEBUFFER_ATTACHMENT_RED_SIZE = 33298] = "FRAMEBUFFER_ATTACHMENT_RED_SIZE", r[r.FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = 33299] = "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE", r[r.FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = 33300] = "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE", r[r.FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = 33301] = "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE", r[r.FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = 33302] = "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE", r[r.FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = 33303] = "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE", r[r.FRAMEBUFFER_DEFAULT = 33304] = "FRAMEBUFFER_DEFAULT", r[r.DEPTH24_STENCIL8 = 35056] = "DEPTH24_STENCIL8", r[r.DRAW_FRAMEBUFFER_BINDING = 36006] = "DRAW_FRAMEBUFFER_BINDING", r[r.READ_FRAMEBUFFER_BINDING = 36010] = "READ_FRAMEBUFFER_BINDING", r[r.RENDERBUFFER_SAMPLES = 36011] = "RENDERBUFFER_SAMPLES", r[r.FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = 36052] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER", r[r.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = 36182] = "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE", r[r.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER", r[r.UNIFORM_BUFFER_BINDING = 35368] = "UNIFORM_BUFFER_BINDING", r[r.UNIFORM_BUFFER_START = 35369] = "UNIFORM_BUFFER_START", r[r.UNIFORM_BUFFER_SIZE = 35370] = "UNIFORM_BUFFER_SIZE", r[r.MAX_VERTEX_UNIFORM_BLOCKS = 35371] = "MAX_VERTEX_UNIFORM_BLOCKS", r[r.MAX_FRAGMENT_UNIFORM_BLOCKS = 35373] = "MAX_FRAGMENT_UNIFORM_BLOCKS", r[r.MAX_COMBINED_UNIFORM_BLOCKS = 35374] = "MAX_COMBINED_UNIFORM_BLOCKS", r[r.MAX_UNIFORM_BUFFER_BINDINGS = 35375] = "MAX_UNIFORM_BUFFER_BINDINGS", r[r.MAX_UNIFORM_BLOCK_SIZE = 35376] = "MAX_UNIFORM_BLOCK_SIZE", r[r.MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = 35377] = "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS", r[r.MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = 35379] = "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS", r[r.UNIFORM_BUFFER_OFFSET_ALIGNMENT = 35380] = "UNIFORM_BUFFER_OFFSET_ALIGNMENT", r[r.ACTIVE_UNIFORM_BLOCKS = 35382] = "ACTIVE_UNIFORM_BLOCKS", r[r.UNIFORM_TYPE = 35383] = "UNIFORM_TYPE", r[r.UNIFORM_SIZE = 35384] = "UNIFORM_SIZE", r[r.UNIFORM_BLOCK_INDEX = 35386] = "UNIFORM_BLOCK_INDEX", r[r.UNIFORM_OFFSET = 35387] = "UNIFORM_OFFSET", r[r.UNIFORM_ARRAY_STRIDE = 35388] = "UNIFORM_ARRAY_STRIDE", r[r.UNIFORM_MATRIX_STRIDE = 35389] = "UNIFORM_MATRIX_STRIDE", r[r.UNIFORM_IS_ROW_MAJOR = 35390] = "UNIFORM_IS_ROW_MAJOR", r[r.UNIFORM_BLOCK_BINDING = 35391] = "UNIFORM_BLOCK_BINDING", r[r.UNIFORM_BLOCK_DATA_SIZE = 35392] = "UNIFORM_BLOCK_DATA_SIZE", r[r.UNIFORM_BLOCK_ACTIVE_UNIFORMS = 35394] = "UNIFORM_BLOCK_ACTIVE_UNIFORMS", r[r.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = 35395] = "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES", r[r.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = 35396] = "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER", r[r.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 35398] = "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER", r[r.OBJECT_TYPE = 37138] = "OBJECT_TYPE", r[r.SYNC_CONDITION = 37139] = "SYNC_CONDITION", r[r.SYNC_STATUS = 37140] = "SYNC_STATUS", r[r.SYNC_FLAGS = 37141] = "SYNC_FLAGS", r[r.SYNC_FENCE = 37142] = "SYNC_FENCE", r[r.SYNC_GPU_COMMANDS_COMPLETE = 37143] = "SYNC_GPU_COMMANDS_COMPLETE", r[r.UNSIGNALED = 37144] = "UNSIGNALED", r[r.SIGNALED = 37145] = "SIGNALED", r[r.ALREADY_SIGNALED = 37146] = "ALREADY_SIGNALED", r[r.TIMEOUT_EXPIRED = 37147] = "TIMEOUT_EXPIRED", r[r.CONDITION_SATISFIED = 37148] = "CONDITION_SATISFIED", r[r.WAIT_FAILED = 37149] = "WAIT_FAILED", r[r.SYNC_FLUSH_COMMANDS_BIT = 1] = "SYNC_FLUSH_COMMANDS_BIT", r[r.COLOR = 6144] = "COLOR", r[r.DEPTH = 6145] = "DEPTH", r[r.STENCIL = 6146] = "STENCIL", r[r.MIN = 32775] = "MIN", r[r.MAX = 32776] = "MAX", r[r.DEPTH_COMPONENT24 = 33190] = "DEPTH_COMPONENT24", r[r.STREAM_READ = 35041] = "STREAM_READ", r[r.STREAM_COPY = 35042] = "STREAM_COPY", r[r.STATIC_READ = 35045] = "STATIC_READ", r[r.STATIC_COPY = 35046] = "STATIC_COPY", r[r.DYNAMIC_READ = 35049] = "DYNAMIC_READ", r[r.DYNAMIC_COPY = 35050] = "DYNAMIC_COPY", r[r.DEPTH_COMPONENT32F = 36012] = "DEPTH_COMPONENT32F", r[r.DEPTH32F_STENCIL8 = 36013] = "DEPTH32F_STENCIL8", r[r.INVALID_INDEX = 4294967295] = "INVALID_INDEX", r[r.TIMEOUT_IGNORED = -1] = "TIMEOUT_IGNORED", r[r.MAX_CLIENT_WAIT_TIMEOUT_WEBGL = 37447] = "MAX_CLIENT_WAIT_TIMEOUT_WEBGL", r[r.UNMASKED_VENDOR_WEBGL = 37445] = "UNMASKED_VENDOR_WEBGL", r[r.UNMASKED_RENDERER_WEBGL = 37446] = "UNMASKED_RENDERER_WEBGL", r[r.MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047] = "MAX_TEXTURE_MAX_ANISOTROPY_EXT", r[r.TEXTURE_MAX_ANISOTROPY_EXT = 34046] = "TEXTURE_MAX_ANISOTROPY_EXT", r[r.R16_EXT = 33322] = "R16_EXT", r[r.RG16_EXT = 33324] = "RG16_EXT", r[r.RGB16_EXT = 32852] = "RGB16_EXT", r[r.RGBA16_EXT = 32859] = "RGBA16_EXT", r[r.R16_SNORM_EXT = 36760] = "R16_SNORM_EXT", r[r.RG16_SNORM_EXT = 36761] = "RG16_SNORM_EXT", r[r.RGB16_SNORM_EXT = 36762] = "RGB16_SNORM_EXT", r[r.RGBA16_SNORM_EXT = 36763] = "RGBA16_SNORM_EXT", r[r.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", r[r.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", r[r.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", r[r.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", r[r.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", r[r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", r[r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", r[r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", r[r.COMPRESSED_RED_RGTC1_EXT = 36283] = "COMPRESSED_RED_RGTC1_EXT", r[r.COMPRESSED_SIGNED_RED_RGTC1_EXT = 36284] = "COMPRESSED_SIGNED_RED_RGTC1_EXT", r[r.COMPRESSED_RED_GREEN_RGTC2_EXT = 36285] = "COMPRESSED_RED_GREEN_RGTC2_EXT", r[r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT = 36286] = "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT", r[r.COMPRESSED_RGBA_BPTC_UNORM_EXT = 36492] = "COMPRESSED_RGBA_BPTC_UNORM_EXT", r[r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = 36493] = "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT", r[r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT = 36494] = "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT", r[r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT = 36495] = "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT", r[r.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", r[r.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", r[r.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", r[r.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", r[r.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", r[r.COMPRESSED_RGBA8_ETC2_EAC = 37493] = "COMPRESSED_RGBA8_ETC2_EAC", r[r.COMPRESSED_SRGB8_ETC2 = 37494] = "COMPRESSED_SRGB8_ETC2", r[r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37495] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", r[r.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37496] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", r[r.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37497] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", r[r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", r[r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", r[r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", r[r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", r[r.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", r[r.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL", r[r.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", r[r.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL", r[r.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR", r[r.COMPRESSED_RGBA_ASTC_5x4_KHR = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR", r[r.COMPRESSED_RGBA_ASTC_5x5_KHR = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR", r[r.COMPRESSED_RGBA_ASTC_6x5_KHR = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR", r[r.COMPRESSED_RGBA_ASTC_6x6_KHR = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR", r[r.COMPRESSED_RGBA_ASTC_8x5_KHR = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR", r[r.COMPRESSED_RGBA_ASTC_8x6_KHR = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR", r[r.COMPRESSED_RGBA_ASTC_8x8_KHR = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR", r[r.COMPRESSED_RGBA_ASTC_10x5_KHR = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR", r[r.COMPRESSED_RGBA_ASTC_10x6_KHR = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR", r[r.COMPRESSED_RGBA_ASTC_10x8_KHR = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR", r[r.COMPRESSED_RGBA_ASTC_10x10_KHR = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR", r[r.COMPRESSED_RGBA_ASTC_12x10_KHR = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR", r[r.COMPRESSED_RGBA_ASTC_12x12_KHR = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR", r[r.QUERY_COUNTER_BITS_EXT = 34916] = "QUERY_COUNTER_BITS_EXT", r[r.CURRENT_QUERY_EXT = 34917] = "CURRENT_QUERY_EXT", r[r.QUERY_RESULT_EXT = 34918] = "QUERY_RESULT_EXT", r[r.QUERY_RESULT_AVAILABLE_EXT = 34919] = "QUERY_RESULT_AVAILABLE_EXT", r[r.TIME_ELAPSED_EXT = 35007] = "TIME_ELAPSED_EXT", r[r.TIMESTAMP_EXT = 36392] = "TIMESTAMP_EXT", r[r.GPU_DISJOINT_EXT = 36795] = "GPU_DISJOINT_EXT", r[r.COMPLETION_STATUS_KHR = 37297] = "COMPLETION_STATUS_KHR", r[r.DEPTH_CLAMP_EXT = 34383] = "DEPTH_CLAMP_EXT", r[r.FIRST_VERTEX_CONVENTION_WEBGL = 36429] = "FIRST_VERTEX_CONVENTION_WEBGL", r[r.LAST_VERTEX_CONVENTION_WEBGL = 36430] = "LAST_VERTEX_CONVENTION_WEBGL", r[r.PROVOKING_VERTEX_WEBL = 36431] = "PROVOKING_VERTEX_WEBL", r[r.POLYGON_MODE_WEBGL = 2880] = "POLYGON_MODE_WEBGL", r[r.POLYGON_OFFSET_LINE_WEBGL = 10754] = "POLYGON_OFFSET_LINE_WEBGL", r[r.LINE_WEBGL = 6913] = "LINE_WEBGL", r[r.FILL_WEBGL = 6914] = "FILL_WEBGL", r[r.MAX_CLIP_DISTANCES_WEBGL = 3378] = "MAX_CLIP_DISTANCES_WEBGL", r[r.MAX_CULL_DISTANCES_WEBGL = 33529] = "MAX_CULL_DISTANCES_WEBGL", r[r.MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL = 33530] = "MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL", r[r.CLIP_DISTANCE0_WEBGL = 12288] = "CLIP_DISTANCE0_WEBGL", r[r.CLIP_DISTANCE1_WEBGL = 12289] = "CLIP_DISTANCE1_WEBGL", r[r.CLIP_DISTANCE2_WEBGL = 12290] = "CLIP_DISTANCE2_WEBGL", r[r.CLIP_DISTANCE3_WEBGL = 12291] = "CLIP_DISTANCE3_WEBGL", r[r.CLIP_DISTANCE4_WEBGL = 12292] = "CLIP_DISTANCE4_WEBGL", r[r.CLIP_DISTANCE5_WEBGL = 12293] = "CLIP_DISTANCE5_WEBGL", r[r.CLIP_DISTANCE6_WEBGL = 12294] = "CLIP_DISTANCE6_WEBGL", r[r.CLIP_DISTANCE7_WEBGL = 12295] = "CLIP_DISTANCE7_WEBGL", r[r.POLYGON_OFFSET_CLAMP_EXT = 36379] = "POLYGON_OFFSET_CLAMP_EXT", r[r.LOWER_LEFT_EXT = 36001] = "LOWER_LEFT_EXT", r[r.UPPER_LEFT_EXT = 36002] = "UPPER_LEFT_EXT", r[r.NEGATIVE_ONE_TO_ONE_EXT = 37726] = "NEGATIVE_ONE_TO_ONE_EXT", r[r.ZERO_TO_ONE_EXT = 37727] = "ZERO_TO_ONE_EXT", r[r.CLIP_ORIGIN_EXT = 37724] = "CLIP_ORIGIN_EXT", r[r.CLIP_DEPTH_MODE_EXT = 37725] = "CLIP_DEPTH_MODE_EXT", r[r.SRC1_COLOR_WEBGL = 35065] = "SRC1_COLOR_WEBGL", r[r.SRC1_ALPHA_WEBGL = 34185] = "SRC1_ALPHA_WEBGL", r[r.ONE_MINUS_SRC1_COLOR_WEBGL = 35066] = "ONE_MINUS_SRC1_COLOR_WEBGL", r[r.ONE_MINUS_SRC1_ALPHA_WEBGL = 35067] = "ONE_MINUS_SRC1_ALPHA_WEBGL", r[r.MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL = 35068] = "MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL", r[r.MIRROR_CLAMP_TO_EDGE_EXT = 34627] = "MIRROR_CLAMP_TO_EDGE_EXT";
})(qd || (qd = {}));
const M$ = {
  WEBGL_depth_texture: {
    UNSIGNED_INT_24_8_WEBGL: 34042
  },
  OES_element_index_uint: {},
  OES_texture_float: {},
  OES_texture_half_float: {
    // @ts-expect-error different numbers?
    HALF_FLOAT_OES: 5131
  },
  EXT_color_buffer_float: {},
  OES_standard_derivatives: {
    FRAGMENT_SHADER_DERIVATIVE_HINT_OES: 35723
  },
  EXT_frag_depth: {},
  EXT_blend_minmax: {
    MIN_EXT: 32775,
    MAX_EXT: 32776
  },
  EXT_shader_texture_lod: {}
}, R$ = (r) => ({
  drawBuffersWEBGL(e) {
    return r.drawBuffers(e);
  },
  COLOR_ATTACHMENT0_WEBGL: 36064,
  COLOR_ATTACHMENT1_WEBGL: 36065,
  COLOR_ATTACHMENT2_WEBGL: 36066,
  COLOR_ATTACHMENT3_WEBGL: 36067
}), B$ = (r) => ({
  VERTEX_ARRAY_BINDING_OES: 34229,
  createVertexArrayOES() {
    return r.createVertexArray();
  },
  deleteVertexArrayOES(e) {
    return r.deleteVertexArray(e);
  },
  isVertexArrayOES(e) {
    return r.isVertexArray(e);
  },
  bindVertexArrayOES(e) {
    return r.bindVertexArray(e);
  }
}), O$ = (r) => ({
  VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: 35070,
  drawArraysInstancedANGLE(...e) {
    return r.drawArraysInstanced(...e);
  },
  drawElementsInstancedANGLE(...e) {
    return r.drawElementsInstanced(...e);
  },
  vertexAttribDivisorANGLE(...e) {
    return r.vertexAttribDivisor(...e);
  }
});
function D$(r = !0) {
  const e = HTMLCanvasElement.prototype;
  if (!r && e.originalGetContext) {
    e.getContext = e.originalGetContext, e.originalGetContext = void 0;
    return;
  }
  e.originalGetContext = e.getContext, e.getContext = function(t, n) {
    if (t === "webgl" || t === "experimental-webgl") {
      const i = this.originalGetContext("webgl2", n);
      return i instanceof HTMLElement && L$(i), i;
    }
    return this.originalGetContext(t, n);
  };
}
function L$(r) {
  r.getExtension("EXT_color_buffer_float");
  const e = {
    ...M$,
    WEBGL_disjoint_timer_query: r.getExtension("EXT_disjoint_timer_query_webgl2"),
    WEBGL_draw_buffers: R$(r),
    OES_vertex_array_object: B$(r),
    ANGLE_instanced_arrays: O$(r)
  }, t = r.getExtension;
  r.getExtension = function(i) {
    const s = t.call(r, i);
    return s || (i in e ? e[i] : null);
  };
  const n = r.getSupportedExtensions;
  r.getSupportedExtensions = function() {
    return (n.apply(r) || [])?.concat(Object.keys(e));
  };
}
async function u6(r, e) {
  const t = document.getElementsByTagName("head")[0];
  if (!t)
    throw new Error("loadScript");
  const n = document.createElement("script");
  return n.setAttribute("type", "text/javascript"), n.setAttribute("src", r), new Promise((i, s) => {
    n.onload = i, n.onerror = (o) => s(new Error(`Unable to load script '${r}': ${o}`)), t.appendChild(n);
  });
}
const k$ = 1;
let oa = null, YC = !1;
const $x = {
  debugSpectorJS: qt.get("debug-spectorjs"),
  // https://github.com/BabylonJS/Spector.js#basic-usage
  // https://forum.babylonjs.com/t/spectorcdn-is-temporarily-off/48241
  // spectorUrl: 'https://spectorcdn.babylonjs.com/spector.bundle.js';
  debugSpectorJSUrl: "https://cdn.jsdelivr.net/npm/spectorjs@0.9.30/dist/spector.bundle.js",
  gl: void 0
};
async function F$(r) {
  if (!globalThis.SPECTOR)
    try {
      await u6(r.debugSpectorJSUrl || $x.debugSpectorJSUrl);
    } catch (e) {
      qt.warn(String(e));
    }
}
function N$(r) {
  if (r = { ...$x, ...r }, !r.debugSpectorJS)
    return null;
  if (!oa && globalThis.SPECTOR && !globalThis.luma?.spector) {
    qt.probe(k$, "SPECTOR found and initialized. Start with `luma.spector.displayUI()`")();
    const { Spector: e } = globalThis.SPECTOR;
    oa = new e(), globalThis.luma && (globalThis.luma.spector = oa);
  }
  if (!oa)
    return null;
  if (YC || (YC = !0, oa.spyCanvases(), oa?.onCaptureStarted.add((e) => qt.info("Spector capture started:", e)()), oa?.onCapture.add((e) => {
    qt.info("Spector capture complete:", e)(), oa?.getResultUI(), oa?.resultView.display(), oa?.resultView.addCapture(e);
  })), r.gl) {
    const e = r.gl, t = e.device;
    oa?.startCapture(r.gl, 500), e.device = t, new Promise((n) => setTimeout(n, 2e3)).then((n) => {
      qt.info("Spector capture stopped after 2 seconds")(), oa?.stopCapture();
    });
  }
  return oa;
}
const U$ = "https://unpkg.com/webgl-debug@2.0.1/index.js";
function f6(r) {
  return r.luma = r.luma || {}, r.luma;
}
async function z$() {
  ph() && !globalThis.WebGLDebugUtils && (globalThis.global = globalThis.global || globalThis, globalThis.global.module = {}, await u6(U$));
}
function V$(r, e = {}) {
  return e.debugWebGL || e.traceWebGL ? H$(r, e) : j$(r);
}
function j$(r) {
  const e = f6(r);
  return e.realContext ? e.realContext : r;
}
function H$(r, e) {
  if (!globalThis.WebGLDebugUtils)
    return qt.warn("webgl-debug not loaded")(), r;
  const t = f6(r);
  if (t.debugContext)
    return t.debugContext;
  globalThis.WebGLDebugUtils.init({ ...qd, ...r });
  const n = globalThis.WebGLDebugUtils.makeDebugContext(r, G$.bind(null, e), W$.bind(null, e));
  for (const o in qd)
    !(o in n) && typeof qd[o] == "number" && (n[o] = qd[o]);
  class i {
  }
  Object.setPrototypeOf(n, Object.getPrototypeOf(r)), Object.setPrototypeOf(i, n);
  const s = Object.create(i);
  return t.realContext = r, t.debugContext = s, s.debug = !0, s;
}
function KC(r, e) {
  e = Array.from(e).map((n) => n === void 0 ? "undefined" : n);
  let t = globalThis.WebGLDebugUtils.glFunctionArgsToString(r, e);
  return t = `${t.slice(0, 100)}${t.length > 100 ? "..." : ""}`, `gl.${r}(${t})`;
}
function G$(r, e, t, n) {
  n = Array.from(n).map((l) => l === void 0 ? "undefined" : l);
  const i = globalThis.WebGLDebugUtils.glEnumToString(e), s = globalThis.WebGLDebugUtils.glFunctionArgsToString(t, n), o = `${i} in gl.${t}(${s})`;
  qt.error(o)();
  debugger;
}
function W$(r, e, t) {
  let n = "";
  qt.level >= 1 && (n = KC(e, t), r.traceWebGL && qt.log(1, n)());
  for (const i of t)
    if (i === void 0) {
      n = n || KC(e, t);
      debugger;
    }
}
const Eg = 1;
class $$ extends L9 {
  /** type of device's created by this adapter */
  type = "webgl";
  constructor() {
    super(), eh.defaultProps = { ...eh.defaultProps, ...$x };
  }
  /** Force any created WebGL contexts to be WebGL2 contexts, polyfilled with WebGL1 extensions */
  enforceWebGL2(e) {
    D$(e);
  }
  /** Check if WebGL 2 is available */
  isSupported() {
    return typeof WebGL2RenderingContext < "u";
  }
  isDeviceHandle(e) {
    return typeof WebGL2RenderingContext < "u" && e instanceof WebGL2RenderingContext ? !0 : (typeof WebGLRenderingContext < "u" && e instanceof WebGLRenderingContext && qt.warn("WebGL1 is not supported", e)(), !1);
  }
  /**
   * Get a device instance from a GL context
   * Creates a WebGLCanvasContext against the contexts canvas
   * @note autoResize will be disabled, assuming that whoever created the external context will be handling resizes.
   * @param gl
   * @returns
   */
  async attach(e, t = {}) {
    const { WebGLDevice: n } = await Promise.resolve().then(() => dS);
    if (e instanceof n)
      return e;
    if (e?.device instanceof n)
      return e.device;
    if (!q$(e))
      throw new Error("Invalid WebGL2RenderingContext");
    const i = t.createCanvasContext === !0 ? {} : t.createCanvasContext;
    return new n({
      ...t,
      _handle: e,
      createCanvasContext: { canvas: e.canvas, autoResize: !1, ...i }
    });
  }
  async create(e = {}) {
    const { WebGLDevice: t } = await Promise.resolve().then(() => dS);
    qt.groupCollapsed(Eg, "WebGLDevice created")();
    try {
      const n = [];
      (e.debugWebGL || e.debug) && n.push(z$()), e.debugSpectorJS && n.push(F$(e));
      const i = await Promise.allSettled(n);
      for (const l of i)
        l.status === "rejected" && qt.error(`Failed to initialize debug libraries ${l.reason}`)();
      const s = new t(e), o = `${s._reused ? "Reusing" : "Created"} device with WebGL2 ${s.props.debug ? "debug " : ""}context: ${s.info.vendor}, ${s.info.renderer} for canvas: ${s.canvasContext.id}`;
      return qt.probe(Eg, o)(), qt.table(Eg, s.info)(), s;
    } finally {
      qt.groupEnd(Eg)();
    }
  }
}
function q$(r) {
  return typeof WebGL2RenderingContext < "u" && r instanceof WebGL2RenderingContext ? !0 : !!(r && Number.isFinite(r._version));
}
const Vv = new $$(), qx = {
  3042: !1,
  32773: new Float32Array([0, 0, 0, 0]),
  32777: 32774,
  34877: 32774,
  32969: 1,
  32968: 0,
  32971: 1,
  32970: 0,
  3106: new Float32Array([0, 0, 0, 0]),
  // TBD
  3107: [!0, !0, !0, !0],
  2884: !1,
  2885: 1029,
  2929: !1,
  2931: 1,
  2932: 513,
  2928: new Float32Array([0, 1]),
  // TBD
  2930: !0,
  3024: !0,
  35725: null,
  // FRAMEBUFFER_BINDING and DRAW_FRAMEBUFFER_BINDING(WebGL2) refer same state.
  36006: null,
  36007: null,
  34229: null,
  34964: null,
  2886: 2305,
  33170: 4352,
  2849: 1,
  32823: !1,
  32824: 0,
  10752: 0,
  32926: !1,
  32928: !1,
  32938: 1,
  32939: !1,
  3089: !1,
  // Note: Dynamic value. If scissor test enabled we expect users to set correct scissor box
  3088: new Int32Array([0, 0, 1024, 1024]),
  2960: !1,
  2961: 0,
  2968: 4294967295,
  36005: 4294967295,
  2962: 519,
  2967: 0,
  2963: 4294967295,
  34816: 519,
  36003: 0,
  36004: 4294967295,
  2964: 7680,
  2965: 7680,
  2966: 7680,
  34817: 7680,
  34818: 7680,
  34819: 7680,
  // Dynamic value: We use [0, 0, 1024, 1024] as default, but usually this is updated in each frame.
  2978: [0, 0, 1024, 1024],
  36389: null,
  36662: null,
  36663: null,
  35053: null,
  35055: null,
  35723: 4352,
  36010: null,
  35977: !1,
  3333: 4,
  3317: 4,
  37440: !1,
  37441: !1,
  37443: 37444,
  3330: 0,
  3332: 0,
  3331: 0,
  3314: 0,
  32878: 0,
  3316: 0,
  3315: 0,
  32877: 0
}, fs = (r, e, t) => e ? r.enable(t) : r.disable(t), QC = (r, e, t) => r.hint(t, e), aa = (r, e, t) => r.pixelStorei(t, e), JC = (r, e, t) => {
  const n = t === 36006 ? 36009 : 36008;
  return r.bindFramebuffer(n, e);
}, yA = (r, e, t) => {
  const i = {
    34964: 34962,
    36662: 36662,
    36663: 36663,
    35053: 35051,
    35055: 35052
  }[t];
  r.bindBuffer(i, e);
};
function jv(r) {
  return Array.isArray(r) || ArrayBuffer.isView(r) && !(r instanceof DataView);
}
const X$ = {
  3042: fs,
  32773: (r, e) => r.blendColor(...e),
  32777: "blendEquation",
  34877: "blendEquation",
  32969: "blendFunc",
  32968: "blendFunc",
  32971: "blendFunc",
  32970: "blendFunc",
  3106: (r, e) => r.clearColor(...e),
  3107: (r, e) => r.colorMask(...e),
  2884: fs,
  2885: (r, e) => r.cullFace(e),
  2929: fs,
  2931: (r, e) => r.clearDepth(e),
  2932: (r, e) => r.depthFunc(e),
  2928: (r, e) => r.depthRange(...e),
  2930: (r, e) => r.depthMask(e),
  3024: fs,
  35723: QC,
  35725: (r, e) => r.useProgram(e),
  36007: (r, e) => r.bindRenderbuffer(36161, e),
  36389: (r, e) => r.bindTransformFeedback?.(36386, e),
  34229: (r, e) => r.bindVertexArray(e),
  // NOTE: FRAMEBUFFER_BINDING and DRAW_FRAMEBUFFER_BINDING(WebGL2) refer same state.
  36006: JC,
  36010: JC,
  // Buffers
  34964: yA,
  36662: yA,
  36663: yA,
  35053: yA,
  35055: yA,
  2886: (r, e) => r.frontFace(e),
  33170: QC,
  2849: (r, e) => r.lineWidth(e),
  32823: fs,
  32824: "polygonOffset",
  10752: "polygonOffset",
  35977: fs,
  32926: fs,
  32928: fs,
  32938: "sampleCoverage",
  32939: "sampleCoverage",
  3089: fs,
  3088: (r, e) => r.scissor(...e),
  2960: fs,
  2961: (r, e) => r.clearStencil(e),
  2968: (r, e) => r.stencilMaskSeparate(1028, e),
  36005: (r, e) => r.stencilMaskSeparate(1029, e),
  2962: "stencilFuncFront",
  2967: "stencilFuncFront",
  2963: "stencilFuncFront",
  34816: "stencilFuncBack",
  36003: "stencilFuncBack",
  36004: "stencilFuncBack",
  2964: "stencilOpFront",
  2965: "stencilOpFront",
  2966: "stencilOpFront",
  34817: "stencilOpBack",
  34818: "stencilOpBack",
  34819: "stencilOpBack",
  2978: (r, e) => r.viewport(...e),
  // WEBGL2 EXTENSIONS
  // EXT_depth_clamp https://registry.khronos.org/webgl/extensions/EXT_depth_clamp/
  34383: fs,
  // WEBGL_provoking_vertex https://registry.khronos.org/webgl/extensions/WEBGL_provoking_vertex/
  // [GL.PROVOKING_VERTEX_WEBL]: TODO - extension function needed
  // WEBGL_polygon_mode https://registry.khronos.org/webgl/extensions/WEBGL_polygon_mode/
  // POLYGON_MODE_WEBGL  TODO - extension function needed
  10754: fs,
  // WEBGL_clip_cull_distance https://registry.khronos.org/webgl/extensions/WEBGL_clip_cull_distance/
  12288: fs,
  12289: fs,
  12290: fs,
  12291: fs,
  12292: fs,
  12293: fs,
  12294: fs,
  12295: fs,
  // PIXEL PACK/UNPACK MODES
  3333: aa,
  3317: aa,
  37440: aa,
  37441: aa,
  37443: aa,
  3330: aa,
  3332: aa,
  3331: aa,
  3314: aa,
  32878: aa,
  3316: aa,
  3315: aa,
  32877: aa,
  // Function-style setters
  framebuffer: (r, e) => {
    const t = e && "handle" in e ? e.handle : e;
    return r.bindFramebuffer(36160, t);
  },
  blend: (r, e) => e ? r.enable(3042) : r.disable(3042),
  blendColor: (r, e) => r.blendColor(...e),
  blendEquation: (r, e) => {
    const t = typeof e == "number" ? [e, e] : e;
    r.blendEquationSeparate(...t);
  },
  blendFunc: (r, e) => {
    const t = e?.length === 2 ? [...e, ...e] : e;
    r.blendFuncSeparate(...t);
  },
  clearColor: (r, e) => r.clearColor(...e),
  clearDepth: (r, e) => r.clearDepth(e),
  clearStencil: (r, e) => r.clearStencil(e),
  colorMask: (r, e) => r.colorMask(...e),
  cull: (r, e) => e ? r.enable(2884) : r.disable(2884),
  cullFace: (r, e) => r.cullFace(e),
  depthTest: (r, e) => e ? r.enable(2929) : r.disable(2929),
  depthFunc: (r, e) => r.depthFunc(e),
  depthMask: (r, e) => r.depthMask(e),
  depthRange: (r, e) => r.depthRange(...e),
  dither: (r, e) => e ? r.enable(3024) : r.disable(3024),
  derivativeHint: (r, e) => {
    r.hint(35723, e);
  },
  frontFace: (r, e) => r.frontFace(e),
  mipmapHint: (r, e) => r.hint(33170, e),
  lineWidth: (r, e) => r.lineWidth(e),
  polygonOffsetFill: (r, e) => e ? r.enable(32823) : r.disable(32823),
  polygonOffset: (r, e) => r.polygonOffset(...e),
  sampleCoverage: (r, e) => r.sampleCoverage(e[0], e[1] || !1),
  scissorTest: (r, e) => e ? r.enable(3089) : r.disable(3089),
  scissor: (r, e) => r.scissor(...e),
  stencilTest: (r, e) => e ? r.enable(2960) : r.disable(2960),
  stencilMask: (r, e) => {
    e = jv(e) ? e : [e, e];
    const [t, n] = e;
    r.stencilMaskSeparate(1028, t), r.stencilMaskSeparate(1029, n);
  },
  stencilFunc: (r, e) => {
    e = jv(e) && e.length === 3 ? [...e, ...e] : e;
    const [t, n, i, s, o, l] = e;
    r.stencilFuncSeparate(1028, t, n, i), r.stencilFuncSeparate(1029, s, o, l);
  },
  stencilOp: (r, e) => {
    e = jv(e) && e.length === 3 ? [...e, ...e] : e;
    const [t, n, i, s, o, l] = e;
    r.stencilOpSeparate(1028, t, n, i), r.stencilOpSeparate(1029, s, o, l);
  },
  viewport: (r, e) => r.viewport(...e)
};
function Qi(r, e, t) {
  return e[r] !== void 0 ? e[r] : t[r];
}
const Z$ = {
  blendEquation: (r, e, t) => r.blendEquationSeparate(Qi(32777, e, t), Qi(34877, e, t)),
  blendFunc: (r, e, t) => r.blendFuncSeparate(Qi(32969, e, t), Qi(32968, e, t), Qi(32971, e, t), Qi(32970, e, t)),
  polygonOffset: (r, e, t) => r.polygonOffset(Qi(32824, e, t), Qi(10752, e, t)),
  sampleCoverage: (r, e, t) => r.sampleCoverage(Qi(32938, e, t), Qi(32939, e, t)),
  stencilFuncFront: (r, e, t) => r.stencilFuncSeparate(1028, Qi(2962, e, t), Qi(2967, e, t), Qi(2963, e, t)),
  stencilFuncBack: (r, e, t) => r.stencilFuncSeparate(1029, Qi(34816, e, t), Qi(36003, e, t), Qi(36004, e, t)),
  stencilOpFront: (r, e, t) => r.stencilOpSeparate(1028, Qi(2964, e, t), Qi(2965, e, t), Qi(2966, e, t)),
  stencilOpBack: (r, e, t) => r.stencilOpSeparate(1029, Qi(34817, e, t), Qi(34818, e, t), Qi(34819, e, t))
}, eS = {
  // GENERIC SETTERS
  enable: (r, e) => r({
    [e]: !0
  }),
  disable: (r, e) => r({
    [e]: !1
  }),
  pixelStorei: (r, e, t) => r({
    [e]: t
  }),
  hint: (r, e, t) => r({
    [e]: t
  }),
  // SPECIFIC SETTERS
  useProgram: (r, e) => r({
    35725: e
  }),
  bindRenderbuffer: (r, e, t) => r({
    36007: t
  }),
  bindTransformFeedback: (r, e, t) => r({
    36389: t
  }),
  bindVertexArray: (r, e) => r({
    34229: e
  }),
  bindFramebuffer: (r, e, t) => {
    switch (e) {
      case 36160:
        return r({
          36006: t,
          36010: t
        });
      case 36009:
        return r({ 36006: t });
      case 36008:
        return r({ 36010: t });
      default:
        return null;
    }
  },
  bindBuffer: (r, e, t) => {
    const n = {
      34962: [34964],
      36662: [36662],
      36663: [36663],
      35051: [35053],
      35052: [35055]
    }[e];
    return n ? r({ [n]: t }) : { valueChanged: !0 };
  },
  blendColor: (r, e, t, n, i) => r({
    32773: new Float32Array([e, t, n, i])
  }),
  blendEquation: (r, e) => r({
    32777: e,
    34877: e
  }),
  blendEquationSeparate: (r, e, t) => r({
    32777: e,
    34877: t
  }),
  blendFunc: (r, e, t) => r({
    32969: e,
    32968: t,
    32971: e,
    32970: t
  }),
  blendFuncSeparate: (r, e, t, n, i) => r({
    32969: e,
    32968: t,
    32971: n,
    32970: i
  }),
  clearColor: (r, e, t, n, i) => r({
    3106: new Float32Array([e, t, n, i])
  }),
  clearDepth: (r, e) => r({
    2931: e
  }),
  clearStencil: (r, e) => r({
    2961: e
  }),
  colorMask: (r, e, t, n, i) => r({
    3107: [e, t, n, i]
  }),
  cullFace: (r, e) => r({
    2885: e
  }),
  depthFunc: (r, e) => r({
    2932: e
  }),
  depthRange: (r, e, t) => r({
    2928: new Float32Array([e, t])
  }),
  depthMask: (r, e) => r({
    2930: e
  }),
  frontFace: (r, e) => r({
    2886: e
  }),
  lineWidth: (r, e) => r({
    2849: e
  }),
  polygonOffset: (r, e, t) => r({
    32824: e,
    10752: t
  }),
  sampleCoverage: (r, e, t) => r({
    32938: e,
    32939: t
  }),
  scissor: (r, e, t, n, i) => r({
    3088: new Int32Array([e, t, n, i])
  }),
  stencilMask: (r, e) => r({
    2968: e,
    36005: e
  }),
  stencilMaskSeparate: (r, e, t) => r({
    [e === 1028 ? 2968 : 36005]: t
  }),
  stencilFunc: (r, e, t, n) => r({
    2962: e,
    2967: t,
    2963: n,
    34816: e,
    36003: t,
    36004: n
  }),
  stencilFuncSeparate: (r, e, t, n, i) => r({
    [e === 1028 ? 2962 : 34816]: t,
    [e === 1028 ? 2967 : 36003]: n,
    [e === 1028 ? 2963 : 36004]: i
  }),
  stencilOp: (r, e, t, n) => r({
    2964: e,
    2965: t,
    2966: n,
    34817: e,
    34818: t,
    34819: n
  }),
  stencilOpSeparate: (r, e, t, n, i) => r({
    [e === 1028 ? 2964 : 34817]: t,
    [e === 1028 ? 2965 : 34818]: n,
    [e === 1028 ? 2966 : 34819]: i
  }),
  viewport: (r, e, t, n, i) => r({
    2978: [e, t, n, i]
  })
}, Yl = (r, e) => r.isEnabled(e), tS = {
  3042: Yl,
  2884: Yl,
  2929: Yl,
  3024: Yl,
  32823: Yl,
  32926: Yl,
  32928: Yl,
  3089: Yl,
  2960: Yl,
  35977: Yl
}, Y$ = /* @__PURE__ */ new Set([
  34016,
  36388,
  36387,
  35983,
  35368,
  34965,
  35739,
  35738,
  3074,
  34853,
  34854,
  34855,
  34856,
  34857,
  34858,
  34859,
  34860,
  34861,
  34862,
  34863,
  34864,
  34865,
  34866,
  34867,
  34868,
  35097,
  32873,
  35869,
  32874,
  34068
]);
function kp(r, e) {
  if (Q$(e))
    return;
  const t = {};
  for (const i in e) {
    const s = Number(i), o = X$[i];
    o && (typeof o == "string" ? t[o] = !0 : o(r, e[i], s));
  }
  const n = r.state && r.state.cache;
  if (n)
    for (const i in t) {
      const s = Z$[i];
      s(r, e, n);
    }
}
function h6(r, e = qx) {
  if (typeof e == "number") {
    const i = e, s = tS[i];
    return s ? s(r, i) : r.getParameter(i);
  }
  const t = Array.isArray(e) ? e : Object.keys(e), n = {};
  for (const i of t) {
    const s = tS[i];
    n[i] = s ? s(r, Number(i)) : r.getParameter(Number(i));
  }
  return n;
}
function K$(r) {
  kp(r, qx);
}
function Q$(r) {
  for (const e in r)
    return !1;
  return !0;
}
function J$(r, e) {
  if (r === e)
    return !0;
  if (rS(r) && rS(e) && r.length === e.length) {
    for (let t = 0; t < r.length; ++t)
      if (r[t] !== e[t])
        return !1;
    return !0;
  }
  return !1;
}
function rS(r) {
  return Array.isArray(r) || ArrayBuffer.isView(r);
}
class Kf {
  static get(e) {
    return e.state;
  }
  gl;
  program = null;
  stateStack = [];
  enable = !0;
  cache = null;
  log;
  initialized = !1;
  constructor(e, t) {
    this.gl = e, this.log = t?.log || (() => {
    }), this._updateCache = this._updateCache.bind(this), Object.seal(this);
  }
  push(e = {}) {
    this.stateStack.push({});
  }
  pop() {
    const e = this.stateStack[this.stateStack.length - 1];
    kp(this.gl, e), this.stateStack.pop();
  }
  /**
   * Initialize WebGL state caching on a context
   * can be called multiple times to enable/disable
   *
   * @note After calling this function, context state will be cached
   * .push() and .pop() will be available for saving,
   * temporarily modifying, and then restoring state.
   */
  trackState(e, t) {
    if (this.cache = t?.copyState ? h6(e) : Object.assign({}, qx), this.initialized)
      throw new Error("WebGLStateTracker");
    this.initialized = !0, this.gl.state = this, tq(e);
    for (const n in eS) {
      const i = eS[n];
      eq(e, n, i);
    }
    nS(e, "getParameter"), nS(e, "isEnabled");
  }
  /**
  // interceptor for context set functions - update our cache and our stack
  // values (Object) - the key values for this setter
   * @param values
   * @returns
   */
  _updateCache(e) {
    let t = !1, n;
    const i = this.stateStack.length > 0 ? this.stateStack[this.stateStack.length - 1] : null;
    for (const s in e) {
      const o = e[s], l = this.cache[s];
      J$(o, l) || (t = !0, n = l, i && !(s in i) && (i[s] = l), this.cache[s] = o);
    }
    return { valueChanged: t, oldValue: n };
  }
}
function nS(r, e) {
  const t = r[e].bind(r);
  r[e] = function(i) {
    if (i === void 0 || Y$.has(i))
      return t(i);
    const s = Kf.get(r);
    return i in s.cache || (s.cache[i] = t(i)), s.enable ? (
      // Call the getter the params so that it can e.g. serve from a cache
      s.cache[i]
    ) : (
      // Optionally call the original function to do a "hard" query from the WebGL2RenderingContext
      t(i)
    );
  }, Object.defineProperty(r[e], "name", {
    value: `${e}-from-cache`,
    configurable: !1
  });
}
function eq(r, e, t) {
  if (!r[e])
    return;
  const n = r[e].bind(r);
  r[e] = function(...s) {
    const o = Kf.get(r), { valueChanged: l, oldValue: u } = t(o._updateCache, ...s);
    return l && n(...s), u;
  }, Object.defineProperty(r[e], "name", {
    value: `${e}-to-cache`,
    configurable: !1
  });
}
function tq(r) {
  const e = r.useProgram.bind(r);
  r.useProgram = function(n) {
    const i = Kf.get(r);
    i.program !== n && (e(n), i.program = n);
  };
}
function rq(r, e, t) {
  let n = "";
  const i = {
    preserveDrawingBuffer: !0,
    // failIfMajorPerformanceCaveat: true,
    ...t
  };
  let s = null;
  if (s ||= r.getContext("webgl2", i), i.failIfMajorPerformanceCaveat && (n ||= "Only software GPU is available. Set `failIfMajorPerformanceCaveat: false` to allow."), !s && !t.failIfMajorPerformanceCaveat && (i.failIfMajorPerformanceCaveat = !1, s = r.getContext("webgl2", i), s.luma ||= {}, s.luma.softwareRenderer = !0), s || (s = r.getContext("webgl", {}), s && (s = null, n ||= "Your browser only supports WebGL1")), !s)
    throw n ||= "Your browser does not support WebGL", new Error(`Failed to create WebGL context: ${n}`);
  const { onContextLost: o, onContextRestored: l } = e;
  return r.addEventListener("webglcontextlost", (u) => o(u), !1), r.addEventListener("webglcontextrestored", (u) => l(u), !1), s.luma ||= {}, s;
}
function bp(r, e, t) {
  return t[e] === void 0 && (t[e] = r.getExtension(e) || null), t[e];
}
function nq(r, e) {
  const t = r.getParameter(7936), n = r.getParameter(7937);
  bp(r, "WEBGL_debug_renderer_info", e);
  const i = e.WEBGL_debug_renderer_info, s = r.getParameter(i ? i.UNMASKED_VENDOR_WEBGL : 7936), o = r.getParameter(i ? i.UNMASKED_RENDERER_WEBGL : 7937), l = s || t, u = o || n, m = r.getParameter(7938), y = d6(l, u), E = iq(l, u), P = sq(l, u);
  return {
    type: "webgl",
    gpu: y,
    gpuType: P,
    gpuBackend: E,
    vendor: l,
    renderer: u,
    version: m,
    shadingLanguage: "glsl",
    shadingLanguageVersion: 300
  };
}
function d6(r, e) {
  return /NVIDIA/i.exec(r) || /NVIDIA/i.exec(e) ? "nvidia" : /INTEL/i.exec(r) || /INTEL/i.exec(e) ? "intel" : /Apple/i.exec(r) || /Apple/i.exec(e) ? "apple" : /AMD/i.exec(r) || /AMD/i.exec(e) || /ATI/i.exec(r) || /ATI/i.exec(e) ? "amd" : /SwiftShader/i.exec(r) || /SwiftShader/i.exec(e) ? "software" : "unknown";
}
function iq(r, e) {
  return /Metal/i.exec(r) || /Metal/i.exec(e) ? "metal" : /ANGLE/i.exec(r) || /ANGLE/i.exec(e) ? "opengl" : "unknown";
}
function sq(r, e) {
  if (/SwiftShader/i.exec(r) || /SwiftShader/i.exec(e))
    return "cpu";
  switch (d6(r, e)) {
    case "intel":
      return "integrated";
    case "software":
      return "cpu";
    case "unknown":
      return "unknown";
    default:
      return "discrete";
  }
}
function p6(r) {
  switch (r) {
    case "uint8":
      return 5121;
    case "sint8":
      return 5120;
    case "unorm8":
      return 5121;
    case "snorm8":
      return 5120;
    case "uint16":
      return 5123;
    case "sint16":
      return 5122;
    case "unorm16":
      return 5123;
    case "snorm16":
      return 5122;
    case "uint32":
      return 5125;
    case "sint32":
      return 5124;
    // WebGPU does not support normalized 32 bit integer attributes
    // case 'unorm32': return GL.UNSIGNED_INT;
    // case 'snorm32': return GL.INT;
    case "float16":
      return 5131;
    case "float32":
      return 5126;
  }
  throw new Error(String(r));
}
const BA = "WEBGL_compressed_texture_s3tc", OA = "WEBGL_compressed_texture_s3tc_srgb", Xd = "EXT_texture_compression_rgtc", Zd = "EXT_texture_compression_bptc", oq = "WEBGL_compressed_texture_etc", aq = "WEBGL_compressed_texture_astc", lq = "WEBGL_compressed_texture_etc1", cq = "WEBGL_compressed_texture_pvrtc", uq = "WEBGL_compressed_texture_atc", iS = "EXT_texture_norm16", sS = "EXT_render_snorm", fq = "EXT_color_buffer_float", Xx = {
  "float32-renderable-webgl": ["EXT_color_buffer_float"],
  "float16-renderable-webgl": ["EXT_color_buffer_half_float"],
  "rgb9e5ufloat-renderable-webgl": ["WEBGL_render_shared_exponent"],
  "snorm8-renderable-webgl": [sS],
  "norm16-renderable-webgl": [iS],
  "snorm16-renderable-webgl": [iS, sS],
  "float32-filterable": ["OES_texture_float_linear"],
  "float16-filterable-webgl": ["OES_texture_half_float_linear"],
  "texture-filterable-anisotropic-webgl": ["EXT_texture_filter_anisotropic"],
  "texture-blend-float-webgl": ["EXT_float_blend"],
  "texture-compression-bc": [BA, OA, Xd, Zd],
  // 'texture-compression-bc3-srgb-webgl': [X_S3TC_SRGB],
  // 'texture-compression-bc3-webgl': [X_S3TC],
  "texture-compression-bc5-webgl": [Xd],
  "texture-compression-bc7-webgl": [Zd],
  "texture-compression-etc2": [oq],
  "texture-compression-astc": [aq],
  "texture-compression-etc1-webgl": [lq],
  "texture-compression-pvrtc-webgl": [cq],
  "texture-compression-atc-webgl": [uq]
};
function hq(r) {
  return r in Xx;
}
function dq(r, e, t) {
  return (Xx[e] || []).every((i) => bp(r, i, t));
}
const Zx = {
  // 8-bit formats
  r8unorm: { gl: 33321, rb: !0 },
  r8snorm: { gl: 36756 },
  r8uint: { gl: 33330, rb: !0 },
  r8sint: { gl: 33329, rb: !0 },
  // 16-bit formats
  rg8unorm: { gl: 33323, rb: !0 },
  rg8snorm: { gl: 36757 },
  rg8uint: { gl: 33336, rb: !0 },
  rg8sint: { gl: 33335, rb: !0 },
  r16uint: { gl: 33332, rb: !0 },
  r16sint: { gl: 33331, rb: !0 },
  r16float: { gl: 33325, rb: !0 },
  r16unorm: { gl: 33322, rb: !0 },
  r16snorm: { gl: 36760 },
  // Packed 16-bit formats
  "rgba4unorm-webgl": { gl: 32854, rb: !0 },
  "rgb565unorm-webgl": { gl: 36194, rb: !0 },
  "rgb5a1unorm-webgl": { gl: 32855, rb: !0 },
  // 24-bit formats
  "rgb8unorm-webgl": { gl: 32849 },
  "rgb8snorm-webgl": { gl: 36758 },
  // 32-bit formats
  rgba8unorm: { gl: 32856 },
  "rgba8unorm-srgb": { gl: 35907 },
  rgba8snorm: { gl: 36759 },
  rgba8uint: { gl: 36220 },
  rgba8sint: { gl: 36238 },
  // reverse colors, webgpu only
  bgra8unorm: {},
  "bgra8unorm-srgb": {},
  rg16uint: { gl: 33338 },
  rg16sint: { gl: 33337 },
  rg16float: { gl: 33327, rb: !0 },
  rg16unorm: { gl: 33324 },
  rg16snorm: { gl: 36761 },
  r32uint: { gl: 33334, rb: !0 },
  r32sint: { gl: 33333, rb: !0 },
  r32float: { gl: 33326 },
  // Packed 32-bit formats
  rgb9e5ufloat: { gl: 35901 },
  // , filter: true},
  rg11b10ufloat: { gl: 35898, rb: !0 },
  rgb10a2unorm: { gl: 32857, rb: !0 },
  rgb10a2uint: { gl: 36975, rb: !0 },
  // 48-bit formats
  "rgb16unorm-webgl": { gl: 32852 },
  // rgb not renderable
  "rgb16snorm-webgl": { gl: 36762 },
  // rgb not renderable
  // 64-bit formats
  rg32uint: { gl: 33340, rb: !0 },
  rg32sint: { gl: 33339, rb: !0 },
  rg32float: { gl: 33328, rb: !0 },
  rgba16uint: { gl: 36214, rb: !0 },
  rgba16sint: { gl: 36232, rb: !0 },
  rgba16float: { gl: 34842 },
  rgba16unorm: { gl: 32859, rb: !0 },
  rgba16snorm: { gl: 36763 },
  // 96-bit formats (deprecated!)
  "rgb32float-webgl": { gl: 34837, x: fq, dataFormat: 6407, types: [5126] },
  // 128-bit formats
  rgba32uint: { gl: 36208, rb: !0 },
  rgba32sint: { gl: 36226, rb: !0 },
  rgba32float: { gl: 34836, rb: !0 },
  // Depth and stencil formats
  stencil8: { gl: 36168, rb: !0 },
  // 8 stencil bits
  depth16unorm: { gl: 33189, dataFormat: 6402, types: [5123], rb: !0 },
  // 16 depth bits
  depth24plus: { gl: 33190, dataFormat: 6402, types: [5125] },
  depth32float: { gl: 36012, dataFormat: 6402, types: [5126], rb: !0 },
  // The depth component of the "depth24plus" and "depth24plus-stencil8" formats may be implemented as either a 24-bit depth value or a "depth32float" value.
  "depth24plus-stencil8": { gl: 35056, rb: !0, depthTexture: !0, dataFormat: 34041, types: [34042] },
  // "depth32float-stencil8" feature - TODO below is render buffer only?
  "depth32float-stencil8": { gl: 36013, dataFormat: 34041, types: [36269], rb: !0 },
  // BC compressed formats: check device.features.has("texture-compression-bc");
  "bc1-rgb-unorm-webgl": { gl: 33776, x: BA },
  "bc1-rgb-unorm-srgb-webgl": { gl: 35916, x: OA },
  "bc1-rgba-unorm": { gl: 33777, x: BA },
  "bc1-rgba-unorm-srgb": { gl: 35916, x: OA },
  "bc2-rgba-unorm": { gl: 33778, x: BA },
  "bc2-rgba-unorm-srgb": { gl: 35918, x: OA },
  "bc3-rgba-unorm": { gl: 33779, x: BA },
  "bc3-rgba-unorm-srgb": { gl: 35919, x: OA },
  "bc4-r-unorm": { gl: 36283, x: Xd },
  "bc4-r-snorm": { gl: 36284, x: Xd },
  "bc5-rg-unorm": { gl: 36285, x: Xd },
  "bc5-rg-snorm": { gl: 36286, x: Xd },
  "bc6h-rgb-ufloat": { gl: 36495, x: Zd },
  "bc6h-rgb-float": { gl: 36494, x: Zd },
  "bc7-rgba-unorm": { gl: 36492, x: Zd },
  "bc7-rgba-unorm-srgb": { gl: 36493, x: Zd },
  // WEBGL_compressed_texture_etc: device.features.has("texture-compression-etc2")
  // Note: Supposedly guaranteed availability compressed formats in WebGL2, but through CPU decompression
  "etc2-rgb8unorm": { gl: 37492 },
  "etc2-rgb8unorm-srgb": { gl: 37494 },
  "etc2-rgb8a1unorm": { gl: 37496 },
  "etc2-rgb8a1unorm-srgb": { gl: 37497 },
  "etc2-rgba8unorm": { gl: 37493 },
  "etc2-rgba8unorm-srgb": { gl: 37495 },
  "eac-r11unorm": { gl: 37488 },
  "eac-r11snorm": { gl: 37489 },
  "eac-rg11unorm": { gl: 37490 },
  "eac-rg11snorm": { gl: 37491 },
  // X_ASTC compressed formats: device.features.has("texture-compression-astc")
  "astc-4x4-unorm": { gl: 37808 },
  "astc-4x4-unorm-srgb": { gl: 37840 },
  "astc-5x4-unorm": { gl: 37809 },
  "astc-5x4-unorm-srgb": { gl: 37841 },
  "astc-5x5-unorm": { gl: 37810 },
  "astc-5x5-unorm-srgb": { gl: 37842 },
  "astc-6x5-unorm": { gl: 37811 },
  "astc-6x5-unorm-srgb": { gl: 37843 },
  "astc-6x6-unorm": { gl: 37812 },
  "astc-6x6-unorm-srgb": { gl: 37844 },
  "astc-8x5-unorm": { gl: 37813 },
  "astc-8x5-unorm-srgb": { gl: 37845 },
  "astc-8x6-unorm": { gl: 37814 },
  "astc-8x6-unorm-srgb": { gl: 37846 },
  "astc-8x8-unorm": { gl: 37815 },
  "astc-8x8-unorm-srgb": { gl: 37847 },
  "astc-10x5-unorm": { gl: 37819 },
  "astc-10x5-unorm-srgb": { gl: 37851 },
  "astc-10x6-unorm": { gl: 37817 },
  "astc-10x6-unorm-srgb": { gl: 37849 },
  "astc-10x8-unorm": { gl: 37818 },
  "astc-10x8-unorm-srgb": { gl: 37850 },
  "astc-10x10-unorm": { gl: 37819 },
  "astc-10x10-unorm-srgb": { gl: 37851 },
  "astc-12x10-unorm": { gl: 37820 },
  "astc-12x10-unorm-srgb": { gl: 37852 },
  "astc-12x12-unorm": { gl: 37821 },
  "astc-12x12-unorm-srgb": { gl: 37853 },
  // WEBGL_compressed_texture_pvrtc
  "pvrtc-rgb4unorm-webgl": { gl: 35840 },
  "pvrtc-rgba4unorm-webgl": { gl: 35842 },
  "pvrtc-rbg2unorm-webgl": { gl: 35841 },
  "pvrtc-rgba2unorm-webgl": { gl: 35843 },
  // WEBGL_compressed_texture_etc1
  "etc1-rbg-unorm-webgl": { gl: 36196 },
  // WEBGL_compressed_texture_atc
  "atc-rgb-unorm-webgl": { gl: 35986 },
  "atc-rgba-unorm-webgl": { gl: 35986 },
  "atc-rgbai-unorm-webgl": { gl: 34798 }
};
function pq(r, e, t) {
  let n = e.create;
  const i = Zx[e.format];
  return i?.gl === void 0 && (n = !1), i?.x && (n = n && !!bp(r, i.x, t)), {
    format: e.format,
    // @ts-ignore
    create: n && e.create,
    // @ts-ignore
    render: n && e.render,
    // @ts-ignore
    filter: n && e.filter,
    // @ts-ignore
    blend: n && e.blend,
    // @ts-ignore
    store: n && e.store
  };
}
function A6(r) {
  const e = Zx[r], t = mq(r), n = ip.getInfo(r);
  return n.compressed && (e.dataFormat = t), {
    internalFormat: t,
    format: e?.dataFormat || gq(n.channels, n.integer, n.normalized, t),
    // depth formats don't have a type
    type: n.dataType ? p6(n.dataType) : e?.types?.[0] || 5121,
    compressed: n.compressed || !1
  };
}
function Aq(r) {
  switch (ip.getInfo(r).attachment) {
    case "depth":
      return 36096;
    case "stencil":
      return 36128;
    case "depth-stencil":
      return 33306;
    default:
      throw new Error(`Not a depth stencil format: ${r}`);
  }
}
function gq(r, e, t, n) {
  if (n === 6408 || n === 6407)
    return n;
  switch (r) {
    case "r":
      return e && !t ? 36244 : 6403;
    case "rg":
      return e && !t ? 33320 : 33319;
    case "rgb":
      return e && !t ? 36248 : 6407;
    case "rgba":
      return e && !t ? 36249 : 6408;
    case "bgra":
      throw new Error("bgra pixels not supported by WebGL");
    default:
      return 6408;
  }
}
function mq(r) {
  const t = Zx[r]?.gl;
  if (t === void 0)
    throw new Error(`Unsupported texture format ${r}`);
  return t;
}
const oS = {
  // optional WebGPU features
  "depth-clip-control": "EXT_depth_clamp",
  // TODO these seem subtly different
  // 'timestamp-query' // GPUQueryType "timestamp-query"
  // "indirect-first-instance"
  // Textures are handled by getTextureFeatures()
  // 'depth32float-stencil8' // GPUTextureFormat 'depth32float-stencil8'
  // optional WebGL features
  "timer-query-webgl": "EXT_disjoint_timer_query_webgl2",
  "compilation-status-async-webgl": "KHR_parallel_shader_compile",
  "polygon-mode-webgl": "WEBGL_polygon_mode",
  "provoking-vertex-webgl": "WEBGL_provoking_vertex",
  "shader-clip-cull-distance-webgl": "WEBGL_clip_cull_distance",
  "shader-noperspective-interpolation-webgl": "NV_shader_noperspective_interpolation",
  "shader-conservative-depth-webgl": "EXT_conservative_depth"
  // Textures are handled by getTextureFeatures()
};
class _q extends O9 {
  gl;
  extensions;
  testedFeatures = /* @__PURE__ */ new Set();
  constructor(e, t, n) {
    super([], n), this.gl = e, this.extensions = t, bp(e, "EXT_color_buffer_float", t);
  }
  *[Symbol.iterator]() {
    const e = this.getFeatures();
    for (const t of e)
      this.has(t) && (yield t);
    return [];
  }
  has(e) {
    return this.disabledFeatures?.[e] ? !1 : (this.testedFeatures.has(e) || (this.testedFeatures.add(e), hq(e) && dq(this.gl, e, this.extensions) && this.features.add(e), this.getWebGLFeature(e) && this.features.add(e)), this.features.has(e));
  }
  // FOR DEVICE
  initializeFeatures() {
    const e = this.getFeatures().filter((t) => t !== "polygon-mode-webgl");
    for (const t of e)
      this.has(t);
  }
  // IMPLEMENTATION
  getFeatures() {
    return [...Object.keys(oS), ...Object.keys(Xx)];
  }
  /** Extract all WebGL features */
  getWebGLFeature(e) {
    const t = oS[e];
    return typeof t == "string" ? !!bp(this.gl, t, this.extensions) : !!t;
  }
}
class yq extends B9 {
  get maxTextureDimension1D() {
    return 0;
  }
  // WebGL does not support 1D textures
  get maxTextureDimension2D() {
    return this.getParameter(3379);
  }
  get maxTextureDimension3D() {
    return this.getParameter(32883);
  }
  get maxTextureArrayLayers() {
    return this.getParameter(35071);
  }
  get maxBindGroups() {
    return 0;
  }
  get maxDynamicUniformBuffersPerPipelineLayout() {
    return 0;
  }
  // TBD
  get maxDynamicStorageBuffersPerPipelineLayout() {
    return 0;
  }
  // TBD
  get maxSampledTexturesPerShaderStage() {
    return this.getParameter(35660);
  }
  // ) TBD
  get maxSamplersPerShaderStage() {
    return this.getParameter(35661);
  }
  get maxStorageBuffersPerShaderStage() {
    return 0;
  }
  // TBD
  get maxStorageTexturesPerShaderStage() {
    return 0;
  }
  // TBD
  get maxUniformBuffersPerShaderStage() {
    return this.getParameter(35375);
  }
  get maxUniformBufferBindingSize() {
    return this.getParameter(35376);
  }
  get maxStorageBufferBindingSize() {
    return 0;
  }
  get minUniformBufferOffsetAlignment() {
    return this.getParameter(35380);
  }
  get minStorageBufferOffsetAlignment() {
    return 0;
  }
  get maxVertexBuffers() {
    return 16;
  }
  // WebGL 2 supports 16 buffers, see https://github.com/gpuweb/gpuweb/issues/4284
  get maxVertexAttributes() {
    return this.getParameter(34921);
  }
  get maxVertexBufferArrayStride() {
    return 2048;
  }
  // TBD, this is just the default value from WebGPU
  get maxInterStageShaderVariables() {
    return this.getParameter(35659);
  }
  get maxComputeWorkgroupStorageSize() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeInvocationsPerWorkgroup() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupSizeX() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupSizeY() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupSizeZ() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupsPerDimension() {
    return 0;
  }
  // WebGL does not support compute shaders
  // PRIVATE
  gl;
  limits = {};
  constructor(e) {
    super(), this.gl = e;
  }
  getParameter(e) {
    return this.limits[e] === void 0 && (this.limits[e] = this.gl.getParameter(e)), this.limits[e] || 0;
  }
}
class GA extends L_ {
  device;
  gl;
  handle;
  colorAttachments = [];
  depthStencilAttachment = null;
  constructor(e, t) {
    super(e, t);
    const n = t.handle === null;
    this.device = e, this.gl = e.gl, this.handle = this.props.handle || n ? this.props.handle : this.gl.createFramebuffer(), n || (e._setWebGLDebugMetadata(this.handle, this, { spector: this.props }), this.autoCreateAttachmentTextures(), this.updateAttachments());
  }
  /** destroys any auto created resources etc. */
  destroy() {
    super.destroy(), !this.destroyed && this.handle !== null && this.gl.deleteFramebuffer(this.handle);
  }
  updateAttachments() {
    const e = this.gl.bindFramebuffer(36160, this.handle);
    for (let t = 0; t < this.colorAttachments.length; ++t) {
      const n = this.colorAttachments[t];
      if (n) {
        const i = 36064 + t;
        this._attachTextureView(i, n);
      }
    }
    if (this.depthStencilAttachment) {
      const t = Aq(this.depthStencilAttachment.props.format);
      this._attachTextureView(t, this.depthStencilAttachment);
    }
    if (this.device.props.debug) {
      const t = this.gl.checkFramebufferStatus(36160);
      if (t !== 36053)
        throw new Error(`Framebuffer ${bq(t)}`);
    }
    this.gl.bindFramebuffer(36160, e);
  }
  // PRIVATE
  /** In WebGL we must use renderbuffers for depth/stencil attachments (unless we have extensions) */
  // protected override createDepthStencilTexture(format: TextureFormat): Texture {
  //   // return new WEBGLRenderbuffer(this.device, {
  //   return new WEBGLTexture(this.device, {
  //     id: `${this.id}-depth-stencil`,
  //     format,
  //     width: this.width,
  //     height: this.height,
  //     mipmaps: false
  //   });
  // }
  /**
   * @param attachment
   * @param texture
   * @param layer = 0 - index into WEBGLTextureArray and Texture3D or face for `TextureCubeMap`
   * @param level = 0 - mipmapLevel
   */
  _attachTextureView(e, t) {
    const { gl: n } = this.device, { texture: i } = t, s = t.props.baseMipLevel, o = t.props.baseArrayLayer;
    switch (n.bindTexture(i.glTarget, i.handle), i.glTarget) {
      case 35866:
      case 32879:
        n.framebufferTextureLayer(36160, e, i.handle, s, o);
        break;
      case 34067:
        const l = vq(o);
        n.framebufferTexture2D(36160, e, l, i.handle, s);
        break;
      case 3553:
        n.framebufferTexture2D(36160, e, 3553, i.handle, s);
        break;
      default:
        throw new Error("Illegal texture type");
    }
    n.bindTexture(i.glTarget, null);
  }
}
function vq(r) {
  return r < 34069 ? r + 34069 : r;
}
function bq(r) {
  switch (r) {
    case 36053:
      return "success";
    case 36054:
      return "Mismatched attachments";
    case 36055:
      return "No attachments";
    case 36057:
      return "Height/width mismatch";
    case 36061:
      return "Unsupported or split attachments";
    // WebGL2
    case 36182:
      return "Samples mismatch";
    // OVR_multiview2 extension
    // case GL.FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_OVR: return 'baseViewIndex mismatch';
    default:
      return `${r}`;
  }
}
class xq extends Gf {
  device;
  handle = null;
  _framebuffer = null;
  get [Symbol.toStringTag]() {
    return "WebGLCanvasContext";
  }
  constructor(e, t) {
    super(t), this.device = e, this._setAutoCreatedCanvasId(`${this.device.id}-canvas`), this._updateDevice();
  }
  getCurrentFramebuffer() {
    return this._framebuffer = this._framebuffer || new GA(this.device, { handle: null }), this._framebuffer;
  }
  // IMPLEMENTATION OF ABSTRACT METHODS
  _updateDevice() {
  }
}
const Hv = {};
function wq(r = "id") {
  Hv[r] = Hv[r] || 1;
  const e = Hv[r]++;
  return `${r}-${e}`;
}
class WA extends vi {
  device;
  gl;
  handle;
  /** Target in OpenGL defines the type of buffer */
  glTarget;
  /** Usage is a hint on how frequently the buffer will be updates */
  glUsage;
  /** Index type is needed when issuing draw calls, so we pre-compute it */
  glIndexType = 5123;
  /** Number of bytes allocated on the GPU for this buffer */
  byteLength = 0;
  /** Number of bytes used */
  bytesUsed = 0;
  constructor(e, t = {}) {
    super(e, t), this.device = e, this.gl = this.device.gl;
    const n = typeof t == "object" ? t.handle : void 0;
    this.handle = n || this.gl.createBuffer(), e._setWebGLDebugMetadata(this.handle, this, {
      spector: { ...this.props, data: typeof this.props.data }
    }), this.glTarget = Tq(this.props.usage), this.glUsage = Eq(this.props.usage), this.glIndexType = this.props.indexType === "uint32" ? 5125 : 5123, t.data ? this._initWithData(t.data, t.byteOffset, t.byteLength) : this._initWithByteLength(t.byteLength || 0);
  }
  destroy() {
    !this.destroyed && this.handle && (this.removeStats(), this.trackDeallocatedMemory(), this.gl.deleteBuffer(this.handle), this.destroyed = !0, this.handle = null);
  }
  /** Allocate a new buffer and initialize to contents of typed array */
  _initWithData(e, t = 0, n = e.byteLength + t) {
    const i = this.glTarget;
    this.gl.bindBuffer(i, this.handle), this.gl.bufferData(i, n, this.glUsage), this.gl.bufferSubData(i, t, e), this.gl.bindBuffer(i, null), this.bytesUsed = n, this.byteLength = n, this._setDebugData(e, t, n), this.trackAllocatedMemory(n);
  }
  // Allocate a GPU buffer of specified size.
  _initWithByteLength(e) {
    let t = e;
    e === 0 && (t = new Float32Array(0));
    const n = this.glTarget;
    return this.gl.bindBuffer(n, this.handle), this.gl.bufferData(n, t, this.glUsage), this.gl.bindBuffer(n, null), this.bytesUsed = e, this.byteLength = e, this._setDebugData(null, 0, e), this.trackAllocatedMemory(e), this;
  }
  write(e, t = 0) {
    const n = ArrayBuffer.isView(e) ? e : new Uint8Array(e), i = 36663;
    this.gl.bindBuffer(i, this.handle), this.gl.bufferSubData(i, t, n), this.gl.bindBuffer(i, null), this._setDebugData(e, t, e.byteLength);
  }
  async mapAndWriteAsync(e, t = 0, n = this.byteLength - t) {
    const i = new ArrayBuffer(n);
    await e(i, "copied"), this.write(i, t);
  }
  async readAsync(e = 0, t) {
    return this.readSyncWebGL(e, t);
  }
  async mapAndReadAsync(e, t = 0, n) {
    const i = await this.readAsync(t, n);
    return await e(i.buffer, "copied");
  }
  readSyncWebGL(e = 0, t) {
    t = t ?? this.byteLength - e;
    const n = new Uint8Array(t), i = 0;
    return this.gl.bindBuffer(36662, this.handle), this.gl.getBufferSubData(36662, e, n, i, t), this.gl.bindBuffer(36662, null), this._setDebugData(n, e, t), n;
  }
}
function Tq(r) {
  return r & vi.INDEX ? 34963 : r & vi.VERTEX ? 34962 : r & vi.UNIFORM ? 35345 : 34962;
}
function Eq(r) {
  return r & vi.INDEX || r & vi.VERTEX ? 35044 : r & vi.UNIFORM ? 35048 : 35044;
}
function Cq(r) {
  const e = r.split(/\r?\n/), t = [];
  for (const n of e) {
    if (n.length <= 1)
      continue;
    const i = n.split(":");
    if (i.length === 2) {
      const [E, P] = i;
      t.push({
        message: P.trim(),
        type: aS(E),
        lineNum: 0,
        linePos: 0
      });
      continue;
    }
    const [s, o, l, ...u] = i;
    let m = parseInt(l, 10);
    isNaN(m) && (m = 0);
    let y = parseInt(o, 10);
    isNaN(y) && (y = 0), t.push({
      message: u.join(":").trim(),
      type: aS(s),
      lineNum: m,
      linePos: y
      // TODO
    });
  }
  return t;
}
function aS(r) {
  const e = ["warning", "error", "info"], t = r.toLowerCase();
  return e.includes(t) ? t : "info";
}
class Sq extends D_ {
  device;
  handle;
  constructor(e, t) {
    switch (super(e, t), this.device = e, this.props.stage) {
      case "vertex":
        this.handle = this.props.handle || this.device.gl.createShader(35633);
        break;
      case "fragment":
        this.handle = this.props.handle || this.device.gl.createShader(35632);
        break;
      default:
        throw new Error(this.props.stage);
    }
    e._setWebGLDebugMetadata(this.handle, this, { spector: this.props }), this._compile(this.source);
  }
  destroy() {
    this.handle && (this.removeStats(), this.device.gl.deleteShader(this.handle), this.destroyed = !0, this.handle.destroyed = !0);
  }
  get asyncCompilationStatus() {
    return this._waitForCompilationComplete().then(() => (this._getCompilationStatus(), this.compilationStatus));
  }
  async getCompilationInfo() {
    return await this._waitForCompilationComplete(), this.getCompilationInfoSync();
  }
  getCompilationInfoSync() {
    const e = this.device.gl.getShaderInfoLog(this.handle);
    return e ? Cq(e) : [];
  }
  getTranslatedSource() {
    return this.device.getExtension("WEBGL_debug_shaders").WEBGL_debug_shaders?.getTranslatedShaderSource(this.handle) || null;
  }
  // PRIVATE METHODS
  /** Compile a shader and get compilation status */
  async _compile(e) {
    e = e.startsWith("#version ") ? e : `#version 300 es
${e}`;
    const { gl: t } = this.device;
    if (t.shaderSource(this.handle, e), t.compileShader(this.handle), !this.device.props.debug) {
      this.compilationStatus = "pending";
      return;
    }
    if (!this.device.features.has("compilation-status-async-webgl")) {
      if (this._getCompilationStatus(), this.debugShader(), this.compilationStatus === "error")
        throw new Error(`GLSL compilation errors in ${this.props.stage} shader ${this.props.id}`);
      return;
    }
    qt.once(1, "Shader compilation is asynchronous")(), await this._waitForCompilationComplete(), qt.info(2, `Shader ${this.id} - async compilation complete: ${this.compilationStatus}`)(), this._getCompilationStatus(), this.debugShader();
  }
  /** Use KHR_parallel_shader_compile extension if available */
  async _waitForCompilationComplete() {
    const e = async (i) => await new Promise((s) => setTimeout(s, i));
    if (!this.device.features.has("compilation-status-async-webgl")) {
      await e(10);
      return;
    }
    const { gl: n } = this.device;
    for (; ; ) {
      if (n.getShaderParameter(this.handle, 37297))
        return;
      await e(10);
    }
  }
  /**
   * Get the shader compilation status
   * TODO - Load log even when no error reported, to catch warnings?
   * https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings
   */
  _getCompilationStatus() {
    this.compilationStatus = this.device.gl.getShaderParameter(this.handle, 35713) ? "success" : "error";
  }
}
function Iq(r, e, t, n) {
  if (Bq(e))
    return n(r);
  const i = r;
  i.pushState();
  try {
    return Pq(r, e), kp(i.gl, t), n(r);
  } finally {
    i.popState();
  }
}
function Pq(r, e) {
  const t = r, { gl: n } = t;
  if (e.cullMode)
    switch (e.cullMode) {
      case "none":
        n.disable(2884);
        break;
      case "front":
        n.enable(2884), n.cullFace(1028);
        break;
      case "back":
        n.enable(2884), n.cullFace(1029);
        break;
    }
  if (e.frontFace && n.frontFace(Qf("frontFace", e.frontFace, {
    ccw: 2305,
    cw: 2304
  })), e.unclippedDepth && r.features.has("depth-clip-control") && n.enable(34383), e.depthBias !== void 0 && (n.enable(32823), n.polygonOffset(e.depthBias, e.depthBiasSlopeScale || 0)), e.provokingVertex && r.features.has("provoking-vertex-webgl")) {
    const s = t.getExtension("WEBGL_provoking_vertex").WEBGL_provoking_vertex, o = Qf("provokingVertex", e.provokingVertex, {
      first: 36429,
      last: 36430
    });
    s?.provokingVertexWEBGL(o);
  }
  if ((e.polygonMode || e.polygonOffsetLine) && r.features.has("polygon-mode-webgl")) {
    if (e.polygonMode) {
      const s = t.getExtension("WEBGL_polygon_mode").WEBGL_polygon_mode, o = Qf("polygonMode", e.polygonMode, {
        fill: 6914,
        line: 6913
      });
      s?.polygonModeWEBGL(1028, o), s?.polygonModeWEBGL(1029, o);
    }
    e.polygonOffsetLine && n.enable(10754);
  }
  if (r.features.has("shader-clip-cull-distance-webgl") && (e.clipDistance0 && n.enable(12288), e.clipDistance1 && n.enable(12289), e.clipDistance2 && n.enable(12290), e.clipDistance3 && n.enable(12291), e.clipDistance4 && n.enable(12292), e.clipDistance5 && n.enable(12293), e.clipDistance6 && n.enable(12294), e.clipDistance7 && n.enable(12295)), e.depthWriteEnabled !== void 0 && n.depthMask(Rq("depthWriteEnabled", e.depthWriteEnabled)), e.depthCompare && (e.depthCompare !== "always" ? n.enable(2929) : n.disable(2929), n.depthFunc($b("depthCompare", e.depthCompare))), e.stencilWriteMask) {
    const i = e.stencilWriteMask;
    n.stencilMaskSeparate(1028, i), n.stencilMaskSeparate(1029, i);
  }
  if (e.stencilReadMask && qt.warn("stencilReadMask not supported under WebGL"), e.stencilCompare) {
    const i = e.stencilReadMask || 4294967295, s = $b("depthCompare", e.stencilCompare);
    e.stencilCompare !== "always" ? n.enable(2960) : n.disable(2960), n.stencilFuncSeparate(1028, s, 0, i), n.stencilFuncSeparate(1029, s, 0, i);
  }
  if (e.stencilPassOperation && e.stencilFailOperation && e.stencilDepthFailOperation) {
    const i = Gv("stencilPassOperation", e.stencilPassOperation), s = Gv("stencilFailOperation", e.stencilFailOperation), o = Gv("stencilDepthFailOperation", e.stencilDepthFailOperation);
    n.stencilOpSeparate(1028, s, o, i), n.stencilOpSeparate(1029, s, o, i);
  }
  switch (e.blend) {
    case !0:
      n.enable(3042);
      break;
    case !1:
      n.disable(3042);
      break;
  }
  if (e.blendColorOperation || e.blendAlphaOperation) {
    const i = lS("blendColorOperation", e.blendColorOperation || "add"), s = lS("blendAlphaOperation", e.blendAlphaOperation || "add");
    n.blendEquationSeparate(i, s);
    const o = Cg("blendColorSrcFactor", e.blendColorSrcFactor || "one"), l = Cg("blendColorDstFactor", e.blendColorDstFactor || "zero"), u = Cg("blendAlphaSrcFactor", e.blendAlphaSrcFactor || "one"), m = Cg("blendAlphaDstFactor", e.blendAlphaDstFactor || "zero");
    n.blendFuncSeparate(o, l, u, m);
  }
}
function $b(r, e) {
  return Qf(r, e, {
    never: 512,
    less: 513,
    equal: 514,
    "less-equal": 515,
    greater: 516,
    "not-equal": 517,
    "greater-equal": 518,
    always: 519
  });
}
function Gv(r, e) {
  return Qf(r, e, {
    keep: 7680,
    zero: 0,
    replace: 7681,
    invert: 5386,
    "increment-clamp": 7682,
    "decrement-clamp": 7683,
    "increment-wrap": 34055,
    "decrement-wrap": 34056
  });
}
function lS(r, e) {
  return Qf(r, e, {
    add: 32774,
    subtract: 32778,
    "reverse-subtract": 32779,
    min: 32775,
    max: 32776
  });
}
function Cg(r, e, t = "color") {
  return Qf(r, e, {
    one: 1,
    zero: 0,
    src: 768,
    "one-minus-src": 769,
    dst: 774,
    "one-minus-dst": 775,
    "src-alpha": 770,
    "one-minus-src-alpha": 771,
    "dst-alpha": 772,
    "one-minus-dst-alpha": 773,
    "src-alpha-saturated": 776,
    constant: t === "color" ? 32769 : 32771,
    "one-minus-constant": t === "color" ? 32770 : 32772,
    // 'constant-alpha': GL.CONSTANT_ALPHA,
    // 'one-minus-constant-alpha': GL.ONE_MINUS_CONSTANT_ALPHA,
    // TODO not supported in WebGL2
    src1: 768,
    "one-minus-src1": 769,
    "src1-alpha": 770,
    "one-minus-src1-alpha": 771
  });
}
function Mq(r, e) {
  return `Illegal parameter ${e} for ${r}`;
}
function Qf(r, e, t) {
  if (!(e in t))
    throw new Error(Mq(r, e));
  return t[e];
}
function Rq(r, e) {
  return e;
}
function Bq(r) {
  let e = !0;
  for (const t in r) {
    e = !1;
    break;
  }
  return e;
}
function g6(r) {
  const e = {};
  return r.addressModeU && (e[10242] = Wv(r.addressModeU)), r.addressModeV && (e[10243] = Wv(r.addressModeV)), r.addressModeW && (e[32882] = Wv(r.addressModeW)), r.magFilter && (e[10240] = qb(r.magFilter)), (r.minFilter || r.mipmapFilter) && (e[10241] = Oq(r.minFilter || "linear", r.mipmapFilter)), r.lodMinClamp !== void 0 && (e[33082] = r.lodMinClamp), r.lodMaxClamp !== void 0 && (e[33083] = r.lodMaxClamp), r.type === "comparison-sampler" && (e[34892] = 34894), r.compare && (e[34893] = $b("compare", r.compare)), r.maxAnisotropy && (e[34046] = r.maxAnisotropy), e;
}
function Wv(r) {
  switch (r) {
    case "clamp-to-edge":
      return 33071;
    case "repeat":
      return 10497;
    case "mirror-repeat":
      return 33648;
  }
}
function qb(r) {
  switch (r) {
    case "nearest":
      return 9728;
    case "linear":
      return 9729;
  }
}
function Oq(r, e = "none") {
  if (!e)
    return qb(r);
  switch (e) {
    case "none":
      return qb(r);
    case "nearest":
      switch (r) {
        case "nearest":
          return 9984;
        case "linear":
          return 9985;
      }
      break;
    case "linear":
      switch (r) {
        case "nearest":
          return 9986;
        case "linear":
          return 9987;
      }
  }
}
class Dq extends th {
  device;
  handle;
  parameters;
  constructor(e, t) {
    super(e, t), this.device = e, this.parameters = g6(t), this.handle = t.handle || this.device.gl.createSampler(), this._setSamplerParameters(this.parameters);
  }
  destroy() {
    this.handle && (this.device.gl.deleteSampler(this.handle), this.handle = void 0);
  }
  toString() {
    return `Sampler(${this.id},${JSON.stringify(this.props)})`;
  }
  /** Set sampler parameters on the sampler */
  _setSamplerParameters(e) {
    for (const [t, n] of Object.entries(e)) {
      const i = Number(t);
      switch (i) {
        case 33082:
        case 33083:
          this.device.gl.samplerParameterf(this.handle, i, n);
          break;
        default:
          this.device.gl.samplerParameteri(this.handle, i, n);
          break;
      }
    }
  }
}
function o0(r, e, t) {
  if (Lq(e))
    return t(r);
  const { nocatch: n = !0 } = e, i = Kf.get(r);
  i.push(), kp(r, e);
  let s;
  if (n)
    s = t(r), i.pop();
  else
    try {
      s = t(r);
    } finally {
      i.pop();
    }
  return s;
}
function Lq(r) {
  for (const e in r)
    return !1;
  return !0;
}
class Yd extends O_ {
  device;
  gl;
  handle;
  // Does not have a WebGL representation
  texture;
  constructor(e, t) {
    super(e, { ...ps.defaultProps, ...t }), this.device = e, this.gl = this.device.gl, this.handle = null, this.texture = t.texture;
  }
}
class $A extends ps {
  // readonly MAX_ATTRIBUTES: number;
  device;
  gl;
  handle;
  // @ts-ignore TODO - currently unused in WebGL. Create dummy sampler?
  sampler = void 0;
  view;
  /**
   * The WebGL target corresponding to the texture type
   * @note `target` cannot be modified by bind:
   * textures are special because when you first bind them to a target,
   * When you first bind a texture as a GL_TEXTURE_2D, you are saying that this texture is a 2D texture.
   * And it will always be a 2D texture; this state cannot be changed ever.
   * A texture that was first bound as a GL_TEXTURE_2D, must always be bound as a GL_TEXTURE_2D;
   * attempting to bind it as GL_TEXTURE_3D will give rise to a run-time error
   */
  glTarget;
  /** The WebGL format - essentially channel structure */
  glFormat;
  /** The WebGL data format - the type of each channel */
  glType;
  /** The WebGL constant corresponding to the WebGPU style constant in format */
  glInternalFormat;
  /** Whether the internal format is compressed */
  compressed;
  // state
  /** Texture binding slot - TODO - move to texture view? */
  _textureUnit = 0;
  constructor(e, t) {
    super(e, t), this.device = e, this.gl = this.device.gl;
    const n = A6(this.props.format);
    this.glTarget = kq(this.props.dimension), this.glInternalFormat = n.internalFormat, this.glFormat = n.format, this.glType = n.type, this.compressed = n.compressed, this.handle = this.props.handle || this.gl.createTexture(), this.device._setWebGLDebugMetadata(this.handle, this, { spector: this.props }), this.gl.bindTexture(this.glTarget, this.handle);
    const { dimension: i, width: s, height: o, depth: l, mipLevels: u, glTarget: m, glInternalFormat: y } = this;
    switch (i) {
      case "2d":
      case "cube":
        this.gl.texStorage2D(m, u, y, s, o);
        break;
      case "2d-array":
      case "3d":
        this.gl.texStorage3D(m, u, y, s, o, l);
        break;
      default:
        throw new Error(i);
    }
    this.gl.bindTexture(this.glTarget, null), this._initializeData(t.data), this.setSampler(this.props.sampler), this.view = new Yd(this.device, { ...this.props, texture: this }), Object.seal(this);
  }
  destroy() {
    this.handle && (this.gl.deleteTexture(this.handle), this.removeStats(), this.trackDeallocatedMemory("Texture"), this.destroyed = !0);
  }
  createView(e) {
    return new Yd(this.device, { ...e, texture: this });
  }
  setSampler(e = {}) {
    super.setSampler(e);
    const t = g6(this.sampler.props);
    this._setSamplerParameters(t);
  }
  copyImageData(e) {
    const t = this._normalizeCopyImageDataOptions(e), n = t.data, { width: i, height: s, depth: o } = this, { mipLevel: l = 0, byteOffset: u = 0, x: m = 0, y = 0, z: E = 0 } = t, { glFormat: P, glType: L, compressed: U } = this, V = cS(this.glTarget, this.dimension, E);
    let q;
    if (!this.compressed) {
      const { bytesPerPixel: K } = this.device.getTextureFormatInfo(this.format);
      if (K) {
        if (t.bytesPerRow % K !== 0)
          throw new Error(`bytesPerRow (${t.bytesPerRow}) must be a multiple of bytesPerPixel (${K}) for ${this.format}`);
        q = t.bytesPerRow / K;
      }
    }
    const j = this.compressed ? {} : {
      ...q !== void 0 ? { 3314: q } : {},
      32878: t.rowsPerImage
    };
    this.gl.bindTexture(V, this.handle), o0(this.gl, j, () => {
      switch (this.dimension) {
        case "2d":
        case "cube":
          U ? this.gl.compressedTexSubImage2D(V, l, m, y, i, s, P, n, u) : this.gl.texSubImage2D(V, l, m, y, i, s, P, L, n, u);
          break;
        case "2d-array":
        case "3d":
          U ? this.gl.compressedTexSubImage3D(V, l, m, y, E, i, s, o, P, n, u) : this.gl.texSubImage3D(V, l, m, y, E, i, s, o, P, L, n, u);
          break;
        default:
      }
    }), this.gl.bindTexture(V, null);
  }
  copyExternalImage(e) {
    const t = this._normalizeCopyExternalImageOptions(e);
    if (t.sourceX || t.sourceY)
      throw new Error("WebGL does not support sourceX/sourceY)");
    const { glFormat: n, glType: i } = this, { image: s, depth: o, mipLevel: l, x: u, y: m, z: y, width: E, height: P } = t, L = cS(this.glTarget, this.dimension, o), U = t.flipY ? { 37440: !0 } : {};
    return this.gl.bindTexture(this.glTarget, this.handle), o0(this.gl, U, () => {
      switch (this.dimension) {
        case "2d":
        case "cube":
          this.gl.texSubImage2D(L, l, u, m, E, P, n, i, s);
          break;
        case "2d-array":
        case "3d":
          this.gl.texSubImage3D(L, l, u, m, y, E, P, o, n, i, s);
          break;
        default:
      }
    }), this.gl.bindTexture(this.glTarget, null), { width: t.width, height: t.height };
  }
  // WEBGL SPECIFIC
  generateMipmapsWebGL(e) {
    if (!(!(this.device.isTextureFormatRenderable(this.props.format) && this.device.isTextureFormatFilterable(this.props.format)) && (qt.warn(`${this} is not renderable or filterable, may not be able to generate mipmaps`)(), !e?.force)))
      try {
        this.gl.bindTexture(this.glTarget, this.handle), this.gl.generateMipmap(this.glTarget);
      } catch (n) {
        qt.warn(`Error generating mipmap for ${this}: ${n.message}`)();
      } finally {
        this.gl.bindTexture(this.glTarget, null);
      }
  }
  // INTERNAL
  /**
   * Sets sampler parameters on texture
   */
  _setSamplerParameters(e) {
    qt.log(2, `${this.id} sampler parameters`, this.device.getGLKeys(e))(), this.gl.bindTexture(this.glTarget, this.handle);
    for (const [t, n] of Object.entries(e)) {
      const i = Number(t), s = n;
      switch (i) {
        case 33082:
        case 33083:
          this.gl.texParameterf(this.glTarget, i, s);
          break;
        case 10240:
        case 10241:
          this.gl.texParameteri(this.glTarget, i, s);
          break;
        case 10242:
        case 10243:
        case 32882:
          this.gl.texParameteri(this.glTarget, i, s);
          break;
        case 34046:
          this.device.features.has("texture-filterable-anisotropic-webgl") && this.gl.texParameteri(this.glTarget, i, s);
          break;
        case 34892:
        case 34893:
          this.gl.texParameteri(this.glTarget, i, s);
          break;
      }
    }
    this.gl.bindTexture(this.glTarget, null);
  }
  _getActiveUnit() {
    return this.gl.getParameter(34016) - 33984;
  }
  _bind(e) {
    const { gl: t } = this;
    return e !== void 0 && (this._textureUnit = e, t.activeTexture(33984 + e)), t.bindTexture(this.glTarget, this.handle), e;
  }
  _unbind(e) {
    const { gl: t } = this;
    return e !== void 0 && (this._textureUnit = e, t.activeTexture(33984 + e)), t.bindTexture(this.glTarget, null), e;
  }
}
function kq(r) {
  switch (r) {
    case "1d":
      break;
    // not supported in any WebGL version
    case "2d":
      return 3553;
    // supported in WebGL1
    case "3d":
      return 32879;
    // supported in WebGL2
    case "cube":
      return 34067;
    // supported in WebGL1
    case "2d-array":
      return 35866;
  }
  throw new Error(r);
}
function cS(r, e, t) {
  return e === "cube" ? 34069 + t : r;
}
function Fq(r) {
  return Vq[r];
}
function Yx(r) {
  return zq[r];
}
function Nq(r) {
  return !!m6[r];
}
function Uq(r) {
  return m6[r];
}
const zq = {
  5126: "f32",
  35664: "vec2<f32>",
  35665: "vec3<f32>",
  35666: "vec4<f32>",
  5124: "i32",
  35667: "vec2<i32>",
  35668: "vec3<i32>",
  35669: "vec4<i32>",
  5125: "u32",
  36294: "vec2<u32>",
  36295: "vec3<u32>",
  36296: "vec4<u32>",
  35670: "f32",
  35671: "vec2<f32>",
  35672: "vec3<f32>",
  35673: "vec4<f32>",
  // TODO - are sizes/components below correct?
  35674: "mat2x2<f32>",
  35685: "mat2x3<f32>",
  35686: "mat2x4<f32>",
  35687: "mat3x2<f32>",
  35675: "mat3x3<f32>",
  35688: "mat3x4<f32>",
  35689: "mat4x2<f32>",
  35690: "mat4x3<f32>",
  35676: "mat4x4<f32>"
}, m6 = {
  35678: { viewDimension: "2d", sampleType: "float" },
  35680: { viewDimension: "cube", sampleType: "float" },
  35679: { viewDimension: "3d", sampleType: "float" },
  35682: { viewDimension: "3d", sampleType: "depth" },
  36289: { viewDimension: "2d-array", sampleType: "float" },
  36292: { viewDimension: "2d-array", sampleType: "depth" },
  36293: { viewDimension: "cube", sampleType: "float" },
  36298: { viewDimension: "2d", sampleType: "sint" },
  36299: { viewDimension: "3d", sampleType: "sint" },
  36300: { viewDimension: "cube", sampleType: "sint" },
  36303: { viewDimension: "2d-array", sampleType: "uint" },
  36306: { viewDimension: "2d", sampleType: "uint" },
  36307: { viewDimension: "3d", sampleType: "uint" },
  36308: { viewDimension: "cube", sampleType: "uint" },
  36311: { viewDimension: "2d-array", sampleType: "uint" }
}, Vq = {
  uint8: 5121,
  sint8: 5120,
  unorm8: 5121,
  snorm8: 5120,
  uint16: 5123,
  sint16: 5122,
  unorm16: 5123,
  snorm16: 5122,
  uint32: 5125,
  sint32: 5124,
  // WebGPU does not support normalized 32 bit integer attributes
  //  'unorm32': GL.UNSIGNED_INT,
  //  'snorm32': GL.INT,
  float16: 5131,
  float32: 5126
};
function jq(r, e) {
  const t = {
    attributes: [],
    bindings: []
  };
  t.attributes = Hq(r, e);
  const n = $q(r, e);
  for (const l of n) {
    const u = l.uniforms.map((m) => ({
      name: m.name,
      format: m.format,
      byteOffset: m.byteOffset,
      byteStride: m.byteStride,
      arrayLength: m.arrayLength
    }));
    t.bindings.push({
      type: "uniform",
      name: l.name,
      group: 0,
      location: l.location,
      visibility: (l.vertex ? 1 : 0) & (l.fragment ? 2 : 0),
      minBindingSize: l.byteLength,
      uniforms: u
    });
  }
  const i = Wq(r, e);
  let s = 0;
  for (const l of i)
    if (Nq(l.type)) {
      const { viewDimension: u, sampleType: m } = Uq(l.type);
      t.bindings.push({
        type: "texture",
        name: l.name,
        group: 0,
        location: s,
        viewDimension: u,
        sampleType: m
      }), l.textureUnit = s, s += 1;
    }
  i.length && (t.uniforms = i);
  const o = Gq(r, e);
  return o?.length && (t.varyings = o), t;
}
function Hq(r, e) {
  const t = [], n = r.getProgramParameter(e, 35721);
  for (let i = 0; i < n; i++) {
    const s = r.getActiveAttrib(e, i);
    if (!s)
      throw new Error("activeInfo");
    const {
      name: o,
      type: l
      /* , size*/
    } = s, u = r.getAttribLocation(e, o);
    if (u >= 0) {
      const m = Yx(l), y = /instance/i.test(o) ? "instance" : "vertex";
      t.push({
        name: o,
        location: u,
        stepMode: y,
        type: m
        // size - for arrays, size is the number of elements in the array
      });
    }
  }
  return t.sort((i, s) => i.location - s.location), t;
}
function Gq(r, e) {
  const t = [], n = r.getProgramParameter(e, 35971);
  for (let i = 0; i < n; i++) {
    const s = r.getTransformFeedbackVarying(e, i);
    if (!s)
      throw new Error("activeInfo");
    const { name: o, type: l, size: u } = s, m = Yx(l), { type: y, components: E } = jB(m);
    t.push({ location: i, name: o, type: y, size: u * E });
  }
  return t.sort((i, s) => i.location - s.location), t;
}
function Wq(r, e) {
  const t = [], n = r.getProgramParameter(e, 35718);
  for (let i = 0; i < n; i++) {
    const s = r.getActiveUniform(e, i);
    if (!s)
      throw new Error("activeInfo");
    const { name: o, size: l, type: u } = s, { name: m, isArray: y } = qq(o);
    let E = r.getUniformLocation(e, m);
    const P = {
      // WebGL locations are uniquely typed but just numbers
      location: E,
      name: m,
      size: l,
      type: u,
      isArray: y
    };
    if (t.push(P), P.size > 1)
      for (let L = 0; L < P.size; L++) {
        const U = `${m}[${L}]`;
        E = r.getUniformLocation(e, U);
        const V = {
          ...P,
          name: U,
          location: E
        };
        t.push(V);
      }
  }
  return t;
}
function $q(r, e) {
  const t = (s, o) => r.getActiveUniformBlockParameter(e, s, o), n = [], i = r.getProgramParameter(e, 35382);
  for (let s = 0; s < i; s++) {
    const o = {
      name: r.getActiveUniformBlockName(e, s) || "",
      location: t(s, 35391),
      byteLength: t(s, 35392),
      vertex: t(s, 35396),
      fragment: t(s, 35398),
      uniformCount: t(s, 35394),
      uniforms: []
    }, l = t(s, 35395) || [], u = r.getActiveUniforms(e, l, 35383), m = r.getActiveUniforms(e, l, 35384), y = r.getActiveUniforms(e, l, 35387), E = r.getActiveUniforms(e, l, 35388);
    for (let P = 0; P < o.uniformCount; ++P) {
      const L = r.getActiveUniform(e, l[P]);
      if (!L)
        throw new Error("activeInfo");
      const U = Yx(u[P]);
      o.uniforms.push({
        name: L.name,
        format: U,
        type: u[P],
        arrayLength: m[P],
        byteOffset: y[P],
        byteStride: E[P]
        // matrixStride: uniformStride[i],
        // rowMajor: uniformRowMajor[i]
      });
    }
    n.push(o);
  }
  return n.sort((s, o) => s.location - o.location), n;
}
function qq(r) {
  if (r[r.length - 1] !== "]")
    return {
      name: r,
      length: 1,
      isArray: !1
    };
  const t = /([^[]*)(\[[0-9]+\])?/.exec(r);
  if (!t || t.length < 2)
    throw new Error(`Failed to parse GLSL uniform name ${r}`);
  return {
    name: t[1],
    length: t[2] ? 1 : 0,
    isArray: !!t[2]
  };
}
function Xq(r, e, t, n) {
  const i = r;
  let s = n;
  s === !0 && (s = 1), s === !1 && (s = 0);
  const o = typeof s == "number" ? [s] : s;
  switch (t) {
    case 35678:
    case 35680:
    case 35679:
    case 35682:
    case 36289:
    case 36292:
    case 36293:
    case 36298:
    case 36299:
    case 36300:
    case 36303:
    case 36306:
    case 36307:
    case 36308:
    case 36311:
      if (typeof n != "number")
        throw new Error("samplers must be set to integers");
      return r.uniform1i(e, n);
    case 5126:
      return r.uniform1fv(e, o);
    case 35664:
      return r.uniform2fv(e, o);
    case 35665:
      return r.uniform3fv(e, o);
    case 35666:
      return r.uniform4fv(e, o);
    case 5124:
      return r.uniform1iv(e, o);
    case 35667:
      return r.uniform2iv(e, o);
    case 35668:
      return r.uniform3iv(e, o);
    case 35669:
      return r.uniform4iv(e, o);
    case 35670:
      return r.uniform1iv(e, o);
    case 35671:
      return r.uniform2iv(e, o);
    case 35672:
      return r.uniform3iv(e, o);
    case 35673:
      return r.uniform4iv(e, o);
    // WEBGL2 - unsigned integers
    case 5125:
      return i.uniform1uiv(e, o, 1);
    case 36294:
      return i.uniform2uiv(e, o, 2);
    case 36295:
      return i.uniform3uiv(e, o, 3);
    case 36296:
      return i.uniform4uiv(e, o, 4);
    // WebGL2 - quadratic matrices
    // false: don't transpose the matrix
    case 35674:
      return r.uniformMatrix2fv(e, !1, o);
    case 35675:
      return r.uniformMatrix3fv(e, !1, o);
    case 35676:
      return r.uniformMatrix4fv(e, !1, o);
    // WebGL2 - rectangular matrices
    case 35685:
      return i.uniformMatrix2x3fv(e, !1, o);
    case 35686:
      return i.uniformMatrix2x4fv(e, !1, o);
    case 35687:
      return i.uniformMatrix3x2fv(e, !1, o);
    case 35688:
      return i.uniformMatrix3x4fv(e, !1, o);
    case 35689:
      return i.uniformMatrix4x2fv(e, !1, o);
    case 35690:
      return i.uniformMatrix4x3fv(e, !1, o);
  }
  throw new Error("Illegal uniform");
}
function Zq(r) {
  switch (r) {
    case "point-list":
      return 0;
    case "line-list":
      return 1;
    case "line-strip":
      return 3;
    case "triangle-list":
      return 4;
    case "triangle-strip":
      return 5;
    default:
      throw new Error(r);
  }
}
function Yq(r) {
  switch (r) {
    case "point-list":
      return 0;
    case "line-list":
      return 1;
    case "line-strip":
      return 1;
    case "triangle-list":
      return 4;
    case "triangle-strip":
      return 4;
    default:
      throw new Error(r);
  }
}
const uS = 4;
class Kq extends Zf {
  /** The WebGL device that created this render pipeline */
  device;
  /** Handle to underlying WebGL program */
  handle;
  /** vertex shader */
  vs;
  /** fragment shader */
  fs;
  /** The layout extracted from shader by WebGL introspection APIs */
  introspectedLayout;
  /** Uniforms set on this model */
  uniforms = {};
  /** Bindings set on this model */
  bindings = {};
  /** WebGL varyings */
  varyings = null;
  _uniformCount = 0;
  _uniformSetters = {};
  // TODO are these used?
  get [Symbol.toStringTag]() {
    return "WEBGLRenderPipeline";
  }
  constructor(e, t) {
    super(e, t), this.device = e, this.handle = this.props.handle || this.device.gl.createProgram(), this.device._setWebGLDebugMetadata(this.handle, this, { spector: { id: this.props.id } }), this.vs = t.vs, this.fs = t.fs;
    const { varyings: n, bufferMode: i = 35981 } = t;
    n && n.length > 0 && (this.varyings = n, this.device.gl.transformFeedbackVaryings(this.handle, n, i)), this._linkShaders(), qt.time(3, `RenderPipeline ${this.id} - shaderLayout introspection`)(), this.introspectedLayout = jq(this.device.gl, this.handle), qt.timeEnd(3, `RenderPipeline ${this.id} - shaderLayout introspection`)(), this.shaderLayout = t.shaderLayout ? Qq(this.introspectedLayout, t.shaderLayout) : this.introspectedLayout;
  }
  destroy() {
    this.handle && (this.device.gl.useProgram(null), this.device.gl.deleteProgram(this.handle), this.destroyed = !0, this.handle.destroyed = !0, this.handle = null);
  }
  /**
   * Bindings include: textures, samplers and uniform buffers
   * @todo needed for portable model
   */
  setBindings(e, t) {
    for (const [n, i] of Object.entries(e)) {
      const s = this.shaderLayout.bindings.find((o) => o.name === n) || this.shaderLayout.bindings.find((o) => o.name === `${n}Uniforms`);
      if (!s) {
        const o = this.shaderLayout.bindings.map((l) => `"${l.name}"`).join(", ");
        t?.disableWarnings || qt.warn(`No binding "${n}" in render pipeline "${this.id}", expected one of ${o}`, i)();
        continue;
      }
      switch (i || qt.warn(`Unsetting binding "${n}" in render pipeline "${this.id}"`)(), s.type) {
        case "uniform":
          if (!(i instanceof WA) && !(i.buffer instanceof WA))
            throw new Error("buffer value");
          break;
        case "texture":
          if (!(i instanceof Yd || i instanceof $A || i instanceof GA))
            throw new Error(`${this} Bad texture binding for ${n}`);
          break;
        case "sampler":
          qt.warn(`Ignoring sampler ${n}`)();
          break;
        default:
          throw new Error(s.type);
      }
      this.bindings[n] = i;
    }
  }
  /** @todo needed for portable model
   * @note The WebGL API is offers many ways to draw things
   * This function unifies those ways into a single call using common parameters with sane defaults
   */
  draw(e) {
    const {
      renderPass: t,
      parameters: n = this.props.parameters,
      topology: i = this.props.topology,
      vertexArray: s,
      vertexCount: o,
      // indexCount,
      instanceCount: l,
      isInstanced: u = !1,
      firstVertex: m = 0,
      // firstIndex,
      // firstInstance,
      // baseVertex,
      transformFeedback: y
    } = e, E = Zq(i), P = !!s.indexBuffer, L = s.indexBuffer?.glIndexType;
    if (this.linkStatus !== "success")
      return qt.info(2, `RenderPipeline:${this.id}.draw() aborted - waiting for shader linking`)(), !1;
    if (!this._areTexturesRenderable())
      return qt.info(2, `RenderPipeline:${this.id}.draw() aborted - textures not yet loaded`)(), !1;
    this.device.gl.useProgram(this.handle), s.bindBeforeRender(t), y && y.begin(this.props.topology), this._applyBindings(), this._applyUniforms();
    const U = t;
    return Iq(this.device, n, U.glParameters, () => {
      P && u ? this.device.gl.drawElementsInstanced(
        E,
        o || 0,
        // indexCount?
        L,
        m,
        l || 0
      ) : P ? this.device.gl.drawElements(E, o || 0, L, m) : u ? this.device.gl.drawArraysInstanced(E, m, o || 0, l || 0) : this.device.gl.drawArrays(E, m, o || 0), y && y.end();
    }), s.unbindAfterRender(t), !0;
  }
  // PRIVATE METHODS
  // setAttributes(attributes: Record<string, Buffer>): void {}
  // setBindings(bindings: Record<string, Binding>): void {}
  async _linkShaders() {
    const { gl: e } = this.device;
    if (e.attachShader(this.handle, this.vs.handle), e.attachShader(this.handle, this.fs.handle), qt.time(uS, `linkProgram for ${this.id}`)(), e.linkProgram(this.handle), qt.timeEnd(uS, `linkProgram for ${this.id}`)(), qt.level, !this.device.features.has("compilation-status-async-webgl")) {
      const n = this._getLinkStatus();
      this._reportLinkStatus(n);
      return;
    }
    qt.once(1, "RenderPipeline linking is asynchronous")(), await this._waitForLinkComplete(), qt.info(2, `RenderPipeline ${this.id} - async linking complete: ${this.linkStatus}`)();
    const t = this._getLinkStatus();
    this._reportLinkStatus(t);
  }
  /** Report link status. First, check for shader compilation failures if linking fails */
  async _reportLinkStatus(e) {
    switch (e) {
      case "success":
        return;
      default:
        const t = e === "link-error" ? "Link error" : "Validation error";
        switch (this.vs.compilationStatus) {
          case "error":
            throw this.vs.debugShader(), new Error(`${this} ${t} during compilation of ${this.vs}`);
          case "pending":
            await this.vs.asyncCompilationStatus, this.vs.debugShader();
            break;
        }
        switch (this.fs?.compilationStatus) {
          case "error":
            throw this.fs.debugShader(), new Error(`${this} ${t} during compilation of ${this.fs}`);
          case "pending":
            await this.fs.asyncCompilationStatus, this.fs.debugShader();
            break;
        }
        const n = this.device.gl.getProgramInfoLog(this.handle);
        this.device.reportError(new Error(`${t} during ${e}: ${n}`), this)(), this.device.debug();
    }
  }
  /**
   * Get the shader compilation status
   * TODO - Load log even when no error reported, to catch warnings?
   * https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings
   */
  _getLinkStatus() {
    const { gl: e } = this.device;
    return e.getProgramParameter(this.handle, 35714) ? (e.validateProgram(this.handle), e.getProgramParameter(this.handle, 35715) ? (this.linkStatus = "success", "success") : (this.linkStatus = "error", "validation-error")) : (this.linkStatus = "error", "link-error");
  }
  /** Use KHR_parallel_shader_compile extension if available */
  async _waitForLinkComplete() {
    const e = async (i) => await new Promise((s) => setTimeout(s, i));
    if (!this.device.features.has("compilation-status-async-webgl")) {
      await e(10);
      return;
    }
    const { gl: n } = this.device;
    for (; ; ) {
      if (n.getProgramParameter(this.handle, 37297))
        return;
      await e(10);
    }
  }
  /**
   * Checks if all texture-values uniforms are renderable (i.e. loaded)
   * Update a texture if needed (e.g. from video)
   * Note: This is currently done before every draw call
   */
  _areTexturesRenderable() {
    let e = !0;
    for (const t of this.shaderLayout.bindings)
      !this.bindings[t.name] && !this.bindings[t.name.replace(/Uniforms$/, "")] && (qt.warn(`Binding ${t.name} not found in ${this.id}`)(), e = !1);
    return e;
  }
  /** Apply any bindings (before each draw call) */
  _applyBindings() {
    if (this.linkStatus !== "success")
      return;
    const { gl: e } = this.device;
    e.useProgram(this.handle);
    let t = 0, n = 0;
    for (const i of this.shaderLayout.bindings) {
      const s = this.bindings[i.name] || this.bindings[i.name.replace(/Uniforms$/, "")];
      if (!s)
        throw new Error(`No value for binding ${i.name} in ${this.id}`);
      switch (i.type) {
        case "uniform":
          const { name: o } = i, l = e.getUniformBlockIndex(this.handle, o);
          if (l === 4294967295)
            throw new Error(`Invalid uniform block name ${o}`);
          e.uniformBlockBinding(this.handle, n, l), s instanceof WA ? e.bindBufferBase(35345, n, s.handle) : e.bindBufferRange(
            35345,
            n,
            // @ts-expect-error
            s.buffer.handle,
            // @ts-expect-error
            s.offset || 0,
            // @ts-expect-error
            s.size || s.buffer.byteLength - s.offset
          ), n += 1;
          break;
        case "texture":
          if (!(s instanceof Yd || s instanceof $A || s instanceof GA))
            throw new Error("texture");
          let u;
          if (s instanceof Yd)
            u = s.texture;
          else if (s instanceof $A)
            u = s;
          else if (s instanceof GA && s.colorAttachments[0] instanceof Yd)
            qt.warn("Passing framebuffer in texture binding may be deprecated. Use fbo.colorAttachments[0] instead")(), u = s.colorAttachments[0].texture;
          else
            throw new Error("No texture");
          e.activeTexture(33984 + t), e.bindTexture(u.glTarget, u.handle), t += 1;
          break;
        case "sampler":
          break;
        case "storage":
        case "read-only-storage":
          throw new Error(`binding type '${i.type}' not supported in WebGL`);
      }
    }
  }
  /**
   * Due to program sharing, uniforms need to be reset before every draw call
   * (though caching will avoid redundant WebGL calls)
   */
  _applyUniforms() {
    for (const e of this.shaderLayout.uniforms || []) {
      const { name: t, location: n, type: i, textureUnit: s } = e, o = this.uniforms[t] ?? s;
      o !== void 0 && Xq(this.device.gl, n, i, o);
    }
  }
}
function Qq(r, e) {
  const t = {
    ...r,
    attributes: r.attributes.map((n) => ({ ...n }))
  };
  for (const n of e?.attributes || []) {
    const i = t.attributes.find((s) => s.name === n.name);
    i ? (i.type = n.type || i.type, i.stepMode = n.stepMode || i.stepMode) : qt.warn(`shader layout attribute ${n.name} not present in shader`);
  }
  return t;
}
class Jq extends px {
  device;
  handle = null;
  commands = [];
  constructor(e) {
    super(e, {}), this.device = e;
  }
  _executeCommands(e = this.commands) {
    for (const t of e)
      switch (t.name) {
        case "copy-buffer-to-buffer":
          eX(this.device, t.options);
          break;
        case "copy-buffer-to-texture":
          tX(this.device, t.options);
          break;
        case "copy-texture-to-buffer":
          rX(this.device, t.options);
          break;
        case "copy-texture-to-texture":
          nX(this.device, t.options);
          break;
        // case 'clear-texture':
        //   _clearTexture(this.device, command.options);
        //   break;
        default:
          throw new Error(t.name);
      }
  }
}
function eX(r, e) {
  const t = e.sourceBuffer, n = e.destinationBuffer;
  r.gl.bindBuffer(36662, t.handle), r.gl.bindBuffer(36663, n.handle), r.gl.copyBufferSubData(36662, 36663, e.sourceOffset ?? 0, e.destinationOffset ?? 0, e.size), r.gl.bindBuffer(36662, null), r.gl.bindBuffer(36663, null);
}
function tX(r, e) {
  throw new Error("Not implemented");
}
function rX(r, e) {
  const {
    /** Texture to copy to/from. */
    sourceTexture: t,
    /**  Mip-map level of the texture to copy to/from. (Default 0) */
    mipLevel: n = 0,
    /** Defines which aspects of the texture to copy to/from. */
    aspect: i = "all",
    /** Width to copy */
    width: s = e.sourceTexture.width,
    /** Height to copy */
    height: o = e.sourceTexture.height,
    depthOrArrayLayers: l = 0,
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */
    origin: u = [0, 0],
    /** Destination buffer */
    destinationBuffer: m,
    /** Offset, in bytes, from the beginning of the buffer to the start of the image data (default 0) */
    byteOffset: y = 0,
    /**
     * The stride, in bytes, between the beginning of each block row and the subsequent block row.
     * Required if there are multiple block rows (i.e. the copy height or depth is more than one block).
     */
    bytesPerRow: E,
    /**
     * Number of block rows per single image of the texture.
     * rowsPerImage &times; bytesPerRow is the stride, in bytes, between the beginning of each image of data and the subsequent image.
     * Required if there are multiple images (i.e. the copy depth is more than one).
     */
    rowsPerImage: P
  } = e;
  if (i !== "all")
    throw new Error("aspect not supported in WebGL");
  if (n !== 0 || l !== 0 || E || P)
    throw new Error("not implemented");
  const { framebuffer: L, destroyFramebuffer: U } = _6(t);
  let V;
  try {
    const q = m, j = s || L.width, K = o || L.height, Y = A6(L.colorAttachments[0].texture.props.format), de = Y.format, ne = Y.type;
    r.gl.bindBuffer(35051, q.handle), V = r.gl.bindFramebuffer(36160, L.handle), r.gl.readPixels(u[0], u[1], j, K, de, ne, y);
  } finally {
    r.gl.bindBuffer(35051, null), V !== void 0 && r.gl.bindFramebuffer(36160, V), U && L.destroy();
  }
}
function nX(r, e) {
  const {
    /** Texture to copy to/from. */
    sourceTexture: t,
    /**  Mip-map level of the texture to copy to (Default 0) */
    destinationMipLevel: n = 0,
    /** Defines which aspects of the texture to copy to/from. */
    // aspect = 'all',
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy from. */
    origin: i = [0, 0],
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to. */
    destinationOrigin: s = [0, 0],
    /** Texture to copy to/from. */
    destinationTexture: o
    /**  Mip-map level of the texture to copy to/from. (Default 0) */
    // destinationMipLevel = options.mipLevel,
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */
    // destinationOrigin = [0, 0],
    /** Defines which aspects of the texture to copy to/from. */
    // destinationAspect = options.aspect,
  } = e;
  let {
    width: l = e.destinationTexture.width,
    height: u = e.destinationTexture.height
    // depthOrArrayLayers = 0
  } = e;
  const { framebuffer: m, destroyFramebuffer: y } = _6(t), [E, P] = i, [L, U, V] = s, q = r.gl.bindFramebuffer(36160, m.handle);
  let j, K;
  if (o instanceof $A)
    j = o, l = Number.isFinite(l) ? l : j.width, u = Number.isFinite(u) ? u : j.height, j._bind(0), K = j.glTarget;
  else
    throw new Error("invalid destination");
  switch (K) {
    case 3553:
    case 34067:
      r.gl.copyTexSubImage2D(K, n, L, U, E, P, l, u);
      break;
    case 35866:
    case 32879:
      r.gl.copyTexSubImage3D(K, n, L, U, V, E, P, l, u);
      break;
  }
  j && j._unbind(), r.gl.bindFramebuffer(36160, q), y && m.destroy();
}
function _6(r) {
  if (r instanceof ps) {
    const { width: e, height: t, id: n } = r;
    return { framebuffer: r.device.createFramebuffer({
      id: `framebuffer-for-${n}`,
      width: e,
      height: t,
      colorAttachments: [r]
    }), destroyFramebuffer: !0 };
  }
  return { framebuffer: r, destroyFramebuffer: !1 };
}
const iX = [1, 2, 4, 8];
class sX extends Vf {
  device;
  handle = null;
  /** Parameters that should be applied before each draw call */
  glParameters = {};
  constructor(e, t) {
    super(e, t), this.device = e;
    let n;
    if (!t?.parameters?.viewport)
      if (t?.framebuffer) {
        const { width: s, height: o } = t.framebuffer;
        n = [0, 0, s, o];
      } else {
        const [s, o] = e.getDefaultCanvasContext().getDrawingBufferSize();
        n = [0, 0, s, o];
      }
    this.device.pushState(), this.setParameters({ viewport: n, ...this.props.parameters });
    const i = this.props.framebuffer;
    if (this.props.framebuffer && i?.handle) {
      const s = this.props.framebuffer.colorAttachments.map((o, l) => 36064 + l);
      this.device.gl.drawBuffers(s);
    } else
      this.device.gl.drawBuffers([1029]);
    this.clear();
  }
  end() {
    this.device.popState();
  }
  pushDebugGroup(e) {
  }
  popDebugGroup() {
  }
  insertDebugMarker(e) {
  }
  // beginOcclusionQuery(queryIndex: number): void;
  // endOcclusionQuery(): void;
  // executeBundles(bundles: Iterable<GPURenderBundle>): void;
  /**
   * Maps RenderPass parameters to GL parameters
   */
  setParameters(e = {}) {
    const t = { ...this.glParameters };
    t.framebuffer = this.props.framebuffer || null, this.props.depthReadOnly && (t.depthMask = !this.props.depthReadOnly), t.stencilMask = this.props.stencilReadOnly ? 0 : 1, t[35977] = this.props.discard, e.viewport && (e.viewport.length >= 6 ? (t.viewport = e.viewport.slice(0, 4), t.depthRange = [
      e.viewport[4],
      e.viewport[5]
    ]) : t.viewport = e.viewport), e.scissorRect && (t.scissorTest = !0, t.scissor = e.scissorRect), e.blendConstant && (t.blendColor = e.blendConstant), e.stencilReference && (console.warn("RenderPassParameters.stencilReference not yet implemented in WebGL"), t[2967] = e.stencilReference), "colorMask" in e && (t.colorMask = iX.map((n) => !!(n & e.colorMask))), this.glParameters = t, kp(this.device.gl, t);
  }
  beginOcclusionQuery(e) {
    this.props.occlusionQuerySet?.beginOcclusionQuery();
  }
  endOcclusionQuery() {
    this.props.occlusionQuerySet?.endOcclusionQuery();
  }
  // PRIVATE
  /**
   * Optionally clears depth, color and stencil buffers based on parameters
   */
  clear() {
    const e = { ...this.glParameters };
    let t = 0;
    this.props.clearColors && this.props.clearColors.forEach((n, i) => {
      n && this.clearColorBuffer(i, n);
    }), this.props.clearColor !== !1 && this.props.clearColors === void 0 && (t |= 16384, e.clearColor = this.props.clearColor), this.props.clearDepth !== !1 && (t |= 256, e.clearDepth = this.props.clearDepth), this.props.clearStencil !== !1 && (t |= 1024, e.clearStencil = this.props.clearStencil), t !== 0 && o0(this.device.gl, e, () => {
      this.device.gl.clear(t);
    });
  }
  /**
   * WebGL2 - clear a specific color buffer
   */
  clearColorBuffer(e = 0, t = [0, 0, 0, 0]) {
    o0(this.device.gl, { framebuffer: this.props.framebuffer }, () => {
      switch (t.constructor) {
        case Int8Array:
        case Int16Array:
        case Int32Array:
          this.device.gl.clearBufferiv(6144, e, t);
          break;
        case Uint8Array:
        case Uint8ClampedArray:
        case Uint16Array:
        case Uint32Array:
          this.device.gl.clearBufferuiv(6144, e, t);
          break;
        case Float32Array:
          this.device.gl.clearBufferfv(6144, e, t);
          break;
        default:
          throw new Error("clearColorBuffer: color must be typed array");
      }
    });
  }
}
class fS extends dx {
  device;
  handle = null;
  commandBuffer;
  constructor(e, t) {
    super(e, t), this.device = e, this.commandBuffer = new Jq(e);
  }
  destroy() {
  }
  finish() {
    return this.commandBuffer;
  }
  beginRenderPass(e) {
    return new sX(this.device, e);
  }
  beginComputePass(e) {
    throw new Error("ComputePass not supported in WebGL");
  }
  copyBufferToBuffer(e) {
    this.commandBuffer.commands.push({ name: "copy-buffer-to-buffer", options: e });
  }
  copyBufferToTexture(e) {
    this.commandBuffer.commands.push({ name: "copy-buffer-to-texture", options: e });
  }
  copyTextureToBuffer(e) {
    this.commandBuffer.commands.push({ name: "copy-texture-to-buffer", options: e });
  }
  copyTextureToTexture(e) {
    this.commandBuffer.commands.push({ name: "copy-texture-to-texture", options: e });
  }
  // clearTexture(options: ClearTextureOptions): void {
  //   this.commandBuffer.commands.push({name: 'copy-texture-to-texture', options});
  // }
  pushDebugGroup(e) {
  }
  popDebugGroup() {
  }
  insertDebugMarker(e) {
  }
  resolveQuerySet(e, t, n) {
  }
}
function oX(r) {
  const { target: e, source: t, start: n = 0, count: i = 1 } = r, s = t.length, o = i * s;
  let l = 0;
  for (let u = n; l < s; l++)
    e[u++] = t[l];
  for (; l < o; )
    l < o - l ? (e.copyWithin(n + l, n, n + l), l *= 2) : (e.copyWithin(n + l, n, n + o - l), l = o);
  return r.target;
}
class Kx extends Ax {
  get [Symbol.toStringTag]() {
    return "VertexArray";
  }
  device;
  handle;
  /** Attribute 0 buffer constant */
  buffer = null;
  bufferValue = null;
  /** * Attribute 0 can not be disable on most desktop OpenGL based browsers */
  static isConstantAttributeZeroSupported(e) {
    return VN() === "Chrome";
  }
  // Create a VertexArray
  constructor(e, t) {
    super(e, t), this.device = e, this.handle = this.device.gl.createVertexArray();
  }
  destroy() {
    super.destroy(), this.buffer && this.buffer?.destroy(), this.handle && (this.device.gl.deleteVertexArray(this.handle), this.handle = void 0);
  }
  /**
  // Set (bind/unbind) an elements buffer, for indexed rendering.
  // Must be a Buffer bound to GL.ELEMENT_ARRAY_BUFFER or null. Constants not supported
   *
   * @param elementBuffer
   */
  setIndexBuffer(e) {
    const t = e;
    if (t && t.glTarget !== 34963)
      throw new Error("Use .setBuffer()");
    this.device.gl.bindVertexArray(this.handle), this.device.gl.bindBuffer(34963, t ? t.handle : null), this.indexBuffer = t, this.device.gl.bindVertexArray(null);
  }
  /** Set a location in vertex attributes array to a buffer, enables the location, sets divisor */
  setBuffer(e, t) {
    const n = t;
    if (n.glTarget === 34963)
      throw new Error("Use .setIndexBuffer()");
    const { size: i, type: s, stride: o, offset: l, normalized: u, integer: m, divisor: y } = this._getAccessor(e);
    this.device.gl.bindVertexArray(this.handle), this.device.gl.bindBuffer(34962, n.handle), m ? this.device.gl.vertexAttribIPointer(e, i, s, o, l) : this.device.gl.vertexAttribPointer(e, i, s, u, o, l), this.device.gl.bindBuffer(34962, null), this.device.gl.enableVertexAttribArray(e), this.device.gl.vertexAttribDivisor(e, y || 0), this.attributes[e] = n, this.device.gl.bindVertexArray(null);
  }
  /** Set a location in vertex attributes array to a constant value, disables the location */
  setConstantWebGL(e, t) {
    this._enable(e, !1), this.attributes[e] = t;
  }
  bindBeforeRender() {
    this.device.gl.bindVertexArray(this.handle), this._applyConstantAttributes();
  }
  unbindAfterRender() {
    this.device.gl.bindVertexArray(null);
  }
  // Internal methods
  /**
   * Constant attributes need to be reset before every draw call
   * Any attribute that is disabled in the current vertex array object
   * is read from the context's global constant value for that attribute location.
   * @note Constant attributes are only supported in WebGL, not in WebGPU
   */
  _applyConstantAttributes() {
    for (let e = 0; e < this.maxVertexAttributes; ++e) {
      const t = this.attributes[e];
      ArrayBuffer.isView(t) && this.device.setConstantAttributeWebGL(e, t);
    }
  }
  /**
   * Set a location in vertex attributes array to a buffer, enables the location, sets divisor
   * @note requires vertex array to be bound
   */
  // protected _setAttributeLayout(location: number): void {
  //   const {size, type, stride, offset, normalized, integer, divisor} = this._getAccessor(location);
  //   // WebGL2 supports *integer* data formats, i.e. GPU will see integer values
  //   if (integer) {
  //     this.device.gl.vertexAttribIPointer(location, size, type, stride, offset);
  //   } else {
  //     // Attaches ARRAY_BUFFER with specified buffer format to location
  //     this.device.gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
  //   }
  //   this.device.gl.vertexAttribDivisor(location, divisor || 0);
  // }
  /** Get an accessor from the  */
  _getAccessor(e) {
    const t = this.attributeInfos[e];
    if (!t)
      throw new Error(`Unknown attribute location ${e}`);
    const n = p6(t.bufferDataType);
    return {
      size: t.bufferComponents,
      type: n,
      stride: t.byteStride,
      offset: t.byteOffset,
      normalized: t.normalized,
      // it is the shader attribute declaration, not the vertex memory format,
      // that determines if the data in the buffer will be treated as integers.
      //
      // Also note that WebGL supports assigning non-normalized integer data to floating point attributes,
      // but as far as we can tell, WebGPU does not.
      integer: t.integer,
      divisor: t.stepMode === "instance" ? 1 : 0
    };
  }
  /**
   * Enabling an attribute location makes it reference the currently bound buffer
   * Disabling an attribute location makes it reference the global constant value
   * TODO - handle single values for size 1 attributes?
   * TODO - convert classic arrays based on known type?
   */
  _enable(e, t = !0) {
    const i = Kx.isConstantAttributeZeroSupported(this.device) || e !== 0;
    (t || i) && (e = Number(e), this.device.gl.bindVertexArray(this.handle), t ? this.device.gl.enableVertexAttribArray(e) : this.device.gl.disableVertexAttribArray(e), this.device.gl.bindVertexArray(null));
  }
  /**
   * Provide a means to create a buffer that is equivalent to a constant.
   * NOTE: Desktop OpenGL cannot disable attribute 0.
   * https://stackoverflow.com/questions/20305231/webgl-warning-attribute-0-is-disabled-
   * this-has-significant-performance-penalty
   */
  getConstantBuffer(e, t) {
    const n = aX(t), i = n.byteLength * e, s = n.length * e;
    if (this.buffer && i !== this.buffer.byteLength)
      throw new Error(`Buffer size is immutable, byte length ${i} !== ${this.buffer.byteLength}.`);
    let o = !this.buffer;
    if (this.buffer = this.buffer || this.device.createBuffer({ byteLength: i }), o ||= !lX(n, this.bufferValue), o) {
      const l = l7(t.constructor, s);
      oX({ target: l, source: n, start: 0, count: s }), this.buffer.write(l), this.bufferValue = t;
    }
    return this.buffer;
  }
}
function aX(r) {
  return Array.isArray(r) ? new Float32Array(r) : r;
}
function lX(r, e) {
  if (!r || !e || r.length !== e.length || r.constructor !== e.constructor)
    return !1;
  for (let t = 0; t < r.length; ++t)
    if (r[t] !== e[t])
      return !1;
  return !0;
}
class cX extends gx {
  device;
  gl;
  handle;
  /**
   * NOTE: The Model already has this information while drawing, but
   * TransformFeedback currently needs it internally, to look up
   * varying information outside of a draw() call.
   */
  layout;
  buffers = {};
  unusedBuffers = {};
  /**
   * Allows us to avoid a Chrome bug where a buffer that is already bound to a
   * different target cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.
   * This a major workaround, see: https://github.com/KhronosGroup/WebGL/issues/2346
   */
  bindOnUse = !0;
  _bound = !1;
  constructor(e, t) {
    super(e, t), this.device = e, this.gl = e.gl, this.handle = this.props.handle || this.gl.createTransformFeedback(), this.layout = this.props.layout, t.buffers && this.setBuffers(t.buffers), Object.seal(this);
  }
  destroy() {
    this.gl.deleteTransformFeedback(this.handle), super.destroy();
  }
  begin(e = "point-list") {
    this.gl.bindTransformFeedback(36386, this.handle), this.bindOnUse && this._bindBuffers(), this.gl.beginTransformFeedback(Yq(e));
  }
  end() {
    this.gl.endTransformFeedback(), this.bindOnUse && this._unbindBuffers(), this.gl.bindTransformFeedback(36386, null);
  }
  // SUBCLASS
  setBuffers(e) {
    this.buffers = {}, this.unusedBuffers = {}, this.bind(() => {
      for (const t in e)
        this.setBuffer(t, e[t]);
    });
  }
  setBuffer(e, t) {
    const n = this._getVaryingIndex(e), { buffer: i, byteLength: s, byteOffset: o } = this._getBufferRange(t);
    if (n < 0) {
      this.unusedBuffers[e] = i, qt.warn(`${this.id} unusedBuffers varying buffer ${e}`)();
      return;
    }
    this.buffers[n] = { buffer: i, byteLength: s, byteOffset: o }, this.bindOnUse || this._bindBuffer(n, i, o, s);
  }
  getBuffer(e) {
    if (hS(e))
      return this.buffers[e] || null;
    const t = this._getVaryingIndex(e);
    return t >= 0 ? this.buffers[t] : null;
  }
  bind(e = this.handle) {
    if (typeof e != "function")
      return this.gl.bindTransformFeedback(36386, e), this;
    let t;
    return this._bound ? t = e() : (this.gl.bindTransformFeedback(36386, this.handle), this._bound = !0, t = e(), this._bound = !1, this.gl.bindTransformFeedback(36386, null)), t;
  }
  unbind() {
    this.bind(null);
  }
  // PRIVATE METHODS
  /** Extract offsets for bindBufferRange */
  _getBufferRange(e) {
    if (e instanceof WA)
      return { buffer: e, byteOffset: 0, byteLength: e.byteLength };
    const { buffer: t, byteOffset: n = 0, byteLength: i = e.buffer.byteLength } = e;
    return { buffer: t, byteOffset: n, byteLength: i };
  }
  _getVaryingIndex(e) {
    if (hS(e))
      return Number(e);
    for (const t of this.layout.varyings || [])
      if (e === t.name)
        return t.location;
    return -1;
  }
  /**
   * Need to avoid chrome bug where buffer that is already bound to a different target
   * cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.
   */
  _bindBuffers() {
    for (const e in this.buffers) {
      const { buffer: t, byteLength: n, byteOffset: i } = this._getBufferRange(this.buffers[e]);
      this._bindBuffer(Number(e), t, i, n);
    }
  }
  _unbindBuffers() {
    for (const e in this.buffers)
      this.gl.bindBufferBase(35982, Number(e), null);
  }
  _bindBuffer(e, t, n = 0, i) {
    const s = t && t.handle;
    !s || i === void 0 ? this.gl.bindBufferBase(35982, e, s) : this.gl.bindBufferRange(35982, e, s, n, i);
  }
}
function hS(r) {
  return typeof r == "number" ? Number.isInteger(r) : /^\d+$/.test(r);
}
class uX extends mx {
  device;
  handle;
  target = null;
  _queryPending = !1;
  _pollingPromise = null;
  get [Symbol.toStringTag]() {
    return "Query";
  }
  // Create a query class
  constructor(e, t) {
    if (super(e, t), this.device = e, t.count > 1)
      throw new Error("WebGL QuerySet can only have one value");
    const n = this.device.gl.createQuery();
    if (!n)
      throw new Error("WebGL query not supported");
    this.handle = n, Object.seal(this);
  }
  destroy() {
    this.device.gl.deleteQuery(this.handle);
  }
  // FOR RENDER PASS AND COMMAND ENCODER
  /**
   * Shortcut for timer query (dependent on extension in both WebGL1 and 2)
   * Measures GPU time delta between this call and a matching `end` call in the
   * GPU instruction stream.
   */
  beginTimestampQuery() {
    return this._begin(35007);
  }
  endTimestampQuery() {
    this._end();
  }
  // Shortcut for occlusion queries
  beginOcclusionQuery(e) {
    return this._begin(e?.conservative ? 36202 : 35887);
  }
  endOcclusionQuery() {
    this._end();
  }
  // Shortcut for transformFeedbackQuery
  beginTransformFeedbackQuery() {
    return this._begin(35976);
  }
  endTransformFeedbackQuery() {
    this._end();
  }
  async resolveQuery() {
    return [await this.pollQuery()];
  }
  // PRIVATE METHODS
  /**
   * Due to OpenGL API limitations, after calling `begin()` on one Query
   * instance, `end()` must be called on that same instance before
   * calling `begin()` on another query. While there can be multiple
   * outstanding queries representing disjoint `begin()`/`end()` intervals.
   * It is not possible to interleave or overlap `begin` and `end` calls.
   */
  _begin(e) {
    this._queryPending || (this.target = e, this.device.gl.beginQuery(this.target, this.handle));
  }
  // ends the current query
  _end() {
    this._queryPending || this.target && (this.device.gl.endQuery(this.target), this.target = null, this._queryPending = !0);
  }
  // Returns true if the query result is available
  isResultAvailable() {
    if (!this._queryPending)
      return !1;
    const e = this.device.gl.getQueryParameter(this.handle, 34919);
    return e && (this._queryPending = !1), e;
  }
  // Timing query is disjoint, i.e. results are invalid
  isTimerDisjoint() {
    return this.device.gl.getParameter(36795);
  }
  // Returns query result.
  getResult() {
    return this.device.gl.getQueryParameter(this.handle, 34918);
  }
  // Returns the query result, converted to milliseconds to match JavaScript conventions.
  getTimerMilliseconds() {
    return this.getResult() / 1e6;
  }
  // Polls the query
  pollQuery(e = Number.POSITIVE_INFINITY) {
    if (this._pollingPromise)
      return this._pollingPromise;
    let t = 0;
    return this._pollingPromise = new Promise((n, i) => {
      const s = () => {
        this.isResultAvailable() ? (n(this.getResult()), this._pollingPromise = null) : t++ > e ? (i("Timed out"), this._pollingPromise = null) : requestAnimationFrame(s);
      };
      requestAnimationFrame(s);
    }), this._pollingPromise;
  }
}
function y6(r) {
  switch (r) {
    case 6406:
    case 33326:
    case 6403:
    case 36244:
      return 1;
    case 33339:
    case 33340:
    case 33328:
    case 33320:
    case 33319:
      return 2;
    case 6407:
    case 36248:
    case 34837:
      return 3;
    case 6408:
    case 36249:
    case 34836:
      return 4;
    // TODO: Add support for additional WebGL2 formats
    default:
      return 0;
  }
}
function fX(r) {
  switch (r) {
    case 5121:
      return 1;
    case 33635:
    case 32819:
    case 32820:
      return 2;
    case 5126:
      return 4;
    // TODO: Add support for additional WebGL2 types
    default:
      return 0;
  }
}
function hX(r) {
  return dX[r];
}
const dX = {
  5124: "sint32",
  5125: "uint32",
  5122: "sint16",
  5123: "uint16",
  5120: "sint8",
  5121: "uint8",
  5126: "float32",
  5131: "float16",
  33635: "uint16",
  32819: "uint16",
  32820: "uint16",
  33640: "uint32",
  35899: "uint32",
  35902: "uint32",
  34042: "uint32",
  36269: "uint32"
};
function pX(r, e) {
  const {
    sourceX: t = 0,
    sourceY: n = 0,
    sourceAttachment: i = 0
    // TODO - support gl.readBuffer
  } = e || {};
  let {
    target: s = null,
    // following parameters are auto deduced if not provided
    sourceWidth: o,
    sourceHeight: l,
    sourceDepth: u,
    sourceFormat: m,
    sourceType: y
  } = e || {};
  const { framebuffer: E, deleteFramebuffer: P } = v6(r), { gl: L, handle: U } = E;
  o ||= E.width, l ||= E.height;
  const V = E.colorAttachments[i]?.texture;
  if (!V)
    throw new Error(`Invalid framebuffer attachment ${i}`);
  u = V?.depth || 1, m ||= V?.glFormat || 6408, y ||= V?.glType || 5121, s = mX(s, y, m, o, l);
  const q = cx(s);
  y = y || Fq(q);
  const j = L.bindFramebuffer(36160, U);
  return L.readBuffer(36064 + i), L.readPixels(t, n, o, l, m, y, s), L.readBuffer(36064), L.bindFramebuffer(36160, j || null), P && E.destroy(), s;
}
function AX(r, e) {
  const { target: t, sourceX: n = 0, sourceY: i = 0, sourceFormat: s = 6408, targetByteOffset: o = 0 } = e || {};
  let { sourceWidth: l, sourceHeight: u, sourceType: m } = e || {};
  const { framebuffer: y, deleteFramebuffer: E } = v6(r);
  l = l || y.width, u = u || y.height;
  const P = y;
  m = m || 5121;
  let L = t;
  if (!L) {
    const V = y6(s), q = fX(m), j = o + l * u * V * q;
    L = P.device.createBuffer({ byteLength: j });
  }
  const U = r.device.createCommandEncoder();
  return U.copyTextureToBuffer({
    sourceTexture: r,
    width: l,
    height: u,
    origin: [n, i],
    destinationBuffer: L,
    byteOffset: o
  }), U.destroy(), E && y.destroy(), L;
}
function v6(r) {
  return r instanceof L_ ? { framebuffer: r, deleteFramebuffer: !1 } : { framebuffer: gX(r), deleteFramebuffer: !0 };
}
function gX(r, e) {
  const { device: t, width: n, height: i, id: s } = r;
  return t.createFramebuffer({
    ...e,
    id: `framebuffer-for-${s}`,
    width: n,
    height: i,
    colorAttachments: [r]
  });
}
function mX(r, e, t, n, i, s) {
  if (r)
    return r;
  e ||= 5121;
  const o = hX(e), l = ux(o), u = y6(t);
  return new l(n * i * u);
}
class Xb extends eh {
  // Public `Device` API
  /** type of this device */
  type = "webgl";
  // Use the ! assertion to handle the case where _reuseDevices causes the constructor to return early
  /** The underlying WebGL context */
  handle;
  features;
  limits;
  info;
  canvasContext;
  preferredColorFormat = "rgba8unorm";
  preferredDepthFormat = "depth24plus";
  commandEncoder;
  lost;
  _resolveContextLost;
  /** WebGL2 context. */
  gl;
  /** Store constants */
  // @ts-ignore TODO fix
  _constants;
  /** State used by luma.gl classes - TODO - not used? */
  _extensions = {};
  _polyfilled = !1;
  /** Instance of Spector.js (if initialized) */
  spectorJS;
  //
  // Public API
  //
  get [Symbol.toStringTag]() {
    return "WebGLDevice";
  }
  toString() {
    return `${this[Symbol.toStringTag]}(${this.id})`;
  }
  isVertexFormatSupported(e) {
    switch (e) {
      case "unorm8x4-bgra":
        return !1;
      default:
        return !0;
    }
  }
  constructor(e) {
    super({ ...e, id: e.id || wq("webgl-device") });
    const t = eh._getCanvasContextProps(e);
    if (!t)
      throw new Error("WebGLDevice requires props.createCanvasContext to be set");
    let n = t.canvas?.gl?.device;
    if (n)
      throw new Error(`WebGL context already attached to device ${n.id}`);
    this.canvasContext = new xq(this, t), this.lost = new Promise((y) => {
      this._resolveContextLost = y;
    });
    const i = { ...e.webgl };
    t.alphaMode === "premultiplied" && (i.premultipliedAlpha = !0), e.powerPreference !== void 0 && (i.powerPreference = e.powerPreference);
    const o = this.props._handle || rq(this.canvasContext.canvas, {
      onContextLost: (y) => this._resolveContextLost?.({
        reason: "destroyed",
        message: "Entered sleep mode, or too many apps or browser tabs are using the GPU."
      }),
      // eslint-disable-next-line no-console
      onContextRestored: (y) => console.log("WebGL context restored")
    }, i);
    if (!o)
      throw new Error("WebGL context creation failed");
    if (n = o.device, n) {
      if (e._reuseDevices)
        return qt.log(1, `Not creating a new Device, instead returning a reference to Device ${n.id} already attached to WebGL context`, n)(), n._reused = !0, n;
      throw new Error(`WebGL context already attached to device ${n.id}`);
    }
    this.handle = o, this.gl = o, this.spectorJS = N$({ ...this.props, gl: this.handle }), this.gl.device = this, this.gl._version = 2, this.info = nq(this.gl, this._extensions), this.limits = new yq(this.gl), this.features = new _q(this.gl, this._extensions, this.props._disabledFeatures), this.props._initializeFeatures && this.features.initializeFeatures(), new Kf(this.gl, {
      log: (...y) => qt.log(1, ...y)()
    }).trackState(this.gl, { copyState: !1 });
    const u = e.debugWebGL || e.debug, m = e.debugWebGL;
    u && (this.gl = V$(this.gl, { debugWebGL: u, traceWebGL: m }), qt.warn("WebGL debug mode activated. Performance reduced.")(), e.debugWebGL && (qt.level = Math.max(qt.level, 1))), this.commandEncoder = new fS(this, { id: `${this}-command-encoder` });
  }
  /**
   * Destroys the device
   *
   * @note "Detaches" from the WebGL context unless _reuseDevices is true.
   *
   * @note The underlying WebGL context is not immediately destroyed,
   * but may be destroyed later through normal JavaScript garbage collection.
   * This is a fundamental limitation since WebGL does not offer any
   * browser API for destroying WebGL contexts.
   */
  destroy() {
    !this.props._reuseDevices && !this._reused && delete this.gl.device;
  }
  get isLost() {
    return this.gl.isContextLost();
  }
  // IMPLEMENTATION OF ABSTRACT DEVICE
  getTextureByteAlignment() {
    return 4;
  }
  createCanvasContext(e) {
    throw new Error("WebGL only supports a single canvas");
  }
  createBuffer(e) {
    const t = this._normalizeBufferProps(e);
    return new WA(this, t);
  }
  createTexture(e) {
    return new $A(this, e);
  }
  createExternalTexture(e) {
    throw new Error("createExternalTexture() not implemented");
  }
  createSampler(e) {
    return new Dq(this, e);
  }
  createShader(e) {
    return new Sq(this, e);
  }
  createFramebuffer(e) {
    return new GA(this, e);
  }
  createVertexArray(e) {
    return new Kx(this, e);
  }
  createTransformFeedback(e) {
    return new cX(this, e);
  }
  createQuerySet(e) {
    return new uX(this, e);
  }
  createRenderPipeline(e) {
    return new Kq(this, e);
  }
  createComputePipeline(e) {
    throw new Error("ComputePipeline not supported in WebGL");
  }
  createCommandEncoder(e = {}) {
    return new fS(this, e);
  }
  /**
   * Offscreen Canvas Support: Commit the frame
   * https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/commit
   * Chrome's offscreen canvas does not require gl.commit
   */
  submit(e) {
    e || (e = this.commandEncoder.finish(), this.commandEncoder.destroy(), this.commandEncoder = this.createCommandEncoder({ id: `${this.id}-default-encoder` })), e._executeCommands();
  }
  //
  // TEMPORARY HACKS - will be removed in v9.1
  //
  /** @deprecated - should use command encoder */
  readPixelsToArrayWebGL(e, t) {
    return pX(e, t);
  }
  /** @deprecated - should use command encoder */
  readPixelsToBufferWebGL(e, t) {
    return AX(e, t);
  }
  setParametersWebGL(e) {
    kp(this.gl, e);
  }
  getParametersWebGL(e) {
    return h6(this.gl, e);
  }
  withParametersWebGL(e, t) {
    return o0(this.gl, e, t);
  }
  resetWebGL() {
    qt.warn("WebGLDevice.resetWebGL is deprecated, use only for debugging")(), K$(this.gl);
  }
  _getDeviceSpecificTextureFormatCapabilities(e) {
    return pq(this.gl, e, this._extensions);
  }
  //
  // WebGL-only API (not part of `Device` API)
  //
  /**
   * Triggers device (or WebGL context) loss.
   * @note primarily intended for testing how application reacts to device loss
   */
  loseDevice() {
    let e = !1;
    const n = this.getExtension("WEBGL_lose_context").WEBGL_lose_context;
    return n && (e = !0, n.loseContext()), this._resolveContextLost?.({
      reason: "destroyed",
      message: "Application triggered context loss"
    }), e;
  }
  /** Save current WebGL context state onto an internal stack */
  pushState() {
    Kf.get(this.gl).push();
  }
  /** Restores previously saved context state */
  popState() {
    Kf.get(this.gl).pop();
  }
  /**
   * Returns the GL.<KEY> constant that corresponds to a numeric value of a GL constant
   * Be aware that there are some duplicates especially for constants that are 0,
   * so this isn't guaranteed to return the right key in all cases.
   */
  getGLKey(e, t) {
    const n = Number(e);
    for (const i in this.gl)
      if (this.gl[i] === n)
        return `GL.${i}`;
    return t?.emptyIfUnknown ? "" : String(e);
  }
  /**
   * Returns a map with any GL.<KEY> constants mapped to strings, both for keys and values
   */
  getGLKeys(e) {
    const t = { emptyIfUnknown: !0 };
    return Object.entries(e).reduce((n, [i, s]) => (n[`${i}:${this.getGLKey(i, t)}`] = `${s}:${this.getGLKey(s, t)}`, n), {});
  }
  /**
   * Set a constant value for a location. Disabled attributes at that location will read from this value
   * @note WebGL constants are stored globally on the WebGL context, not the VertexArray
   * so they need to be updated before every render
   * @todo - remember/cache values to avoid setting them unnecessarily?
   */
  setConstantAttributeWebGL(e, t) {
    const n = this.limits.maxVertexAttributes;
    this._constants = this._constants || new Array(n).fill(null);
    const i = this._constants[e];
    switch (i && bX(i, t) && qt.info(1, `setConstantAttributeWebGL(${e}) could have been skipped, value unchanged`)(), this._constants[e] = t, t.constructor) {
      case Float32Array:
        _X(this, e, t);
        break;
      case Int32Array:
        yX(this, e, t);
        break;
      case Uint32Array:
        vX(this, e, t);
        break;
      default:
        throw new Error("constant");
    }
  }
  /** Ensure extensions are only requested once */
  getExtension(e) {
    return bp(this.gl, e, this._extensions), this._extensions;
  }
  // INTERNAL SUPPORT METHODS FOR WEBGL RESOURCES
  /**
   * Storing data on a special field on WebGLObjects makes that data visible in SPECTOR chrome debug extension
   * luma.gl ids and props can be inspected
   */
  _setWebGLDebugMetadata(e, t, n) {
    e.luma = t;
    const i = { props: n.spector, id: n.spector.id };
    e.__SPECTOR_Metadata = i;
  }
}
function _X(r, e, t) {
  switch (t.length) {
    case 1:
      r.gl.vertexAttrib1fv(e, t);
      break;
    case 2:
      r.gl.vertexAttrib2fv(e, t);
      break;
    case 3:
      r.gl.vertexAttrib3fv(e, t);
      break;
    case 4:
      r.gl.vertexAttrib4fv(e, t);
      break;
  }
}
function yX(r, e, t) {
  r.gl.vertexAttribI4iv(e, t);
}
function vX(r, e, t) {
  r.gl.vertexAttribI4uiv(e, t);
}
function bX(r, e) {
  if (!r || !e || r.length !== e.length || r.constructor !== e.constructor)
    return !1;
  for (let t = 0; t < r.length; ++t)
    if (r[t] !== e[t])
      return !1;
  return !0;
}
const dS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  WebGLDevice: Xb
}, Symbol.toStringTag, { value: "Module" }));
function ku() {
}
const xX = ({ isDragging: r }) => r ? "grabbing" : "grab", b6 = {
  id: "",
  width: "100%",
  height: "100%",
  style: null,
  viewState: null,
  initialViewState: null,
  pickingRadius: 0,
  layerFilter: null,
  parameters: {},
  parent: null,
  device: null,
  deviceProps: {},
  gl: null,
  canvas: null,
  layers: [],
  effects: [],
  views: null,
  controller: null,
  // Rely on external controller, e.g. react-map-gl
  useDevicePixels: !0,
  touchAction: "none",
  eventRecognizerOptions: {},
  _framebuffer: null,
  _animate: !1,
  _pickable: !0,
  _typedArrayManagerProps: {},
  _customRender: null,
  widgets: [],
  onDeviceInitialized: ku,
  onWebGLInitialized: ku,
  onResize: ku,
  onViewStateChange: ku,
  onInteractionStateChange: ku,
  onBeforeRender: ku,
  onAfterRender: ku,
  onLoad: ku,
  onError: (r) => Jr.error(r.message, r.cause)(),
  onHover: null,
  onClick: null,
  onDragStart: null,
  onDrag: null,
  onDragEnd: null,
  _onMetrics: null,
  getCursor: xX,
  getTooltip: null,
  debug: !1,
  drawPickingColors: !1
};
class Qx {
  constructor(e) {
    this.width = 0, this.height = 0, this.userData = {}, this.device = null, this.canvas = null, this.viewManager = null, this.layerManager = null, this.effectManager = null, this.deckRenderer = null, this.deckPicker = null, this.eventManager = null, this.widgetManager = null, this.tooltip = null, this.animationLoop = null, this.cursorState = {
      isHovering: !1,
      isDragging: !1
    }, this.stats = new Bp({ id: "deck.gl" }), this.metrics = {
      fps: 0,
      setPropsTime: 0,
      updateAttributesTime: 0,
      framesRedrawn: 0,
      pickTime: 0,
      pickCount: 0,
      gpuTime: 0,
      gpuTimePerFrame: 0,
      cpuTime: 0,
      cpuTimePerFrame: 0,
      bufferMemory: 0,
      textureMemory: 0,
      renderbufferMemory: 0,
      gpuMemory: 0
    }, this._metricsCounter = 0, this._needsRedraw = "Initial render", this._pickRequest = {
      mode: "hover",
      x: -1,
      y: -1,
      radius: 0,
      event: null
    }, this._lastPointerDownInfo = null, this._onPointerMove = (n) => {
      const { _pickRequest: i } = this;
      if (n.type === "pointerleave")
        i.x = -1, i.y = -1, i.radius = 0;
      else {
        if (n.leftButton || n.rightButton)
          return;
        {
          const s = n.offsetCenter;
          if (!s)
            return;
          i.x = s.x, i.y = s.y, i.radius = this.props.pickingRadius;
        }
      }
      this.layerManager && (this.layerManager.context.mousePosition = { x: i.x, y: i.y }), i.event = n;
    }, this._onEvent = (n) => {
      const i = kb[n.type], s = n.offsetCenter;
      if (!i || !s || !this.layerManager)
        return;
      const o = this.layerManager.getLayers(), l = this.deckPicker.getLastPickedObject({
        x: s.x,
        y: s.y,
        layers: o,
        viewports: this.getViewports(s)
      }, this._lastPointerDownInfo), { layer: u } = l, m = u && (u[i] || u.props[i]), y = this.props[i];
      let E = !1;
      m && (E = m.call(u, l, n)), E || (y?.(l, n), this.widgetManager.onEvent(l, n));
    }, this._onPointerDown = (n) => {
      if (this.device?.type === "webgpu")
        return;
      const i = n.offsetCenter, s = this._pick("pickObject", "pickObject Time", {
        x: i.x,
        y: i.y,
        radius: this.props.pickingRadius
      });
      this._lastPointerDownInfo = s.result[0] || s.emptyInfo;
    }, this.props = { ...b6, ...e }, e = this.props, e.viewState && e.initialViewState && Jr.warn("View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.")(), this.viewState = this.props.initialViewState, e.device && (this.device = e.device);
    let t = this.device;
    !t && e.gl && (e.gl instanceof WebGLRenderingContext && Jr.error("WebGL1 context not supported.")(), t = Vv.attach(e.gl, this.props.deviceProps)), t || (t = this._createDevice(e)), this.animationLoop = this._createAnimationLoop(t, e), this.setProps(e), e._typedArrayManagerProps && yp.setOptions(e._typedArrayManagerProps), this.animationLoop.start();
  }
  /** Stop rendering and dispose all resources */
  finalize() {
    this.animationLoop?.stop(), this.animationLoop?.destroy(), this.animationLoop = null, this._lastPointerDownInfo = null, this.layerManager?.finalize(), this.layerManager = null, this.viewManager?.finalize(), this.viewManager = null, this.effectManager?.finalize(), this.effectManager = null, this.deckRenderer?.finalize(), this.deckRenderer = null, this.deckPicker?.finalize(), this.deckPicker = null, this.eventManager?.destroy(), this.eventManager = null, this.widgetManager?.finalize(), this.widgetManager = null, !this.props.canvas && !this.props.device && !this.props.gl && this.canvas && (this.canvas.parentElement?.removeChild(this.canvas), this.canvas = null);
  }
  /** Partially update props */
  setProps(e) {
    this.stats.get("setProps Time").timeStart(), "onLayerHover" in e && Jr.removed("onLayerHover", "onHover")(), "onLayerClick" in e && Jr.removed("onLayerClick", "onClick")(), e.initialViewState && // depth = 3 when comparing viewStates: viewId.position.0
    !Fi(this.props.initialViewState, e.initialViewState, 3) && (this.viewState = e.initialViewState), Object.assign(this.props, e), this._setCanvasSize(this.props);
    const t = Object.create(this.props);
    if (Object.assign(t, {
      views: this._getViews(),
      width: this.width,
      height: this.height,
      viewState: this._getViewState()
    }), e.device && e.device.id !== this.device?.id && (this.animationLoop?.stop(), this.canvas !== e.device.canvasContext?.canvas && (this.canvas?.remove(), this.eventManager?.destroy(), this.canvas = null), Jr.log(`recreating animation loop for new device! id=${e.device.id}`)(), this.animationLoop = this._createAnimationLoop(e.device, e), this.animationLoop.start()), this.animationLoop?.setProps(t), e.useDevicePixels !== void 0 && this.device?.canvasContext?.canvas instanceof HTMLCanvasElement) {
      this.device.canvasContext.props.useDevicePixels = e.useDevicePixels;
      const n = this.device.canvasContext.canvas, i = {
        target: n,
        contentBoxSize: [{ inlineSize: n.clientWidth, blockSize: n.clientHeight }],
        devicePixelContentBoxSize: [
          { inlineSize: n.clientWidth, blockSize: n.clientHeight }
        ],
        borderBoxSize: [{ inlineSize: n.clientWidth, blockSize: n.clientHeight }]
      };
      this.device.canvasContext._handleResize([i]);
    }
    this.layerManager && (this.viewManager.setProps(t), this.layerManager.activateViewport(this.getViewports()[0]), this.layerManager.setProps(t), this.effectManager.setProps(t), this.deckRenderer.setProps(t), this.deckPicker.setProps(t), this.widgetManager.setProps(t)), this.stats.get("setProps Time").timeEnd();
  }
  // Public API
  /**
   * Check if a redraw is needed
   * @returns `false` or a string summarizing the redraw reason
   */
  needsRedraw(e = { clearRedrawFlags: !1 }) {
    if (!this.layerManager)
      return !1;
    if (this.props._animate)
      return "Deck._animate";
    let t = this._needsRedraw;
    e.clearRedrawFlags && (this._needsRedraw = !1);
    const n = this.viewManager.needsRedraw(e), i = this.layerManager.needsRedraw(e), s = this.effectManager.needsRedraw(e), o = this.deckRenderer.needsRedraw(e);
    return t = t || n || i || s || o, t;
  }
  /**
   * Redraw the GL context
   * @param reason If not provided, only redraw if deemed necessary. Otherwise redraw regardless of internal states.
   * @returns
   */
  redraw(e) {
    if (!this.layerManager)
      return;
    let t = this.needsRedraw({ clearRedrawFlags: !0 });
    t = e || t, t && (this.stats.get("Redraw Count").incrementCount(), this.props._customRender ? this.props._customRender(t) : this._drawLayers(t));
  }
  /** Flag indicating that the Deck instance has initialized its resources and it's safe to call public methods. */
  get isInitialized() {
    return this.viewManager !== null;
  }
  /** Get a list of views that are currently rendered */
  getViews() {
    return to(this.viewManager), this.viewManager.views;
  }
  /** Get a list of viewports that are currently rendered.
   * @param rect If provided, only returns viewports within the given bounding box.
   */
  getViewports(e) {
    return to(this.viewManager), this.viewManager.getViewports(e);
  }
  /** Get the current canvas element. */
  getCanvas() {
    return this.canvas;
  }
  /** Query the object rendered on top at a given point */
  pickObject(e) {
    const t = this._pick("pickObject", "pickObject Time", e).result;
    return t.length ? t[0] : null;
  }
  /* Query all rendered objects at a given point */
  pickMultipleObjects(e) {
    return e.depth = e.depth || 10, this._pick("pickObject", "pickMultipleObjects Time", e).result;
  }
  /* Query all objects rendered on top within a bounding box */
  pickObjects(e) {
    return this._pick("pickObjects", "pickObjects Time", e);
  }
  /** Experimental
   * Add a global resource for sharing among layers
   */
  _addResources(e, t = !1) {
    for (const n in e)
      this.layerManager.resourceManager.add({ resourceId: n, data: e[n], forceUpdate: t });
  }
  /** Experimental
   * Remove a global resource
   */
  _removeResources(e) {
    for (const t of e)
      this.layerManager.resourceManager.remove(t);
  }
  /** Experimental
   * Register a default effect. Effects will be sorted by order, those with a low order will be rendered first
   */
  _addDefaultEffect(e) {
    this.effectManager.addDefaultEffect(e);
  }
  _addDefaultShaderModule(e) {
    this.layerManager.addDefaultShaderModule(e);
  }
  _removeDefaultShaderModule(e) {
    this.layerManager?.removeDefaultShaderModule(e);
  }
  _pick(e, t, n) {
    to(this.deckPicker);
    const { stats: i } = this;
    i.get("Pick Count").incrementCount(), i.get(t).timeStart();
    const s = this.deckPicker[e]({
      // layerManager, viewManager and effectManager are always defined if deckPicker is
      layers: this.layerManager.getLayers(n),
      views: this.viewManager.getViews(),
      viewports: this.getViewports(n),
      onViewportActive: this.layerManager.activateViewport,
      effects: this.effectManager.getEffects(),
      ...n
    });
    return i.get(t).timeEnd(), s;
  }
  /** Resolve props.canvas to element */
  _createCanvas(e) {
    let t = e.canvas;
    return typeof t == "string" && (t = document.getElementById(t), to(t)), t || (t = document.createElement("canvas"), t.id = e.id || "deckgl-overlay", e.width && typeof e.width == "number" && (t.width = e.width), e.height && typeof e.height == "number" && (t.height = e.height), (e.parent || document.body).appendChild(t)), Object.assign(t.style, e.style), t;
  }
  /** Updates canvas width and/or height, if provided as props */
  _setCanvasSize(e) {
    if (!this.canvas)
      return;
    const { width: t, height: n } = e;
    if (t || t === 0) {
      const i = Number.isFinite(t) ? `${t}px` : t;
      this.canvas.style.width = i;
    }
    if (n || n === 0) {
      const i = Number.isFinite(n) ? `${n}px` : n;
      this.canvas.style.position = e.style?.position || "absolute", this.canvas.style.height = i;
    }
  }
  /** If canvas size has changed, reads out the new size and update */
  _updateCanvasSize() {
    const { canvas: e } = this;
    if (!e)
      return;
    const t = e.clientWidth ?? e.width, n = e.clientHeight ?? e.height;
    (t !== this.width || n !== this.height) && (this.width = t, this.height = n, this.viewManager?.setProps({ width: t, height: n }), this.layerManager?.activateViewport(this.getViewports()[0]), this.props.onResize({ width: t, height: n }));
  }
  _createAnimationLoop(e, t) {
    const {
      // width,
      // height,
      gl: n,
      // debug,
      onError: i
      // onBeforeRender,
      // onAfterRender,
    } = t;
    return new jx({
      device: e,
      // TODO v9
      autoResizeDrawingBuffer: !n,
      // do not auto resize external context
      autoResizeViewport: !1,
      // @ts-expect-error luma.gl needs to accept Promise<void> return value
      onInitialize: (s) => this._setDevice(s.device),
      onRender: this._onRenderFrame.bind(this),
      // @ts-expect-error typing mismatch: AnimationLoop does not accept onError:null
      onError: i
      // onBeforeRender,
      // onAfterRender,
    });
  }
  // Create a device from the deviceProps, assigning required defaults
  _createDevice(e) {
    const t = this.props.deviceProps?.createCanvasContext, n = typeof t == "object" ? t : void 0, i = { adapters: [], ...e.deviceProps };
    i.adapters.includes(Vv) || i.adapters.push(Vv);
    const s = {
      // we must use 'premultiplied' canvas for webgpu to enable transparency and match shaders
      alphaMode: this.props.deviceProps?.type === "webgpu" ? "premultiplied" : void 0
    };
    return Eb.createDevice({
      // luma by default throws if a device is already attached
      // asynchronous device creation could happen after finalize() is called
      // TODO - createDevice should support AbortController?
      _reuseDevices: !0,
      // tests can't handle WebGPU devices yet so we force WebGL2 unless overridden
      type: "webgl",
      ...i,
      // In deck.gl v10 we may emphasize multi canvas support and unwind this prop wrapping
      createCanvasContext: {
        ...s,
        ...n,
        canvas: this._createCanvas(e),
        useDevicePixels: this.props.useDevicePixels,
        autoResize: !0
      }
    });
  }
  // Get the most relevant view state: props.viewState, if supplied, shadows internal viewState
  // TODO: For backwards compatibility ensure numeric width and height is added to the viewState
  _getViewState() {
    return this.props.viewState || this.viewState;
  }
  // Get the view descriptor list
  _getViews() {
    const { views: e } = this.props, t = Array.isArray(e) ? e : (
      // If null, default to a full screen map view port
      e ? [e] : [new l6({ id: "default-view" })]
    );
    return t.length && this.props.controller && (t[0].props.controller = this.props.controller), t;
  }
  _onContextLost() {
    const { onError: e } = this.props;
    this.animationLoop && e && e(new Error("WebGL context is lost"));
  }
  /** Actually run picking */
  _pickAndCallback() {
    if (this.device?.type === "webgpu")
      return;
    const { _pickRequest: e } = this;
    if (e.event) {
      const { result: t, emptyInfo: n } = this._pick("pickObject", "pickObject Time", e);
      this.cursorState.isHovering = t.length > 0;
      let i = n, s = !1;
      for (const o of t)
        i = o, s = o.layer?.onHover(o, e.event) || s;
      s || (this.props.onHover?.(i, e.event), this.widgetManager.onHover(i, e.event)), e.event = null;
    }
  }
  _updateCursor() {
    const e = this.props.parent || this.canvas;
    e && (e.style.cursor = this.props.getCursor(this.cursorState));
  }
  _setDevice(e) {
    if (this.device = e, !this.animationLoop)
      return;
    this.canvas || (this.canvas = this.device.canvasContext?.canvas, !this.canvas.isConnected && this.props.parent && this.props.parent.insertBefore(this.canvas, this.props.parent.firstChild)), this.device.type === "webgl" && this.device.setParametersWebGL({
      blend: !0,
      blendFunc: [770, 771, 1, 771],
      polygonOffsetFill: !0,
      depthTest: !0,
      depthFunc: 515
    }), this.props.onDeviceInitialized(this.device), this.device.type === "webgl" && this.props.onWebGLInitialized(this.device.gl);
    const t = new t6();
    t.play(), this.animationLoop.attachTimeline(t), this.eventManager = new NH(this.props.parent || this.canvas, {
      touchAction: this.props.touchAction,
      recognizers: Object.keys(SC).map((i) => {
        const [s, o, l, u] = SC[i], m = this.props.eventRecognizerOptions?.[i], y = { ...o, ...m, event: i };
        return {
          recognizer: new s(y),
          recognizeWith: l,
          requestFailure: u
        };
      }),
      events: {
        pointerdown: this._onPointerDown,
        pointermove: this._onPointerMove,
        pointerleave: this._onPointerMove
      }
    });
    for (const i in kb)
      this.eventManager.on(i, this._onEvent);
    this.viewManager = new r$({
      timeline: t,
      eventManager: this.eventManager,
      onViewStateChange: this._onViewStateChange.bind(this),
      onInteractionStateChange: this._onInteractionStateChange.bind(this),
      views: this._getViews(),
      viewState: this._getViewState(),
      width: this.width,
      height: this.height
    });
    const n = this.viewManager.getViewports()[0];
    this.layerManager = new t$(this.device, {
      deck: this,
      stats: this.stats,
      viewport: n,
      timeline: t
    }), this.effectManager = new _$({
      deck: this,
      device: this.device
    }), this.deckRenderer = new b$(this.device), this.deckPicker = new T$(this.device), this.widgetManager = new S$({
      deck: this,
      parentElement: this.canvas?.parentElement
    }), this.widgetManager.addDefault(new c6()), this.setProps(this.props), this._updateCanvasSize(), this.props.onLoad();
  }
  /** Internal only: default render function (redraw all layers and views) */
  _drawLayers(e, t) {
    const { device: n, gl: i } = this.layerManager.context;
    this.props.onBeforeRender({ device: n, gl: i });
    const s = {
      target: this.props._framebuffer,
      layers: this.layerManager.getLayers(),
      viewports: this.viewManager.getViewports(),
      onViewportActive: this.layerManager.activateViewport,
      views: this.viewManager.getViews(),
      pass: "screen",
      effects: this.effectManager.getEffects(),
      ...t
    };
    this.deckRenderer?.renderLayers(s), s.pass === "screen" && this.widgetManager.onRedraw({
      viewports: s.viewports,
      layers: s.layers
    }), this.props.onAfterRender({ device: n, gl: i });
  }
  // Callbacks
  _onRenderFrame() {
    this._getFrameStats(), this._metricsCounter++ % 60 === 0 && (this._getMetrics(), this.stats.reset(), Jr.table(4, this.metrics)(), this.props._onMetrics && this.props._onMetrics(this.metrics)), this._updateCanvasSize(), this._updateCursor(), this.layerManager.updateLayers(), this.device?.type !== "webgpu" && this._pickAndCallback(), this.redraw(), this.viewManager && this.viewManager.updateViewStates();
  }
  // Callbacks
  _onViewStateChange(e) {
    const t = this.props.onViewStateChange(e) || e.viewState;
    this.viewState && (this.viewState = { ...this.viewState, [e.viewId]: t }, this.props.viewState || this.viewManager && this.viewManager.setProps({ viewState: this.viewState }));
  }
  _onInteractionStateChange(e) {
    this.cursorState.isDragging = e.isDragging || !1, this.props.onInteractionStateChange(e);
  }
  _getFrameStats() {
    const { stats: e } = this;
    e.get("frameRate").timeEnd(), e.get("frameRate").timeStart();
    const t = this.animationLoop.stats;
    e.get("GPU Time").addTime(t.get("GPU Time").lastTiming), e.get("CPU Time").addTime(t.get("CPU Time").lastTiming);
  }
  _getMetrics() {
    const { metrics: e, stats: t } = this;
    e.fps = t.get("frameRate").getHz(), e.setPropsTime = t.get("setProps Time").time, e.updateAttributesTime = t.get("Update Attributes").time, e.framesRedrawn = t.get("Redraw Count").count, e.pickTime = t.get("pickObject Time").time + t.get("pickMultipleObjects Time").time + t.get("pickObjects Time").time, e.pickCount = t.get("Pick Count").count, e.gpuTime = t.get("GPU Time").time, e.cpuTime = t.get("CPU Time").time, e.gpuTimePerFrame = t.get("GPU Time").getAverageTime(), e.cpuTimePerFrame = t.get("CPU Time").getAverageTime();
    const n = Eb.stats.get("Memory Usage");
    e.bufferMemory = n.get("Buffer Memory").count, e.textureMemory = n.get("Texture Memory").count, e.renderbufferMemory = n.get("Renderbuffer Memory").count, e.gpuMemory = n.get("GPU Memory").count;
  }
}
Qx.defaultProps = b6;
Qx.VERSION = Uz;
function wX(r) {
  switch (r) {
    case "float64":
      return Float64Array;
    case "uint8":
    case "unorm8":
      return Uint8ClampedArray;
    default:
      return ux(r);
  }
}
const TX = cx;
function Sg(r, e, t) {
  const n = t === "webgpu" && e.type === "uint8" ? "unorm8" : e.type;
  return {
    attribute: r,
    // @ts-expect-error Not all combinations are valid vertex formats; it's up to DataColumn to ensure
    format: e.size > 1 ? `${n}x${e.size}` : e.type,
    byteOffset: e.offset || 0
    // Note stride is set on the top level
  };
}
function Wf(r) {
  return r.stride || r.size * r.bytesPerElement;
}
function EX(r, e) {
  return r.type === e.type && r.size === e.size && Wf(r) === Wf(e) && (r.offset || 0) === (e.offset || 0);
}
function Zb(r, e) {
  e.offset && Jr.removed("shaderAttribute.offset", "vertexOffset, elementOffset")();
  const t = Wf(r), n = e.vertexOffset !== void 0 ? e.vertexOffset : r.vertexOffset || 0, i = e.elementOffset || 0, s = (
    // offsets defined by the attribute
    n * t + i * r.bytesPerElement + // offsets defined by external buffers if any
    (r.offset || 0)
  );
  return {
    ...e,
    offset: s,
    stride: t
  };
}
function CX(r, e) {
  const t = Zb(r, e);
  return {
    high: t,
    low: {
      ...t,
      offset: t.offset + r.size * 4
    }
  };
}
class SX {
  /* eslint-disable max-statements */
  constructor(e, t, n) {
    this._buffer = null, this.device = e, this.id = t.id || "", this.size = t.size || 1;
    const i = t.logicalType || t.type, s = i === "float64";
    let { defaultValue: o } = t;
    o = Number.isFinite(o) ? [o] : o || new Array(this.size).fill(0);
    let l;
    s ? l = "float32" : !i && t.isIndexed ? l = "uint32" : l = i || "float32";
    let u = wX(i || l);
    this.doublePrecision = s, s && t.fp64 === !1 && (u = Float32Array), this.value = null, this.settings = {
      ...t,
      defaultType: u,
      defaultValue: o,
      logicalType: i,
      type: l,
      normalized: l.includes("norm"),
      size: this.size,
      bytesPerElement: u.BYTES_PER_ELEMENT
    }, this.state = {
      ...n,
      externalBuffer: null,
      bufferAccessor: this.settings,
      allocatedValue: null,
      numInstances: 0,
      bounds: null,
      constant: !1
    };
  }
  /* eslint-enable max-statements */
  get isConstant() {
    return this.state.constant;
  }
  get buffer() {
    return this._buffer;
  }
  get byteOffset() {
    const e = this.getAccessor();
    return e.vertexOffset ? e.vertexOffset * Wf(e) : 0;
  }
  get numInstances() {
    return this.state.numInstances;
  }
  set numInstances(e) {
    this.state.numInstances = e;
  }
  delete() {
    this._buffer && (this._buffer.delete(), this._buffer = null), yp.release(this.state.allocatedValue);
  }
  getBuffer() {
    return this.state.constant ? null : this.state.externalBuffer || this._buffer;
  }
  getValue(e = this.id, t = null) {
    const n = {};
    if (this.state.constant) {
      const i = this.value;
      if (t) {
        const s = Zb(this.getAccessor(), t), o = s.offset / i.BYTES_PER_ELEMENT, l = s.size || this.size;
        n[e] = i.subarray(o, o + l);
      } else
        n[e] = i;
    } else
      n[e] = this.getBuffer();
    return this.doublePrecision && (this.value instanceof Float64Array ? n[`${e}64Low`] = n[e] : n[`${e}64Low`] = new Float32Array(this.size)), n;
  }
  _getBufferLayout(e = this.id, t = null) {
    const n = this.getAccessor(), i = [], s = {
      name: this.id,
      byteStride: Wf(n),
      attributes: i
    };
    if (this.doublePrecision) {
      const o = CX(n, t || {});
      i.push(Sg(e, { ...n, ...o.high }, this.device.type), Sg(`${e}64Low`, {
        ...n,
        ...o.low
      }, this.device.type));
    } else if (t) {
      const o = Zb(n, t);
      i.push(Sg(e, { ...n, ...o }, this.device.type));
    } else
      i.push(Sg(e, n, this.device.type));
    return s;
  }
  setAccessor(e) {
    this.state.bufferAccessor = e;
  }
  getAccessor() {
    return this.state.bufferAccessor;
  }
  // Returns [min: Array(size), max: Array(size)]
  /* eslint-disable max-depth */
  getBounds() {
    if (this.state.bounds)
      return this.state.bounds;
    let e = null;
    if (this.state.constant && this.value) {
      const t = Array.from(this.value);
      e = [t, t];
    } else {
      const { value: t, numInstances: n, size: i } = this, s = n * i;
      if (t && s && t.length >= s) {
        const o = new Array(i).fill(1 / 0), l = new Array(i).fill(-1 / 0);
        for (let u = 0; u < s; )
          for (let m = 0; m < i; m++) {
            const y = t[u++];
            y < o[m] && (o[m] = y), y > l[m] && (l[m] = y);
          }
        e = [o, l];
      }
    }
    return this.state.bounds = e, e;
  }
  // returns true if success
  // eslint-disable-next-line max-statements
  setData(e) {
    const { state: t } = this;
    let n;
    ArrayBuffer.isView(e) ? n = { value: e } : e instanceof vi ? n = { buffer: e } : n = e;
    const i = { ...this.settings, ...n };
    if (ArrayBuffer.isView(n.value)) {
      if (!n.type)
        if (this.doublePrecision && n.value instanceof Float64Array)
          i.type = "float32";
        else {
          const o = TX(n.value);
          i.type = i.normalized ? o.replace("int", "norm") : o;
        }
      i.bytesPerElement = n.value.BYTES_PER_ELEMENT, i.stride = Wf(i);
    }
    if (t.bounds = null, n.constant) {
      let s = n.value;
      if (s = this._normalizeValue(s, [], 0), this.settings.normalized && (s = this.normalizeConstant(s)), !(!t.constant || !this._areValuesEqual(s, this.value)))
        return !1;
      t.externalBuffer = null, t.constant = !0, this.value = ArrayBuffer.isView(s) ? s : new Float32Array(s);
    } else if (n.buffer) {
      const s = n.buffer;
      t.externalBuffer = s, t.constant = !1, this.value = n.value || null;
    } else if (n.value) {
      this._checkExternalBuffer(n);
      let s = n.value;
      t.externalBuffer = null, t.constant = !1, this.value = s;
      let { buffer: o } = this;
      const l = Wf(i), u = (i.vertexOffset || 0) * l;
      if (this.doublePrecision && s instanceof Float64Array && (s = Lv(s, i)), this.settings.isIndexed) {
        const y = this.settings.defaultType;
        s.constructor !== y && (s = new y(s));
      }
      const m = s.byteLength + u + l * 2;
      (!o || o.byteLength < m) && (o = this._createBuffer(m)), o.write(s, u);
    }
    return this.setAccessor(i), !0;
  }
  updateSubBuffer(e = {}) {
    this.state.bounds = null;
    const t = this.value, { startOffset: n = 0, endOffset: i } = e;
    this.buffer.write(this.doublePrecision && t instanceof Float64Array ? Lv(t, {
      size: this.size,
      startIndex: n,
      endIndex: i
    }) : t.subarray(n, i), n * t.BYTES_PER_ELEMENT + this.byteOffset);
  }
  allocate(e, t = !1) {
    const { state: n } = this, i = n.allocatedValue, s = yp.allocate(i, e + 1, {
      size: this.size,
      type: this.settings.defaultType,
      copy: t
    });
    this.value = s;
    const { byteOffset: o } = this;
    let { buffer: l } = this;
    return (!l || l.byteLength < s.byteLength + o) && (l = this._createBuffer(s.byteLength + o), t && i && l.write(i instanceof Float64Array ? Lv(i, this) : i, o)), n.allocatedValue = s, n.constant = !1, n.externalBuffer = null, this.setAccessor(this.settings), !0;
  }
  // PRIVATE HELPER METHODS
  _checkExternalBuffer(e) {
    const { value: t } = e;
    if (!ArrayBuffer.isView(t))
      throw new Error(`Attribute ${this.id} value is not TypedArray`);
    const n = this.settings.defaultType;
    let i = !1;
    if (this.doublePrecision && (i = t.BYTES_PER_ELEMENT < 4), i)
      throw new Error(`Attribute ${this.id} does not support ${t.constructor.name}`);
    !(t instanceof n) && this.settings.normalized && !("normalized" in e) && Jr.warn(`Attribute ${this.id} is normalized`)();
  }
  // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer
  normalizeConstant(e) {
    switch (this.settings.type) {
      case "snorm8":
        return new Float32Array(e).map((t) => (t + 128) / 255 * 2 - 1);
      case "snorm16":
        return new Float32Array(e).map((t) => (t + 32768) / 65535 * 2 - 1);
      case "unorm8":
        return new Float32Array(e).map((t) => t / 255);
      case "unorm16":
        return new Float32Array(e).map((t) => t / 65535);
      default:
        return e;
    }
  }
  /* check user supplied values and apply fallback */
  _normalizeValue(e, t, n) {
    const { defaultValue: i, size: s } = this.settings;
    if (Number.isFinite(e))
      return t[n] = e, t;
    if (!e) {
      let o = s;
      for (; --o >= 0; )
        t[n + o] = i[o];
      return t;
    }
    switch (s) {
      case 4:
        t[n + 3] = Number.isFinite(e[3]) ? e[3] : i[3];
      case 3:
        t[n + 2] = Number.isFinite(e[2]) ? e[2] : i[2];
      case 2:
        t[n + 1] = Number.isFinite(e[1]) ? e[1] : i[1];
      case 1:
        t[n + 0] = Number.isFinite(e[0]) ? e[0] : i[0];
        break;
      default:
        let o = s;
        for (; --o >= 0; )
          t[n + o] = Number.isFinite(e[o]) ? e[o] : i[o];
    }
    return t;
  }
  _areValuesEqual(e, t) {
    if (!e || !t)
      return !1;
    const { size: n } = this;
    for (let i = 0; i < n; i++)
      if (e[i] !== t[i])
        return !1;
    return !0;
  }
  _createBuffer(e) {
    this._buffer && this._buffer.destroy();
    const { isIndexed: t, type: n } = this.settings;
    return this._buffer = this.device.createBuffer({
      ...this._buffer?.props,
      id: this.id,
      // TODO(ibgreen) - WebGPU requires COPY_DST and COPY_SRC to allow write / read
      usage: (t ? vi.INDEX : vi.VERTEX) | vi.COPY_DST,
      indexType: t ? n : void 0,
      byteLength: e
    }), this._buffer;
  }
}
const pS = [], AS = [];
function hc(r, e = 0, t = 1 / 0) {
  let n = pS;
  const i = {
    index: -1,
    data: r,
    // visitor can optionally utilize this to avoid constructing a new array for every object
    target: []
  };
  return r ? typeof r[Symbol.iterator] == "function" ? n = r : r.length > 0 && (AS.length = r.length, n = AS) : n = pS, (e > 0 || Number.isFinite(t)) && (n = (Array.isArray(n) ? n : Array.from(n)).slice(e, t), i.index = e - 1), { iterable: n, objectInfo: i };
}
function x6(r) {
  return r && r[Symbol.asyncIterator];
}
function w6(r, e) {
  const { size: t, stride: n, offset: i, startIndices: s, nested: o } = e, l = r.BYTES_PER_ELEMENT, u = n ? n / l : t, m = i ? i / l : 0, y = Math.floor((r.length - m) / u);
  return (E, { index: P, target: L }) => {
    if (!s) {
      const j = P * u + m;
      for (let K = 0; K < t; K++)
        L[K] = r[j + K];
      return L;
    }
    const U = s[P], V = s[P + 1] || y;
    let q;
    if (o) {
      q = new Array(V - U);
      for (let j = U; j < V; j++) {
        const K = j * u + m;
        L = new Array(t);
        for (let Y = 0; Y < t; Y++)
          L[Y] = r[K + Y];
        q[j - U] = L;
      }
    } else if (u === t)
      q = r.subarray(U * t + m, V * t + m);
    else {
      q = new r.constructor((V - U) * t);
      let j = 0;
      for (let K = U; K < V; K++) {
        const Y = K * u + m;
        for (let de = 0; de < t; de++)
          q[j++] = r[Y + de];
      }
    }
    return q;
  };
}
const IX = [], wm = [[0, 1 / 0]];
function PX(r, e) {
  if (r === wm || (e[0] < 0 && (e[0] = 0), e[0] >= e[1]))
    return r;
  const t = [], n = r.length;
  let i = 0;
  for (let s = 0; s < n; s++) {
    const o = r[s];
    o[1] < e[0] ? (t.push(o), i = s + 1) : o[0] > e[1] ? t.push(o) : e = [Math.min(o[0], e[0]), Math.max(o[1], e[1])];
  }
  return t.splice(i, 0, e), t;
}
const MX = {
  interpolation: {
    duration: 0,
    easing: (r) => r
  },
  spring: {
    stiffness: 0.05,
    damping: 0.5
  }
};
function T6(r, e) {
  if (!r)
    return null;
  Number.isFinite(r) && (r = { type: "interpolation", duration: r });
  const t = r.type || "interpolation";
  return {
    ...MX[t],
    ...e,
    ...r,
    type: t
  };
}
class E6 extends SX {
  constructor(e, t) {
    super(e, t, {
      startIndices: null,
      lastExternalBuffer: null,
      binaryValue: null,
      binaryAccessor: null,
      needsUpdate: !0,
      needsRedraw: !1,
      layoutChanged: !1,
      updateRanges: wm
    }), this.constant = !1, this.settings.update = t.update || (t.accessor ? this._autoUpdater : void 0), Object.seal(this.settings), Object.seal(this.state), this._validateAttributeUpdaters();
  }
  get startIndices() {
    return this.state.startIndices;
  }
  set startIndices(e) {
    this.state.startIndices = e;
  }
  needsUpdate() {
    return this.state.needsUpdate;
  }
  needsRedraw({ clearChangedFlags: e = !1 } = {}) {
    const t = this.state.needsRedraw;
    return this.state.needsRedraw = t && !e, t;
  }
  layoutChanged() {
    return this.state.layoutChanged;
  }
  setAccessor(e) {
    var t;
    (t = this.state).layoutChanged || (t.layoutChanged = !EX(e, this.getAccessor())), super.setAccessor(e);
  }
  getUpdateTriggers() {
    const { accessor: e } = this.settings;
    return [this.id].concat(typeof e != "function" && e || []);
  }
  supportsTransition() {
    return !!this.settings.transition;
  }
  // Resolve transition settings object if transition is enabled, otherwise `null`
  getTransitionSetting(e) {
    if (!e || !this.supportsTransition())
      return null;
    const { accessor: t } = this.settings, n = this.settings.transition, i = Array.isArray(t) ? (
      // @ts-ignore
      e[t.find((s) => e[s])]
    ) : (
      // @ts-ignore
      e[t]
    );
    return T6(i, n);
  }
  setNeedsUpdate(e = this.id, t) {
    if (this.state.needsUpdate = this.state.needsUpdate || e, this.setNeedsRedraw(e), t) {
      const { startRow: n = 0, endRow: i = 1 / 0 } = t;
      this.state.updateRanges = PX(this.state.updateRanges, [n, i]);
    } else
      this.state.updateRanges = wm;
  }
  clearNeedsUpdate() {
    this.state.needsUpdate = !1, this.state.updateRanges = IX;
  }
  setNeedsRedraw(e = this.id) {
    this.state.needsRedraw = this.state.needsRedraw || e;
  }
  allocate(e) {
    const { state: t, settings: n } = this;
    return n.noAlloc ? !1 : n.update ? (super.allocate(e, t.updateRanges !== wm), !0) : !1;
  }
  updateBuffer({ numInstances: e, data: t, props: n, context: i }) {
    if (!this.needsUpdate())
      return !1;
    const { state: { updateRanges: s }, settings: { update: o, noAlloc: l } } = this;
    let u = !0;
    if (o) {
      for (const [m, y] of s)
        o.call(i, this, { data: t, startRow: m, endRow: y, props: n, numInstances: e });
      if (this.value) if (this.constant || !this.buffer || this.buffer.byteLength < this.value.byteLength + this.byteOffset)
        this.setData({
          value: this.value,
          constant: this.constant
        }), this.constant = !1;
      else
        for (const [m, y] of s) {
          const E = Number.isFinite(m) ? this.getVertexOffset(m) : 0, P = Number.isFinite(y) ? this.getVertexOffset(y) : l || !Number.isFinite(e) ? this.value.length : e * this.size;
          super.updateSubBuffer({ startOffset: E, endOffset: P });
        }
      this._checkAttributeArray();
    } else
      u = !1;
    return this.clearNeedsUpdate(), this.setNeedsRedraw(), u;
  }
  // Use generic value
  // Returns true if successful
  setConstantValue(e, t) {
    const n = this.device.type === "webgpu";
    if (n || t === void 0 || typeof t == "function") {
      if (n && typeof t != "function") {
        const o = this._normalizeValue(t, [], 0);
        this._areValuesEqual(o, this.value) || this.setNeedsUpdate("WebGPU constant updated");
      }
      return !1;
    }
    const i = this.settings.transform && e ? this.settings.transform.call(e, t) : t;
    return this.setData({ constant: !0, value: i }) && this.setNeedsRedraw(), this.clearNeedsUpdate(), !0;
  }
  // Use external buffer
  // Returns true if successful
  // eslint-disable-next-line max-statements
  setExternalBuffer(e) {
    const { state: t } = this;
    return e ? (this.clearNeedsUpdate(), t.lastExternalBuffer === e || (t.lastExternalBuffer = e, this.setNeedsRedraw(), this.setData(e)), !0) : (t.lastExternalBuffer = null, !1);
  }
  // Binary value is a typed array packed from mapping the source data with the accessor
  // If the returned value from the accessor is the same as the attribute value, set it directly
  // Otherwise use the auto updater for transform/normalization
  setBinaryValue(e, t = null) {
    const { state: n, settings: i } = this;
    if (!e)
      return n.binaryValue = null, n.binaryAccessor = null, !1;
    if (i.noAlloc)
      return !1;
    if (n.binaryValue === e)
      return this.clearNeedsUpdate(), !0;
    if (n.binaryValue = e, this.setNeedsRedraw(), i.transform || t !== this.startIndices) {
      ArrayBuffer.isView(e) && (e = { value: e });
      const o = e;
      to(ArrayBuffer.isView(o.value), `invalid ${i.accessor}`);
      const l = !!o.size && o.size !== this.size;
      return n.binaryAccessor = w6(o.value, {
        size: o.size || this.size,
        stride: o.stride,
        offset: o.offset,
        startIndices: t,
        nested: l
      }), !1;
    }
    return this.clearNeedsUpdate(), this.setData(e), !0;
  }
  getVertexOffset(e) {
    const { startIndices: t } = this;
    return (t ? e < t.length ? t[e] : this.numInstances : e) * this.size;
  }
  getValue() {
    const e = this.settings.shaderAttributes, t = super.getValue();
    if (!e)
      return t;
    for (const n in e)
      Object.assign(t, super.getValue(n, e[n]));
    return t;
  }
  /** Generate WebGPU-style buffer layout descriptor from this attribute */
  getBufferLayout(e) {
    this.state.layoutChanged = !1;
    const t = this.settings.shaderAttributes, n = super._getBufferLayout(), { stepMode: i } = this.settings;
    if (i === "dynamic" ? n.stepMode = e ? e.isInstanced ? "instance" : "vertex" : "instance" : n.stepMode = i ?? "vertex", !t)
      return n;
    for (const s in t) {
      const o = super._getBufferLayout(s, t[s]);
      n.attributes.push(...o.attributes);
    }
    return n;
  }
  /* eslint-disable max-depth, max-statements */
  _autoUpdater(e, { data: t, startRow: n, endRow: i, props: s, numInstances: o }) {
    if (e.constant && this.context.device.type !== "webgpu")
      return;
    const { settings: l, state: u, value: m, size: y, startIndices: E } = e, { accessor: P, transform: L } = l;
    let U = u.binaryAccessor || // @ts-ignore
    (typeof P == "function" ? P : s[P]);
    typeof U != "function" && typeof P == "string" && (U = () => s[P]), to(typeof U == "function", `accessor "${P}" is not a function`);
    let V = e.getVertexOffset(n);
    const { iterable: q, objectInfo: j } = hc(t, n, i);
    for (const K of q) {
      j.index++;
      let Y = U(K, j);
      if (L && (Y = L.call(this, Y)), E) {
        const de = (j.index < E.length - 1 ? E[j.index + 1] : o) - E[j.index];
        if (Y && Array.isArray(Y[0])) {
          let ne = V;
          for (const ae of Y)
            e._normalizeValue(ae, m, ne), ne += y;
        } else Y && Y.length > y ? m.set(Y, V) : (e._normalizeValue(Y, j.target, 0), YW({
          target: m,
          source: j.target,
          start: V,
          count: de
        }));
        V += de * y;
      } else
        e._normalizeValue(Y, m, V), V += y;
    }
  }
  /* eslint-enable max-depth, max-statements */
  // Validate deck.gl level fields
  _validateAttributeUpdaters() {
    const { settings: e } = this;
    if (!(e.noAlloc || typeof e.update == "function"))
      throw new Error(`Attribute ${this.id} missing update or accessor`);
  }
  // check that the first few elements of the attribute are reasonable
  /* eslint-disable no-fallthrough */
  _checkAttributeArray() {
    const { value: e } = this, t = Math.min(4, this.size);
    if (e && e.length >= t) {
      let n = !0;
      switch (t) {
        case 4:
          n = n && Number.isFinite(e[3]);
        case 3:
          n = n && Number.isFinite(e[2]);
        case 2:
          n = n && Number.isFinite(e[1]);
        case 1:
          n = n && Number.isFinite(e[0]);
          break;
        default:
          n = !1;
      }
      if (!n)
        throw new Error(`Illegal attribute generated for ${this.id}`);
    }
  }
}
function $v(r) {
  const { source: e, target: t, start: n = 0, size: i, getData: s } = r, o = r.end || t.length, l = e.length, u = o - n;
  if (l > u) {
    t.set(e.subarray(0, u), n);
    return;
  }
  if (t.set(e, n), !s)
    return;
  let m = l;
  for (; m < u; ) {
    const y = s(m, e);
    for (let E = 0; E < i; E++)
      t[n + m] = y[E] || 0, m++;
  }
}
function RX({ source: r, target: e, size: t, getData: n, sourceStartIndices: i, targetStartIndices: s }) {
  if (!i || !s)
    return $v({
      source: r,
      target: e,
      size: t,
      getData: n
    }), e;
  let o = 0, l = 0;
  const u = n && ((y, E) => n(y + l, E)), m = Math.min(i.length, s.length);
  for (let y = 1; y < m; y++) {
    const E = i[y] * t, P = s[y] * t;
    $v({
      source: r.subarray(o, E),
      target: e,
      start: l,
      end: P,
      size: t,
      getData: u
    }), o = E, l = P;
  }
  return l < e.length && $v({
    // @ts-ignore
    source: [],
    target: e,
    start: l,
    size: t,
    getData: u
  }), e;
}
function BX(r) {
  const { device: e, settings: t, value: n } = r, i = new E6(e, t);
  return i.setData({
    value: n instanceof Float64Array ? new Float64Array(0) : new Float32Array(0),
    normalized: t.normalized
  }), i;
}
function C6(r) {
  switch (r) {
    case 1:
      return "float";
    case 2:
      return "vec2";
    case 3:
      return "vec3";
    case 4:
      return "vec4";
    default:
      throw new Error(`No defined attribute type for size "${r}"`);
  }
}
function S6(r) {
  switch (r) {
    case 1:
      return "float32";
    case 2:
      return "float32x2";
    case 3:
      return "float32x3";
    case 4:
      return "float32x4";
    default:
      throw new Error("invalid type size");
  }
}
function I6(r) {
  r.push(r.shift());
}
function OX(r, e) {
  const { doublePrecision: t, settings: n, value: i, size: s } = r, o = t && i instanceof Float64Array ? 2 : 1;
  let l = 0;
  const { shaderAttributes: u } = r.settings;
  if (u)
    for (const m of Object.values(u))
      l = Math.max(l, m.vertexOffset ?? 0);
  return (n.noAlloc ? i.length : (e + l) * s) * o;
}
function P6({ device: r, source: e, target: t }) {
  return (!t || t.byteLength < e.byteLength) && (t?.destroy(), t = r.createBuffer({
    byteLength: e.byteLength,
    usage: e.usage
  })), t;
}
function M6({ device: r, buffer: e, attribute: t, fromLength: n, toLength: i, fromStartIndices: s, getData: o = (l) => l }) {
  const l = t.doublePrecision && t.value instanceof Float64Array ? 2 : 1, u = t.size * l, m = t.byteOffset, y = t.settings.bytesPerElement < 4 ? m / t.settings.bytesPerElement * 4 : m, E = t.startIndices, P = s && E, L = t.isConstant;
  if (!P && e && n >= i)
    return e;
  const U = t.value instanceof Float64Array ? Float32Array : t.value.constructor, V = L ? t.value : (
    // TODO(v9.1): Avoid non-portable synchronous reads.
    new U(t.getBuffer().readSyncWebGL(m, i * U.BYTES_PER_ELEMENT).buffer)
  );
  if (t.settings.normalized && !L) {
    const Y = o;
    o = (de, ne) => t.normalizeConstant(Y(de, ne));
  }
  const q = L ? (Y, de) => o(V, de) : (Y, de) => o(V.subarray(Y + m, Y + m + u), de), j = e ? new Float32Array(e.readSyncWebGL(y, n * 4).buffer) : new Float32Array(0), K = new Float32Array(i);
  return RX({
    source: j,
    target: K,
    sourceStartIndices: s,
    targetStartIndices: E,
    size: u,
    getData: q
  }), (!e || e.byteLength < K.byteLength + y) && (e?.destroy(), e = r.createBuffer({
    byteLength: K.byteLength + y,
    usage: 35050
  })), e.write(K, y), e;
}
class R6 {
  constructor({ device: e, attribute: t, timeline: n }) {
    this.buffers = [], this.currentLength = 0, this.device = e, this.transition = new V_(n), this.attribute = t, this.attributeInTransition = BX(t), this.currentStartIndices = t.startIndices;
  }
  get inProgress() {
    return this.transition.inProgress;
  }
  start(e, t, n = 1 / 0) {
    this.settings = e, this.currentStartIndices = this.attribute.startIndices, this.currentLength = OX(this.attribute, t), this.transition.start({ ...e, duration: n });
  }
  update() {
    const e = this.transition.update();
    return e && this.onUpdate(), e;
  }
  setBuffer(e) {
    this.attributeInTransition.setData({
      buffer: e,
      normalized: this.attribute.settings.normalized,
      // Retain placeholder value to generate correct shader layout
      value: this.attributeInTransition.value
    });
  }
  cancel() {
    this.transition.cancel();
  }
  delete() {
    this.cancel();
    for (const e of this.buffers)
      e.destroy();
    this.buffers.length = 0;
  }
}
class DX extends R6 {
  constructor({ device: e, attribute: t, timeline: n }) {
    super({ device: e, attribute: t, timeline: n }), this.type = "interpolation", this.transform = NX(e, t);
  }
  start(e, t) {
    const n = this.currentLength, i = this.currentStartIndices;
    if (super.start(e, t, e.duration), e.duration <= 0) {
      this.transition.cancel();
      return;
    }
    const { buffers: s, attribute: o } = this;
    I6(s), s[0] = M6({
      device: this.device,
      buffer: s[0],
      attribute: o,
      fromLength: n,
      toLength: this.currentLength,
      fromStartIndices: i,
      getData: e.enter
    }), s[1] = P6({
      device: this.device,
      source: s[0],
      target: s[1]
    }), this.setBuffer(s[1]);
    const { transform: l } = this, u = l.model;
    let m = Math.floor(this.currentLength / o.size);
    B6(o) && (m /= 2), u.setVertexCount(m), o.isConstant ? (u.setAttributes({ aFrom: s[0] }), u.setConstantAttributes({ aTo: o.value })) : u.setAttributes({
      aFrom: s[0],
      aTo: o.getBuffer()
    }), l.transformFeedback.setBuffers({ vCurrent: s[1] });
  }
  onUpdate() {
    const { duration: e, easing: t } = this.settings, { time: n } = this.transition;
    let i = n / e;
    t && (i = t(i));
    const { model: s } = this.transform, o = { time: i };
    s.shaderInputs.setProps({ interpolation: o }), this.transform.run({ discard: !0 });
  }
  delete() {
    super.delete(), this.transform.destroy();
  }
}
const LX = `uniform interpolationUniforms {
  float time;
} interpolation;
`, gS = {
  name: "interpolation",
  vs: LX,
  uniformTypes: {
    time: "f32"
  }
}, kX = `#version 300 es
#define SHADER_NAME interpolation-transition-vertex-shader

in ATTRIBUTE_TYPE aFrom;
in ATTRIBUTE_TYPE aTo;
out ATTRIBUTE_TYPE vCurrent;

void main(void) {
  vCurrent = mix(aFrom, aTo, interpolation.time);
  gl_Position = vec4(0.0);
}
`, FX = `#version 300 es
#define SHADER_NAME interpolation-transition-vertex-shader

in ATTRIBUTE_TYPE aFrom;
in ATTRIBUTE_TYPE aFrom64Low;
in ATTRIBUTE_TYPE aTo;
in ATTRIBUTE_TYPE aTo64Low;
out ATTRIBUTE_TYPE vCurrent;
out ATTRIBUTE_TYPE vCurrent64Low;

vec2 mix_fp64(vec2 a, vec2 b, float x) {
  vec2 range = sub_fp64(b, a);
  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));
}

void main(void) {
  for (int i=0; i<ATTRIBUTE_SIZE; i++) {
    vec2 value = mix_fp64(vec2(aFrom[i], aFrom64Low[i]), vec2(aTo[i], aTo64Low[i]), interpolation.time);
    vCurrent[i] = value.x;
    vCurrent64Low[i] = value.y;
  }
  gl_Position = vec4(0.0);
}
`;
function B6(r) {
  return r.doublePrecision && r.value instanceof Float64Array;
}
function NX(r, e) {
  const t = e.size, n = C6(t), i = S6(t), s = e.getBufferLayout();
  return B6(e) ? new ih(r, {
    vs: FX,
    bufferLayout: [
      {
        name: "aFrom",
        byteStride: 8 * t,
        attributes: [
          { attribute: "aFrom", format: i, byteOffset: 0 },
          { attribute: "aFrom64Low", format: i, byteOffset: 4 * t }
        ]
      },
      {
        name: "aTo",
        byteStride: 8 * t,
        attributes: [
          { attribute: "aTo", format: i, byteOffset: 0 },
          { attribute: "aTo64Low", format: i, byteOffset: 4 * t }
        ]
      }
    ],
    // @ts-expect-error fp64 module only sets ONE uniform via defaultUniforms
    modules: [Ej, gS],
    defines: {
      // @ts-expect-error TODO fix luma type
      ATTRIBUTE_TYPE: n,
      // @ts-expect-error TODO fix luma type
      ATTRIBUTE_SIZE: t
    },
    // Default uniforms are not set without this
    moduleSettings: {},
    varyings: ["vCurrent", "vCurrent64Low"],
    bufferMode: 35980,
    disableWarnings: !0
  }) : new ih(r, {
    vs: kX,
    bufferLayout: [
      { name: "aFrom", format: i },
      { name: "aTo", format: s.attributes[0].format }
    ],
    modules: [gS],
    defines: {
      // @ts-expect-error TODO fix luma type
      ATTRIBUTE_TYPE: n
    },
    varyings: ["vCurrent"],
    // TODO investigate why this is needed
    disableWarnings: !0
  });
}
class UX extends R6 {
  constructor({ device: e, attribute: t, timeline: n }) {
    super({ device: e, attribute: t, timeline: n }), this.type = "spring", this.texture = WX(e), this.framebuffer = $X(e, this.texture), this.transform = GX(e, t);
  }
  start(e, t) {
    const n = this.currentLength, i = this.currentStartIndices;
    super.start(e, t);
    const { buffers: s, attribute: o } = this;
    for (let u = 0; u < 2; u++)
      s[u] = M6({
        device: this.device,
        buffer: s[u],
        attribute: o,
        fromLength: n,
        toLength: this.currentLength,
        fromStartIndices: i,
        getData: e.enter
      });
    s[2] = P6({
      device: this.device,
      source: s[0],
      target: s[2]
    }), this.setBuffer(s[1]);
    const { model: l } = this.transform;
    l.setVertexCount(Math.floor(this.currentLength / o.size)), o.isConstant ? l.setConstantAttributes({ aTo: o.value }) : l.setAttributes({ aTo: o.getBuffer() });
  }
  onUpdate() {
    const { buffers: e, transform: t, framebuffer: n, transition: i } = this, s = this.settings;
    t.model.setAttributes({
      aPrev: e[0],
      aCur: e[1]
    }), t.transformFeedback.setBuffers({ vNext: e[2] });
    const o = {
      stiffness: s.stiffness,
      damping: s.damping
    };
    t.model.shaderInputs.setProps({ spring: o }), t.run({
      framebuffer: n,
      discard: !1,
      parameters: { viewport: [0, 0, 1, 1] },
      clearColor: [0, 0, 0, 0]
    }), I6(e), this.setBuffer(e[1]), this.device.readPixelsToArrayWebGL(n)[0] > 0 || i.end();
  }
  delete() {
    super.delete(), this.transform.destroy(), this.texture.destroy(), this.framebuffer.destroy();
  }
}
const zX = `uniform springUniforms {
  float damping;
  float stiffness;
} spring;
`, VX = {
  name: "spring",
  vs: zX,
  uniformTypes: {
    damping: "f32",
    stiffness: "f32"
  }
}, jX = `#version 300 es
#define SHADER_NAME spring-transition-vertex-shader

#define EPSILON 0.00001

in ATTRIBUTE_TYPE aPrev;
in ATTRIBUTE_TYPE aCur;
in ATTRIBUTE_TYPE aTo;
out ATTRIBUTE_TYPE vNext;
out float vIsTransitioningFlag;

ATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {
  ATTRIBUTE_TYPE velocity = cur - prev;
  ATTRIBUTE_TYPE delta = dest - cur;
  ATTRIBUTE_TYPE force = delta * spring.stiffness;
  ATTRIBUTE_TYPE resistance = velocity * spring.damping;
  return force - resistance + velocity + cur;
}

void main(void) {
  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;
  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;

  vNext = getNextValue(aCur, aPrev, aTo);
  gl_Position = vec4(0, 0, 0, 1);
  gl_PointSize = 100.0;
}
`, HX = `#version 300 es
#define SHADER_NAME spring-transition-is-transitioning-fragment-shader

in float vIsTransitioningFlag;

out vec4 fragColor;

void main(void) {
  if (vIsTransitioningFlag == 0.0) {
    discard;
  }
  fragColor = vec4(1.0);
}`;
function GX(r, e) {
  const t = C6(e.size), n = S6(e.size);
  return new ih(r, {
    vs: jX,
    fs: HX,
    bufferLayout: [
      { name: "aPrev", format: n },
      { name: "aCur", format: n },
      { name: "aTo", format: e.getBufferLayout().attributes[0].format }
    ],
    varyings: ["vNext"],
    modules: [VX],
    // @ts-expect-error TODO fix luma type
    defines: { ATTRIBUTE_TYPE: t },
    parameters: {
      depthCompare: "always",
      blendColorOperation: "max",
      blendColorSrcFactor: "one",
      blendColorDstFactor: "one",
      blendAlphaOperation: "max",
      blendAlphaSrcFactor: "one",
      blendAlphaDstFactor: "one"
    }
  });
}
function WX(r) {
  return r.createTexture({
    data: new Uint8Array(4),
    format: "rgba8unorm",
    width: 1,
    height: 1
  });
}
function $X(r, e) {
  return r.createFramebuffer({
    id: "spring-transition-is-transitioning-framebuffer",
    width: 1,
    height: 1,
    colorAttachments: [e]
  });
}
const qX = {
  interpolation: DX,
  spring: UX
};
class XX {
  constructor(e, { id: t, timeline: n }) {
    if (!e)
      throw new Error("AttributeTransitionManager is constructed without device");
    this.id = t, this.device = e, this.timeline = n, this.transitions = {}, this.needsRedraw = !1, this.numInstances = 1;
  }
  finalize() {
    for (const e in this.transitions)
      this._removeTransition(e);
  }
  /* Public methods */
  // Called when attribute manager updates
  // Check the latest attributes for updates.
  update({ attributes: e, transitions: t, numInstances: n }) {
    this.numInstances = n || 1;
    for (const i in e) {
      const s = e[i], o = s.getTransitionSetting(t);
      o && this._updateAttribute(i, s, o);
    }
    for (const i in this.transitions) {
      const s = e[i];
      (!s || !s.getTransitionSetting(t)) && this._removeTransition(i);
    }
  }
  // Returns `true` if attribute is transition-enabled
  hasAttribute(e) {
    const t = this.transitions[e];
    return t && t.inProgress;
  }
  // Get all the animated attributes
  getAttributes() {
    const e = {};
    for (const t in this.transitions) {
      const n = this.transitions[t];
      n.inProgress && (e[t] = n.attributeInTransition);
    }
    return e;
  }
  /* eslint-disable max-statements */
  // Called every render cycle, run transform feedback
  // Returns `true` if anything changes
  run() {
    if (this.numInstances === 0)
      return !1;
    for (const t in this.transitions)
      this.transitions[t].update() && (this.needsRedraw = !0);
    const e = this.needsRedraw;
    return this.needsRedraw = !1, e;
  }
  /* eslint-enable max-statements */
  /* Private methods */
  _removeTransition(e) {
    this.transitions[e].delete(), delete this.transitions[e];
  }
  // Check an attributes for updates
  // Returns a transition object if a new transition is triggered.
  _updateAttribute(e, t, n) {
    const i = this.transitions[e];
    let s = !i || i.type !== n.type;
    if (s) {
      i && this._removeTransition(e);
      const o = qX[n.type];
      o ? this.transitions[e] = new o({
        attribute: t,
        timeline: this.timeline,
        device: this.device
      }) : (Jr.error(`unsupported transition type '${n.type}'`)(), s = !1);
    }
    (s || t.needsRedraw()) && (this.needsRedraw = !0, this.transitions[e].start(n, this.numInstances));
  }
}
const mS = "attributeManager.invalidate", ZX = "attributeManager.updateStart", YX = "attributeManager.updateEnd", KX = "attribute.updateStart", QX = "attribute.allocate", JX = "attribute.updateEnd";
class j_ {
  constructor(e, { id: t = "attribute-manager", stats: n, timeline: i } = {}) {
    this.mergeBoundsMemoized = v0(XG), this.id = t, this.device = e, this.attributes = {}, this.updateTriggers = {}, this.needsRedraw = !0, this.userData = {}, this.stats = n, this.attributeTransitionManager = new XX(e, {
      id: `${t}-transitions`,
      timeline: i
    }), Object.seal(this);
  }
  finalize() {
    for (const e in this.attributes)
      this.attributes[e].delete();
    this.attributeTransitionManager.finalize();
  }
  // Returns the redraw flag, optionally clearing it.
  // Redraw flag will be set if any attributes attributes changed since
  // flag was last cleared.
  //
  // @param {String} [clearRedrawFlags=false] - whether to clear the flag
  // @return {false|String} - reason a redraw is needed.
  getNeedsRedraw(e = { clearRedrawFlags: !1 }) {
    const t = this.needsRedraw;
    return this.needsRedraw = this.needsRedraw && !e.clearRedrawFlags, t && this.id;
  }
  // Sets the redraw flag.
  // @param {Boolean} redraw=true
  setNeedsRedraw() {
    this.needsRedraw = !0;
  }
  // Adds attributes
  add(e) {
    this._add(e);
  }
  // Adds attributes
  addInstanced(e) {
    this._add(e, { stepMode: "instance" });
  }
  /**
   * Removes attributes
   * Takes an array of attribute names and delete them from
   * the attribute map if they exists
   *
   * @example
   * attributeManager.remove(['position']);
   *
   * @param {Object} attributeNameArray - attribute name array (see above)
   */
  remove(e) {
    for (const t of e)
      this.attributes[t] !== void 0 && (this.attributes[t].delete(), delete this.attributes[t]);
  }
  // Marks an attribute for update
  invalidate(e, t) {
    const n = this._invalidateTrigger(e, t);
    go(mS, this, e, n);
  }
  invalidateAll(e) {
    for (const t in this.attributes)
      this.attributes[t].setNeedsUpdate(t, e);
    go(mS, this, "all");
  }
  // Ensure all attribute buffers are updated from props or data.
  // eslint-disable-next-line complexity
  update({ data: e, numInstances: t, startIndices: n = null, transitions: i, props: s = {}, buffers: o = {}, context: l = {} }) {
    let u = !1;
    go(ZX, this), this.stats && this.stats.get("Update Attributes").timeStart();
    for (const m in this.attributes) {
      const y = this.attributes[m], E = y.settings.accessor;
      y.startIndices = n, y.numInstances = t, s[m] && Jr.removed(`props.${m}`, `data.attributes.${m}`)(), y.setExternalBuffer(o[m]) || y.setBinaryValue(typeof E == "string" ? o[E] : void 0, e.startIndices) || typeof E == "string" && !o[E] && y.setConstantValue(l, s[E]) || y.needsUpdate() && (u = !0, this._updateAttribute({
        attribute: y,
        numInstances: t,
        data: e,
        props: s,
        context: l
      })), this.needsRedraw = this.needsRedraw || y.needsRedraw();
    }
    u && go(YX, this, t), this.stats && this.stats.get("Update Attributes").timeEnd(), this.attributeTransitionManager.update({
      attributes: this.attributes,
      numInstances: t,
      transitions: i
    });
  }
  // Update attribute transition to the current timestamp
  // Returns `true` if any transition is in progress
  updateTransition() {
    const { attributeTransitionManager: e } = this, t = e.run();
    return this.needsRedraw = this.needsRedraw || t, t;
  }
  /**
   * Returns all attribute descriptors
   * Note: Format matches luma.gl Model/Program.setAttributes()
   * @return {Object} attributes - descriptors
   */
  getAttributes() {
    return { ...this.attributes, ...this.attributeTransitionManager.getAttributes() };
  }
  /**
   * Computes the spatial bounds of a given set of attributes
   */
  getBounds(e) {
    const t = e.map((n) => this.attributes[n]?.getBounds());
    return this.mergeBoundsMemoized(t);
  }
  /**
   * Returns changed attribute descriptors
   * This indicates which WebGLBuffers need to be updated
   * @return {Object} attributes - descriptors
   */
  getChangedAttributes(e = { clearChangedFlags: !1 }) {
    const { attributes: t, attributeTransitionManager: n } = this, i = { ...n.getAttributes() };
    for (const s in t) {
      const o = t[s];
      o.needsRedraw(e) && !n.hasAttribute(s) && (i[s] = o);
    }
    return i;
  }
  /** Generate WebGPU-style buffer layout descriptors from all attributes */
  getBufferLayouts(e) {
    return Object.values(this.getAttributes()).map((t) => t.getBufferLayout(e));
  }
  // PRIVATE METHODS
  /** Register new attributes */
  _add(e, t) {
    for (const n in e) {
      const i = e[n], s = {
        ...i,
        id: n,
        size: i.isIndexed && 1 || i.size || 1,
        ...t
      };
      this.attributes[n] = new E6(this.device, s);
    }
    this._mapUpdateTriggersToAttributes();
  }
  // build updateTrigger name to attribute name mapping
  _mapUpdateTriggersToAttributes() {
    const e = {};
    for (const t in this.attributes)
      this.attributes[t].getUpdateTriggers().forEach((i) => {
        e[i] || (e[i] = []), e[i].push(t);
      });
    this.updateTriggers = e;
  }
  _invalidateTrigger(e, t) {
    const { attributes: n, updateTriggers: i } = this, s = i[e];
    return s && s.forEach((o) => {
      const l = n[o];
      l && l.setNeedsUpdate(l.id, t);
    }), s;
  }
  _updateAttribute(e) {
    const { attribute: t, numInstances: n } = e;
    if (go(KX, t), t.constant) {
      t.setConstantValue(e.context, t.value);
      return;
    }
    t.allocate(n) && go(QX, t, n), t.updateBuffer(e) && (this.needsRedraw = !0, go(JX, t, n));
  }
}
class eZ extends V_ {
  get value() {
    return this._value;
  }
  _onUpdate() {
    const { time: e, settings: { fromValue: t, toValue: n, duration: i, easing: s } } = this, o = s(e / i);
    this._value = ml(t, n, o);
  }
}
const _S = 1e-5;
function yS(r, e, t, n, i) {
  const s = e - r, l = (t - e) * i, u = -s * n;
  return l + u + s + e;
}
function tZ(r, e, t, n, i) {
  if (Array.isArray(t)) {
    const s = [];
    for (let o = 0; o < t.length; o++)
      s[o] = yS(r[o], e[o], t[o], n, i);
    return s;
  }
  return yS(r, e, t, n, i);
}
function vS(r, e) {
  if (Array.isArray(r)) {
    let t = 0;
    for (let n = 0; n < r.length; n++) {
      const i = r[n] - e[n];
      t += i * i;
    }
    return Math.sqrt(t);
  }
  return Math.abs(r - e);
}
class rZ extends V_ {
  get value() {
    return this._currValue;
  }
  _onUpdate() {
    const { fromValue: e, toValue: t, damping: n, stiffness: i } = this.settings, { _prevValue: s = e, _currValue: o = e } = this;
    let l = tZ(s, o, t, n, i);
    const u = vS(l, t), m = vS(l, o);
    u < _S && m < _S && (l = t, this.end()), this._prevValue = o, this._currValue = l;
  }
}
const nZ = {
  interpolation: eZ,
  spring: rZ
};
class iZ {
  constructor(e) {
    this.transitions = /* @__PURE__ */ new Map(), this.timeline = e;
  }
  get active() {
    return this.transitions.size > 0;
  }
  add(e, t, n, i) {
    const { transitions: s } = this;
    if (s.has(e)) {
      const u = s.get(e), { value: m = u.settings.fromValue } = u;
      t = m, this.remove(e);
    }
    if (i = T6(i), !i)
      return;
    const o = nZ[i.type];
    if (!o) {
      Jr.error(`unsupported transition type '${i.type}'`)();
      return;
    }
    const l = new o(this.timeline);
    l.start({
      ...i,
      fromValue: t,
      toValue: n
    }), s.set(e, l);
  }
  remove(e) {
    const { transitions: t } = this;
    t.has(e) && (t.get(e).cancel(), t.delete(e));
  }
  update() {
    const e = {};
    for (const [t, n] of this.transitions)
      n.update(), e[t] = n.value, n.inProgress || this.remove(t);
    return e;
  }
  clear() {
    for (const e of this.transitions.keys())
      this.remove(e);
  }
}
function sZ(r) {
  const e = r[qu];
  for (const t in e) {
    const n = e[t], { validate: i } = n;
    if (i && !i(r[t], n))
      throw new Error(`Invalid prop ${t}: ${r[t]}`);
  }
}
function oZ(r, e) {
  const t = Jx({
    newProps: r,
    oldProps: e,
    propTypes: r[qu],
    ignoreProps: { data: null, updateTriggers: null, extensions: null, transitions: null }
  }), n = lZ(r, e);
  let i = !1;
  return n || (i = cZ(r, e)), {
    dataChanged: n,
    propsChanged: t,
    updateTriggersChanged: i,
    extensionsChanged: uZ(r, e),
    transitionsChanged: aZ(r, e)
  };
}
function aZ(r, e) {
  if (!r.transitions)
    return !1;
  const t = {}, n = r[qu];
  let i = !1;
  for (const s in r.transitions) {
    const o = n[s], l = o && o.type;
    (l === "number" || l === "color" || l === "array") && Yb(r[s], e[s], o) && (t[s] = !0, i = !0);
  }
  return i ? t : !1;
}
function Jx({ newProps: r, oldProps: e, ignoreProps: t = {}, propTypes: n = {}, triggerName: i = "props" }) {
  if (e === r)
    return !1;
  if (typeof r != "object" || r === null)
    return `${i} changed shallowly`;
  if (typeof e != "object" || e === null)
    return `${i} changed shallowly`;
  for (const s of Object.keys(r))
    if (!(s in t)) {
      if (!(s in e))
        return `${i}.${s} added`;
      const o = Yb(r[s], e[s], n[s]);
      if (o)
        return `${i}.${s} ${o}`;
    }
  for (const s of Object.keys(e))
    if (!(s in t)) {
      if (!(s in r))
        return `${i}.${s} dropped`;
      if (!Object.hasOwnProperty.call(r, s)) {
        const o = Yb(r[s], e[s], n[s]);
        if (o)
          return `${i}.${s} ${o}`;
      }
    }
  return !1;
}
function Yb(r, e, t) {
  let n = t && t.equal;
  return n && !n(r, e, t) || !n && (n = r && e && r.equals, n && !n.call(r, e)) ? "changed deeply" : !n && e !== r ? "changed shallowly" : null;
}
function lZ(r, e) {
  if (e === null)
    return "oldProps is null, initial diff";
  let t = !1;
  const { dataComparator: n, _dataDiff: i } = r;
  return n ? n(r.data, e.data) || (t = "Data comparator detected a change") : r.data !== e.data && (t = "A new data container was supplied"), t && i && (t = i(r.data, e.data) || t), t;
}
function cZ(r, e) {
  if (e === null)
    return { all: !0 };
  if ("all" in r.updateTriggers && bS(r, e, "all"))
    return { all: !0 };
  const t = {};
  let n = !1;
  for (const i in r.updateTriggers)
    i !== "all" && bS(r, e, i) && (t[i] = !0, n = !0);
  return n ? t : !1;
}
function uZ(r, e) {
  if (e === null)
    return !0;
  const t = e.extensions, { extensions: n } = r;
  if (n === t)
    return !1;
  if (!t || !n || n.length !== t.length)
    return !0;
  for (let i = 0; i < n.length; i++)
    if (!n[i].equals(t[i]))
      return !0;
  return !1;
}
function bS(r, e, t) {
  let n = r.updateTriggers[t];
  n = n ?? {};
  let i = e.updateTriggers[t];
  return i = i ?? {}, Jx({
    oldProps: i,
    newProps: n,
    triggerName: t
  });
}
const fZ = "count(): argument not an object", hZ = "count(): argument not a container";
function dZ(r) {
  if (!AZ(r))
    throw new Error(fZ);
  if (typeof r.count == "function")
    return r.count();
  if (Number.isFinite(r.size))
    return r.size;
  if (Number.isFinite(r.length))
    return r.length;
  if (pZ(r))
    return Object.keys(r).length;
  throw new Error(hZ);
}
function pZ(r) {
  return r !== null && typeof r == "object" && r.constructor === Object;
}
function AZ(r) {
  return r !== null && typeof r == "object";
}
function xS(r, e) {
  if (!e)
    return r;
  const t = { ...r, ...e };
  if ("defines" in e && (t.defines = { ...r.defines, ...e.defines }), "modules" in e && (t.modules = (r.modules || []).concat(e.modules), e.modules.some((n) => n.name === "project64"))) {
    const n = t.modules.findIndex((i) => i.name === "project32");
    n >= 0 && t.modules.splice(n, 1);
  }
  if ("inject" in e)
    if (!r.inject)
      t.inject = e.inject;
    else {
      const n = { ...r.inject };
      for (const i in e.inject)
        n[i] = (n[i] || "") + e.inject[i];
      t.inject = n;
    }
  return t;
}
const gZ = {
  minFilter: "linear",
  mipmapFilter: "linear",
  magFilter: "linear",
  addressModeU: "clamp-to-edge",
  addressModeV: "clamp-to-edge"
}, Kb = {};
function mZ(r, e, t, n) {
  if (t instanceof ps)
    return t;
  t.constructor && t.constructor.name !== "Object" && (t = { data: t });
  let i = null;
  t.compressed && (i = {
    minFilter: "linear",
    mipmapFilter: t.data.length > 1 ? "nearest" : "linear"
  });
  const { width: s, height: o } = t.data, l = e.createTexture({
    ...t,
    sampler: {
      ...gZ,
      ...i,
      ...n
    },
    mipLevels: e.getMipLevelCount(s, o)
  });
  return l.generateMipmapsWebGL(), Kb[l.id] = r, l;
}
function _Z(r, e) {
  !e || !(e instanceof ps) || Kb[e.id] === r && (e.delete(), delete Kb[e.id]);
}
const yZ = {
  boolean: {
    validate(r, e) {
      return !0;
    },
    equal(r, e, t) {
      return !!r == !!e;
    }
  },
  number: {
    validate(r, e) {
      return Number.isFinite(r) && (!("max" in e) || r <= e.max) && (!("min" in e) || r >= e.min);
    }
  },
  color: {
    validate(r, e) {
      return e.optional && !r || Qb(r) && (r.length === 3 || r.length === 4);
    },
    equal(r, e, t) {
      return Fi(r, e, 1);
    }
  },
  accessor: {
    validate(r, e) {
      const t = o_(r);
      return t === "function" || t === o_(e.value);
    },
    equal(r, e, t) {
      return typeof e == "function" ? !0 : Fi(r, e, 1);
    }
  },
  array: {
    validate(r, e) {
      return e.optional && !r || Qb(r);
    },
    equal(r, e, t) {
      const { compare: n } = t, i = Number.isInteger(n) ? n : n ? 1 : 0;
      return n ? Fi(r, e, i) : r === e;
    }
  },
  object: {
    equal(r, e, t) {
      if (t.ignore)
        return !0;
      const { compare: n } = t, i = Number.isInteger(n) ? n : n ? 1 : 0;
      return n ? Fi(r, e, i) : r === e;
    }
  },
  function: {
    validate(r, e) {
      return e.optional && !r || typeof r == "function";
    },
    equal(r, e, t) {
      return !t.compare && t.ignore !== !1 || r === e;
    }
  },
  data: {
    transform: (r, e, t) => {
      if (!r)
        return r;
      const { dataTransform: n } = t.props;
      return n ? n(r) : typeof r.shape == "string" && r.shape.endsWith("-table") && Array.isArray(r.data) ? r.data : r;
    }
  },
  image: {
    transform: (r, e, t) => {
      const n = t.context;
      return !n || !n.device ? null : mZ(t.id, n.device, r, {
        ...e.parameters,
        ...t.props.textureParameters
      });
    },
    release: (r, e, t) => {
      _Z(t.id, r);
    }
  }
};
function vZ(r) {
  const e = {}, t = {}, n = {};
  for (const [i, s] of Object.entries(r)) {
    const o = s?.deprecatedFor;
    if (o)
      n[i] = Array.isArray(o) ? o : [o];
    else {
      const l = bZ(i, s);
      e[i] = l, t[i] = l.value;
    }
  }
  return { propTypes: e, defaultProps: t, deprecatedProps: n };
}
function bZ(r, e) {
  switch (o_(e)) {
    case "object":
      return vA(r, e);
    case "array":
      return vA(r, { type: "array", value: e, compare: !1 });
    case "boolean":
      return vA(r, { type: "boolean", value: e });
    case "number":
      return vA(r, { type: "number", value: e });
    case "function":
      return vA(r, { type: "function", value: e, compare: !0 });
    default:
      return { name: r, type: "unknown", value: e };
  }
}
function vA(r, e) {
  return "type" in e ? { name: r, ...yZ[e.type], ...e } : "value" in e ? { name: r, type: o_(e.value), ...e } : { name: r, type: "object", value: e };
}
function Qb(r) {
  return Array.isArray(r) || ArrayBuffer.isView(r);
}
function o_(r) {
  return Qb(r) ? "array" : r === null ? "null" : typeof r;
}
function xZ(r, e) {
  let t;
  for (let s = e.length - 1; s >= 0; s--) {
    const o = e[s];
    "extensions" in o && (t = o.extensions);
  }
  const n = Jb(r.constructor, t), i = Object.create(n);
  i[s_] = r, i[sh] = {}, i[Hu] = {};
  for (let s = 0; s < e.length; ++s) {
    const o = e[s];
    for (const l in o)
      i[l] = o[l];
  }
  return Object.freeze(i), i;
}
const wZ = "_mergedDefaultProps";
function Jb(r, e) {
  if (!(r instanceof H_.constructor))
    return {};
  let t = wZ;
  if (e)
    for (const i of e) {
      const s = i.constructor;
      s && (t += `:${s.extensionName || s.name}`);
    }
  const n = O6(r, t);
  return n || (r[t] = TZ(r, e || []));
}
function TZ(r, e) {
  if (!r.prototype)
    return null;
  const n = Object.getPrototypeOf(r), i = Jb(n), s = O6(r, "defaultProps") || {}, o = vZ(s), l = Object.assign(/* @__PURE__ */ Object.create(null), i, o.defaultProps), u = Object.assign(/* @__PURE__ */ Object.create(null), i?.[qu], o.propTypes), m = Object.assign(/* @__PURE__ */ Object.create(null), i?.[zv], o.deprecatedProps);
  for (const y of e) {
    const E = Jb(y.constructor);
    E && (Object.assign(l, E), Object.assign(u, E[qu]), Object.assign(m, E[zv]));
  }
  return EZ(l, r), SZ(l, u), CZ(l, m), l[qu] = u, l[zv] = m, e.length === 0 && !ew(r, "_propTypes") && (r._propTypes = u), l;
}
function EZ(r, e) {
  const t = PZ(e);
  Object.defineProperties(r, {
    // `id` is treated specially because layer might need to override it
    id: {
      writable: !0,
      value: t
    }
  });
}
function CZ(r, e) {
  for (const t in e)
    Object.defineProperty(r, t, {
      enumerable: !1,
      set(n) {
        const i = `${this.id}: ${t}`;
        for (const s of e[t])
          ew(this, s) || (this[s] = n);
        Jr.deprecated(i, e[t].join("/"))();
      }
    });
}
function SZ(r, e) {
  const t = {}, n = {};
  for (const i in e) {
    const s = e[i], { name: o, value: l } = s;
    s.async && (t[o] = l, n[o] = IZ(o));
  }
  r[ap] = t, r[sh] = {}, Object.defineProperties(r, n);
}
function IZ(r) {
  return {
    enumerable: !0,
    // Save the provided value for async props in a special map
    set(e) {
      typeof e == "string" || e instanceof Promise || x6(e) ? this[sh][r] = e : this[Hu][r] = e;
    },
    // Only the component's state knows the true value of async prop
    get() {
      if (this[Hu]) {
        if (r in this[Hu])
          return this[Hu][r] || this[ap][r];
        if (r in this[sh]) {
          const e = this[s_] && this[s_].internalState;
          if (e && e.hasAsyncProp(r))
            return e.getAsyncProp(r) || this[ap][r];
        }
      }
      return this[ap][r];
    }
  };
}
function ew(r, e) {
  return Object.prototype.hasOwnProperty.call(r, e);
}
function O6(r, e) {
  return ew(r, e) && r[e];
}
function PZ(r) {
  const e = r.componentName;
  return e || Jr.warn(`${r.name}.componentName not specified`)(), e || r.name;
}
let MZ = 0;
class H_ {
  constructor(...e) {
    this.props = xZ(this, e), this.id = this.props.id, this.count = MZ++;
  }
  // clone this layer with modified props
  clone(e) {
    const { props: t } = this, n = {};
    for (const i in t[ap])
      i in t[Hu] ? n[i] = t[Hu][i] : i in t[sh] && (n[i] = t[sh][i]);
    return new this.constructor({ ...t, ...n, ...e });
  }
}
H_.componentName = "Component";
H_.defaultProps = {};
const RZ = Object.freeze({});
class BZ {
  constructor(e) {
    this.component = e, this.asyncProps = {}, this.onAsyncPropUpdated = () => {
    }, this.oldProps = null, this.oldAsyncProps = null;
  }
  finalize() {
    for (const e in this.asyncProps) {
      const t = this.asyncProps[e];
      t && t.type && t.type.release && t.type.release(t.resolvedValue, t.type, this.component);
    }
    this.asyncProps = {}, this.component = null, this.resetOldProps();
  }
  /* Layer-facing props API */
  getOldProps() {
    return this.oldAsyncProps || this.oldProps || RZ;
  }
  resetOldProps() {
    this.oldAsyncProps = null, this.oldProps = this.component ? this.component.props : null;
  }
  // Checks if a prop is overridden
  hasAsyncProp(e) {
    return e in this.asyncProps;
  }
  // Returns value of an overriden prop
  getAsyncProp(e) {
    const t = this.asyncProps[e];
    return t && t.resolvedValue;
  }
  isAsyncPropLoading(e) {
    if (e) {
      const t = this.asyncProps[e];
      return !!(t && t.pendingLoadCount > 0 && t.pendingLoadCount !== t.resolvedLoadCount);
    }
    for (const t in this.asyncProps)
      if (this.isAsyncPropLoading(t))
        return !0;
    return !1;
  }
  // Without changing the original prop value, swap out the data resolution under the hood
  reloadAsyncProp(e, t) {
    this._watchPromise(e, Promise.resolve(t));
  }
  // Updates all async/overridden props (when new props come in)
  // Checks if urls have changed, starts loading, or removes override
  setAsyncProps(e) {
    this.component = e[s_] || this.component;
    const t = e[Hu] || {}, n = e[sh] || e, i = e[ap] || {};
    for (const s in t) {
      const o = t[s];
      this._createAsyncPropData(s, i[s]), this._updateAsyncProp(s, o), t[s] = this.getAsyncProp(s);
    }
    for (const s in n) {
      const o = n[s];
      this._createAsyncPropData(s, i[s]), this._updateAsyncProp(s, o);
    }
  }
  /* Placeholder methods for subclassing */
  _fetch(e, t) {
    return null;
  }
  _onResolve(e, t) {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
  _onError(e, t) {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
  // Intercept strings (URLs) and Promises and activates loading and prop rewriting
  _updateAsyncProp(e, t) {
    if (this._didAsyncInputValueChange(e, t)) {
      if (typeof t == "string" && (t = this._fetch(e, t)), t instanceof Promise) {
        this._watchPromise(e, t);
        return;
      }
      if (x6(t)) {
        this._resolveAsyncIterable(e, t);
        return;
      }
      this._setPropValue(e, t);
    }
  }
  // Whenever async props are changing, we need to make a copy of oldProps
  // otherwise the prop rewriting will affect the value both in props and oldProps.
  // While the copy is relatively expensive, this only happens on load completion.
  _freezeAsyncOldProps() {
    if (!this.oldAsyncProps && this.oldProps) {
      this.oldAsyncProps = Object.create(this.oldProps);
      for (const e in this.asyncProps)
        Object.defineProperty(this.oldAsyncProps, e, {
          enumerable: !0,
          value: this.oldProps[e]
        });
    }
  }
  // Checks if an input value actually changed (to avoid reloading/rewatching promises/urls)
  _didAsyncInputValueChange(e, t) {
    const n = this.asyncProps[e];
    return t === n.resolvedValue || t === n.lastValue ? !1 : (n.lastValue = t, !0);
  }
  // Set normal, non-async value
  _setPropValue(e, t) {
    this._freezeAsyncOldProps();
    const n = this.asyncProps[e];
    n && (t = this._postProcessValue(n, t), n.resolvedValue = t, n.pendingLoadCount++, n.resolvedLoadCount = n.pendingLoadCount);
  }
  // Set a just resolved async value, calling onAsyncPropUpdates if value changes asynchronously
  _setAsyncPropValue(e, t, n) {
    const i = this.asyncProps[e];
    i && n >= i.resolvedLoadCount && t !== void 0 && (this._freezeAsyncOldProps(), i.resolvedValue = t, i.resolvedLoadCount = n, this.onAsyncPropUpdated(e, t));
  }
  // Tracks a promise, sets the prop when loaded, handles load count
  _watchPromise(e, t) {
    const n = this.asyncProps[e];
    if (n) {
      n.pendingLoadCount++;
      const i = n.pendingLoadCount;
      t.then((s) => {
        this.component && (s = this._postProcessValue(n, s), this._setAsyncPropValue(e, s, i), this._onResolve(e, s));
      }).catch((s) => {
        this._onError(e, s);
      });
    }
  }
  async _resolveAsyncIterable(e, t) {
    if (e !== "data") {
      this._setPropValue(e, t);
      return;
    }
    const n = this.asyncProps[e];
    if (!n)
      return;
    n.pendingLoadCount++;
    const i = n.pendingLoadCount;
    let s = [], o = 0;
    for await (const l of t) {
      if (!this.component)
        return;
      const { dataTransform: u } = this.component.props;
      u ? s = u(l, s) : s = s.concat(l), Object.defineProperty(s, "__diff", {
        enumerable: !1,
        value: [{ startRow: o, endRow: s.length }]
      }), o = s.length, this._setAsyncPropValue(e, s, i);
    }
    this._onResolve(e, s);
  }
  // Give the app a chance to post process the loaded data
  _postProcessValue(e, t) {
    const n = e.type;
    return n && this.component && (n.release && n.release(e.resolvedValue, n, this.component), n.transform) ? n.transform(t, n, this.component) : t;
  }
  // Creating an asyncProp record if needed
  _createAsyncPropData(e, t) {
    if (!this.asyncProps[e]) {
      const i = this.component && this.component.props[qu];
      this.asyncProps[e] = {
        type: i && i[e],
        lastValue: null,
        resolvedValue: t,
        pendingLoadCount: 0,
        resolvedLoadCount: 0
      };
    }
  }
}
class OZ extends BZ {
  constructor({ attributeManager: e, layer: t }) {
    super(t), this.attributeManager = e, this.needsRedraw = !0, this.needsUpdate = !0, this.subLayers = null, this.usesPickingColorCache = !1;
  }
  get layer() {
    return this.component;
  }
  /* Override base Component methods with Layer-specific handling */
  _fetch(e, t) {
    const n = this.layer, i = n?.props.fetch;
    return i ? i(t, { propName: e, layer: n }) : super._fetch(e, t);
  }
  _onResolve(e, t) {
    const n = this.layer;
    if (n) {
      const i = n.props.onDataLoad;
      e === "data" && i && i(t, { propName: e, layer: n });
    }
  }
  _onError(e, t) {
    const n = this.layer;
    n && n.raiseError(t, `loading ${e} of ${this.layer}`);
  }
}
const DZ = "layer.changeFlag", LZ = "layer.initialize", kZ = "layer.update", FZ = "layer.finalize", NZ = "layer.matched", wS = 2 ** 24 - 1, UZ = Object.freeze([]), zZ = v0(({ oldViewport: r, viewport: e }) => r.equals(e));
let nl = new Uint8ClampedArray(0);
const VZ = {
  // data: Special handling for null, see below
  data: { type: "data", value: UZ, async: !0 },
  dataComparator: { type: "function", value: null, optional: !0 },
  _dataDiff: {
    type: "function",
    // @ts-ignore __diff is not defined on data
    value: (r) => r && r.__diff,
    optional: !0
  },
  dataTransform: { type: "function", value: null, optional: !0 },
  onDataLoad: { type: "function", value: null, optional: !0 },
  onError: { type: "function", value: null, optional: !0 },
  fetch: {
    type: "function",
    value: (r, { propName: e, layer: t, loaders: n, loadOptions: i, signal: s }) => {
      const { resourceManager: o } = t.context;
      i = i || t.getLoadOptions(), n = n || t.props.loaders, s && (i = {
        ...i,
        fetch: {
          ...i?.fetch,
          signal: s
        }
      });
      let l = o.contains(r);
      return !l && !i && (o.add({ resourceId: r, data: Kc(r, n), persistent: !1 }), l = !0), l ? o.subscribe({
        resourceId: r,
        onChange: (u) => t.internalState?.reloadAsyncProp(e, u),
        consumerId: t.id,
        requestId: e
      }) : Kc(r, n, i);
    }
  },
  updateTriggers: {},
  // Update triggers: a core change detection mechanism in deck.gl
  visible: !0,
  pickable: !1,
  opacity: { type: "number", min: 0, max: 1, value: 1 },
  operation: "draw",
  onHover: { type: "function", value: null, optional: !0 },
  onClick: { type: "function", value: null, optional: !0 },
  onDragStart: { type: "function", value: null, optional: !0 },
  onDrag: { type: "function", value: null, optional: !0 },
  onDragEnd: { type: "function", value: null, optional: !0 },
  coordinateSystem: rn.DEFAULT,
  coordinateOrigin: { type: "array", value: [0, 0, 0], compare: !0 },
  modelMatrix: { type: "array", value: null, compare: !0, optional: !0 },
  wrapLongitude: !1,
  positionFormat: "XYZ",
  colorFormat: "RGBA",
  parameters: { type: "object", value: {}, optional: !0, compare: 2 },
  loadOptions: { type: "object", value: null, optional: !0, ignore: !0 },
  transitions: null,
  extensions: [],
  loaders: { type: "array", value: [], optional: !0, ignore: !0 },
  // Offset depth based on layer index to avoid z-fighting.
  // Negative values pull layer towards the camera
  // https://www.opengl.org/archives/resources/faq/technical/polygonoffset.htm
  getPolygonOffset: {
    type: "function",
    value: ({ layerIndex: r }) => [0, -r * 100]
  },
  // Selection/Highlighting
  highlightedObjectIndex: null,
  autoHighlight: !1,
  highlightColor: { type: "accessor", value: [0, 0, 128, 128] }
};
class Is extends H_ {
  constructor() {
    super(...arguments), this.internalState = null, this.lifecycle = Hd.NO_STATE, this.parent = null;
  }
  static get componentName() {
    return Object.prototype.hasOwnProperty.call(this, "layerName") ? this.layerName : "";
  }
  get root() {
    let e = this;
    for (; e.parent; )
      e = e.parent;
    return e;
  }
  toString() {
    return `${this.constructor.layerName || this.constructor.name}({id: '${this.props.id}'})`;
  }
  // Public API for users
  /** Projects a point with current view state from the current layer's coordinate system to screen */
  project(e) {
    to(this.internalState);
    const t = this.internalState.viewport || this.context.viewport, n = e6(e, {
      viewport: t,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem
    }), [i, s, o] = ZO(n, t.pixelProjectionMatrix);
    return e.length === 2 ? [i, s] : [i, s, o];
  }
  /** Unprojects a screen pixel to the current view's default coordinate system
      Note: this does not reverse `project`. */
  unproject(e) {
    return to(this.internalState), (this.internalState.viewport || this.context.viewport).unproject(e);
  }
  /** Projects a point with current view state from the current layer's coordinate system to the world space */
  projectPosition(e, t) {
    to(this.internalState);
    const n = this.internalState.viewport || this.context.viewport;
    return eW(e, {
      viewport: n,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem,
      ...t
    });
  }
  // Public API for custom layer implementation
  /** `true` if this layer renders other layers */
  get isComposite() {
    return !1;
  }
  /** `true` if the layer renders to screen */
  get isDrawable() {
    return !0;
  }
  /** Updates selected state members and marks the layer for redraw */
  setState(e) {
    this.setChangeFlags({ stateChanged: !0 }), Object.assign(this.state, e), this.setNeedsRedraw();
  }
  /** Sets the redraw flag for this layer, will trigger a redraw next animation frame */
  setNeedsRedraw() {
    this.internalState && (this.internalState.needsRedraw = !0);
  }
  /** Mark this layer as needs a deep update */
  setNeedsUpdate() {
    this.internalState && (this.context.layerManager.setNeedsUpdate(String(this)), this.internalState.needsUpdate = !0);
  }
  /** Returns true if all async resources are loaded */
  get isLoaded() {
    return this.internalState ? !this.internalState.isAsyncPropLoading() : !1;
  }
  /** Returns true if using shader-based WGS84 longitude wrapping */
  get wrapLongitude() {
    return this.props.wrapLongitude;
  }
  /** @deprecated Returns true if the layer is visible in the picking pass */
  isPickable() {
    return this.props.pickable && this.props.visible;
  }
  /** Returns an array of models used by this layer, can be overriden by layer subclass */
  getModels() {
    const e = this.state;
    return e && (e.models || e.model && [e.model]) || [];
  }
  /** Update shader input parameters */
  setShaderModuleProps(...e) {
    for (const t of this.getModels())
      t.shaderInputs.setProps(...e);
  }
  /** Returns the attribute manager of this layer */
  getAttributeManager() {
    return this.internalState && this.internalState.attributeManager;
  }
  /** Returns the most recent layer that matched to this state
    (When reacting to an async event, this layer may no longer be the latest) */
  getCurrentLayer() {
    return this.internalState && this.internalState.layer;
  }
  /** Returns the default parse options for async props */
  getLoadOptions() {
    return this.props.loadOptions;
  }
  use64bitPositions() {
    const { coordinateSystem: e } = this.props;
    return e === rn.DEFAULT || e === rn.LNGLAT || e === rn.CARTESIAN;
  }
  // Event handling
  onHover(e, t) {
    return this.props.onHover && this.props.onHover(e, t) || !1;
  }
  onClick(e, t) {
    return this.props.onClick && this.props.onClick(e, t) || !1;
  }
  // Returns the picking color that doesn't match any subfeature
  // Use if some graphics do not belong to any pickable subfeature
  // @return {Array} - a black color
  nullPickingColor() {
    return [0, 0, 0];
  }
  // Returns the picking color that doesn't match any subfeature
  // Use if some graphics do not belong to any pickable subfeature
  encodePickingColor(e, t = []) {
    return t[0] = e + 1 & 255, t[1] = e + 1 >> 8 & 255, t[2] = e + 1 >> 8 >> 8 & 255, t;
  }
  // Returns the index corresponding to a picking color that doesn't match any subfeature
  // @param {Uint8Array} color - color array to be decoded
  // @return {Array} - the decoded picking color
  decodePickingColor(e) {
    to(e instanceof Uint8Array);
    const [t, n, i] = e;
    return t + n * 256 + i * 65536 - 1;
  }
  /** Deduces number of instances. Intention is to support:
    - Explicit setting of numInstances
    - Auto-deduction for ES6 containers that define a size member
    - Auto-deduction for Classic Arrays via the built-in length attribute
    - Auto-deduction via arrays */
  getNumInstances() {
    return Number.isFinite(this.props.numInstances) ? this.props.numInstances : this.state && this.state.numInstances !== void 0 ? this.state.numInstances : dZ(this.props.data);
  }
  /** Buffer layout describes how many attribute values are packed for each data object
      The default (null) is one value each object.
      Some data formats (e.g. paths, polygons) have various length. Their buffer layout
      is in the form of [L0, L1, L2, ...] */
  getStartIndices() {
    return this.props.startIndices ? this.props.startIndices : this.state && this.state.startIndices ? this.state.startIndices : null;
  }
  // Default implementation
  getBounds() {
    return this.getAttributeManager()?.getBounds(["positions", "instancePositions"]);
  }
  getShaders(e) {
    e = xS(e, {
      disableWarnings: !0,
      modules: this.context.defaultShaderModules
    });
    for (const t of this.props.extensions)
      e = xS(e, t.getShaders.call(this, t));
    return e;
  }
  /** Controls if updateState should be called. By default returns true if any prop has changed */
  shouldUpdateState(e) {
    return e.changeFlags.propsOrDataChanged;
  }
  /** Default implementation, all attributes will be invalidated and updated when data changes */
  // eslint-disable-next-line complexity
  updateState(e) {
    const t = this.getAttributeManager(), { dataChanged: n } = e.changeFlags;
    if (n && t)
      if (Array.isArray(n))
        for (const i of n)
          t.invalidateAll(i);
      else
        t.invalidateAll();
    if (t) {
      const { props: i } = e, s = this.internalState.hasPickingBuffer, o = Number.isInteger(i.highlightedObjectIndex) || i.pickable || i.extensions.some((l) => l.getNeedsPickingBuffer.call(this, l));
      if (s !== o) {
        this.internalState.hasPickingBuffer = o;
        const { pickingColors: l, instancePickingColors: u } = t.attributes, m = l || u;
        m && (o && m.constant && (m.constant = !1, t.invalidate(m.id)), !m.value && !o && (m.constant = !0, m.value = [0, 0, 0]));
      }
    }
  }
  /** Called once when layer is no longer matched and state will be discarded. Layers can destroy WebGL resources here. */
  finalizeState(e) {
    for (const n of this.getModels())
      n.destroy();
    const t = this.getAttributeManager();
    t && t.finalize(), this.context && this.context.resourceManager.unsubscribe({ consumerId: this.id }), this.internalState && (this.internalState.uniformTransitions.clear(), this.internalState.finalize());
  }
  // If state has a model, draw it with supplied uniforms
  draw(e) {
    for (const t of this.getModels())
      t.draw(e.renderPass);
  }
  // called to populate the info object that is passed to the event handler
  // @return null to cancel event
  getPickingInfo({ info: e, mode: t, sourceLayer: n }) {
    const { index: i } = e;
    return i >= 0 && Array.isArray(this.props.data) && (e.object = this.props.data[i]), e;
  }
  // END LIFECYCLE METHODS
  // / INTERNAL METHODS - called by LayerManager, DeckRenderer and DeckPicker
  /** (Internal) Propagate an error event through the system */
  raiseError(e, t) {
    t && (e = new Error(`${t}: ${e.message}`, { cause: e })), this.props.onError?.(e) || this.context?.onError?.(e, this);
  }
  /** (Internal) Checks if this layer needs redraw */
  getNeedsRedraw(e = { clearRedrawFlags: !1 }) {
    return this._getNeedsRedraw(e);
  }
  /** (Internal) Checks if this layer needs a deep update */
  needsUpdate() {
    return this.internalState ? this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams()) : !1;
  }
  /** Checks if this layer has ongoing uniform transition */
  hasUniformTransition() {
    return this.internalState?.uniformTransitions.active || !1;
  }
  /** Called when this layer is rendered into the given viewport */
  activateViewport(e) {
    if (!this.internalState)
      return;
    const t = this.internalState.viewport;
    this.internalState.viewport = e, (!t || !zZ({ oldViewport: t, viewport: e })) && (this.setChangeFlags({ viewportChanged: !0 }), this.isComposite ? this.needsUpdate() && this.setNeedsUpdate() : this._update());
  }
  /** Default implementation of attribute invalidation, can be redefined */
  invalidateAttribute(e = "all") {
    const t = this.getAttributeManager();
    t && (e === "all" ? t.invalidateAll() : t.invalidate(e));
  }
  /** Send updated attributes to the WebGL model */
  updateAttributes(e) {
    let t = !1;
    for (const n in e)
      e[n].layoutChanged() && (t = !0);
    for (const n of this.getModels())
      this._setModelAttributes(n, e, t);
  }
  /** Recalculate any attributes if needed */
  _updateAttributes() {
    const e = this.getAttributeManager();
    if (!e)
      return;
    const t = this.props, n = this.getNumInstances(), i = this.getStartIndices();
    e.update({
      data: t.data,
      numInstances: n,
      startIndices: i,
      props: t,
      transitions: t.transitions,
      // @ts-ignore (TS2339) property attribute is not present on some acceptable data types
      buffers: t.data.attributes,
      context: this
    });
    const s = e.getChangedAttributes({ clearChangedFlags: !0 });
    this.updateAttributes(s);
  }
  /** Update attribute transitions. This is called in drawLayer, no model updates required. */
  _updateAttributeTransition() {
    const e = this.getAttributeManager();
    e && e.updateTransition();
  }
  /** Update uniform (prop) transitions. This is called in updateState, may result in model updates. */
  _updateUniformTransition() {
    const { uniformTransitions: e } = this.internalState;
    if (e.active) {
      const t = e.update(), n = Object.create(this.props);
      for (const i in t)
        Object.defineProperty(n, i, { value: t[i] });
      return n;
    }
    return this.props;
  }
  /** Updater for the automatically populated instancePickingColors attribute */
  calculateInstancePickingColors(e, { numInstances: t }) {
    if (e.constant)
      return;
    const n = Math.floor(nl.length / 4);
    if (this.internalState.usesPickingColorCache = !0, n < t) {
      t > wS && Jr.warn("Layer has too many data objects. Picking might not be able to distinguish all objects.")(), nl = yp.allocate(nl, t, {
        size: 4,
        copy: !0,
        maxCount: Math.max(t, wS)
      });
      const i = Math.floor(nl.length / 4), s = [0, 0, 0];
      for (let o = n; o < i; o++)
        this.encodePickingColor(o, s), nl[o * 4 + 0] = s[0], nl[o * 4 + 1] = s[1], nl[o * 4 + 2] = s[2], nl[o * 4 + 3] = 0;
    }
    e.value = nl.subarray(0, t * 4);
  }
  /** Apply changed attributes to model */
  _setModelAttributes(e, t, n = !1) {
    if (!Object.keys(t).length)
      return;
    if (n) {
      const l = this.getAttributeManager();
      e.setBufferLayout(l.getBufferLayouts(e)), t = l.getAttributes();
    }
    const i = e.userData?.excludeAttributes || {}, s = {}, o = {};
    for (const l in t) {
      if (i[l])
        continue;
      const u = t[l].getValue();
      for (const m in u) {
        const y = u[m];
        y instanceof vi ? t[l].settings.isIndexed ? e.setIndexBuffer(y) : s[m] = y : y && (o[m] = y);
      }
    }
    e.setAttributes(s), e.setConstantAttributes(o);
  }
  /** (Internal) Sets the picking color at the specified index to null picking color. Used for multi-depth picking.
     This method may be overriden by layer implementations */
  disablePickingIndex(e) {
    const t = this.props.data;
    if (!("attributes" in t)) {
      this._disablePickingIndex(e);
      return;
    }
    const { pickingColors: n, instancePickingColors: i } = this.getAttributeManager().attributes, s = n || i, o = s && t.attributes && t.attributes[s.id];
    if (o && o.value) {
      const l = o.value, u = this.encodePickingColor(e);
      for (let m = 0; m < t.length; m++) {
        const y = s.getVertexOffset(m);
        l[y] === u[0] && l[y + 1] === u[1] && l[y + 2] === u[2] && this._disablePickingIndex(m);
      }
    } else
      this._disablePickingIndex(e);
  }
  // TODO - simplify subclassing interface
  _disablePickingIndex(e) {
    const { pickingColors: t, instancePickingColors: n } = this.getAttributeManager().attributes, i = t || n;
    if (!i)
      return;
    const s = i.getVertexOffset(e), o = i.getVertexOffset(e + 1);
    i.buffer.write(new Uint8Array(o - s), s);
  }
  /** (Internal) Re-enable all picking indices after multi-depth picking */
  restorePickingColors() {
    const { pickingColors: e, instancePickingColors: t } = this.getAttributeManager().attributes, n = e || t;
    n && // @ts-ignore (TS2531) this method is only called internally with internalState defined
    (this.internalState.usesPickingColorCache && n.value.buffer !== nl.buffer && (n.value = nl.subarray(0, n.value.length)), n.updateSubBuffer({ startOffset: 0 }));
  }
  /* eslint-disable max-statements */
  /* (Internal) Called by layer manager when a new layer is found */
  _initialize() {
    to(!this.internalState), to(Number.isFinite(this.props.coordinateSystem)), go(LZ, this);
    const e = this._getAttributeManager();
    e && e.addInstanced({
      instancePickingColors: {
        type: "uint8",
        size: 4,
        noAlloc: !0,
        // Updaters are always called with `this` pointing to the layer
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculateInstancePickingColors
      }
    }), this.internalState = new OZ({
      attributeManager: e,
      layer: this
    }), this._clearChangeFlags(), this.state = {}, Object.defineProperty(this.state, "attributeManager", {
      get: () => (Jr.deprecated("layer.state.attributeManager", "layer.getAttributeManager()")(), e)
    }), this.internalState.uniformTransitions = new iZ(this.context.timeline), this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this), this.internalState.setAsyncProps(this.props), this.initializeState(this.context);
    for (const t of this.props.extensions)
      t.initializeState.call(this, this.context, t);
    this.setChangeFlags({
      dataChanged: "init",
      propsChanged: "init",
      viewportChanged: !0,
      extensionsChanged: !0
    }), this._update();
  }
  /** (Internal) Called by layer manager to transfer state from an old layer */
  _transferState(e) {
    go(NZ, this, this === e);
    const { state: t, internalState: n } = e;
    this !== e && (this.internalState = n, this.state = t, this.internalState.setAsyncProps(this.props), this._diffProps(this.props, this.internalState.getOldProps()));
  }
  /** (Internal) Called by layer manager when a new layer is added or an existing layer is matched with a new instance */
  _update() {
    const e = this.needsUpdate();
    if (go(kZ, this, e), !e)
      return;
    const t = this.props, n = this.context, i = this.internalState, s = n.viewport, o = this._updateUniformTransition();
    i.propsInTransition = o, n.viewport = i.viewport || s, this.props = o;
    try {
      const l = this._getUpdateParams(), u = this.getModels();
      if (n.device)
        this.updateState(l);
      else
        try {
          this.updateState(l);
        } catch {
        }
      for (const y of this.props.extensions)
        y.updateState.call(this, l, y);
      this.setNeedsRedraw(), this._updateAttributes();
      const m = this.getModels()[0] !== u[0];
      this._postUpdate(l, m);
    } finally {
      n.viewport = s, this.props = t, this._clearChangeFlags(), i.needsUpdate = !1, i.resetOldProps();
    }
  }
  /* eslint-enable max-statements */
  /** (Internal) Called by manager when layer is about to be disposed
      Note: not guaranteed to be called on application shutdown */
  _finalize() {
    go(FZ, this), this.finalizeState(this.context);
    for (const e of this.props.extensions)
      e.finalizeState.call(this, this.context, e);
  }
  // Calculates uniforms
  _drawLayer({ renderPass: e, shaderModuleProps: t = null, uniforms: n = {}, parameters: i = {} }) {
    this._updateAttributeTransition();
    const s = this.props, o = this.context;
    this.props = this.internalState.propsInTransition || s;
    try {
      t && this.setShaderModuleProps(t);
      const { getPolygonOffset: l } = this.props, u = l && l(n) || [0, 0];
      o.device instanceof Xb && o.device.setParametersWebGL({ polygonOffset: u });
      for (const m of this.getModels())
        m.device.type === "webgpu" ? m.setParameters({ ...m.parameters, ...i }) : m.setParameters(i);
      if (o.device instanceof Xb)
        o.device.withParametersWebGL(i, () => {
          const m = { renderPass: e, shaderModuleProps: t, uniforms: n, parameters: i, context: o };
          for (const y of this.props.extensions)
            y.draw.call(this, m, y);
          this.draw(m);
        });
      else {
        const m = { renderPass: e, shaderModuleProps: t, uniforms: n, parameters: i, context: o };
        for (const y of this.props.extensions)
          y.draw.call(this, m, y);
        this.draw(m);
      }
    } finally {
      this.props = s;
    }
  }
  // Helper methods
  /** Returns the current change flags */
  getChangeFlags() {
    return this.internalState?.changeFlags;
  }
  /* eslint-disable complexity */
  /** Dirty some change flags, will be handled by updateLayer */
  setChangeFlags(e) {
    if (!this.internalState)
      return;
    const { changeFlags: t } = this.internalState;
    for (const i in e)
      if (e[i]) {
        let s = !1;
        switch (i) {
          case "dataChanged":
            const o = e[i], l = t[i];
            o && Array.isArray(l) && (t.dataChanged = Array.isArray(o) ? l.concat(o) : o, s = !0);
          default:
            t[i] || (t[i] = e[i], s = !0);
        }
        s && go(DZ, this, i, e);
      }
    const n = !!(t.dataChanged || t.updateTriggersChanged || t.propsChanged || t.extensionsChanged);
    t.propsOrDataChanged = n, t.somethingChanged = n || t.viewportChanged || t.stateChanged;
  }
  /* eslint-enable complexity */
  /** Clear all changeFlags, typically after an update */
  _clearChangeFlags() {
    this.internalState.changeFlags = {
      dataChanged: !1,
      propsChanged: !1,
      updateTriggersChanged: !1,
      viewportChanged: !1,
      stateChanged: !1,
      extensionsChanged: !1,
      propsOrDataChanged: !1,
      somethingChanged: !1
    };
  }
  /** Compares the layers props with old props from a matched older layer
      and extracts change flags that describe what has change so that state
      can be update correctly with minimal effort */
  _diffProps(e, t) {
    const n = oZ(e, t);
    if (n.updateTriggersChanged)
      for (const i in n.updateTriggersChanged)
        n.updateTriggersChanged[i] && this.invalidateAttribute(i);
    if (n.transitionsChanged)
      for (const i in n.transitionsChanged)
        this.internalState.uniformTransitions.add(i, t[i], e[i], e.transitions?.[i]);
    return this.setChangeFlags(n);
  }
  /** (Internal) called by layer manager to perform extra props validation (in development only) */
  validateProps() {
    sZ(this.props);
  }
  /** (Internal) Called by deck picker when the hovered object changes to update the auto highlight */
  updateAutoHighlight(e) {
    this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex) && this._updateAutoHighlight(e);
  }
  // May be overriden by subclasses
  // TODO - simplify subclassing interface
  /** Update picking module parameters to highlight the hovered object */
  _updateAutoHighlight(e) {
    const t = {
      // @ts-ignore
      highlightedObjectColor: e.picked ? e.color : null
    }, { highlightColor: n } = this.props;
    e.picked && typeof n == "function" && (t.highlightColor = n(e)), this.setShaderModuleProps({ picking: t }), this.setNeedsRedraw();
  }
  /** Create new attribute manager */
  _getAttributeManager() {
    const e = this.context;
    return new j_(e.device, {
      id: this.props.id,
      stats: e.stats,
      timeline: e.timeline
    });
  }
  // Private methods
  /** Called after updateState to perform common tasks */
  // eslint-disable-next-line complexity
  _postUpdate(e, t) {
    const { props: n, oldProps: i } = e, s = this.state.model;
    s?.isInstanced && s.setInstanceCount(this.getNumInstances());
    const { autoHighlight: o, highlightedObjectIndex: l, highlightColor: u } = n;
    if (t || i.autoHighlight !== o || i.highlightedObjectIndex !== l || i.highlightColor !== u) {
      const m = {};
      Array.isArray(u) && (m.highlightColor = u), (t || i.autoHighlight !== o || l !== i.highlightedObjectIndex) && (m.highlightedObjectColor = Number.isFinite(l) && l >= 0 ? this.encodePickingColor(l) : null), this.setShaderModuleProps({ picking: m });
    }
  }
  _getUpdateParams() {
    return {
      props: this.props,
      // @ts-ignore TS2531 this method can only be called internally with internalState assigned
      oldProps: this.internalState.getOldProps(),
      context: this.context,
      // @ts-ignore TS2531 this method can only be called internally with internalState assigned
      changeFlags: this.internalState.changeFlags
    };
  }
  /** Checks state of attributes and model */
  _getNeedsRedraw(e) {
    if (!this.internalState)
      return !1;
    let t = !1;
    t = t || this.internalState.needsRedraw && this.id;
    const n = this.getAttributeManager(), i = n ? n.getNeedsRedraw(e) : !1;
    if (t = t || i, t)
      for (const s of this.props.extensions)
        s.onNeedsRedraw.call(this, s);
    return this.internalState.needsRedraw = this.internalState.needsRedraw && !e.clearRedrawFlags, t;
  }
  /** Callback when asyn prop is loaded */
  _onAsyncPropUpdated() {
    this._diffProps(this.props, this.internalState.getOldProps()), this.setNeedsUpdate();
  }
}
Is.defaultProps = VZ;
Is.layerName = "Layer";
const jZ = "compositeLayer.renderLayers";
class Ps extends Is {
  /** `true` if this layer renders other layers */
  get isComposite() {
    return !0;
  }
  /** `true` if the layer renders to screen */
  get isDrawable() {
    return !1;
  }
  /** Returns true if all async resources are loaded */
  get isLoaded() {
    return super.isLoaded && this.getSubLayers().every((e) => e.isLoaded);
  }
  /** Return last rendered sub layers */
  getSubLayers() {
    return this.internalState && this.internalState.subLayers || [];
  }
  // initializeState is usually not needed for composite layers
  // Provide empty definition to disable check for missing definition
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  initializeState(e) {
  }
  /** Updates selected state members and marks the composite layer to need rerender */
  setState(e) {
    super.setState(e), this.setNeedsUpdate();
  }
  /** called to augment the info object that is bubbled up from a sublayer
      override Layer.getPickingInfo() because decoding / setting uniform do
      not apply to a composite layer. */
  getPickingInfo({ info: e }) {
    const { object: t } = e;
    return t && t.__source && t.__source.parent && t.__source.parent.id === this.id && (e.object = t.__source.object, e.index = t.__source.index), e;
  }
  /**
   * Filters sub layers at draw time. Return true if the sub layer should be drawn.
   */
  filterSubLayer(e) {
    return !0;
  }
  /** Returns true if sub layer needs to be rendered */
  shouldRenderSubLayer(e, t) {
    return t && t.length;
  }
  /** Returns sub layer class for a specific sublayer */
  getSubLayerClass(e, t) {
    const { _subLayerProps: n } = this.props;
    return n && n[e] && n[e].type || t;
  }
  /** When casting user data into another format to pass to sublayers,
      add reference to the original object and object index */
  getSubLayerRow(e, t, n) {
    return e.__source = {
      parent: this,
      object: t,
      index: n
    }, e;
  }
  /** Some composite layers cast user data into another format before passing to sublayers
    We need to unwrap them before calling the accessor so that they see the original data
    objects */
  getSubLayerAccessor(e) {
    if (typeof e == "function") {
      const t = {
        index: -1,
        // @ts-ignore accessing resolved data
        data: this.props.data,
        target: []
      };
      return (n, i) => n && n.__source ? (t.index = n.__source.index, e(n.__source.object, t)) : e(n, i);
    }
    return e;
  }
  /** Returns sub layer props for a specific sublayer */
  // eslint-disable-next-line complexity
  getSubLayerProps(e = {}) {
    const { opacity: t, pickable: n, visible: i, parameters: s, getPolygonOffset: o, highlightedObjectIndex: l, autoHighlight: u, highlightColor: m, coordinateSystem: y, coordinateOrigin: E, wrapLongitude: P, positionFormat: L, modelMatrix: U, extensions: V, fetch: q, operation: j, _subLayerProps: K } = this.props, Y = {
      id: "",
      updateTriggers: {},
      opacity: t,
      pickable: n,
      visible: i,
      parameters: s,
      getPolygonOffset: o,
      highlightedObjectIndex: l,
      autoHighlight: u,
      highlightColor: m,
      coordinateSystem: y,
      coordinateOrigin: E,
      wrapLongitude: P,
      positionFormat: L,
      modelMatrix: U,
      extensions: V,
      fetch: q,
      operation: j
    }, de = K && e.id && K[e.id], ne = de && de.updateTriggers, ae = e.id || "sublayer";
    if (de) {
      const De = this.props[qu], Ge = e.type ? e.type._propTypes : {};
      for (const fe in de) {
        const ve = Ge[fe] || De[fe];
        ve && ve.type === "accessor" && (de[fe] = this.getSubLayerAccessor(de[fe]));
      }
    }
    Object.assign(
      Y,
      e,
      // experimental feature that allows users to override sublayer props via parent layer prop
      de
    ), Y.id = `${this.props.id}-${ae}`, Y.updateTriggers = {
      all: this.props.updateTriggers?.all,
      ...e.updateTriggers,
      ...ne
    };
    for (const De of V) {
      const Ge = De.getSubLayerProps.call(this, De);
      Ge && Object.assign(Y, Ge, {
        updateTriggers: Object.assign(Y.updateTriggers, Ge.updateTriggers)
      });
    }
    return Y;
  }
  /** Update sub layers to highlight the hovered object */
  _updateAutoHighlight(e) {
    for (const t of this.getSubLayers())
      t.updateAutoHighlight(e);
  }
  /** Override base Layer method */
  _getAttributeManager() {
    return null;
  }
  /** (Internal) Called after an update to rerender sub layers */
  _postUpdate(e, t) {
    let n = this.internalState.subLayers;
    const i = !n || this.needsUpdate();
    if (i) {
      const s = this.renderLayers();
      n = z_(s, Boolean), this.internalState.subLayers = n;
    }
    go(jZ, this, i, n);
    for (const s of n)
      s.parent = this;
  }
}
Ps.layerName = "CompositeLayer";
const Ig = Math.PI / 180, TS = 180 / Math.PI, Tm = 6370972, Kd = 256;
function HZ() {
  const r = Kd / Tm, e = Math.PI / 180 * Kd;
  return {
    unitsPerMeter: [r, r, r],
    unitsPerMeter2: [0, 0, 0],
    metersPerUnit: [1 / r, 1 / r, 1 / r],
    unitsPerDegree: [e, e, r],
    unitsPerDegree2: [0, 0, 0],
    degreesPerUnit: [1 / e, 1 / e, 1 / r]
  };
}
class GZ extends tu {
  constructor(e = {}) {
    const {
      longitude: t = 0,
      zoom: n = 0,
      // Matches Maplibre defaults
      // https://github.com/maplibre/maplibre-gl-js/blob/f8ab4b48d59ab8fe7b068b102538793bbdd4c848/src/geo/projection/globe_transform.ts#L632-L633
      nearZMultiplier: i = 0.5,
      farZMultiplier: s = 1,
      resolution: o = 10
    } = e;
    let { latitude: l = 0, height: u, altitude: m = 1.5, fovy: y } = e;
    l = Math.max(Math.min(l, $d), -$d), u = u || 1, y ? m = zx(y) : y = i0(m);
    const E = 1 / Math.PI / Math.cos(l * Math.PI / 180), P = Math.pow(2, n) * E, L = e.nearZ ?? i, U = e.farZ ?? (m + Kd * 2 * P / u) * s, V = new xn().lookAt({ eye: [0, -m, 0], up: [0, 0, 1] });
    V.rotateX(l * Ig), V.rotateZ(-t * Ig), V.scale(P / u), super({
      ...e,
      // x, y, width,
      height: u,
      // view matrix
      viewMatrix: V,
      longitude: t,
      latitude: l,
      zoom: n,
      // projection matrix parameters
      distanceScales: HZ(),
      fovy: y,
      focalDistance: m,
      near: L,
      far: U
    }), this.scale = P, this.latitude = l, this.longitude = t, this.resolution = o;
  }
  get projectionMode() {
    return ha.GLOBE;
  }
  getDistanceScales() {
    return this.distanceScales;
  }
  getBounds(e = {}) {
    const t = { targetZ: e.z || 0 }, n = this.unproject([0, this.height / 2], t), i = this.unproject([this.width / 2, 0], t), s = this.unproject([this.width, this.height / 2], t), o = this.unproject([this.width / 2, this.height], t);
    return s[0] < this.longitude && (s[0] += 360), n[0] > this.longitude && (n[0] -= 360), [
      Math.min(n[0], s[0], i[0], o[0]),
      Math.min(n[1], s[1], i[1], o[1]),
      Math.max(n[0], s[0], i[0], o[0]),
      Math.max(n[1], s[1], i[1], o[1])
    ];
  }
  unproject(e, { topLeft: t = !0, targetZ: n } = {}) {
    const [i, s, o] = e, l = t ? s : this.height - s, { pixelUnprojectionMatrix: u } = this;
    let m;
    if (Number.isFinite(o))
      m = qv(u, [i, l, o, 1]);
    else {
      const L = qv(u, [i, l, -1, 1]), U = qv(u, [i, l, 1, 1]), V = ((n || 0) / Tm + 1) * Kd, q = Sv(wO([], L, U)), j = Sv(L), K = Sv(U), de = 4 * ((4 * j * K - (q - j - K) ** 2) / 16) / q, ne = Math.sqrt(j - de), ae = Math.sqrt(Math.max(0, V * V - de)), De = (ne - ae) / Math.sqrt(q);
      m = dV([], L, U, De);
    }
    const [y, E, P] = this.unprojectPosition(m);
    return Number.isFinite(o) ? [y, E, P] : Number.isFinite(n) ? [y, E, n] : [y, E];
  }
  projectPosition(e) {
    const [t, n, i = 0] = e, s = t * Ig, o = n * Ig, l = Math.cos(o), u = (i / Tm + 1) * Kd;
    return [Math.sin(s) * l * u, -Math.cos(s) * l * u, Math.sin(o) * u];
  }
  unprojectPosition(e) {
    const [t, n, i] = e, s = TO(e), o = Math.asin(i / s), u = Math.atan2(t, -n) * TS, m = o * TS, y = (s / Kd - 1) * Tm;
    return [u, m, y];
  }
  projectFlat(e) {
    return e;
  }
  unprojectFlat(e) {
    return e;
  }
  panByPosition(e, t) {
    const n = this.unproject(t);
    return {
      longitude: e[0] - n[0] + this.longitude,
      latitude: e[1] - n[1] + this.latitude
    };
  }
}
function qv(r, e) {
  const t = Dp([], e, r);
  return Lx(t, t, 1 / t[3]), t;
}
class G_ {
  static get componentName() {
    return Object.prototype.hasOwnProperty.call(this, "extensionName") ? this.extensionName : "";
  }
  constructor(e) {
    e && (this.opts = e);
  }
  /** Returns true if two extensions are equivalent */
  equals(e) {
    return this === e ? !0 : this.constructor === e.constructor && Fi(this.opts, e.opts, 1);
  }
  /** Only called if attached to a primitive layer */
  getShaders(e) {
    return null;
  }
  /** Only called if attached to a CompositeLayer */
  getSubLayerProps(e) {
    const { defaultProps: t } = e.constructor, n = {
      updateTriggers: {}
    };
    for (const i in t)
      if (i in this.props) {
        const s = t[i], o = this.props[i];
        n[i] = o, s && s.type === "accessor" && (n.updateTriggers[i] = this.props.updateTriggers[i], typeof o == "function" && (n[i] = this.getSubLayerAccessor(o)));
      }
    return n;
  }
  /* eslint-disable @typescript-eslint/no-empty-function */
  initializeState(e, t) {
  }
  updateState(e, t) {
  }
  onNeedsRedraw(e) {
  }
  getNeedsPickingBuffer(e) {
    return !1;
  }
  draw(e, t) {
  }
  finalizeState(e, t) {
  }
}
G_.defaultProps = {};
G_.extensionName = "LayerExtension";
class D6 {
  constructor(e) {
    this.indexStarts = [0], this.vertexStarts = [0], this.vertexCount = 0, this.instanceCount = 0;
    const { attributes: t = {} } = e;
    this.typedArrayManager = yp, this.attributes = {}, this._attributeDefs = t, this.opts = e, this.updateGeometry(e);
  }
  /* Public methods */
  updateGeometry(e) {
    Object.assign(this.opts, e);
    const { data: t, buffers: n = {}, getGeometry: i, geometryBuffer: s, positionFormat: o, dataChanged: l, normalize: u = !0 } = this.opts;
    if (this.data = t, this.getGeometry = i, this.positionSize = // @ts-ignore (2339) when geometryBuffer is a luma Buffer, size falls back to positionFormat
    s && s.size || (o === "XY" ? 2 : 3), this.buffers = n, this.normalize = u, s && (to(t.startIndices), this.getGeometry = this.getGeometryFromBuffer(s), u || (n.vertexPositions = s)), this.geometryBuffer = n.vertexPositions, Array.isArray(l))
      for (const m of l)
        this._rebuildGeometry(m);
    else
      this._rebuildGeometry();
  }
  updatePartialGeometry({ startRow: e, endRow: t }) {
    this._rebuildGeometry({ startRow: e, endRow: t });
  }
  getGeometryFromBuffer(e) {
    const t = e.value || e;
    return ArrayBuffer.isView(t) ? w6(t, {
      size: this.positionSize,
      offset: e.offset,
      stride: e.stride,
      startIndices: this.data.startIndices
    }) : null;
  }
  /* Private utility methods */
  _allocate(e, t) {
    const { attributes: n, buffers: i, _attributeDefs: s, typedArrayManager: o } = this;
    for (const l in s)
      if (l in i)
        o.release(n[l]), n[l] = null;
      else {
        const u = s[l];
        u.copy = t, n[l] = o.allocate(n[l], e, u);
      }
  }
  /**
   * Visit all objects
   * `data` is expected to be an iterable consistent with the base Layer expectation
   */
  _forEachGeometry(e, t, n) {
    const { data: i, getGeometry: s } = this, { iterable: o, objectInfo: l } = hc(i, t, n);
    for (const u of o) {
      l.index++;
      const m = s ? s(u, l) : null;
      e(m, l.index);
    }
  }
  /* eslint-disable complexity,max-statements */
  _rebuildGeometry(e) {
    if (!this.data)
      return;
    let { indexStarts: t, vertexStarts: n, instanceCount: i } = this;
    const { data: s, geometryBuffer: o } = this, { startRow: l = 0, endRow: u = 1 / 0 } = e || {}, m = {};
    if (e || (t = [0], n = [0]), this.normalize || !o)
      this._forEachGeometry((E, P) => {
        const L = E && this.normalizeGeometry(E);
        m[P] = L, n[P + 1] = n[P] + (L ? this.getGeometrySize(L) : 0);
      }, l, u), i = n[n.length - 1];
    else if (n = s.startIndices, i = n[s.length] || 0, ArrayBuffer.isView(o))
      i = i || o.length / this.positionSize;
    else if (o instanceof vi) {
      const E = this.positionSize * 4;
      i = i || o.byteLength / E;
    } else if (o.buffer) {
      const E = o.stride || this.positionSize * 4;
      i = i || o.buffer.byteLength / E;
    } else if (o.value) {
      const E = o.value, P = (
        // @ts-ignore (2339) if stride is not specified, will fall through to positionSize
        o.stride / E.BYTES_PER_ELEMENT || this.positionSize
      );
      i = i || E.length / P;
    }
    this._allocate(i, !!e), this.indexStarts = t, this.vertexStarts = n, this.instanceCount = i;
    const y = {};
    this._forEachGeometry((E, P) => {
      const L = m[P] || E;
      y.vertexStart = n[P], y.indexStart = t[P];
      const U = P < n.length - 1 ? n[P + 1] : i;
      y.geometrySize = U - n[P], y.geometryIndex = P, this.updateGeometryAttributes(L, y);
    }, l, u), this.vertexCount = t[t.length - 1];
  }
}
const WZ = typeof window < "u" ? Dt.useLayoutEffect : Dt.useEffect;
function a_(r, e) {
  for (; r; ) {
    if (r === e)
      return !0;
    r = Object.getPrototypeOf(r);
  }
  return !1;
}
const $Z = { position: "absolute", zIndex: -1 };
function L6(r, e) {
  if (typeof r == "function")
    return r(e);
  if (Array.isArray(r))
    return r.map((t) => L6(t, e));
  if (W_(r)) {
    if (qZ(r))
      return e.style = $Z, Dt.cloneElement(r, e);
    if (XZ(r))
      return Dt.cloneElement(r, e);
  }
  return r;
}
function W_(r) {
  return r && typeof r == "object" && "type" in r || !1;
}
function qZ(r) {
  return r.props?.mapStyle;
}
function XZ(r) {
  const e = r.type;
  return e && e.deckGLViewProps;
}
function e2(r) {
  if (typeof r == "function")
    return Dt.createElement(vp, {}, r);
  if (Array.isArray(r))
    return r.map(e2);
  if (W_(r)) {
    if (r.type === Dt.Fragment)
      return e2(r.props.children);
    if (a_(r.type, vp))
      return r;
  }
  return r;
}
function ZZ({ children: r, layers: e = [], views: t = null }) {
  const n = [], i = [], s = {};
  return Dt.Children.forEach(e2(r), (o) => {
    if (W_(o)) {
      const l = o.type;
      if (a_(l, Is)) {
        const u = YZ(l, o.props);
        i.push(u);
      } else
        n.push(o);
      if (a_(l, vp) && l !== vp && o.props.id) {
        const u = new l(o.props);
        s[u.id] = u;
      }
    } else o && n.push(o);
  }), Object.keys(s).length > 0 && (Array.isArray(t) ? t.forEach((o) => {
    s[o.id] = o;
  }) : t && (s[t.id] = t), t = Object.values(s)), e = i.length > 0 ? [...i, ...e] : e, { layers: e, children: n, views: t };
}
function YZ(r, e) {
  const t = {}, n = r.defaultProps || {};
  for (const i in e)
    n[i] !== e[i] && (t[i] = e[i]);
  return new r(t);
}
const KZ = Dt.createContext();
function QZ({ children: r, deck: e, ContextProvider: t = KZ.Provider }) {
  const { viewManager: n } = e || {};
  if (!n || !n.views.length)
    return [];
  const i = {}, s = n.views[0].id;
  for (const o of r) {
    let l = s, u = o;
    W_(o) && a_(o.type, vp) && (l = o.props.id || s, u = o.props.children);
    const m = n.getViewport(l), y = n.getViewState(l);
    if (m) {
      y.padding = m.padding;
      const { x: E, y: P, width: L, height: U } = m;
      u = L6(u, {
        x: E,
        y: P,
        width: L,
        height: U,
        viewport: m,
        viewState: y
      }), i[l] || (i[l] = {
        viewport: m,
        children: []
      }), i[l].children.push(u);
    }
  }
  return Object.keys(i).map((o) => {
    const { viewport: l, children: u } = i[o], { x: m, y, width: E, height: P } = l, L = {
      position: "absolute",
      left: m,
      top: y,
      width: E,
      height: P
    }, U = `view-${o}`, V = Dt.createElement("div", { key: U, id: U, style: L }, ...u), q = {
      deck: e,
      viewport: l,
      // @ts-expect-error accessing protected property
      container: e.canvas.offsetParent,
      // @ts-expect-error accessing protected property
      eventManager: e.eventManager,
      onViewStateChange: (K) => {
        K.viewId = o, e._onViewStateChange(K);
      },
      widgets: []
    }, j = `view-${o}-context`;
    return Dt.createElement(t, { key: j, value: q }, V);
  });
}
const JZ = {
  mixBlendMode: null
};
function eY({ width: r, height: e, style: t }) {
  const n = {
    position: "absolute",
    zIndex: 0,
    left: 0,
    top: 0,
    width: r,
    height: e
  }, i = {
    left: 0,
    top: 0
  };
  if (t)
    for (const s in t)
      s in JZ ? i[s] = t[s] : n[s] = t[s];
  return { containerStyle: n, canvasStyle: i };
}
function tY(r) {
  return {
    get deck() {
      return r.deck;
    },
    // The following method can only be called after ref is available, by which point deck is defined in useEffect
    pickObject: (e) => r.deck.pickObject(e),
    pickMultipleObjects: (e) => r.deck.pickMultipleObjects(e),
    pickObjects: (e) => r.deck.pickObjects(e)
  };
}
function k6(r) {
  r.redrawReason && (r.deck._drawLayers(r.redrawReason), r.redrawReason = null);
}
function rY(r, e, t) {
  const n = new e({
    ...t,
    // The Deck's animation loop is independent from React's render cycle, causing potential
    // synchronization issues. We provide this custom render function to make sure that React
    // and Deck update on the same schedule.
    // TODO(ibgreen) - Hack to enable WebGPU as it needs to render quickly to avoid CanvasContext texture from going stale
    _customRender: t.deviceProps?.adapters?.[0]?.type === "webgpu" ? void 0 : (i) => {
      r.redrawReason = i;
      const s = n.getViewports();
      r.lastRenderedViewports !== s ? r.forceUpdate() : k6(r);
    }
  });
  return n;
}
function nY(r, e) {
  const [t, n] = Dt.useState(0), s = Dt.useRef({
    control: null,
    version: t,
    forceUpdate: () => n((ne) => ne + 1)
  }).current, o = Dt.useRef(null), l = Dt.useRef(null), u = Dt.useMemo(() => ZZ(r), [r.layers, r.views, r.children]);
  let m = !0;
  const y = (ne) => m && r.viewState ? (s.viewStateUpdateRequested = ne, null) : (s.viewStateUpdateRequested = null, r.onViewStateChange?.(ne)), E = (ne) => {
    m ? s.interactionStateUpdateRequested = ne : (s.interactionStateUpdateRequested = null, r.onInteractionStateChange?.(ne));
  }, P = Dt.useMemo(() => {
    const ne = {
      widgets: [],
      ...r,
      // Override user styling props. We will set the canvas style in render()
      style: null,
      width: "100%",
      height: "100%",
      parent: o.current,
      canvas: l.current,
      layers: u.layers,
      views: u.views,
      onViewStateChange: y,
      onInteractionStateChange: E
    };
    return delete ne._customRender, s.deck && s.deck.setProps(ne), ne;
  }, [r]);
  Dt.useEffect(() => {
    const ne = r.Deck || Qx;
    return s.deck = rY(s, ne, {
      ...P,
      parent: o.current,
      canvas: l.current
    }), () => s.deck?.finalize();
  }, []), WZ(() => {
    k6(s);
    const { viewStateUpdateRequested: ne, interactionStateUpdateRequested: ae } = s;
    ne && y(ne), ae && E(ae), s.deck?.isInitialized && s.deck.redraw("Initial render");
  }), Dt.useImperativeHandle(e, () => tY(s), []);
  const L = s.deck && s.deck.isInitialized ? s.deck.getViewports() : void 0, { ContextProvider: U, width: V = "100%", height: q = "100%", id: j, style: K } = r, { containerStyle: Y, canvasStyle: de } = Dt.useMemo(() => eY({ width: V, height: q, style: K }), [V, q, K]);
  if (!s.viewStateUpdateRequested && s.lastRenderedViewports === L || // case 2
  s.version !== t) {
    s.lastRenderedViewports = L, s.version = t;
    const ne = QZ({
      children: u.children,
      deck: s.deck,
      ContextProvider: U
    }), ae = Dt.createElement("canvas", {
      key: "canvas",
      id: j || "deckgl-overlay",
      ref: l,
      style: de
    });
    s.control = Dt.createElement("div", { id: `${j || "deckgl"}-wrapper`, ref: o, style: Y }, [ae, ne]);
  }
  return m = !1, s.control;
}
const iY = Dt.forwardRef(nY);
const ES = "\uFEFF";
function sY(r, e = {}, t = aY) {
  e = e || {};
  var n = e.dynamicTyping || !1;
  dl(n) && (e.dynamicTypingFunction = n, n = {}), e.dynamicTyping = n, e.transform = dl(e.transform) ? e.transform : !1;
  var i = new t(e);
  return i.stream(r);
}
function oY(r, e) {
  var t = !1, n = !0, i = ",", s = `\r
`, o = '"', l = o + o, u = !1, m = null;
  E();
  var y = new RegExp(a0(o), "g");
  if (typeof r == "string" && (r = JSON.parse(r)), Array.isArray(r)) {
    if (!r.length || Array.isArray(r[0]))
      return P(null, r, u);
    if (typeof r[0] == "object")
      return P(m || Object.keys(r[0]), r, u);
  } else if (typeof r == "object")
    return typeof r.data == "string" && (r.data = JSON.parse(r.data)), Array.isArray(r.data) && (r.fields || (r.fields = r.meta && r.meta.fields), r.fields || (r.fields = Array.isArray(r.data[0]) ? r.fields : Object.keys(r.data[0])), !Array.isArray(r.data[0]) && typeof r.data[0] != "object" && (r.data = [r.data])), P(r.fields || [], r.data || [], u);
  throw new Error("Unable to serialize unrecognized input");
  function E() {
    if (typeof e == "object") {
      if (typeof e.delimiter == "string" && !Ba.BAD_DELIMITERS.filter(function(V) {
        return e.delimiter.indexOf(V) !== -1;
      }).length && (i = e.delimiter), (typeof e.quotes == "boolean" || Array.isArray(e.quotes)) && (t = e.quotes), (typeof e.skipEmptyLines == "boolean" || typeof e.skipEmptyLines == "string") && (u = e.skipEmptyLines), typeof e.newline == "string" && (s = e.newline), typeof e.quoteChar == "string" && (o = e.quoteChar), typeof e.header == "boolean" && (n = e.header), Array.isArray(e.columns)) {
        if (e.columns.length === 0)
          throw new Error("Option columns is empty");
        m = e.columns;
      }
      e.escapeChar !== void 0 && (l = e.escapeChar + o);
    }
  }
  function P(V, q, j) {
    var K = "";
    typeof V == "string" && (V = JSON.parse(V)), typeof q == "string" && (q = JSON.parse(q));
    var Y = Array.isArray(V) && V.length > 0, de = !Array.isArray(q[0]);
    if (Y && n) {
      for (var ne = 0; ne < V.length; ne++)
        ne > 0 && (K += i), K += L(V[ne], ne);
      q.length > 0 && (K += s);
    }
    for (var ae = 0; ae < q.length; ae++) {
      var De = Y ? V.length : q[ae].length, Ge = !1, fe = Y ? Object.keys(q[ae]).length === 0 : q[ae].length === 0;
      if (j && !Y && (Ge = j === "greedy" ? q[ae].join("").trim() === "" : q[ae].length === 1 && q[ae][0].length === 0), j === "greedy" && Y) {
        for (var ve = [], me = 0; me < De; me++) {
          var X = de ? V[me] : me;
          ve.push(q[ae][X]);
        }
        Ge = ve.join("").trim() === "";
      }
      if (!Ge) {
        for (var re = 0; re < De; re++) {
          re > 0 && !fe && (K += i);
          var Me = Y && de ? V[re] : re;
          K += L(q[ae][Me], re);
        }
        ae < q.length - 1 && (!j || De > 0 && !fe) && (K += s);
      }
    }
    return K;
  }
  function L(V, q) {
    if (typeof V > "u" || V === null)
      return "";
    if (V.constructor === Date)
      return JSON.stringify(V).slice(1, 25);
    V = V.toString().replace(y, l);
    var j = typeof t == "boolean" && t || Array.isArray(t) && t[q] || U(V, Ba.BAD_DELIMITERS) || V.indexOf(i) > -1 || V.charAt(0) === " " || V.charAt(V.length - 1) === " ";
    return j ? o + V + o : V;
  }
  function U(V, q) {
    for (var j = 0; j < q.length; j++)
      if (V.indexOf(q[j]) > -1)
        return !0;
    return !1;
  }
}
let F6 = class {
  _handle;
  _config;
  _finished = !1;
  _completed = !1;
  _input = null;
  _baseIndex = 0;
  _partialLine = "";
  _rowCount = 0;
  _start = 0;
  isFirstChunk = !0;
  _completeResults = {
    data: [],
    errors: [],
    meta: {}
  };
  constructor(e) {
    var t = { ...e };
    t.chunkSize = parseInt(t.chunkSize), !e.step && !e.chunk && (t.chunkSize = null), this._handle = new N6(t), this._handle.streamer = this, this._config = t;
  }
  parseChunk(e, t) {
    if (this.isFirstChunk && dl(this._config.beforeFirstChunk)) {
      var n = this._config.beforeFirstChunk(e);
      n !== void 0 && (e = n);
    }
    this.isFirstChunk = !1;
    var i = this._partialLine + e;
    this._partialLine = "";
    var s = this._handle.parse(i, this._baseIndex, !this._finished);
    if (!(this._handle.paused() || this._handle.aborted())) {
      var o = s.meta.cursor;
      this._finished || (this._partialLine = i.substring(o - this._baseIndex), this._baseIndex = o), s && s.data && (this._rowCount += s.data.length);
      var l = this._finished || this._config.preview && this._rowCount >= this._config.preview;
      if (dl(this._config.chunk) && !t) {
        if (this._config.chunk(s, this._handle), this._handle.paused() || this._handle.aborted())
          return;
        s = void 0, this._completeResults = void 0;
      }
      return !this._config.step && !this._config.chunk && (this._completeResults.data = this._completeResults.data.concat(s.data), this._completeResults.errors = this._completeResults.errors.concat(s.errors), this._completeResults.meta = s.meta), !this._completed && l && dl(this._config.complete) && (!s || !s.meta.aborted) && (this._config.complete(this._completeResults, this._input), this._completed = !0), s;
    }
  }
  _sendError(e) {
    dl(this._config.error) && this._config.error(e);
  }
};
class aY extends F6 {
  remaining;
  constructor(e = {}) {
    super(e);
  }
  stream(e) {
    return this.remaining = e, this._nextChunk();
  }
  _nextChunk() {
    if (!this._finished) {
      var e = this._config.chunkSize, t = e ? this.remaining.substr(0, e) : this.remaining;
      return this.remaining = e ? this.remaining.substr(e) : "", this._finished = !this.remaining, this.parseChunk(t);
    }
  }
}
const lY = /^\s*-?(\d*\.?\d+|\d+\.?\d*)(e[-+]?\d+)?\s*$/i, cY = /(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/;
class N6 {
  _config;
  /** Number of times step was called (number of rows parsed) */
  _stepCounter = 0;
  /** Number of rows that have been parsed so far */
  _rowCounter = 0;
  /** The input being parsed */
  _input;
  /** The core parser being used */
  _parser;
  /** Whether we are paused or not */
  _paused = !1;
  /** Whether the parser has aborted or not */
  _aborted = !1;
  /** Temporary state between delimiter detection and processing results */
  _delimiterError = !1;
  /** Fields are from the header row of the input, if there is one */
  _fields = [];
  /** The last results returned from the parser */
  _results = {
    data: [],
    errors: [],
    meta: {}
  };
  constructor(e) {
    if (dl(e.step)) {
      var t = e.step;
      e.step = (n) => {
        if (this._results = n, this.needsHeaderRow())
          this.processResults();
        else {
          if (this.processResults(), !this._results.data || this._results.data.length === 0)
            return;
          this._stepCounter += n.data.length, e.preview && this._stepCounter > e.preview ? this._parser.abort() : t(this._results, this);
        }
      };
    }
    this._config = e;
  }
  /**
   * Parses input. Most users won't need, and shouldn't mess with, the baseIndex
   * and ignoreLastRow parameters. They are used by streamers (wrapper functions)
   * when an input comes in multiple chunks, like from a file.
   */
  parse(e, t, n) {
    var i = this._config.quoteChar || '"';
    if (this._config.newline || (this._config.newline = uY(e, i)), this._delimiterError = !1, this._config.delimiter)
      dl(this._config.delimiter) && (this._config.delimiter = this._config.delimiter(e), this._results.meta.delimiter = this._config.delimiter);
    else {
      var s = this.guessDelimiter(e, this._config.newline, this._config.skipEmptyLines, this._config.comments, this._config.delimitersToGuess);
      s.successful ? this._config.delimiter = s.bestDelimiter : (this._delimiterError = !0, this._config.delimiter = Ba.DefaultDelimiter), this._results.meta.delimiter = this._config.delimiter;
    }
    var o = U6(this._config);
    return this._config.preview && this._config.header && o.preview++, this._input = e, this._parser = new t2(o), this._results = this._parser.parse(this._input, t, n), this.processResults(), this._paused ? { meta: { paused: !0 } } : this._results || { meta: { paused: !1 } };
  }
  paused() {
    return this._paused;
  }
  pause() {
    this._paused = !0, this._parser.abort(), this._input = this._input.substr(this._parser.getCharIndex());
  }
  resume() {
    this._paused = !1, this.streamer.parseChunk(this._input, !0);
  }
  aborted() {
    return this._aborted;
  }
  abort() {
    this._aborted = !0, this._parser.abort(), this._results.meta.aborted = !0, dl(this._config.complete) && this._config.complete(this._results), this._input = "";
  }
  testEmptyLine(e) {
    return this._config.skipEmptyLines === "greedy" ? e.join("").trim() === "" : e.length === 1 && e[0].length === 0;
  }
  processResults() {
    if (this._results && this._delimiterError && (this.addError("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + Ba.DefaultDelimiter + "'"), this._delimiterError = !1), this._config.skipEmptyLines)
      for (var e = 0; e < this._results.data.length; e++)
        this.testEmptyLine(this._results.data[e]) && this._results.data.splice(e--, 1);
    return this.needsHeaderRow() && this.fillHeaderFields(), this.applyHeaderAndDynamicTypingAndTransformation();
  }
  needsHeaderRow() {
    return this._config.header && this._fields.length === 0;
  }
  fillHeaderFields() {
    if (!this._results)
      return;
    const e = (n) => {
      dl(this._config.transformHeader) && (n = this._config.transformHeader(n)), this._fields.push(n);
    };
    if (Array.isArray(this._results.data[0])) {
      for (var t = 0; this.needsHeaderRow() && t < this._results.data.length; t++)
        this._results.data[t].forEach(e);
      this._results.data.splice(0, 1);
    } else
      this._results.data.forEach(e);
  }
  shouldApplyDynamicTyping(e) {
    return this._config.dynamicTypingFunction && this._config.dynamicTyping[e] === void 0 && (this._config.dynamicTyping[e] = this._config.dynamicTypingFunction(e)), (this._config.dynamicTyping[e] || this._config.dynamicTyping) === !0;
  }
  parseDynamic(e, t) {
    return this.shouldApplyDynamicTyping(e) ? t === "true" || t === "TRUE" ? !0 : t === "false" || t === "FALSE" ? !1 : lY.test(t) ? parseFloat(t) : cY.test(t) ? new Date(t) : t === "" ? null : t : t;
  }
  applyHeaderAndDynamicTypingAndTransformation() {
    if (!this._results || !this._results.data || !this._config.header && !this._config.dynamicTyping && !this._config.transform)
      return this._results;
    var e = 1;
    return !this._results.data[0] || Array.isArray(this._results.data[0]) ? (this._results.data = this._results.data.map(this.processRow.bind(this)), e = this._results.data.length) : this._results.data = this.processRow(this._results.data, 0), this._config.header && this._results.meta && (this._results.meta.fields = this._fields), this._rowCounter += e, this._results;
  }
  processRow(e, t) {
    var n = this._config.header ? {} : [], i;
    for (i = 0; i < e.length; i++) {
      var s = i, o = e[i];
      this._config.header && (s = i >= this._fields.length ? "__parsed_extra" : this._fields[i]), this._config.transform && (o = this._config.transform(o, s)), o = this.parseDynamic(s, o), s === "__parsed_extra" ? (n[s] = n[s] || [], n[s].push(o)) : n[s] = o;
    }
    return this._config.header && (i > this._fields.length ? this.addError("FieldMismatch", "TooManyFields", "Too many fields: expected " + this._fields.length + " fields but parsed " + i, this._rowCounter + t) : i < this._fields.length && this.addError("FieldMismatch", "TooFewFields", "Too few fields: expected " + this._fields.length + " fields but parsed " + i, this._rowCounter + t)), n;
  }
  guessDelimiter(e, t, n, i, s) {
    var o, l, u;
    s = s || [",", "	", "|", ";", Ba.RECORD_SEP, Ba.UNIT_SEP];
    for (var m = 0; m < s.length; m++) {
      var y = s[m], E = 0, P = 0, L = 0;
      u = void 0;
      for (var U = new t2({
        comments: i,
        delimiter: y,
        newline: t,
        preview: 10
      }).parse(e), V = 0; V < U.data.length; V++) {
        if (n && this.testEmptyLine(U.data[V])) {
          L++;
          continue;
        }
        var q = U.data[V].length;
        if (P += q, typeof u > "u") {
          u = 0;
          continue;
        } else q > 1 && (E += Math.abs(q - u), u = q);
      }
      U.data.length > 0 && (P /= U.data.length - L), (typeof l > "u" || E > l) && P > 1.99 && (l = E, o = y);
    }
    return this._config.delimiter = o, {
      successful: !!o,
      bestDelimiter: o
    };
  }
  addError(e, t, n, i) {
    this._results.errors.push({
      type: e,
      code: t,
      message: n,
      row: i
    });
  }
}
function uY(r, e) {
  r = r.substr(0, 1024 * 1024);
  var t = new RegExp(a0(e) + "([^]*?)" + a0(e), "gm");
  r = r.replace(t, "");
  var n = r.split("\r"), i = r.split(`
`), s = i.length > 1 && i[0].length < n[0].length;
  if (n.length === 1 || s)
    return `
`;
  for (var o = 0, l = 0; l < n.length; l++)
    n[l][0] === `
` && o++;
  return o >= n.length / 2 ? `\r
` : "\r";
}
function a0(r) {
  return r.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function t2(r) {
  r = r || {};
  var e = r.delimiter, t = r.newline, n = r.comments, i = r.step, s = r.preview, o = r.fastMode, l;
  r.quoteChar === void 0 ? l = '"' : l = r.quoteChar;
  var u = l;
  if (r.escapeChar !== void 0 && (u = r.escapeChar), (typeof e != "string" || Ba.BAD_DELIMITERS.indexOf(e) > -1) && (e = ","), n === e)
    throw new Error("Comment character same as delimiter");
  n === !0 ? n = "#" : (typeof n != "string" || Ba.BAD_DELIMITERS.indexOf(n) > -1) && (n = !1), t !== `
` && t !== "\r" && t !== `\r
` && (t = `
`);
  var m = 0, y = !1;
  this.parse = function(E, P, L) {
    if (typeof E != "string")
      throw new Error("Input must be a string");
    var U = E.length, V = e.length, q = t.length, j = n.length, K = dl(i);
    m = 0;
    var Y = [], de = [], ne = [], ae = 0;
    if (!E)
      return ct();
    if (o || o !== !1 && E.indexOf(l) === -1) {
      for (var De = E.split(t), Ge = 0; Ge < De.length; Ge++) {
        const St = De[Ge];
        if (m += St.length, Ge !== De.length - 1)
          m += t.length;
        else if (L)
          return ct();
        if (!(n && St.substr(0, j) === n)) {
          if (K) {
            if (Y = [], Ue(St.split(e)), gt(), y)
              return ct();
          } else
            Ue(St.split(e));
          if (s && Ge >= s)
            return Y = Y.slice(0, s), ct(!0);
        }
      }
      return ct();
    }
    for (var fe = E.indexOf(e, m), ve = E.indexOf(t, m), me = new RegExp(a0(u) + a0(l), "g"), X; ; ) {
      if (E[m] === l) {
        for (X = m, m++; ; ) {
          if (X = E.indexOf(l, X + 1), X === -1)
            return L || de.push({
              type: "Quotes",
              code: "MissingQuotes",
              message: "Quoted field unterminated",
              row: Y.length,
              // row has yet to be inserted
              index: m
            }), lt();
          if (X === U - 1) {
            var re = E.substring(m, X).replace(me, l);
            return lt(re);
          }
          if (l === u && E[X + 1] === u) {
            X++;
            continue;
          }
          if (!(l !== u && X !== 0 && E[X - 1] === u)) {
            var Me = ve === -1 ? fe : Math.min(fe, ve), ot = Xe(Me);
            if (E[X + 1 + ot] === e) {
              if (ne.push(E.substring(m, X).replace(me, l)), m = X + 1 + ot + V, fe = E.indexOf(e, m), ve = E.indexOf(t, m), K && (gt(), y))
                return ct();
              if (s && Y.length >= s)
                return ct(!0);
              break;
            }
            var be = Xe(ve);
            if (E.substr(X + 1 + be, q) === t) {
              if (ne.push(E.substring(m, X).replace(me, l)), at(X + 1 + be + q), fe = E.indexOf(e, m), K && (gt(), y))
                return ct();
              if (s && Y.length >= s)
                return ct(!0);
              break;
            }
            de.push({
              type: "Quotes",
              code: "InvalidQuotes",
              message: "Trailing quote on quoted field is malformed",
              row: Y.length,
              // row has yet to be inserted
              index: m
            }), X++;
          }
        }
        if (K && (gt(), y))
          return ct();
        if (s && Y.length >= s)
          return ct(!0);
        continue;
      }
      if (n && ne.length === 0 && E.substr(m, j) === n) {
        if (ve === -1)
          return ct();
        m = ve + q, ve = E.indexOf(t, m), fe = E.indexOf(e, m);
        continue;
      }
      if (fe !== -1 && (fe < ve || ve === -1)) {
        ne.push(E.substring(m, fe)), m = fe + V, fe = E.indexOf(e, m);
        continue;
      }
      if (ve !== -1) {
        if (ne.push(E.substring(m, ve)), at(ve + q), K && (gt(), y))
          return ct();
        if (s && Y.length >= s)
          return ct(!0);
        continue;
      }
      break;
    }
    return lt();
    function Ue(St) {
      Y.push(St), ae = m;
    }
    function Xe(St) {
      var Ot = 0;
      if (St !== -1) {
        var dt = E.substring(X + 1, St);
        dt && dt.trim() === "" && (Ot = dt.length);
      }
      return Ot;
    }
    function lt(St) {
      return L || (typeof St > "u" && (St = E.substr(m)), ne.push(St), m = U, Ue(ne), K && gt()), ct();
    }
    function at(St) {
      m = St, Ue(ne), ne = [], ve = E.indexOf(t, m);
    }
    function ct(St, Ot) {
      var dt = Ot || !1;
      return {
        data: dt ? Y[0] : Y,
        errors: de,
        meta: {
          delimiter: e,
          linebreak: t,
          aborted: y,
          truncated: !!St,
          cursor: ae + (P || 0)
        }
      };
    }
    function gt() {
      i(ct(void 0, !0)), Y = [], de = [];
    }
  }, this.abort = function() {
    y = !0;
  }, this.getCharIndex = function() {
    return m;
  };
}
function U6(r) {
  if (typeof r != "object" || r === null)
    return r;
  var e = Array.isArray(r) ? [] : {};
  for (var t in r)
    e[t] = U6(r[t]);
  return e;
}
function dl(r) {
  return typeof r == "function";
}
const Ba = {
  parse: sY,
  unparse: oY,
  RECORD_SEP: "",
  UNIT_SEP: "",
  BYTE_ORDER_MARK: ES,
  BAD_DELIMITERS: ["\r", `
`, '"', ES],
  WORKERS_SUPPORTED: !1,
  // !IS_WORKER && !!globalThis.Worker
  NODE_STREAM_INPUT: 1,
  // Configurable chunk sizes for local and remote files, respectively
  LocalChunkSize: 1024 * 1024 * 10,
  // 10 M,
  RemoteChunkSize: 1024 * 1024 * 5,
  // 5 M,
  DefaultDelimiter: ",",
  // Used if not specified and detection fail,
  // Exposed for testing and development only
  Parser: t2,
  ParserHandle: N6,
  // BEGIN FORK
  ChunkStreamer: F6
}, { ChunkStreamer: fY } = Ba;
class hY extends fY {
  textDecoder = new TextDecoder(this._config.encoding);
  constructor(e = {}) {
    super(e);
  }
  // Implement ChunkStreamer base class methods
  // this.pause = function() {
  //   ChunkStreamer.prototype.pause.apply(this, arguments);
  // };
  // this.resume = function() {
  //   ChunkStreamer.prototype.resume.apply(this, arguments);
  //   this._input.resume();
  // };
  async stream(e) {
    this._input = e;
    try {
      for await (const t of e)
        this.parseChunk(this.getStringChunk(t));
      this._finished = !0, this.parseChunk("");
    } catch (t) {
      this._sendError(t);
    }
  }
  _nextChunk() {
  }
  // HELPER METHODS
  getStringChunk(e) {
    return typeof e == "string" ? e : this.textDecoder.decode(e, { stream: !0 });
  }
}
const dY = "4.3.3", tw = "object-row-table", rw = {
  dataType: null,
  batchType: null,
  id: "csv",
  module: "csv",
  name: "CSV",
  version: dY,
  extensions: ["csv", "tsv", "dsv"],
  mimeTypes: ["text/csv", "text/tab-separated-values", "text/dsv"],
  category: "table",
  parse: async (r, e) => CS(new TextDecoder().decode(r), e),
  parseText: (r, e) => CS(r, e),
  parseInBatches: pY,
  // @ts-ignore
  // testText: null,
  options: {
    csv: {
      shape: tw,
      // 'object-row-table'
      optimizeMemoryUsage: !1,
      // CSV options
      header: "auto",
      columnPrefix: "column",
      // delimiter: auto
      // newline: auto
      quoteChar: '"',
      escapeChar: '"',
      dynamicTyping: !0,
      comments: !1,
      skipEmptyLines: !0,
      // transform: null?
      delimitersToGuess: [",", "	", "|", ";"]
      // fastMode: auto
    }
  }
};
async function CS(r, e) {
  const t = { ...rw.options.csv, ...e?.csv }, n = AY(r), s = t.header === "auto" ? z6(n) : !!t.header, o = {
    // dynamicTyping: true,
    ...t,
    header: s,
    download: !1,
    // We handle loading, no need for papaparse to do it for us
    transformHeader: s ? V6() : void 0,
    error: (E) => {
      throw new Error(E);
    }
  }, l = Ba.parse(r, o), u = l.data, m = l.meta.fields || j6(t.columnPrefix, n.length), y = t.shape || tw;
  switch (y) {
    case "object-row-table":
      return {
        shape: "object-row-table",
        data: u.map((E) => Array.isArray(E) ? xB(E, m) : E)
      };
    case "array-row-table":
      return {
        shape: "array-row-table",
        data: u.map((E) => Array.isArray(E) ? E : wB(E, m))
      };
    default:
      throw new Error(y);
  }
}
function pY(r, e) {
  e = { ...e }, e.batchSize === "auto" && (e.batchSize = 4e3);
  const t = { ...rw.options.csv, ...e?.csv }, n = new QU();
  let i = !0, s = null, o = null, l = null;
  const u = {
    // dynamicTyping: true, // Convert numbers and boolean values in rows from strings,
    ...t,
    header: !1,
    // Unfortunately, header detection is not automatic and does not infer shapes
    download: !1,
    // We handle loading, no need for papaparse to do it for us
    // chunkSize is set to 5MB explicitly (same as Papaparse default) due to a bug where the
    // streaming parser gets stuck if skipEmptyLines and a step callback are both supplied.
    // See https://github.com/mholt/PapaParse/issues/465
    chunkSize: 1024 * 1024 * 5,
    // skipEmptyLines is set to a boolean value if supplied. Greedy is set to true
    // skipEmptyLines is handled manually given two bugs where the streaming parser gets stuck if
    // both of the skipEmptyLines and step callback options are provided:
    // - true doesn't work unless chunkSize is set: https://github.com/mholt/PapaParse/issues/465
    // - greedy doesn't work: https://github.com/mholt/PapaParse/issues/825
    skipEmptyLines: !1,
    // step is called on every row
    // eslint-disable-next-line complexity, max-statements
    step(m) {
      let y = m.data;
      if (t.skipEmptyLines && y.flat().join("").trim() === "")
        return;
      const E = m.meta.cursor;
      if (i && !s && (t.header === "auto" ? z6(y) : !!t.header)) {
        s = y.map(V6());
        return;
      }
      i && (i = !1, s || (s = j6(t.columnPrefix, y.length)), l = gY(y, s)), t.optimizeMemoryUsage && (y = JSON.parse(JSON.stringify(y)));
      const P = t.shape || tw;
      o = o || new Hm(
        // @ts-expect-error TODO this is not a proper schema
        l,
        {
          shape: P,
          ...e
        }
      );
      try {
        o.addRow(y);
        const L = o && o.getFullBatch({ bytesUsed: E });
        L && n.enqueue(L);
      } catch (L) {
        n.enqueue(L);
      }
    },
    // complete is called when all rows have been read
    complete(m) {
      try {
        const y = m.meta.cursor, E = o && o.getFinalBatch({ bytesUsed: y });
        E && n.enqueue(E);
      } catch (y) {
        n.enqueue(y);
      }
      n.close();
    }
  };
  return Ba.parse(r, u, hY), n;
}
function z6(r) {
  return r && r.every((e) => typeof e == "string");
}
function AY(r) {
  return Ba.parse(r, {
    dynamicTyping: !0,
    preview: 1
  }).data[0];
}
function V6() {
  const r = /* @__PURE__ */ new Set();
  return (e) => {
    let t = e, n = 1;
    for (; r.has(t); )
      t = `${e}.${n}`, n++;
    return r.add(t), t;
  };
}
function j6(r, e = 0) {
  const t = [];
  for (let n = 0; n < e; n++)
    t.push(`${r}${n + 1}`);
  return t;
}
function gY(r, e) {
  const t = e ? {} : [];
  for (let n = 0; n < r.length; n++) {
    const i = e && e[n] || n;
    switch (typeof r[n]) {
      case "number":
      case "boolean":
        t[i] = { name: String(i), index: n, type: Float32Array };
        break;
      case "string":
      default:
        t[i] = { name: String(i), index: n, type: Array };
    }
  }
  return t;
}
function da(r, e) {
  if (!r)
    throw new Error(e || "assert failed: gltf");
}
const H6 = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, G6 = {
  5120: 1,
  // BYTE
  5121: 1,
  // UNSIGNED_BYTE
  5122: 2,
  // SHORT
  5123: 2,
  // UNSIGNED_SHORT
  5125: 4,
  // UNSIGNED_INT
  5126: 4
  // FLOAT
}, mY = 1.33, SS = ["SCALAR", "VEC2", "VEC3", "VEC4"], _Y = [
  [Int8Array, 5120],
  [Uint8Array, 5121],
  [Int16Array, 5122],
  [Uint16Array, 5123],
  [Uint32Array, 5125],
  [Float32Array, 5126],
  [Float64Array, 5130]
], yY = new Map(_Y), vY = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, bY = {
  5120: 1,
  5121: 1,
  5122: 2,
  5123: 2,
  5125: 4,
  5126: 4
}, xY = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
function W6(r) {
  return SS[r - 1] || SS[0];
}
function $_(r) {
  const e = yY.get(r.constructor);
  if (!e)
    throw new Error("Illegal typed array");
  return e;
}
function nw(r, e) {
  const t = xY[r.componentType], n = vY[r.type], i = bY[r.componentType], s = r.count * n, o = r.count * n * i;
  da(o >= 0 && o <= e.byteLength);
  const l = G6[r.componentType], u = H6[r.type];
  return { ArrayType: t, length: s, byteLength: o, componentByteSize: l, numberOfComponentsInElement: u };
}
function $6(r) {
  let { images: e, bufferViews: t } = r;
  e = e || [], t = t || [];
  const n = e.map((o) => o.bufferView);
  t = t.filter((o) => !n.includes(o));
  const i = t.reduce((o, l) => o + l.byteLength, 0), s = e.reduce((o, l) => {
    const { width: u, height: m } = l.image;
    return o + u * m;
  }, 0);
  return i + Math.ceil(4 * s * mY);
}
function wY(r, e, t) {
  const n = r.bufferViews[t];
  da(n);
  const i = n.buffer, s = e[i];
  da(s);
  const o = (n.byteOffset || 0) + s.byteOffset;
  return new Uint8Array(s.arrayBuffer, o, n.byteLength);
}
function TY(r, e, t) {
  const n = typeof t == "number" ? r.accessors?.[t] : t;
  if (!n)
    throw new Error(`No gltf accessor ${JSON.stringify(t)}`);
  const i = r.bufferViews?.[n.bufferView || 0];
  if (!i)
    throw new Error(`No gltf buffer view for accessor ${i}`);
  const { arrayBuffer: s, byteOffset: o } = e[i.buffer], l = (o || 0) + (n.byteOffset || 0) + (i.byteOffset || 0), { ArrayType: u, length: m, componentByteSize: y, numberOfComponentsInElement: E } = nw(n, i), P = y * E, L = i.byteStride || P;
  if (typeof i.byteStride > "u" || i.byteStride === P)
    return new u(s, l, m);
  const U = new u(m);
  for (let V = 0; V < n.count; V++) {
    const q = new u(s, l + V * L, E);
    U.set(q, V * E);
  }
  return U;
}
function EY() {
  return {
    asset: {
      version: "2.0",
      generator: "loaders.gl"
    },
    buffers: [],
    extensions: {},
    extensionsRequired: [],
    extensionsUsed: []
  };
}
class $s {
  // internal
  gltf;
  sourceBuffers;
  byteLength;
  // TODO - why is this not GLTFWithBuffers - what happens to images?
  constructor(e) {
    this.gltf = {
      json: e?.json || EY(),
      buffers: e?.buffers || [],
      images: e?.images || []
    }, this.sourceBuffers = [], this.byteLength = 0, this.gltf.buffers && this.gltf.buffers[0] && (this.byteLength = this.gltf.buffers[0].byteLength, this.sourceBuffers = [this.gltf.buffers[0]]);
  }
  // Accessors
  get json() {
    return this.gltf.json;
  }
  getApplicationData(e) {
    return this.json[e];
  }
  getExtraData(e) {
    return (this.json.extras || {})[e];
  }
  hasExtension(e) {
    const t = this.getUsedExtensions().find((i) => i === e), n = this.getRequiredExtensions().find((i) => i === e);
    return typeof t == "string" || typeof n == "string";
  }
  getExtension(e) {
    const t = this.getUsedExtensions().find((i) => i === e), n = this.json.extensions || {};
    return t ? n[e] : null;
  }
  getRequiredExtension(e) {
    return this.getRequiredExtensions().find((n) => n === e) ? this.getExtension(e) : null;
  }
  getRequiredExtensions() {
    return this.json.extensionsRequired || [];
  }
  getUsedExtensions() {
    return this.json.extensionsUsed || [];
  }
  getRemovedExtensions() {
    return this.json.extensionsRemoved || [];
  }
  getObjectExtension(e, t) {
    return (e.extensions || {})[t];
  }
  getScene(e) {
    return this.getObject("scenes", e);
  }
  getNode(e) {
    return this.getObject("nodes", e);
  }
  getSkin(e) {
    return this.getObject("skins", e);
  }
  getMesh(e) {
    return this.getObject("meshes", e);
  }
  getMaterial(e) {
    return this.getObject("materials", e);
  }
  getAccessor(e) {
    return this.getObject("accessors", e);
  }
  // getCamera(index: number): object | null {
  //   return null; // TODO: fix thi: object  as null;
  // }
  getTexture(e) {
    return this.getObject("textures", e);
  }
  getSampler(e) {
    return this.getObject("samplers", e);
  }
  getImage(e) {
    return this.getObject("images", e);
  }
  getBufferView(e) {
    return this.getObject("bufferViews", e);
  }
  getBuffer(e) {
    return this.getObject("buffers", e);
  }
  getObject(e, t) {
    if (typeof t == "object")
      return t;
    const n = this.json[e] && this.json[e][t];
    if (!n)
      throw new Error(`glTF file error: Could not find ${e}[${t}]`);
    return n;
  }
  /**
   * Accepts buffer view index or buffer view object
   * @returns a `Uint8Array`
   */
  getTypedArrayForBufferView(e) {
    e = this.getBufferView(e);
    const t = e.buffer, n = this.gltf.buffers[t];
    da(n);
    const i = (e.byteOffset || 0) + n.byteOffset;
    return new Uint8Array(n.arrayBuffer, i, e.byteLength);
  }
  /** Accepts accessor index or accessor object
   * @returns a typed array with type that matches the types
   */
  getTypedArrayForAccessor(e) {
    const t = this.getAccessor(e);
    return TY(this.gltf.json, this.gltf.buffers, t);
  }
  /** accepts accessor index or accessor object
   * returns a `Uint8Array`
   */
  getTypedArrayForImageData(e) {
    e = this.getAccessor(e);
    const t = this.getBufferView(e.bufferView), i = this.getBuffer(t.buffer).data, s = t.byteOffset || 0;
    return new Uint8Array(i, s, t.byteLength);
  }
  // MODIFERS
  /**
   * Add an extra application-defined key to the top-level data structure
   */
  addApplicationData(e, t) {
    return this.json[e] = t, this;
  }
  /**
   * `extras` - Standard GLTF field for storing application specific data
   */
  addExtraData(e, t) {
    return this.json.extras = this.json.extras || {}, this.json.extras[e] = t, this;
  }
  addObjectExtension(e, t, n) {
    return e.extensions = e.extensions || {}, e.extensions[t] = n, this.registerUsedExtension(t), this;
  }
  setObjectExtension(e, t, n) {
    const i = e.extensions || {};
    i[t] = n;
  }
  removeObjectExtension(e, t) {
    const n = e?.extensions || {};
    if (n[t]) {
      this.json.extensionsRemoved = this.json.extensionsRemoved || [];
      const i = this.json.extensionsRemoved;
      i.includes(t) || i.push(t);
    }
    delete n[t];
  }
  /**
   * Add to standard GLTF top level extension object, mark as used
   */
  addExtension(e, t = {}) {
    return da(t), this.json.extensions = this.json.extensions || {}, this.json.extensions[e] = t, this.registerUsedExtension(e), t;
  }
  /**
   * Standard GLTF top level extension object, mark as used and required
   */
  addRequiredExtension(e, t = {}) {
    return da(t), this.addExtension(e, t), this.registerRequiredExtension(e), t;
  }
  /**
   * Add extensionName to list of used extensions
   */
  registerUsedExtension(e) {
    this.json.extensionsUsed = this.json.extensionsUsed || [], this.json.extensionsUsed.find((t) => t === e) || this.json.extensionsUsed.push(e);
  }
  /**
   * Add extensionName to list of required extensions
   */
  registerRequiredExtension(e) {
    this.registerUsedExtension(e), this.json.extensionsRequired = this.json.extensionsRequired || [], this.json.extensionsRequired.find((t) => t === e) || this.json.extensionsRequired.push(e);
  }
  /**
   * Removes an extension from the top-level list
   */
  removeExtension(e) {
    if (this.json.extensions?.[e]) {
      this.json.extensionsRemoved = this.json.extensionsRemoved || [];
      const t = this.json.extensionsRemoved;
      t.includes(e) || t.push(e);
    }
    this.json.extensions && delete this.json.extensions[e], this.json.extensionsRequired && this._removeStringFromArray(this.json.extensionsRequired, e), this.json.extensionsUsed && this._removeStringFromArray(this.json.extensionsUsed, e);
  }
  /**
   *  Set default scene which is to be displayed at load time
   */
  setDefaultScene(e) {
    this.json.scene = e;
  }
  /**
   * @todo: add more properties for scene initialization:
   *   name`, `extensions`, `extras`
   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-scene
   */
  addScene(e) {
    const { nodeIndices: t } = e;
    return this.json.scenes = this.json.scenes || [], this.json.scenes.push({ nodes: t }), this.json.scenes.length - 1;
  }
  /**
   * @todo: add more properties for node initialization:
   *   `name`, `extensions`, `extras`, `camera`, `children`, `skin`, `rotation`, `scale`, `translation`, `weights`
   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#node
   */
  addNode(e) {
    const { meshIndex: t, matrix: n } = e;
    this.json.nodes = this.json.nodes || [];
    const i = { mesh: t };
    return n && (i.matrix = n), this.json.nodes.push(i), this.json.nodes.length - 1;
  }
  /** Adds a mesh to the json part */
  addMesh(e) {
    const { attributes: t, indices: n, material: i, mode: s = 4 } = e, l = {
      primitives: [
        {
          attributes: this._addAttributes(t),
          mode: s
        }
      ]
    };
    if (n) {
      const u = this._addIndices(n);
      l.primitives[0].indices = u;
    }
    return Number.isFinite(i) && (l.primitives[0].material = i), this.json.meshes = this.json.meshes || [], this.json.meshes.push(l), this.json.meshes.length - 1;
  }
  addPointCloud(e) {
    const n = {
      primitives: [
        {
          attributes: this._addAttributes(e),
          mode: 0
          // GL.POINTS
        }
      ]
    };
    return this.json.meshes = this.json.meshes || [], this.json.meshes.push(n), this.json.meshes.length - 1;
  }
  /**
   * Adds a binary image. Builds glTF "JSON metadata" and saves buffer reference
   * Buffer will be copied into BIN chunk during "pack"
   * Currently encodes as glTF image
   * @param imageData
   * @param mimeType
   */
  addImage(e, t) {
    const n = ox(e), i = t || n?.mimeType, o = {
      bufferView: this.addBufferView(e),
      mimeType: i
    };
    return this.json.images = this.json.images || [], this.json.images.push(o), this.json.images.length - 1;
  }
  /**
   * Add one untyped source buffer, create a matching glTF `bufferView`, and return its index
   * @param buffer
   */
  addBufferView(e, t = 0, n = this.byteLength) {
    const i = e.byteLength;
    da(Number.isFinite(i)), this.sourceBuffers = this.sourceBuffers || [], this.sourceBuffers.push(e);
    const s = {
      buffer: t,
      // Write offset from the start of the binary body
      byteOffset: n,
      byteLength: i
    };
    return this.byteLength += m0(i, 4), this.json.bufferViews = this.json.bufferViews || [], this.json.bufferViews.push(s), this.json.bufferViews.length - 1;
  }
  /**
   * Adds an accessor to a bufferView
   * @param bufferViewIndex
   * @param accessor
   */
  addAccessor(e, t) {
    const n = {
      bufferView: e,
      // @ts-ignore
      type: W6(t.size),
      // @ts-ignore
      componentType: t.componentType,
      // @ts-ignore
      count: t.count,
      // @ts-ignore
      max: t.max,
      // @ts-ignore
      min: t.min
    };
    return this.json.accessors = this.json.accessors || [], this.json.accessors.push(n), this.json.accessors.length - 1;
  }
  /**
   * Add a binary buffer. Builds glTF "JSON metadata" and saves buffer reference
   * Buffer will be copied into BIN chunk during "pack"
   * Currently encodes buffers as glTF accessors, but this could be optimized
   * @param sourceBuffer
   * @param accessor
   */
  addBinaryBuffer(e, t = { size: 3 }) {
    const n = this.addBufferView(e);
    let i = { min: t.min, max: t.max };
    (!i.min || !i.max) && (i = this._getAccessorMinMax(e, t.size));
    const s = {
      // @ts-ignore
      size: t.size,
      componentType: $_(e),
      // @ts-ignore
      count: Math.round(e.length / t.size),
      min: i.min,
      max: i.max
    };
    return this.addAccessor(n, Object.assign(s, t));
  }
  /**
   * Adds a texture to the json part
   * @todo: add more properties for texture initialization
   * `sampler`, `name`, `extensions`, `extras`
   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture
   */
  addTexture(e) {
    const { imageIndex: t } = e, n = {
      source: t
    };
    return this.json.textures = this.json.textures || [], this.json.textures.push(n), this.json.textures.length - 1;
  }
  /** Adds a material to the json part */
  addMaterial(e) {
    return this.json.materials = this.json.materials || [], this.json.materials.push(e), this.json.materials.length - 1;
  }
  /** Pack the binary chunk */
  createBinaryChunk() {
    const e = this.byteLength, t = new ArrayBuffer(e), n = new Uint8Array(t);
    let i = 0;
    for (const s of this.sourceBuffers || [])
      i = S5(s, n, i);
    this.json?.buffers?.[0] ? this.json.buffers[0].byteLength = e : this.json.buffers = [{ byteLength: e }], this.gltf.binary = t, this.sourceBuffers = [t], this.gltf.buffers = [{ arrayBuffer: t, byteOffset: 0, byteLength: t.byteLength }];
  }
  // PRIVATE
  _removeStringFromArray(e, t) {
    let n = !0;
    for (; n; ) {
      const i = e.indexOf(t);
      i > -1 ? e.splice(i, 1) : n = !1;
    }
  }
  /**
   * Add attributes to buffers and create `attributes` object which is part of `mesh`
   */
  _addAttributes(e = {}) {
    const t = {};
    for (const n in e) {
      const i = e[n], s = this._getGltfAttributeName(n), o = this.addBinaryBuffer(i.value, i);
      t[s] = o;
    }
    return t;
  }
  /**
   * Add indices to buffers
   */
  _addIndices(e) {
    return this.addBinaryBuffer(e, { size: 1 });
  }
  /**
   * Deduce gltf specific attribue name from input attribute name
   */
  _getGltfAttributeName(e) {
    switch (e.toLowerCase()) {
      case "position":
      case "positions":
      case "vertices":
        return "POSITION";
      case "normal":
      case "normals":
        return "NORMAL";
      case "color":
      case "colors":
        return "COLOR_0";
      case "texcoord":
      case "texcoords":
        return "TEXCOORD_0";
      default:
        return e;
    }
  }
  /**
   * Calculate `min` and `max` arrays of accessor according to spec:
   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-accessor
   */
  _getAccessorMinMax(e, t) {
    const n = { min: null, max: null };
    if (e.length < t)
      return n;
    n.min = [], n.max = [];
    const i = e.subarray(0, t);
    for (const s of i)
      n.min.push(s), n.max.push(s);
    for (let s = t; s < e.length; s += t)
      for (let o = 0; o < t; o++)
        n.min[0 + o] = Math.min(
          // @ts-ignore
          n.min[0 + o],
          e[s + o]
        ), n.max[0 + o] = Math.max(
          // @ts-ignore
          n.max[0 + o],
          e[s + o]
        );
    return n;
  }
}
function IS(r) {
  return (r % 1 + 1) % 1;
}
const q6 = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16,
  BOOLEAN: 1,
  STRING: 1,
  ENUM: 1
}, CY = {
  INT8: Int8Array,
  UINT8: Uint8Array,
  INT16: Int16Array,
  UINT16: Uint16Array,
  INT32: Int32Array,
  UINT32: Uint32Array,
  INT64: BigInt64Array,
  UINT64: BigUint64Array,
  FLOAT32: Float32Array,
  FLOAT64: Float64Array
}, X6 = {
  INT8: 1,
  UINT8: 1,
  INT16: 2,
  UINT16: 2,
  INT32: 4,
  UINT32: 4,
  INT64: 8,
  UINT64: 8,
  FLOAT32: 4,
  FLOAT64: 8
};
function iw(r, e) {
  return X6[e] * q6[r];
}
function q_(r, e, t, n) {
  if (t !== "UINT8" && t !== "UINT16" && t !== "UINT32" && t !== "UINT64")
    return null;
  const i = r.getTypedArrayForBufferView(e), s = X_(
    i,
    "SCALAR",
    // offsets consist of ONE component
    t,
    n + 1
    // The number of offsets is equal to the property table `count` plus one.
  );
  return s instanceof BigInt64Array || s instanceof BigUint64Array ? null : s;
}
function X_(r, e, t, n = 1) {
  const i = q6[e], s = CY[t], o = X6[t], l = n * i, u = l * o;
  let m = r.buffer, y = r.byteOffset;
  return y % o !== 0 && (m = new Uint8Array(m).slice(y, y + u).buffer, y = 0), new s(m, y, l);
}
function sw(r, e, t) {
  const n = `TEXCOORD_${e.texCoord || 0}`, i = t.attributes[n], s = r.getTypedArrayForAccessor(i), o = r.gltf.json, l = e.index, u = o.textures?.[l]?.source;
  if (typeof u < "u") {
    const m = o.images?.[u]?.mimeType, y = r.gltf.images?.[u];
    if (y && typeof y.width < "u") {
      const E = [];
      for (let P = 0; P < s.length; P += 2) {
        const L = SY(y, m, s, P, e.channels);
        E.push(L);
      }
      return E;
    }
  }
  return [];
}
function Z6(r, e, t, n, i) {
  if (!t?.length)
    return;
  const s = [];
  for (const y of t) {
    let E = n.findIndex((P) => P === y);
    E === -1 && (E = n.push(y) - 1), s.push(E);
  }
  const o = new Uint32Array(s), l = r.gltf.buffers.push({
    arrayBuffer: o.buffer,
    byteOffset: o.byteOffset,
    byteLength: o.byteLength
  }) - 1, u = r.addBufferView(o, l, 0), m = r.addAccessor(u, {
    size: 1,
    componentType: $_(o),
    count: o.length
  });
  i.attributes[e] = m;
}
function SY(r, e, t, n, i = [0]) {
  const s = {
    r: { offset: 0, shift: 0 },
    g: { offset: 1, shift: 8 },
    b: { offset: 2, shift: 16 },
    a: { offset: 3, shift: 24 }
  }, o = t[n], l = t[n + 1];
  let u = 1;
  e && (e.indexOf("image/jpeg") !== -1 || e.indexOf("image/png") !== -1) && (u = 4);
  const m = IY(o, l, r, u);
  let y = 0;
  for (const E of i) {
    const P = typeof E == "number" ? Object.values(s)[E] : s[E], L = m + P.offset, U = EB(r);
    if (U.data.length <= L)
      throw new Error(`${U.data.length} <= ${L}`);
    const V = U.data[L];
    y |= V << P.shift;
  }
  return y;
}
function IY(r, e, t, n = 1) {
  const i = t.width, s = IS(r) * (i - 1), o = Math.round(s), l = t.height, u = IS(e) * (l - 1), m = Math.round(u), y = t.components ? t.components : n;
  return (m * i + o) * y;
}
function Y6(r, e, t, n, i) {
  const s = [];
  for (let o = 0; o < e; o++) {
    const l = t[o], u = t[o + 1] - t[o];
    if (u + l > n)
      break;
    const m = l / i, y = u / i;
    s.push(r.slice(m, m + y));
  }
  return s;
}
function K6(r, e, t) {
  const n = [];
  for (let i = 0; i < e; i++) {
    const s = i * t;
    n.push(r.slice(s, s + t));
  }
  return n;
}
function Q6(r, e, t, n) {
  if (t)
    throw new Error("Not implemented - arrayOffsets for strings is specified");
  if (n) {
    const i = [], s = new TextDecoder("utf8");
    let o = 0;
    for (let l = 0; l < r; l++) {
      const u = n[l + 1] - n[l];
      if (u + o <= e.length) {
        const m = e.subarray(o, u + o), y = s.decode(m);
        i.push(y), o += u;
      }
    }
    return i;
  }
  return [];
}
const lp = "EXT_mesh_features", PY = lp;
async function MY(r, e) {
  const t = new $s(r);
  BY(t, e);
}
function RY(r, e) {
  const t = new $s(r);
  return DY(t), t.createBinaryChunk(), t.gltf;
}
function BY(r, e) {
  const t = r.gltf.json;
  if (t.meshes)
    for (const n of t.meshes)
      for (const i of n.primitives)
        OY(r, i, e);
}
function OY(r, e, t) {
  if (!t?.gltf?.loadBuffers)
    return;
  const i = e.extensions?.[lp]?.featureIds;
  if (i)
    for (const s of i) {
      let o;
      if (typeof s.attribute < "u") {
        const l = `_FEATURE_ID_${s.attribute}`, u = e.attributes[l];
        o = r.getTypedArrayForAccessor(u);
      } else typeof s.texture < "u" && t?.gltf?.loadImages ? o = sw(r, s.texture, e) : o = [];
      s.data = o;
    }
}
function DY(r, e) {
  const t = r.gltf.json.meshes;
  if (t)
    for (const n of t)
      for (const i of n.primitives)
        kY(r, i);
}
function LY(r, e, t, n) {
  e.extensions || (e.extensions = {});
  let i = e.extensions[lp];
  i || (i = { featureIds: [] }, e.extensions[lp] = i);
  const { featureIds: s } = i, o = {
    featureCount: t.length,
    propertyTable: n,
    data: t
  };
  s.push(o), r.addObjectExtension(e, lp, i);
}
function kY(r, e) {
  const t = e.extensions?.[lp];
  if (!t)
    return;
  const n = t.featureIds;
  n.forEach((i, s) => {
    if (i.data) {
      const { accessorKey: o, index: l } = FY(e.attributes), u = new Uint32Array(i.data);
      n[s] = {
        featureCount: u.length,
        propertyTable: i.propertyTable,
        attribute: l
      }, r.gltf.buffers.push({
        arrayBuffer: u.buffer,
        byteOffset: u.byteOffset,
        byteLength: u.byteLength
      });
      const m = r.addBufferView(u), y = r.addAccessor(m, {
        size: 1,
        componentType: $_(u),
        count: u.length
      });
      e.attributes[o] = y;
    }
  });
}
function FY(r) {
  const e = "_FEATURE_ID_", t = Object.keys(r).filter((s) => s.indexOf(e) === 0);
  let n = -1;
  for (const s of t) {
    const o = Number(s.substring(e.length));
    o > n && (n = o);
  }
  return n++, { accessorKey: `${e}${n}`, index: n };
}
const NY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createExtMeshFeatures: LY,
  decode: MY,
  encode: RY,
  name: PY
}, Symbol.toStringTag, { value: "Module" })), xp = "EXT_structural_metadata", UY = xp;
async function zY(r, e) {
  const t = new $s(r);
  jY(t, e);
}
function VY(r, e) {
  const t = new $s(r);
  return iK(t), t.createBinaryChunk(), t.gltf;
}
function jY(r, e) {
  if (!e.gltf?.loadBuffers)
    return;
  const t = r.getExtension(xp);
  t && (e.gltf?.loadImages && HY(r, t), GY(r, t));
}
function HY(r, e) {
  const t = e.propertyTextures, n = r.gltf.json;
  if (t && n.meshes)
    for (const i of n.meshes)
      for (const s of i.primitives)
        $Y(r, t, s, e);
}
function GY(r, e) {
  const t = e.schema;
  if (!t)
    return;
  const n = t.classes, i = e.propertyTables;
  if (n && i)
    for (const s in n) {
      const o = WY(i, s);
      o && XY(r, t, o);
    }
}
function WY(r, e) {
  for (const t of r)
    if (t.class === e)
      return t;
  return null;
}
function $Y(r, e, t, n) {
  if (!e)
    return;
  const s = t.extensions?.[xp]?.propertyTextures;
  if (s)
    for (const o of s) {
      const l = e[o];
      qY(r, l, t, n);
    }
}
function qY(r, e, t, n) {
  if (!e.properties)
    return;
  n.dataAttributeNames || (n.dataAttributeNames = []);
  const i = e.class;
  for (const s in e.properties) {
    const o = `${i}_${s}`, l = e.properties?.[s];
    if (!l)
      continue;
    l.data || (l.data = []);
    const u = l.data, m = sw(r, l, t);
    m !== null && (Z6(r, o, m, u, t), l.data = u, n.dataAttributeNames.push(o));
  }
}
function XY(r, e, t) {
  const n = e.classes?.[t.class];
  if (!n)
    throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${t.class}`);
  const i = t.count;
  for (const s in n.properties) {
    const o = n.properties[s], l = t.properties?.[s];
    if (l) {
      const u = ZY(r, e, o, i, l);
      l.data = u;
    }
  }
}
function ZY(r, e, t, n, i) {
  let s = [];
  const o = i.values, l = r.getTypedArrayForBufferView(o), u = YY(r, t, i, n), m = KY(r, i, n);
  switch (t.type) {
    case "SCALAR":
    case "VEC2":
    case "VEC3":
    case "VEC4":
    case "MAT2":
    case "MAT3":
    case "MAT4": {
      s = QY(t, n, l, u);
      break;
    }
    case "BOOLEAN":
      throw new Error(`Not implemented - classProperty.type=${t.type}`);
    case "STRING": {
      s = Q6(n, l, u, m);
      break;
    }
    case "ENUM": {
      s = JY(e, t, n, l, u);
      break;
    }
    default:
      throw new Error(`Unknown classProperty type ${t.type}`);
  }
  return s;
}
function YY(r, e, t, n) {
  return e.array && // `count` is a number of array elements. May only be defined when `array` is true.
  // If `count` is NOT defined, it's a VARIABLE-length array
  typeof e.count > "u" && // `arrayOffsets` is an index of the buffer view containing offsets for variable-length arrays.
  typeof t.arrayOffsets < "u" ? q_(r, t.arrayOffsets, t.arrayOffsetType || "UINT32", n) : null;
}
function KY(r, e, t) {
  return typeof e.stringOffsets < "u" ? q_(r, e.stringOffsets, e.stringOffsetType || "UINT32", t) : null;
}
function QY(r, e, t, n) {
  const i = r.array, s = r.count, o = iw(r.type, r.componentType), l = t.byteLength / o;
  let u;
  return r.componentType ? u = X_(
    t,
    r.type,
    // The datatype of the element's components. Only applicable to `SCALAR`, `VECN`, and `MATN` types.
    r.componentType,
    l
  ) : u = t, i ? n ? Y6(u, e, n, t.length, o) : s ? K6(u, e, s) : [] : u;
}
function JY(r, e, t, n, i) {
  const s = e.enumType;
  if (!s)
    throw new Error("Incorrect data in the EXT_structural_metadata extension: classProperty.enumType is not set for type ENUM");
  const o = r.enums?.[s];
  if (!o)
    throw new Error(`Incorrect data in the EXT_structural_metadata extension: schema.enums does't contain ${s}`);
  const l = o.valueType || "UINT16", u = iw(e.type, l), m = n.byteLength / u;
  let y = X_(n, e.type, l, m);
  if (y || (y = n), e.array) {
    if (i)
      return eK({
        valuesData: y,
        numberOfElements: t,
        arrayOffsets: i,
        valuesDataBytesLength: n.length,
        elementSize: u,
        enumEntry: o
      });
    const E = e.count;
    return E ? tK(y, t, E, o) : [];
  }
  return ow(y, 0, t, o);
}
function eK(r) {
  const { valuesData: e, numberOfElements: t, arrayOffsets: n, valuesDataBytesLength: i, elementSize: s, enumEntry: o } = r, l = [];
  for (let u = 0; u < t; u++) {
    const m = n[u], y = n[u + 1] - n[u];
    if (y + m > i)
      break;
    const E = m / s, P = y / s, L = ow(e, E, P, o);
    l.push(L);
  }
  return l;
}
function tK(r, e, t, n) {
  const i = [];
  for (let s = 0; s < e; s++) {
    const o = t * s, l = ow(r, o, t, n);
    i.push(l);
  }
  return i;
}
function ow(r, e, t, n) {
  const i = [];
  for (let s = 0; s < t; s++)
    if (r instanceof BigInt64Array || r instanceof BigUint64Array)
      i.push("");
    else {
      const o = r[e + s], l = rK(n, o);
      l ? i.push(l.name) : i.push("");
    }
  return i;
}
function rK(r, e) {
  for (const t of r.values)
    if (t.value === e)
      return t;
  return null;
}
const nK = "schemaClassId";
function iK(r, e) {
  const t = r.getExtension(xp);
  if (t && t.propertyTables)
    for (const n of t.propertyTables) {
      const i = n.class, s = t.schema?.classes?.[i];
      n.properties && s && sK(n, s, r);
    }
}
function sK(r, e, t) {
  for (const n in r.properties) {
    const i = r.properties[n].data;
    if (i) {
      const s = e.properties[n];
      if (s) {
        const o = cK(i, s, t);
        r.properties[n] = o;
      }
    }
  }
}
function oK(r, e, t = nK) {
  let n = r.getExtension(xp);
  n || (n = r.addExtension(xp)), n.schema = aK(e, t, n.schema);
  const i = lK(e, t, n.schema);
  return n.propertyTables || (n.propertyTables = []), n.propertyTables.push(i) - 1;
}
function aK(r, e, t) {
  const n = t ?? {
    id: "schema_id"
  }, i = {
    properties: {}
  };
  for (const s of r) {
    const o = {
      type: s.elementType,
      componentType: s.componentType
    };
    i.properties[s.name] = o;
  }
  return n.classes = {}, n.classes[e] = i, n;
}
function lK(r, e, t) {
  const n = {
    class: e,
    count: 0
  };
  let i = 0;
  const s = t.classes?.[e];
  for (const o of r) {
    if (i === 0 && (i = o.values.length), i !== o.values.length && o.values.length)
      throw new Error("Illegal values in attributes");
    s?.properties[o.name] && (n.properties || (n.properties = {}), n.properties[o.name] = { values: 0, data: o.values });
  }
  return n.count = i, n;
}
function cK(r, e, t) {
  const n = { values: 0 };
  if (e.type === "STRING") {
    const { stringData: i, stringOffsets: s } = hK(r);
    n.stringOffsets = Xv(s, t), n.values = Xv(i, t);
  } else if (e.type === "SCALAR" && e.componentType) {
    const i = fK(r, e.componentType);
    n.values = Xv(i, t);
  }
  return n;
}
const uK = {
  INT8: Int8Array,
  UINT8: Uint8Array,
  INT16: Int16Array,
  UINT16: Uint16Array,
  INT32: Int32Array,
  UINT32: Uint32Array,
  INT64: Int32Array,
  UINT64: Uint32Array,
  FLOAT32: Float32Array,
  FLOAT64: Float64Array
};
function fK(r, e) {
  const t = [];
  for (const i of r)
    t.push(Number(i));
  const n = uK[e];
  if (!n)
    throw new Error("Illegal component type");
  return new n(t);
}
function hK(r) {
  const e = new TextEncoder(), t = [];
  let n = 0;
  for (const u of r) {
    const m = e.encode(u);
    n += m.length, t.push(m);
  }
  const i = new Uint8Array(n), s = [];
  let o = 0;
  for (const u of t)
    i.set(u, o), s.push(o), o += u.length;
  s.push(o);
  const l = new Uint32Array(s);
  return { stringData: i, stringOffsets: l };
}
function Xv(r, e) {
  return e.gltf.buffers.push({
    arrayBuffer: r.buffer,
    byteOffset: r.byteOffset,
    byteLength: r.byteLength
  }), e.addBufferView(r);
}
const dK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createExtStructuralMetadata: oK,
  decode: zY,
  encode: VY,
  name: UY
}, Symbol.toStringTag, { value: "Module" })), J6 = "EXT_feature_metadata", pK = J6;
async function AK(r, e) {
  const t = new $s(r);
  gK(t, e);
}
function gK(r, e) {
  if (!e.gltf?.loadBuffers)
    return;
  const t = r.getExtension(J6);
  t && (e.gltf?.loadImages && mK(r, t), _K(r, t));
}
function mK(r, e) {
  const t = e.schema;
  if (!t)
    return;
  const n = t.classes, { featureTextures: i } = e;
  if (n && i)
    for (const s in n) {
      const o = n[s], l = vK(i, s);
      l && xK(r, l, o);
    }
}
function _K(r, e) {
  const t = e.schema;
  if (!t)
    return;
  const n = t.classes, i = e.featureTables;
  if (n && i)
    for (const s in n) {
      const o = yK(i, s);
      o && bK(r, t, o);
    }
}
function yK(r, e) {
  for (const t in r) {
    const n = r[t];
    if (n.class === e)
      return n;
  }
  return null;
}
function vK(r, e) {
  for (const t in r) {
    const n = r[t];
    if (n.class === e)
      return n;
  }
  return null;
}
function bK(r, e, t) {
  if (!t.class)
    return;
  const n = e.classes?.[t.class];
  if (!n)
    throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${t.class}`);
  const i = t.count;
  for (const s in n.properties) {
    const o = n.properties[s], l = t.properties?.[s];
    if (l) {
      const u = wK(r, e, o, i, l);
      l.data = u;
    }
  }
}
function xK(r, e, t) {
  const n = e.class;
  for (const i in t.properties) {
    const s = e?.properties?.[i];
    if (s) {
      const o = IK(r, s, n);
      s.data = o;
    }
  }
}
function wK(r, e, t, n, i) {
  let s = [];
  const o = i.bufferView, l = r.getTypedArrayForBufferView(o), u = TK(r, t, i, n), m = EK(r, t, i, n);
  return t.type === "STRING" || t.componentType === "STRING" ? s = Q6(n, l, u, m) : CK(t) && (s = SK(t, n, l, u)), s;
}
function TK(r, e, t, n) {
  return e.type === "ARRAY" && // `componentCount` is a number of fixed-length array elements.
  // If `componentCount` is NOT defined, it's a VARIABLE-length array
  typeof e.componentCount > "u" && // `arrayOffsetBufferView` is an index of the buffer view containing offsets for variable-length arrays.
  typeof t.arrayOffsetBufferView < "u" ? q_(
    r,
    t.arrayOffsetBufferView,
    t.offsetType || "UINT32",
    // offsetType is used both for stringOffsetBufferView and arrayOffsetBufferView
    n
  ) : null;
}
function EK(r, e, t, n) {
  return typeof t.stringOffsetBufferView < "u" ? q_(
    r,
    t.stringOffsetBufferView,
    t.offsetType || "UINT32",
    // offsetType is used both for stringOffsetBufferView and arrayOffsetBufferView
    n
  ) : null;
}
function CK(r) {
  const e = [
    "UINT8",
    "INT16",
    "UINT16",
    "INT32",
    "UINT32",
    "INT64",
    "UINT64",
    "FLOAT32",
    "FLOAT64"
  ];
  return e.includes(r.type) || typeof r.componentType < "u" && e.includes(r.componentType);
}
function SK(r, e, t, n) {
  const i = r.type === "ARRAY", s = r.componentCount, o = "SCALAR", l = r.componentType || r.type, u = iw(o, l), m = t.byteLength / u, y = X_(t, o, l, m);
  return i ? n ? Y6(y, e, n, t.length, u) : s ? K6(y, e, s) : [] : y;
}
function IK(r, e, t) {
  const n = r.gltf.json;
  if (!n.meshes)
    return [];
  const i = [];
  for (const s of n.meshes)
    for (const o of s.primitives)
      PK(r, t, e, i, o);
  return i;
}
function PK(r, e, t, n, i) {
  const s = {
    channels: t.channels,
    ...t.texture
  }, o = sw(r, s, i);
  o && Z6(r, e, o, n, i);
}
const MK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: AK,
  name: pK
}, Symbol.toStringTag, { value: "Module" })), RK = "4.3.3", BK = "4.3.3", l_ = {
  /** Basis transcoder, javascript wrapper part */
  TRANSCODER: "basis_transcoder.js",
  /** Basis transcoder, compiled web assembly part */
  TRANSCODER_WASM: "basis_transcoder.wasm",
  /** Basis encoder, javascript wrapper part */
  ENCODER: "basis_encoder.js",
  /** Basis encoder, compiled web assembly part */
  ENCODER_WASM: "basis_encoder.wasm"
};
let PS;
async function MS(r) {
  t5(r.modules);
  const e = r5("basis");
  return e || (PS ||= OK(r), await PS);
}
async function OK(r) {
  let e = null, t = null;
  return [e, t] = await Promise.all([
    await Xf(l_.TRANSCODER, "textures", r),
    await Xf(l_.TRANSCODER_WASM, "textures", r)
  ]), e = e || globalThis.BASIS, await DK(e, t);
}
function DK(r, e) {
  const t = {};
  return e && (t.wasmBinary = e), new Promise((n) => {
    r(t).then((i) => {
      const { BasisFile: s, initializeBasis: o } = i;
      o(), n({ BasisFile: s });
    });
  });
}
let Zv;
async function RS(r) {
  const e = r.modules || {};
  return e.basisEncoder ? e.basisEncoder : (Zv = Zv || LK(r), await Zv);
}
async function LK(r) {
  let e = null, t = null;
  return [e, t] = await Promise.all([
    await Xf(l_.ENCODER, "textures", r),
    await Xf(l_.ENCODER_WASM, "textures", r)
  ]), e = e || globalThis.BASIS, await kK(e, t);
}
function kK(r, e) {
  const t = {};
  return e && (t.wasmBinary = e), new Promise((n) => {
    r(t).then((i) => {
      const { BasisFile: s, KTX2File: o, initializeBasis: l, BasisEncoder: u } = i;
      l(), n({ BasisFile: s, KTX2File: o, BasisEncoder: u });
    });
  });
}
const xd = {
  // WEBGL_compressed_texture_s3tc
  COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,
  COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,
  // WEBGL_compressed_texture_pvrtc
  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,
  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,
  // WEBGL_compressed_texture_etc1
  COMPRESSED_RGB_ETC1_WEBGL: 36196,
  // WEBGL_compressed_texture_astc
  COMPRESSED_RGBA_ASTC_4X4_KHR: 37808
}, FK = ["", "WEBKIT_", "MOZ_"], BS = {
  /* eslint-disable camelcase */
  WEBGL_compressed_texture_s3tc: "dxt",
  WEBGL_compressed_texture_s3tc_srgb: "dxt-srgb",
  WEBGL_compressed_texture_etc1: "etc1",
  WEBGL_compressed_texture_etc: "etc2",
  WEBGL_compressed_texture_pvrtc: "pvrtc",
  WEBGL_compressed_texture_atc: "atc",
  WEBGL_compressed_texture_astc: "astc",
  EXT_texture_compression_rgtc: "rgtc"
  /* eslint-enable camelcase */
};
let Pg = null;
function NK(r) {
  if (!Pg) {
    r = r || UK() || void 0, Pg = /* @__PURE__ */ new Set();
    for (const e of FK)
      for (const t in BS)
        if (r && r.getExtension(`${e}${t}`)) {
          const n = BS[t];
          Pg.add(n);
        }
  }
  return Pg;
}
function UK() {
  try {
    return document.createElement("canvas").getContext("webgl");
  } catch {
    return null;
  }
}
const la = [
  // '', 'K', 'T', 'X', '2', '0', '', '\r', '\n', '\x1A', '\n'
  171,
  75,
  84,
  88,
  32,
  50,
  48,
  187,
  13,
  10,
  26,
  10
];
function zK(r) {
  const e = new Uint8Array(r);
  return !(e.byteLength < la.length || e[0] !== la[0] || // ''
  e[1] !== la[1] || // 'K'
  e[2] !== la[2] || // 'T'
  e[3] !== la[3] || // 'X'
  e[4] !== la[4] || // ' '
  e[5] !== la[5] || // '2'
  e[6] !== la[6] || // '0'
  e[7] !== la[7] || // ''
  e[8] !== la[8] || // '\r'
  e[9] !== la[9] || // '\n'
  e[10] !== la[10] || // '\x1A'
  e[11] !== la[11]);
}
const VK = {
  etc1: {
    basisFormat: 0,
    compressed: !0,
    format: xd.COMPRESSED_RGB_ETC1_WEBGL
  },
  etc2: { basisFormat: 1, compressed: !0 },
  bc1: {
    basisFormat: 2,
    compressed: !0,
    format: xd.COMPRESSED_RGB_S3TC_DXT1_EXT
  },
  bc3: {
    basisFormat: 3,
    compressed: !0,
    format: xd.COMPRESSED_RGBA_S3TC_DXT5_EXT
  },
  bc4: { basisFormat: 4, compressed: !0 },
  bc5: { basisFormat: 5, compressed: !0 },
  "bc7-m6-opaque-only": { basisFormat: 6, compressed: !0 },
  "bc7-m5": { basisFormat: 7, compressed: !0 },
  "pvrtc1-4-rgb": {
    basisFormat: 8,
    compressed: !0,
    format: xd.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
  },
  "pvrtc1-4-rgba": {
    basisFormat: 9,
    compressed: !0,
    format: xd.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
  },
  "astc-4x4": {
    basisFormat: 10,
    compressed: !0,
    format: xd.COMPRESSED_RGBA_ASTC_4X4_KHR
  },
  "atc-rgb": { basisFormat: 11, compressed: !0 },
  "atc-rgba-interpolated-alpha": { basisFormat: 12, compressed: !0 },
  rgba32: { basisFormat: 13, compressed: !1 },
  rgb565: { basisFormat: 14, compressed: !1 },
  bgr565: { basisFormat: 15, compressed: !1 },
  rgba4444: { basisFormat: 16, compressed: !1 }
};
async function jK(r, e) {
  if (e.basis.containerFormat === "auto") {
    if (zK(r)) {
      const n = await RS(e);
      return OS(n.KTX2File, r, e);
    }
    const { BasisFile: t } = await MS(e);
    return Yv(t, r, e);
  }
  switch (e.basis.module) {
    case "encoder":
      const t = await RS(e);
      switch (e.basis.containerFormat) {
        case "ktx2":
          return OS(t.KTX2File, r, e);
        case "basis":
        default:
          return Yv(t.BasisFile, r, e);
      }
    case "transcoder":
    default:
      const { BasisFile: n } = await MS(e);
      return Yv(n, r, e);
  }
}
function Yv(r, e, t) {
  const n = new r(new Uint8Array(e));
  try {
    if (!n.startTranscoding())
      throw new Error("Failed to start basis transcoding");
    const i = n.getNumImages(), s = [];
    for (let o = 0; o < i; o++) {
      const l = n.getNumLevels(o), u = [];
      for (let m = 0; m < l; m++)
        u.push(HK(n, o, m, t));
      s.push(u);
    }
    return s;
  } finally {
    n.close(), n.delete();
  }
}
function HK(r, e, t, n) {
  const i = r.getImageWidth(e, t), s = r.getImageHeight(e, t), o = r.getHasAlpha(
    /* imageIndex, levelIndex */
  ), { compressed: l, format: u, basisFormat: m } = eD(n, o), y = r.getImageTranscodedSizeInBytes(e, t, m), E = new Uint8Array(y);
  if (!r.transcodeImage(E, e, t, m, 0, 0))
    throw new Error("failed to start Basis transcoding");
  return {
    // standard loaders.gl image category payload
    width: i,
    height: s,
    data: E,
    compressed: l,
    format: u,
    // Additional fields
    // Add levelSize field.
    hasAlpha: o
  };
}
function OS(r, e, t) {
  const n = new r(new Uint8Array(e));
  try {
    if (!n.startTranscoding())
      throw new Error("failed to start KTX2 transcoding");
    const i = n.getLevels(), s = [];
    for (let o = 0; o < i; o++)
      s.push(GK(n, o, t));
    return [s];
  } finally {
    n.close(), n.delete();
  }
}
function GK(r, e, t) {
  const { alphaFlag: n, height: i, width: s } = r.getImageLevelInfo(e, 0, 0), { compressed: o, format: l, basisFormat: u } = eD(t, n), m = r.getImageTranscodedSizeInBytes(e, 0, 0, u), y = new Uint8Array(m);
  if (!r.transcodeImage(
    y,
    e,
    0,
    0,
    u,
    0,
    -1,
    -1
    /* channel1 */
  ))
    throw new Error("Failed to transcode KTX2 image");
  return {
    // standard loaders.gl image category payload
    width: s,
    height: i,
    data: y,
    compressed: o,
    // Additional fields
    levelSize: m,
    hasAlpha: n,
    format: l
  };
}
function eD(r, e) {
  let t = r && r.basis && r.basis.format;
  return t === "auto" && (t = tD()), typeof t == "object" && (t = e ? t.alpha : t.noAlpha), t = t.toLowerCase(), VK[t];
}
function tD() {
  const r = NK();
  return r.has("astc") ? "astc-4x4" : r.has("dxt") ? {
    alpha: "bc3",
    noAlpha: "bc1"
  } : r.has("pvrtc") ? {
    alpha: "pvrtc1-4-rgba",
    noAlpha: "pvrtc1-4-rgb"
  } : r.has("etc1") ? "etc1" : r.has("etc2") ? "etc2" : "rgb565";
}
const WK = {
  dataType: null,
  batchType: null,
  name: "Basis",
  id: "basis",
  module: "textures",
  version: BK,
  worker: !0,
  extensions: ["basis", "ktx2"],
  mimeTypes: ["application/octet-stream", "image/ktx2"],
  tests: ["sB"],
  binary: !0,
  options: {
    basis: {
      format: "auto",
      libraryPath: "libs/",
      containerFormat: "auto",
      module: "transcoder"
    }
  }
}, $K = {
  ...WK,
  parse: jK
}, wp = !0, DS = 1735152710, aw = 12, c_ = 8, qK = 1313821514, XK = 5130562, ZK = 0, YK = 0, KK = 1;
function QK(r, e = 0) {
  return `${String.fromCharCode(r.getUint8(e + 0))}${String.fromCharCode(r.getUint8(e + 1))}${String.fromCharCode(r.getUint8(e + 2))}${String.fromCharCode(r.getUint8(e + 3))}`;
}
function JK(r, e = 0, t = {}) {
  const n = new DataView(r), { magic: i = DS } = t, s = n.getUint32(e, !1);
  return s === i || s === DS;
}
function eQ(r, e, t = 0, n = {}) {
  const i = new DataView(e), s = QK(i, t + 0), o = i.getUint32(t + 4, wp), l = i.getUint32(t + 8, wp);
  switch (Object.assign(r, {
    // Put less important stuff in a header, to avoid clutter
    header: {
      byteOffset: t,
      // Byte offset into the initial arrayBuffer
      byteLength: l,
      hasBinChunk: !1
    },
    type: s,
    version: o,
    json: {},
    binChunks: []
  }), t += aw, r.version) {
    case 1:
      return tQ(r, i, t);
    case 2:
      return rQ(r, i, t, n = {});
    default:
      throw new Error(`Invalid GLB version ${r.version}. Only supports version 1 and 2.`);
  }
}
function tQ(r, e, t) {
  _i(r.header.byteLength > aw + c_);
  const n = e.getUint32(t + 0, wp), i = e.getUint32(t + 4, wp);
  return t += c_, _i(i === ZK), r2(r, e, t, n), t += n, t += n2(r, e, t, r.header.byteLength), t;
}
function rQ(r, e, t, n) {
  return _i(r.header.byteLength > aw + c_), nQ(r, e, t, n), t + r.header.byteLength;
}
function nQ(r, e, t, n) {
  for (; t + 8 <= r.header.byteLength; ) {
    const i = e.getUint32(t + 0, wp), s = e.getUint32(t + 4, wp);
    switch (t += c_, s) {
      case qK:
        r2(r, e, t, i);
        break;
      case XK:
        n2(r, e, t, i);
        break;
      // Backward compatibility for very old xviz files
      case YK:
        n.strict || r2(r, e, t, i);
        break;
      case KK:
        n.strict || n2(r, e, t, i);
        break;
    }
    t += m0(i, 4);
  }
  return t;
}
function r2(r, e, t, n) {
  const i = new Uint8Array(e.buffer, t, n), o = new TextDecoder("utf8").decode(i);
  return r.json = JSON.parse(o), m0(n, 4);
}
function n2(r, e, t, n) {
  return r.header.hasBinChunk = !0, r.binChunks.push({
    byteOffset: t,
    byteLength: n,
    arrayBuffer: e.buffer
    // TODO - copy, or create typed array view?
  }), m0(n, 4);
}
function rD(r, e) {
  if (r.startsWith("data:") || r.startsWith("http:") || r.startsWith("https:"))
    return r;
  const n = e.baseUri || e.uri;
  if (!n)
    throw new Error(`'baseUri' must be provided to resolve relative url ${r}`);
  return n.substr(0, n.lastIndexOf("/") + 1) + r;
}
const iQ = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB", sQ = "B9h9z9tFBBBF8dL9gBB9gLaaaaaFa9gEaaaB9gGaaB9gFaFaEQSBBFBFFGEGEGIILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBNn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBcI9z9iqlBMc/j9JSIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMkRIbaG97FaK978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAnDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAnDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBRnCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBHiCFD9tAiAPD9OD9hD9RHiDQBTFtGmEYIPLdKeOnH8ZAIAQJDBIBHpCFD9tApAPD9OD9hD9RHpAIASJDBIBHyCFD9tAyAPD9OD9hD9RHyDQBTFtGmEYIPLdKeOnH8cDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAnD9uHnDyBjGBAEAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnA8ZA8cDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNiV8ZcpMyS8cQ8df8eb8fHdApAyDQNiV8ZcpMyS8cQ8df8eb8fHiDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/xLGEaK978jUUUUBCAlHE8kUUUUBGXGXAGCI9HQBGXAFC98ZHI9FQBABRGCBRLEXAGAGDBBBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMBBAGCTJRGALCIJHLAI9JQBMMAIAF9PQFAEAFCEZHLCGWHGqCBCTAGl/8MBAEABAICGWJHIAG/8cBBGXAL9FQBAEAEDBIBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMIBMAIAEAG/8cBBSFMABAFC98ZHGT+HUUUBAGAF9PQBAEAFCEZHICEWHLJCBCAALl/8MBAEABAGCEWJHGAL/8cBBAEAIT+HUUUBAGAEAL/8cBBMAECAJ8kUUUUBM+yEGGaO97GXAF9FQBCBRGEXABCTJHEAEDBBBHICBDtHLCUU98D8cFCUU98D8cEHKD9OABDBBBHOAIDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAOAIDQBFGENVcMTtmYi8ZpyHICTD+sFD/6FHND/gFAICTD+rFCTD+sFD/6FHVD/gFD/kFD/lFHI9DB/+g6DYAVAIALD+2FHLAVCUUUU94DtHcD9OD9RD/kFHVAVD/mFAIAID/mFANALANAcD9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHLD/kFCTD+rFAVAND/mFALD/kFCggEDtD9OD9QHVAIAND/mFALD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHIDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAOAKD9OAVAIDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM94FEa8jUUUUBCAlHE8kUUUUBABAFC98ZHIT+JUUUBGXAIAF9PQBAEAFCEZHLCEWHFJCBCAAFl/8MBAEABAICEWJHBAF/8cBBAEALT+JUUUBABAEAF/8cBBMAECAJ8kUUUUBM/hEIGaF97FaL978jUUUUBCTlRGGXAF9FQBCBREEXAGABDBBBHIABCTJHLDBBBHKDQILKOSQfbPden8c8d8e8fHOCTD+sFHNCID+rFDMIBAB9DBBU8/DY9D/zI818/DYANCEDtD9QD/6FD/nFHNAIAKDQBFGENVcMTtmYi8ZpyHICTD+rFCTD+sFD/6FD/mFHKAKD/mFANAICTD+sFD/6FD/mFHVAVD/mFANAOCTD+rFCTD+sFD/6FD/mFHOAOD/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHND/mF9DBBX9LDYHID/kFCggEDtHcD9OAVAND/mFAID/kFCTD+rFD9QHVAOAND/mFAID/kFCTD+rFAKAND/mFAID/kFAcD9OD9QHNDQBFTtGEmYILPdKOenHID8dBAGDBIBDyB+t+J83EBABCNJAID8dFAGDBIBDyF+t+J83EBALAVANDQNVi8ZcMpySQ8c8dfb8e8fHND8dBAGDBIBDyG+t+J83EBABCiJAND8dFAGDBIBDyE+t+J83EBABCAJRBAECIJHEAF9JQBMMM/3FGEaF978jUUUUBCoBlREGXAGCGrAF9sHIC98ZHL9FQBCBRGABRFEXAFAFDBBBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBAFCTJRFAGCIJHGAL9JQBMMGXALAI9PQBAEAICEZHGCGWHFqCBCoBAFl/8MBAEABALCGWJHLAF/8cBBGXAG9FQBAEAEDBIBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMIBMALAEAF/8cBBMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB", oQ = new Uint8Array([
  0,
  97,
  115,
  109,
  1,
  0,
  0,
  0,
  1,
  4,
  1,
  96,
  0,
  0,
  3,
  3,
  2,
  0,
  0,
  5,
  3,
  1,
  0,
  1,
  12,
  1,
  0,
  10,
  22,
  2,
  12,
  0,
  65,
  0,
  65,
  0,
  65,
  0,
  252,
  10,
  0,
  0,
  11,
  7,
  0,
  65,
  0,
  253,
  15,
  26,
  11
]), aQ = new Uint8Array([
  32,
  0,
  65,
  253,
  3,
  1,
  2,
  34,
  4,
  106,
  6,
  5,
  11,
  8,
  7,
  20,
  13,
  33,
  12,
  16,
  128,
  9,
  116,
  64,
  19,
  113,
  127,
  15,
  10,
  21,
  22,
  14,
  255,
  66,
  24,
  54,
  136,
  107,
  18,
  23,
  192,
  26,
  114,
  118,
  132,
  17,
  77,
  101,
  130,
  144,
  27,
  87,
  131,
  44,
  45,
  74,
  156,
  154,
  70,
  167
]), lQ = {
  // legacy index-based enums for glTF
  0: "",
  1: "meshopt_decodeFilterOct",
  2: "meshopt_decodeFilterQuat",
  3: "meshopt_decodeFilterExp",
  // string-based enums for glTF
  NONE: "",
  OCTAHEDRAL: "meshopt_decodeFilterOct",
  QUATERNION: "meshopt_decodeFilterQuat",
  EXPONENTIAL: "meshopt_decodeFilterExp"
}, cQ = {
  // legacy index-based enums for glTF
  0: "meshopt_decodeVertexBuffer",
  1: "meshopt_decodeIndexBuffer",
  2: "meshopt_decodeIndexSequence",
  // string-based enums for glTF
  ATTRIBUTES: "meshopt_decodeVertexBuffer",
  TRIANGLES: "meshopt_decodeIndexBuffer",
  INDICES: "meshopt_decodeIndexSequence"
};
async function uQ(r, e, t, n, i, s = "NONE") {
  const o = await fQ();
  pQ(o, o.exports[cQ[i]], r, e, t, n, o.exports[lQ[s || "NONE"]]);
}
let Kv;
async function fQ() {
  return Kv || (Kv = hQ()), Kv;
}
async function hQ() {
  let r = iQ;
  WebAssembly.validate(oQ) && (r = sQ, console.log("Warning: meshopt_decoder is using experimental SIMD support"));
  const e = await WebAssembly.instantiate(dQ(r), {});
  return await e.instance.exports.__wasm_call_ctors(), e.instance;
}
function dQ(r) {
  const e = new Uint8Array(r.length);
  for (let n = 0; n < r.length; ++n) {
    const i = r.charCodeAt(n);
    e[n] = i > 96 ? i - 71 : i > 64 ? i - 65 : i > 47 ? i + 4 : i > 46 ? 63 : 62;
  }
  let t = 0;
  for (let n = 0; n < r.length; ++n)
    e[t++] = e[n] < 60 ? aQ[e[n]] : (e[n] - 60) * 64 + e[++n];
  return e.buffer.slice(0, t);
}
function pQ(r, e, t, n, i, s, o) {
  const l = r.exports.sbrk, u = n + 3 & -4, m = l(u * i), y = l(s.length), E = new Uint8Array(r.exports.memory.buffer);
  E.set(s, y);
  const P = e(m, n, i, y, s.length);
  if (P === 0 && o && o(m, u, i), t.set(E.subarray(m, m + n * i)), l(m - l(0)), P !== 0)
    throw new Error(`Malformed buffer data: ${P}`);
}
const u_ = "EXT_meshopt_compression", AQ = u_;
async function gQ(r, e) {
  const t = new $s(r);
  if (!e?.gltf?.decompressMeshes || !e.gltf?.loadBuffers)
    return;
  const n = [];
  for (const i of r.json.bufferViews || [])
    n.push(mQ(t, i));
  await Promise.all(n), t.removeExtension(u_);
}
async function mQ(r, e) {
  const t = r.getObjectExtension(e, u_);
  if (t) {
    const { byteOffset: n = 0, byteLength: i = 0, byteStride: s, count: o, mode: l, filter: u = "NONE", buffer: m } = t, y = r.gltf.buffers[m], E = new Uint8Array(y.arrayBuffer, y.byteOffset + n, i), P = new Uint8Array(r.gltf.buffers[e.buffer].arrayBuffer, e.byteOffset, e.byteLength);
    await uQ(P, o, s, E, l, u), r.removeObjectExtension(e, u_);
  }
}
const _Q = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: gQ,
  name: AQ
}, Symbol.toStringTag, { value: "Module" })), Gd = "EXT_texture_webp", yQ = Gd;
function vQ(r, e) {
  const t = new $s(r);
  if (!Rz("image/webp")) {
    if (t.getRequiredExtensions().includes(Gd))
      throw new Error(`gltf: Required extension ${Gd} not supported by browser`);
    return;
  }
  const { json: n } = t;
  for (const i of n.textures || []) {
    const s = t.getObjectExtension(i, Gd);
    s && (i.source = s.source), t.removeObjectExtension(i, Gd);
  }
  t.removeExtension(Gd);
}
const bQ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  name: yQ,
  preprocess: vQ
}, Symbol.toStringTag, { value: "Module" })), Em = "KHR_texture_basisu", xQ = Em;
function wQ(r, e) {
  const t = new $s(r), { json: n } = t;
  for (const i of n.textures || []) {
    const s = t.getObjectExtension(i, Em);
    s && (i.source = s.source, t.removeObjectExtension(i, Em));
  }
  t.removeExtension(Em);
}
const TQ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  name: xQ,
  preprocess: wQ
}, Symbol.toStringTag, { value: "Module" })), EQ = "4.3.3", CQ = {
  dataType: null,
  batchType: null,
  name: "Draco",
  id: "draco",
  module: "draco",
  // shapes: ['mesh'],
  version: EQ,
  worker: !0,
  extensions: ["drc"],
  mimeTypes: ["application/octet-stream"],
  binary: !0,
  tests: ["DRACO"],
  options: {
    draco: {
      decoderType: typeof WebAssembly == "object" ? "wasm" : "js",
      // 'js' for IE11
      libraryPath: "libs/",
      extraAttributes: {},
      attributeNameEntry: void 0
    }
  }
};
function SQ(r, e, t) {
  const n = nD(e.metadata), i = [], s = IQ(e.attributes);
  for (const o in r) {
    const l = r[o], u = LS(o, l, s[o]);
    i.push(u);
  }
  if (t) {
    const o = LS("indices", t);
    i.push(o);
  }
  return { fields: i, metadata: n };
}
function IQ(r) {
  const e = {};
  for (const t in r) {
    const n = r[t];
    e[n.name || "undefined"] = n;
  }
  return e;
}
function LS(r, e, t) {
  const n = t ? nD(t.metadata) : void 0;
  return YU(r, e, n);
}
function nD(r) {
  Object.entries(r);
  const e = {};
  for (const t in r)
    e[`${t}.string`] = JSON.stringify(r[t]);
  return e;
}
const kS = {
  POSITION: "POSITION",
  NORMAL: "NORMAL",
  COLOR: "COLOR_0",
  TEX_COORD: "TEXCOORD_0"
}, PQ = {
  1: Int8Array,
  2: Uint8Array,
  3: Int16Array,
  4: Uint16Array,
  5: Int32Array,
  6: Uint32Array,
  // 7: BigInt64Array,
  // 8: BigUint64Array,
  9: Float32Array
  // 10: Float64Array
  // 11: BOOL - What array type do we use for this?
}, MQ = 4;
class RQ {
  draco;
  decoder;
  metadataQuerier;
  // draco - the draco decoder, either import `draco3d` or load dynamically
  constructor(e) {
    this.draco = e, this.decoder = new this.draco.Decoder(), this.metadataQuerier = new this.draco.MetadataQuerier();
  }
  /**
   * Destroy draco resources
   */
  destroy() {
    this.draco.destroy(this.decoder), this.draco.destroy(this.metadataQuerier);
  }
  /**
   * NOTE: caller must call `destroyGeometry` on the return value after using it
   * @param arrayBuffer
   * @param options
   */
  parseSync(e, t = {}) {
    const n = new this.draco.DecoderBuffer();
    n.Init(new Int8Array(e), e.byteLength), this._disableAttributeTransforms(t);
    const i = this.decoder.GetEncodedGeometryType(n), s = i === this.draco.TRIANGULAR_MESH ? new this.draco.Mesh() : new this.draco.PointCloud();
    try {
      let o;
      switch (i) {
        case this.draco.TRIANGULAR_MESH:
          o = this.decoder.DecodeBufferToMesh(n, s);
          break;
        case this.draco.POINT_CLOUD:
          o = this.decoder.DecodeBufferToPointCloud(n, s);
          break;
        default:
          throw new Error("DRACO: Unknown geometry type.");
      }
      if (!o.ok() || !s.ptr) {
        const P = `DRACO decompression failed: ${o.error_msg()}`;
        throw new Error(P);
      }
      const l = this._getDracoLoaderData(s, i, t), u = this._getMeshData(s, l, t), m = TB(u.attributes), y = SQ(u.attributes, l, u.indices);
      return {
        loader: "draco",
        loaderData: l,
        header: {
          vertexCount: s.num_points(),
          boundingBox: m
        },
        ...u,
        schema: y
      };
    } finally {
      this.draco.destroy(n), s && this.draco.destroy(s);
    }
  }
  // Draco specific "loader data"
  /**
   * Extract
   * @param dracoGeometry
   * @param geometry_type
   * @param options
   * @returns
   */
  _getDracoLoaderData(e, t, n) {
    const i = this._getTopLevelMetadata(e), s = this._getDracoAttributes(e, n);
    return {
      geometry_type: t,
      num_attributes: e.num_attributes(),
      num_points: e.num_points(),
      num_faces: e instanceof this.draco.Mesh ? e.num_faces() : 0,
      metadata: i,
      attributes: s
    };
  }
  /**
   * Extract all draco provided information and metadata for each attribute
   * @param dracoGeometry
   * @param options
   * @returns
   */
  _getDracoAttributes(e, t) {
    const n = {};
    for (let i = 0; i < e.num_attributes(); i++) {
      const s = this.decoder.GetAttribute(e, i), o = this._getAttributeMetadata(e, i);
      n[s.unique_id()] = {
        unique_id: s.unique_id(),
        attribute_type: s.attribute_type(),
        data_type: s.data_type(),
        num_components: s.num_components(),
        byte_offset: s.byte_offset(),
        byte_stride: s.byte_stride(),
        normalized: s.normalized(),
        attribute_index: i,
        metadata: o
      };
      const l = this._getQuantizationTransform(s, t);
      l && (n[s.unique_id()].quantization_transform = l);
      const u = this._getOctahedronTransform(s, t);
      u && (n[s.unique_id()].octahedron_transform = u);
    }
    return n;
  }
  /**
   * Get standard loaders.gl mesh category data
   * Extracts the geometry from draco
   * @param dracoGeometry
   * @param options
   */
  _getMeshData(e, t, n) {
    const i = this._getMeshAttributes(t, e, n);
    if (!i.POSITION)
      throw new Error("DRACO: No position attribute found.");
    if (e instanceof this.draco.Mesh)
      switch (n.topology) {
        case "triangle-strip":
          return {
            topology: "triangle-strip",
            mode: 4,
            // GL.TRIANGLES
            attributes: i,
            indices: {
              value: this._getTriangleStripIndices(e),
              size: 1
            }
          };
        case "triangle-list":
        default:
          return {
            topology: "triangle-list",
            mode: 5,
            // GL.TRIANGLE_STRIP
            attributes: i,
            indices: {
              value: this._getTriangleListIndices(e),
              size: 1
            }
          };
      }
    return {
      topology: "point-list",
      mode: 0,
      // GL.POINTS
      attributes: i
    };
  }
  _getMeshAttributes(e, t, n) {
    const i = {};
    for (const s of Object.values(e.attributes)) {
      const o = this._deduceAttributeName(s, n);
      s.name = o;
      const l = this._getAttributeValues(t, s);
      if (l) {
        const { value: u, size: m } = l;
        i[o] = {
          value: u,
          size: m,
          byteOffset: s.byte_offset,
          byteStride: s.byte_stride,
          normalized: s.normalized
        };
      }
    }
    return i;
  }
  // MESH INDICES EXTRACTION
  /**
   * For meshes, we need indices to define the faces.
   * @param dracoGeometry
   */
  _getTriangleListIndices(e) {
    const n = e.num_faces() * 3, i = n * MQ, s = this.draco._malloc(i);
    try {
      return this.decoder.GetTrianglesUInt32Array(e, i, s), new Uint32Array(this.draco.HEAPF32.buffer, s, n).slice();
    } finally {
      this.draco._free(s);
    }
  }
  /**
   * For meshes, we need indices to define the faces.
   * @param dracoGeometry
   */
  _getTriangleStripIndices(e) {
    const t = new this.draco.DracoInt32Array();
    try {
      return this.decoder.GetTriangleStripsFromMesh(e, t), DQ(t);
    } finally {
      this.draco.destroy(t);
    }
  }
  /**
   *
   * @param dracoGeometry
   * @param dracoAttribute
   * @param attributeName
   */
  _getAttributeValues(e, t) {
    const n = PQ[t.data_type];
    if (!n)
      return console.warn(`DRACO: Unsupported attribute type ${t.data_type}`), null;
    const i = t.num_components, o = e.num_points() * i, l = o * n.BYTES_PER_ELEMENT, u = BQ(this.draco, n);
    let m;
    const y = this.draco._malloc(l);
    try {
      const E = this.decoder.GetAttribute(e, t.attribute_index);
      this.decoder.GetAttributeDataArrayForAllPoints(e, E, u, l, y), m = new n(this.draco.HEAPF32.buffer, y, o).slice();
    } finally {
      this.draco._free(y);
    }
    return { value: m, size: i };
  }
  // Attribute names
  /**
   * DRACO does not store attribute names - We need to deduce an attribute name
   * for each attribute
  _getAttributeNames(
    dracoGeometry: Mesh | PointCloud,
    options: DracoParseOptions
  ): {[unique_id: number]: string} {
    const attributeNames: {[unique_id: number]: string} = {};
    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {
      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);
      const attributeName = this._deduceAttributeName(dracoAttribute, options);
      attributeNames[attributeName] = attributeName;
    }
    return attributeNames;
  }
   */
  /**
   * Deduce an attribute name.
   * @note DRACO does not save attribute names, just general type (POSITION, COLOR)
   * to help optimize compression. We generate GLTF compatible names for the Draco-recognized
   * types
   * @param attributeData
   */
  _deduceAttributeName(e, t) {
    const n = e.unique_id;
    for (const [o, l] of Object.entries(t.extraAttributes || {}))
      if (l === n)
        return o;
    const i = e.attribute_type;
    for (const o in kS)
      if (this.draco[o] === i)
        return kS[o];
    const s = t.attributeNameEntry || "name";
    return e.metadata[s] ? e.metadata[s].string : `CUSTOM_ATTRIBUTE_${n}`;
  }
  // METADATA EXTRACTION
  /** Get top level metadata */
  _getTopLevelMetadata(e) {
    const t = this.decoder.GetMetadata(e);
    return this._getDracoMetadata(t);
  }
  /** Get per attribute metadata */
  _getAttributeMetadata(e, t) {
    const n = this.decoder.GetAttributeMetadata(e, t);
    return this._getDracoMetadata(n);
  }
  /**
   * Extract metadata field values
   * @param dracoMetadata
   * @returns
   */
  _getDracoMetadata(e) {
    if (!e || !e.ptr)
      return {};
    const t = {}, n = this.metadataQuerier.NumEntries(e);
    for (let i = 0; i < n; i++) {
      const s = this.metadataQuerier.GetEntryName(e, i);
      t[s] = this._getDracoMetadataField(e, s);
    }
    return t;
  }
  /**
   * Extracts possible values for one metadata entry by name
   * @param dracoMetadata
   * @param entryName
   */
  _getDracoMetadataField(e, t) {
    const n = new this.draco.DracoInt32Array();
    try {
      this.metadataQuerier.GetIntEntryArray(e, t, n);
      const i = OQ(n);
      return {
        int: this.metadataQuerier.GetIntEntry(e, t),
        string: this.metadataQuerier.GetStringEntry(e, t),
        double: this.metadataQuerier.GetDoubleEntry(e, t),
        intArray: i
      };
    } finally {
      this.draco.destroy(n);
    }
  }
  // QUANTIZED ATTRIBUTE SUPPORT (NO DECOMPRESSION)
  /** Skip transforms for specific attribute types */
  _disableAttributeTransforms(e) {
    const { quantizedAttributes: t = [], octahedronAttributes: n = [] } = e, i = [...t, ...n];
    for (const s of i)
      this.decoder.SkipAttributeTransform(this.draco[s]);
  }
  /**
   * Extract (and apply?) Position Transform
   * @todo not used
   */
  _getQuantizationTransform(e, t) {
    const { quantizedAttributes: n = [] } = t, i = e.attribute_type();
    if (n.map((o) => this.decoder[o]).includes(i)) {
      const o = new this.draco.AttributeQuantizationTransform();
      try {
        if (o.InitFromAttribute(e))
          return {
            quantization_bits: o.quantization_bits(),
            range: o.range(),
            min_values: new Float32Array([1, 2, 3]).map((l) => o.min_value(l))
          };
      } finally {
        this.draco.destroy(o);
      }
    }
    return null;
  }
  _getOctahedronTransform(e, t) {
    const { octahedronAttributes: n = [] } = t, i = e.attribute_type();
    if (n.map((o) => this.decoder[o]).includes(i)) {
      const o = new this.draco.AttributeQuantizationTransform();
      try {
        if (o.InitFromAttribute(e))
          return {
            quantization_bits: o.quantization_bits()
          };
      } finally {
        this.draco.destroy(o);
      }
    }
    return null;
  }
}
function BQ(r, e) {
  switch (e) {
    case Float32Array:
      return r.DT_FLOAT32;
    case Int8Array:
      return r.DT_INT8;
    case Int16Array:
      return r.DT_INT16;
    case Int32Array:
      return r.DT_INT32;
    case Uint8Array:
      return r.DT_UINT8;
    case Uint16Array:
      return r.DT_UINT16;
    case Uint32Array:
      return r.DT_UINT32;
    default:
      return r.DT_INVALID;
  }
}
function OQ(r) {
  const e = r.size(), t = new Int32Array(e);
  for (let n = 0; n < e; n++)
    t[n] = r.GetValue(n);
  return t;
}
function DQ(r) {
  const e = r.size(), t = new Int32Array(e);
  for (let n = 0; n < e; n++)
    t[n] = r.GetValue(n);
  return t;
}
const LQ = "1.5.6", kQ = "1.4.1", Qv = `https://www.gstatic.com/draco/versioned/decoders/${LQ}`, Zo = {
  /** The primary Draco3D encoder, javascript wrapper part */
  DECODER: "draco_wasm_wrapper.js",
  /** The primary draco decoder, compiled web assembly part */
  DECODER_WASM: "draco_decoder.wasm",
  /** Fallback decoder for non-webassebly environments. Very big bundle, lower performance */
  FALLBACK_DECODER: "draco_decoder.js",
  /** Draco encoder */
  ENCODER: "draco_encoder.js"
}, Jv = {
  [Zo.DECODER]: `${Qv}/${Zo.DECODER}`,
  [Zo.DECODER_WASM]: `${Qv}/${Zo.DECODER_WASM}`,
  [Zo.FALLBACK_DECODER]: `${Qv}/${Zo.FALLBACK_DECODER}`,
  [Zo.ENCODER]: `https://raw.githubusercontent.com/google/draco/${kQ}/javascript/${Zo.ENCODER}`
};
let e1;
async function FQ(r) {
  const e = r.modules || {};
  return e.draco3d ? e1 ||= e.draco3d.createDecoderModule({}).then((t) => ({ draco: t })) : e1 ||= NQ(r), await e1;
}
async function NQ(r) {
  let e, t;
  switch (r.draco && r.draco.decoderType) {
    case "js":
      e = await Xf(Jv[Zo.FALLBACK_DECODER], "draco", r, Zo.FALLBACK_DECODER);
      break;
    case "wasm":
    default:
      [e, t] = await Promise.all([
        await Xf(Jv[Zo.DECODER], "draco", r, Zo.DECODER),
        await Xf(Jv[Zo.DECODER_WASM], "draco", r, Zo.DECODER_WASM)
      ]);
  }
  return e = e || globalThis.DracoDecoderModule, await UQ(e, t);
}
function UQ(r, e) {
  const t = {};
  return e && (t.wasmBinary = e), new Promise((n) => {
    r({
      ...t,
      onModuleLoaded: (i) => n({ draco: i })
      // Module is Promise-like. Wrap in object to avoid loop.
    });
  });
}
const iD = {
  ...CQ,
  parse: zQ
};
async function zQ(r, e) {
  const { draco: t } = await FQ(e), n = new RQ(t);
  try {
    return n.parseSync(r, e?.draco);
  } finally {
    n.destroy();
  }
}
function VQ(r) {
  const e = {};
  for (const t in r) {
    const n = r[t];
    if (t !== "indices") {
      const i = sD(n);
      e[t] = i;
    }
  }
  return e;
}
function sD(r) {
  const { buffer: e, size: t, count: n } = jQ(r);
  return {
    // glTF Accessor values
    // TODO: Instead of a bufferView index we could have an actual buffer (typed array)
    // bufferView: null,
    // TODO: Deprecate `value` in favor of bufferView?
    // @ts-ignore
    value: e,
    size: t,
    // Decoded `type` (e.g. SCALAR)
    byteOffset: 0,
    count: n,
    type: W6(t),
    componentType: $_(e)
  };
}
function jQ(r) {
  let e = r, t = 1, n = 0;
  return r && r.value && (e = r.value, t = r.size || 1), e && (ArrayBuffer.isView(e) || (e = HQ(e, Float32Array)), n = e.length / t), { buffer: e, size: t, count: n };
}
function HQ(r, e, t = !1) {
  return r ? Array.isArray(r) ? new e(r) : t && !(r instanceof e) ? new e(r) : r : null;
}
const Yu = "KHR_draco_mesh_compression", GQ = Yu;
function WQ(r, e, t) {
  const n = new $s(r);
  for (const i of oD(n))
    n.getObjectExtension(i, Yu);
}
async function $Q(r, e, t) {
  if (!e?.gltf?.decompressMeshes)
    return;
  const n = new $s(r), i = [];
  for (const s of oD(n))
    n.getObjectExtension(s, Yu) && i.push(XQ(n, s, e, t));
  await Promise.all(i), n.removeExtension(Yu);
}
function qQ(r, e = {}) {
  const t = new $s(r);
  for (const n of t.json.meshes || [])
    ZQ(n), t.addRequiredExtension(Yu);
}
async function XQ(r, e, t, n) {
  const i = r.getObjectExtension(e, Yu);
  if (!i)
    return;
  const s = r.getTypedArrayForBufferView(i.bufferView), o = Q2(s.buffer, s.byteOffset), l = { ...t };
  delete l["3d-tiles"];
  const u = await g0(o, iD, l, n), m = VQ(u.attributes);
  for (const [y, E] of Object.entries(m))
    if (y in e.attributes) {
      const P = e.attributes[y], L = r.getAccessor(P);
      L?.min && L?.max && (E.min = L.min, E.max = L.max);
    }
  e.attributes = m, u.indices && (e.indices = sD(u.indices)), r.removeObjectExtension(e, Yu), YQ(e);
}
function ZQ(r, e, t = 4, n, i) {
  if (!n.DracoWriter)
    throw new Error("options.gltf.DracoWriter not provided");
  const s = n.DracoWriter.encodeSync({ attributes: r }), o = i?.parseSync?.({ attributes: r }), l = n._addFauxAttributes(o.attributes), u = n.addBufferView(s);
  return {
    primitives: [
      {
        attributes: l,
        // TODO - verify with spec
        mode: t,
        // GL.POINTS
        extensions: {
          [Yu]: {
            bufferView: u,
            attributes: l
            // TODO - verify with spec
          }
        }
      }
    ]
  };
}
function YQ(r) {
  if (!r.attributes && Object.keys(r.attributes).length > 0)
    throw new Error("glTF: Empty primitive detected: Draco decompression failure?");
}
function* oD(r) {
  for (const e of r.json.meshes || [])
    for (const t of e.primitives)
      yield t;
}
const KQ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: $Q,
  encode: qQ,
  name: GQ,
  preprocess: WQ
}, Symbol.toStringTag, { value: "Module" })), Z_ = "KHR_texture_transform", QQ = Z_, Mg = new yt(), JQ = new es(), eJ = new es();
async function tJ(r, e) {
  if (!new $s(r).hasExtension(Z_) || !e.gltf?.loadBuffers)
    return;
  const i = r.json.materials || [];
  for (let s = 0; s < i.length; s++)
    rJ(s, r);
}
function rJ(r, e) {
  const t = e.json.materials?.[r], n = [
    t?.pbrMetallicRoughness?.baseColorTexture,
    t?.emissiveTexture,
    t?.normalTexture,
    t?.occlusionTexture,
    t?.pbrMetallicRoughness?.metallicRoughnessTexture
  ], i = [];
  for (const s of n)
    s && s?.extensions?.[Z_] && nJ(e, r, s, i);
}
function nJ(r, e, t, n) {
  const i = iJ(t, n);
  if (!i)
    return;
  const s = r.json.meshes || [];
  for (const o of s)
    for (const l of o.primitives) {
      const u = l.material;
      Number.isFinite(u) && e === u && sJ(r, l, i);
    }
}
function iJ(r, e) {
  const t = r.extensions?.[Z_], { texCoord: n = 0 } = r, { texCoord: i = n } = t;
  if (!(e.findIndex(([o, l]) => o === n && l === i) !== -1)) {
    const o = lJ(t);
    return n !== i && (r.texCoord = i), e.push([n, i]), { originalTexCoord: n, texCoord: i, matrix: o };
  }
  return null;
}
function sJ(r, e, t) {
  const { originalTexCoord: n, texCoord: i, matrix: s } = t, o = e.attributes[`TEXCOORD_${n}`];
  if (Number.isFinite(o)) {
    const l = r.json.accessors?.[o];
    if (l && l.bufferView) {
      const u = r.json.bufferViews?.[l.bufferView];
      if (u) {
        const { arrayBuffer: m, byteOffset: y } = r.buffers[u.buffer], E = (y || 0) + (l.byteOffset || 0) + (u.byteOffset || 0), { ArrayType: P, length: L } = nw(l, u), U = G6[l.componentType], V = H6[l.type], q = u.byteStride || U * V, j = new Float32Array(L);
        for (let K = 0; K < l.count; K++) {
          const Y = new P(m, E + K * q, 2);
          Mg.set(Y[0], Y[1], 1), Mg.transformByMatrix3(s), j.set([Mg[0], Mg[1]], K * V);
        }
        n === i ? oJ(l, u, r.buffers, j) : aJ(i, l, e, r, j);
      }
    }
  }
}
function oJ(r, e, t, n) {
  r.componentType = 5126, t.push({
    arrayBuffer: n.buffer,
    byteOffset: 0,
    byteLength: n.buffer.byteLength
  }), e.buffer = t.length - 1, e.byteLength = n.buffer.byteLength, e.byteOffset = 0, delete e.byteStride;
}
function aJ(r, e, t, n, i) {
  n.buffers.push({
    arrayBuffer: i.buffer,
    byteOffset: 0,
    byteLength: i.buffer.byteLength
  });
  const s = n.json.bufferViews;
  if (!s)
    return;
  s.push({
    buffer: n.buffers.length - 1,
    byteLength: i.buffer.byteLength,
    byteOffset: 0
  });
  const o = n.json.accessors;
  o && (o.push({
    bufferView: s?.length - 1,
    byteOffset: 0,
    componentType: 5126,
    count: e.count,
    type: "VEC2"
  }), t.attributes[`TEXCOORD_${r}`] = o.length - 1);
}
function lJ(r) {
  const { offset: e = [0, 0], rotation: t = 0, scale: n = [1, 1] } = r, i = new es().set(1, 0, 0, 0, 1, 0, e[0], e[1], 1), s = JQ.set(Math.cos(t), Math.sin(t), 0, -Math.sin(t), Math.cos(t), 0, 0, 0, 1), o = eJ.set(n[0], 0, 0, 0, n[1], 0, 0, 0, 1);
  return i.multiplyRight(s).multiplyRight(o);
}
const cJ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: tJ,
  name: QQ
}, Symbol.toStringTag, { value: "Module" })), $f = "KHR_lights_punctual", uJ = $f;
async function fJ(r) {
  const e = new $s(r), { json: t } = e, n = e.getExtension($f);
  n && (e.json.lights = n.lights, e.removeExtension($f));
  for (const i of t.nodes || []) {
    const s = e.getObjectExtension(i, $f);
    s && (i.light = s.light), e.removeObjectExtension(i, $f);
  }
}
async function hJ(r) {
  const e = new $s(r), { json: t } = e;
  if (t.lights) {
    const n = e.addExtension($f);
    da(!n.lights), n.lights = t.lights, delete t.lights;
  }
  if (e.json.lights) {
    for (const n of e.json.lights) {
      const i = n.node;
      e.addObjectExtension(i, $f, n);
    }
    delete e.json.lights;
  }
}
const dJ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: fJ,
  encode: hJ,
  name: uJ
}, Symbol.toStringTag, { value: "Module" })), l0 = "KHR_materials_unlit", pJ = l0;
async function AJ(r) {
  const e = new $s(r), { json: t } = e;
  for (const n of t.materials || [])
    n.extensions && n.extensions.KHR_materials_unlit && (n.unlit = !0), e.removeObjectExtension(n, l0);
  e.removeExtension(l0);
}
function gJ(r) {
  const e = new $s(r), { json: t } = e;
  if (e.materials)
    for (const n of t.materials || [])
      n.unlit && (delete n.unlit, e.addObjectExtension(n, l0, {}), e.addExtension(l0));
}
const mJ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: AJ,
  encode: gJ,
  name: pJ
}, Symbol.toStringTag, { value: "Module" })), DA = "KHR_techniques_webgl", _J = DA;
async function yJ(r) {
  const e = new $s(r), { json: t } = e, n = e.getExtension(DA);
  if (n) {
    const i = bJ(n, e);
    for (const s of t.materials || []) {
      const o = e.getObjectExtension(s, DA);
      o && (s.technique = Object.assign(
        {},
        o,
        // @ts-ignore
        i[o.technique]
      ), s.technique.values = xJ(s.technique, e)), e.removeObjectExtension(s, DA);
    }
    e.removeExtension(DA);
  }
}
async function vJ(r, e) {
}
function bJ(r, e) {
  const { programs: t = [], shaders: n = [], techniques: i = [] } = r, s = new TextDecoder();
  return n.forEach((o) => {
    if (Number.isFinite(o.bufferView))
      o.code = s.decode(e.getTypedArrayForBufferView(o.bufferView));
    else
      throw new Error("KHR_techniques_webgl: no shader code");
  }), t.forEach((o) => {
    o.fragmentShader = n[o.fragmentShader], o.vertexShader = n[o.vertexShader];
  }), i.forEach((o) => {
    o.program = t[o.program];
  }), i;
}
function xJ(r, e) {
  const t = Object.assign({}, r.values);
  return Object.keys(r.uniforms || {}).forEach((n) => {
    r.uniforms[n].value && !(n in t) && (t[n] = r.uniforms[n].value);
  }), Object.keys(t).forEach((n) => {
    typeof t[n] == "object" && t[n].index !== void 0 && (t[n].texture = e.getTexture(t[n].index));
  }), t;
}
const wJ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: yJ,
  encode: vJ,
  name: _J
}, Symbol.toStringTag, { value: "Module" })), aD = [
  // 1.0
  // KHR_binary_gltf is handled separately - must be processed before other parsing starts
  // KHR_binary_gltf,
  // 2.0
  dK,
  NY,
  _Q,
  bQ,
  // Basisu should come after webp, we want basisu to be preferred if both are provided
  TQ,
  KQ,
  dJ,
  mJ,
  wJ,
  cJ,
  MK
];
function TJ(r, e = {}, t) {
  const n = aD.filter((i) => lD(i.name, e));
  for (const i of n)
    i.preprocess?.(r, e, t);
}
async function EJ(r, e = {}, t) {
  const n = aD.filter((i) => lD(i.name, e));
  for (const i of n)
    await i.decode?.(r, e, t);
}
function lD(r, e) {
  const t = e?.gltf?.excludeExtensions || {};
  return !(r in t && !t[r]);
}
const t1 = "KHR_binary_glTF";
function CJ(r) {
  const e = new $s(r), { json: t } = e;
  for (const n of t.images || []) {
    const i = e.getObjectExtension(n, t1);
    i && Object.assign(n, i), e.removeObjectExtension(n, t1);
  }
  t.buffers && t.buffers[0] && delete t.buffers[0].uri, e.removeExtension(t1);
}
const FS = {
  accessors: "accessor",
  animations: "animation",
  buffers: "buffer",
  bufferViews: "bufferView",
  images: "image",
  materials: "material",
  meshes: "mesh",
  nodes: "node",
  samplers: "sampler",
  scenes: "scene",
  skins: "skin",
  textures: "texture"
}, SJ = {
  accessor: "accessors",
  animations: "animation",
  buffer: "buffers",
  bufferView: "bufferViews",
  image: "images",
  material: "materials",
  mesh: "meshes",
  node: "nodes",
  sampler: "samplers",
  scene: "scenes",
  skin: "skins",
  texture: "textures"
};
class IJ {
  idToIndexMap = {
    animations: {},
    accessors: {},
    buffers: {},
    bufferViews: {},
    images: {},
    materials: {},
    meshes: {},
    nodes: {},
    samplers: {},
    scenes: {},
    skins: {},
    textures: {}
  };
  json;
  // constructor() {}
  /**
   * Convert (normalize) glTF < 2.0 to glTF 2.0
   * @param gltf - object with json and binChunks
   * @param options
   * @param options normalize Whether to actually normalize
   */
  normalize(e, t) {
    this.json = e.json;
    const n = e.json;
    switch (n.asset && n.asset.version) {
      // We are converting to v2 format. Return if there is nothing to do
      case "2.0":
        return;
      // This class is written to convert 1.0
      case void 0:
      case "1.0":
        break;
      default:
        console.warn(`glTF: Unknown version ${n.asset.version}`);
        return;
    }
    if (!t.normalize)
      throw new Error("glTF v1 is not supported.");
    console.warn("Converting glTF v1 to glTF v2 format. This is experimental and may fail."), this._addAsset(n), this._convertTopLevelObjectsToArrays(n), CJ(e), this._convertObjectIdsToArrayIndices(n), this._updateObjects(n), this._updateMaterial(n);
  }
  // asset is now required, #642 https://github.com/KhronosGroup/glTF/issues/639
  _addAsset(e) {
    e.asset = e.asset || {}, e.asset.version = "2.0", e.asset.generator = e.asset.generator || "Normalized to glTF 2.0 by loaders.gl";
  }
  _convertTopLevelObjectsToArrays(e) {
    for (const t in FS)
      this._convertTopLevelObjectToArray(e, t);
  }
  /** Convert one top level object to array */
  _convertTopLevelObjectToArray(e, t) {
    const n = e[t];
    if (!(!n || Array.isArray(n))) {
      e[t] = [];
      for (const i in n) {
        const s = n[i];
        s.id = s.id || i;
        const o = e[t].length;
        e[t].push(s), this.idToIndexMap[t][i] = o;
      }
    }
  }
  /** Go through all objects in all top-level arrays and replace ids with indices */
  _convertObjectIdsToArrayIndices(e) {
    for (const t in FS)
      this._convertIdsToIndices(e, t);
    "scene" in e && (e.scene = this._convertIdToIndex(e.scene, "scene"));
    for (const t of e.textures)
      this._convertTextureIds(t);
    for (const t of e.meshes)
      this._convertMeshIds(t);
    for (const t of e.nodes)
      this._convertNodeIds(t);
    for (const t of e.scenes)
      this._convertSceneIds(t);
  }
  _convertTextureIds(e) {
    e.source && (e.source = this._convertIdToIndex(e.source, "image"));
  }
  _convertMeshIds(e) {
    for (const t of e.primitives) {
      const { attributes: n, indices: i, material: s } = t;
      for (const o in n)
        n[o] = this._convertIdToIndex(n[o], "accessor");
      i && (t.indices = this._convertIdToIndex(i, "accessor")), s && (t.material = this._convertIdToIndex(s, "material"));
    }
  }
  _convertNodeIds(e) {
    e.children && (e.children = e.children.map((t) => this._convertIdToIndex(t, "node"))), e.meshes && (e.meshes = e.meshes.map((t) => this._convertIdToIndex(t, "mesh")));
  }
  _convertSceneIds(e) {
    e.nodes && (e.nodes = e.nodes.map((t) => this._convertIdToIndex(t, "node")));
  }
  /** Go through all objects in a top-level array and replace ids with indices */
  _convertIdsToIndices(e, t) {
    e[t] || (console.warn(`gltf v1: json doesn't contain attribute ${t}`), e[t] = []);
    for (const n of e[t])
      for (const i in n) {
        const s = n[i], o = this._convertIdToIndex(s, i);
        n[i] = o;
      }
  }
  _convertIdToIndex(e, t) {
    const n = SJ[t];
    if (n in this.idToIndexMap) {
      const i = this.idToIndexMap[n][e];
      if (!Number.isFinite(i))
        throw new Error(`gltf v1: failed to resolve ${t} with id ${e}`);
      return i;
    }
    return e;
  }
  /**
   *
   * @param {*} json
   */
  _updateObjects(e) {
    for (const t of this.json.buffers)
      delete t.type;
  }
  /**
   * Update material (set pbrMetallicRoughness)
   * @param {*} json
   */
  _updateMaterial(e) {
    for (const t of e.materials) {
      t.pbrMetallicRoughness = {
        baseColorFactor: [1, 1, 1, 1],
        metallicFactor: 1,
        roughnessFactor: 1
      };
      const n = t.values?.tex || t.values?.texture2d_0 || t.values?.diffuseTex, i = e.textures.findIndex((s) => s.id === n);
      i !== -1 && (t.pbrMetallicRoughness.baseColorTexture = { index: i });
    }
  }
}
function PJ(r, e = {}) {
  return new IJ().normalize(r, e);
}
async function MJ(r, e, t = 0, n, i) {
  return RJ(r, e, t, n), PJ(r, { normalize: n?.gltf?.normalize }), TJ(r, n, i), n?.gltf?.loadBuffers && r.json.buffers && await BJ(r, n, i), n?.gltf?.loadImages && await OJ(r, n, i), await EJ(r, n, i), r;
}
function RJ(r, e, t, n) {
  if (n.uri && (r.baseUri = n.uri), e instanceof ArrayBuffer && !JK(e, t, n) && (e = new TextDecoder().decode(e)), typeof e == "string")
    r.json = w5(e);
  else if (e instanceof ArrayBuffer) {
    const o = {};
    t = eQ(o, e, t, n.glb), da(o.type === "glTF", `Invalid GLB magic string ${o.type}`), r._glb = o, r.json = o.json;
  } else
    da(!1, "GLTF: must be ArrayBuffer or string");
  const i = r.json.buffers || [];
  if (r.buffers = new Array(i.length).fill(null), r._glb && r._glb.header.hasBinChunk) {
    const { binChunks: o } = r._glb;
    r.buffers[0] = {
      arrayBuffer: o[0].arrayBuffer,
      byteOffset: o[0].byteOffset,
      byteLength: o[0].byteLength
    };
  }
  const s = r.json.images || [];
  r.images = new Array(s.length).fill({});
}
async function BJ(r, e, t) {
  const n = r.json.buffers || [];
  for (let i = 0; i < n.length; ++i) {
    const s = n[i];
    if (s.uri) {
      const { fetch: o } = t;
      da(o);
      const l = rD(s.uri, e), m = await (await t?.fetch?.(l))?.arrayBuffer?.();
      r.buffers[i] = {
        arrayBuffer: m,
        byteOffset: 0,
        byteLength: m.byteLength
      }, delete s.uri;
    } else r.buffers[i] === null && (r.buffers[i] = {
      arrayBuffer: new ArrayBuffer(s.byteLength),
      byteOffset: 0,
      byteLength: s.byteLength
    });
  }
}
async function OJ(r, e, t) {
  const n = DJ(r), i = r.json.images || [], s = [];
  for (const o of n)
    s.push(LJ(r, i[o], o, e, t));
  return await Promise.all(s);
}
function DJ(r) {
  const e = /* @__PURE__ */ new Set(), t = r.json.textures || [];
  for (const n of t)
    n.source !== void 0 && e.add(n.source);
  return Array.from(e).sort();
}
async function LJ(r, e, t, n, i) {
  let s;
  if (e.uri && !e.hasOwnProperty("bufferView")) {
    const l = rD(e.uri, n), { fetch: u } = i;
    s = await (await u(l)).arrayBuffer(), e.bufferView = {
      data: s
    };
  }
  if (Number.isFinite(e.bufferView)) {
    const l = wY(r.json, r.buffers, e.bufferView);
    s = Q2(l.buffer, l.byteOffset, l.byteLength);
  }
  da(s, "glTF image has no data");
  let o = await g0(s, [Gm, $K], {
    ...n,
    mimeType: e.mimeType,
    basis: n.basis || { format: tD() }
  }, i);
  o && o[0] && (o = {
    compressed: !0,
    // @ts-expect-error
    mipmaps: !1,
    width: o[0].width,
    height: o[0].height,
    data: o[0]
  }), r.images = r.images || [], r.images[t] = o;
}
const Tp = {
  dataType: null,
  batchType: null,
  name: "glTF",
  id: "gltf",
  module: "gltf",
  version: RK,
  extensions: ["gltf", "glb"],
  mimeTypes: ["model/gltf+json", "model/gltf-binary"],
  text: !0,
  binary: !0,
  tests: ["glTF"],
  parse: kJ,
  options: {
    gltf: {
      normalize: !0,
      // Normalize glTF v1 to glTF v2 format (not yet stable)
      loadBuffers: !0,
      // Fetch any linked .BIN buffers, decode base64
      loadImages: !0,
      // Create image objects
      decompressMeshes: !0
      // Decompress Draco encoded meshes
    },
    // common?
    log: console
    // eslint-disable-line
  }
};
async function kJ(r, e = {}, t) {
  e = { ...Tp.options, ...e }, e.gltf = { ...Tp.options.gltf, ...e.gltf };
  const { byteOffset: n = 0 } = e;
  return await MJ({}, r, n, e, t);
}
const FJ = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, NJ = {
  5120: 1,
  // BYTE
  5121: 1,
  // UNSIGNED_BYTE
  5122: 2,
  // SHORT
  5123: 2,
  // UNSIGNED_SHORT
  5125: 4,
  // UNSIGNED_INT
  5126: 4
  // FLOAT
}, Ma = {
  // Sampler parameters
  TEXTURE_MAG_FILTER: 10240,
  TEXTURE_MIN_FILTER: 10241,
  TEXTURE_WRAP_S: 10242,
  TEXTURE_WRAP_T: 10243,
  // Sampler default values
  REPEAT: 10497,
  LINEAR: 9729,
  NEAREST_MIPMAP_LINEAR: 9986
}, UJ = {
  magFilter: Ma.TEXTURE_MAG_FILTER,
  minFilter: Ma.TEXTURE_MIN_FILTER,
  wrapS: Ma.TEXTURE_WRAP_S,
  wrapT: Ma.TEXTURE_WRAP_T
}, zJ = {
  [Ma.TEXTURE_MAG_FILTER]: Ma.LINEAR,
  [Ma.TEXTURE_MIN_FILTER]: Ma.NEAREST_MIPMAP_LINEAR,
  [Ma.TEXTURE_WRAP_S]: Ma.REPEAT,
  [Ma.TEXTURE_WRAP_T]: Ma.REPEAT
};
function VJ() {
  return {
    id: "default-sampler",
    parameters: zJ
  };
}
function jJ(r) {
  return NJ[r];
}
function HJ(r) {
  return FJ[r];
}
class GJ {
  baseUri = "";
  // @ts-expect-error
  jsonUnprocessed;
  // @ts-expect-error
  json;
  buffers = [];
  images = [];
  postProcess(e, t = {}) {
    const { json: n, buffers: i = [], images: s = [] } = e, { baseUri: o = "" } = e;
    return da(n), this.baseUri = o, this.buffers = i, this.images = s, this.jsonUnprocessed = n, this.json = this._resolveTree(e.json, t), this.json;
  }
  // Convert indexed glTF structure into tree structure
  // cross-link index resolution, enum lookup, convenience calculations
  // eslint-disable-next-line complexity, max-statements
  _resolveTree(e, t = {}) {
    const n = { ...e };
    return this.json = n, e.bufferViews && (n.bufferViews = e.bufferViews.map((i, s) => this._resolveBufferView(i, s))), e.images && (n.images = e.images.map((i, s) => this._resolveImage(i, s))), e.samplers && (n.samplers = e.samplers.map((i, s) => this._resolveSampler(i, s))), e.textures && (n.textures = e.textures.map((i, s) => this._resolveTexture(i, s))), e.accessors && (n.accessors = e.accessors.map((i, s) => this._resolveAccessor(i, s))), e.materials && (n.materials = e.materials.map((i, s) => this._resolveMaterial(i, s))), e.meshes && (n.meshes = e.meshes.map((i, s) => this._resolveMesh(i, s))), e.nodes && (n.nodes = e.nodes.map((i, s) => this._resolveNode(i, s)), n.nodes = n.nodes.map((i, s) => this._resolveNodeChildren(i))), e.skins && (n.skins = e.skins.map((i, s) => this._resolveSkin(i, s))), e.scenes && (n.scenes = e.scenes.map((i, s) => this._resolveScene(i, s))), typeof this.json.scene == "number" && n.scenes && (n.scene = n.scenes[this.json.scene]), n;
  }
  getScene(e) {
    return this._get(this.json.scenes, e);
  }
  getNode(e) {
    return this._get(this.json.nodes, e);
  }
  getSkin(e) {
    return this._get(this.json.skins, e);
  }
  getMesh(e) {
    return this._get(this.json.meshes, e);
  }
  getMaterial(e) {
    return this._get(this.json.materials, e);
  }
  getAccessor(e) {
    return this._get(this.json.accessors, e);
  }
  getCamera(e) {
    return this._get(this.json.cameras, e);
  }
  getTexture(e) {
    return this._get(this.json.textures, e);
  }
  getSampler(e) {
    return this._get(this.json.samplers, e);
  }
  getImage(e) {
    return this._get(this.json.images, e);
  }
  getBufferView(e) {
    return this._get(this.json.bufferViews, e);
  }
  getBuffer(e) {
    return this._get(this.json.buffers, e);
  }
  _get(e, t) {
    if (typeof t == "object")
      return t;
    const n = e && e[t];
    return n || console.warn(`glTF file error: Could not find ${e}[${t}]`), n;
  }
  // PARSING HELPERS
  _resolveScene(e, t) {
    return {
      ...e,
      // @ts-ignore
      id: e.id || `scene-${t}`,
      nodes: (e.nodes || []).map((n) => this.getNode(n))
    };
  }
  _resolveNode(e, t) {
    const n = {
      ...e,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: e?.id || `node-${t}`
    };
    return e.mesh !== void 0 && (n.mesh = this.getMesh(e.mesh)), e.camera !== void 0 && (n.camera = this.getCamera(e.camera)), e.skin !== void 0 && (n.skin = this.getSkin(e.skin)), e.meshes !== void 0 && e.meshes.length && (n.mesh = e.meshes.reduce((i, s) => {
      const o = this.getMesh(s);
      return i.id = o.id, i.primitives = i.primitives.concat(o.primitives), i;
    }, { primitives: [] })), n;
  }
  _resolveNodeChildren(e) {
    return e.children && (e.children = e.children.map((t) => this.getNode(t))), e;
  }
  _resolveSkin(e, t) {
    const n = typeof e.inverseBindMatrices == "number" ? this.getAccessor(e.inverseBindMatrices) : void 0;
    return {
      ...e,
      id: e.id || `skin-${t}`,
      inverseBindMatrices: n
    };
  }
  _resolveMesh(e, t) {
    const n = {
      ...e,
      id: e.id || `mesh-${t}`,
      primitives: []
    };
    return e.primitives && (n.primitives = e.primitives.map((i) => {
      const s = {
        ...i,
        attributes: {},
        indices: void 0,
        material: void 0
      }, o = i.attributes;
      for (const l in o)
        s.attributes[l] = this.getAccessor(o[l]);
      return i.indices !== void 0 && (s.indices = this.getAccessor(i.indices)), i.material !== void 0 && (s.material = this.getMaterial(i.material)), s;
    })), n;
  }
  _resolveMaterial(e, t) {
    const n = {
      ...e,
      // @ts-expect-error
      id: e.id || `material-${t}`
    };
    if (n.normalTexture && (n.normalTexture = { ...n.normalTexture }, n.normalTexture.texture = this.getTexture(n.normalTexture.index)), n.occlusionTexture && (n.occlusionTexture = { ...n.occlusionTexture }, n.occlusionTexture.texture = this.getTexture(n.occlusionTexture.index)), n.emissiveTexture && (n.emissiveTexture = { ...n.emissiveTexture }, n.emissiveTexture.texture = this.getTexture(n.emissiveTexture.index)), n.emissiveFactor || (n.emissiveFactor = n.emissiveTexture ? [1, 1, 1] : [0, 0, 0]), n.pbrMetallicRoughness) {
      n.pbrMetallicRoughness = { ...n.pbrMetallicRoughness };
      const i = n.pbrMetallicRoughness;
      i.baseColorTexture && (i.baseColorTexture = { ...i.baseColorTexture }, i.baseColorTexture.texture = this.getTexture(i.baseColorTexture.index)), i.metallicRoughnessTexture && (i.metallicRoughnessTexture = { ...i.metallicRoughnessTexture }, i.metallicRoughnessTexture.texture = this.getTexture(i.metallicRoughnessTexture.index));
    }
    return n;
  }
  _resolveAccessor(e, t) {
    const n = jJ(e.componentType), i = HJ(e.type), s = n * i, o = {
      ...e,
      // @ts-expect-error
      id: e.id || `accessor-${t}`,
      bytesPerComponent: n,
      components: i,
      bytesPerElement: s,
      value: void 0,
      bufferView: void 0,
      sparse: void 0
    };
    if (e.bufferView !== void 0 && (o.bufferView = this.getBufferView(e.bufferView)), o.bufferView) {
      const l = o.bufferView.buffer, { ArrayType: u, byteLength: m } = nw(o, o.bufferView), y = (o.bufferView.byteOffset || 0) + (o.byteOffset || 0) + l.byteOffset;
      let E = l.arrayBuffer.slice(y, y + m);
      o.bufferView.byteStride && (E = this._getValueFromInterleavedBuffer(l, y, o.bufferView.byteStride, o.bytesPerElement, o.count)), o.value = new u(E);
    }
    return o;
  }
  /**
   * Take values of particular accessor from interleaved buffer
   * various parts of the buffer
   * @param buffer
   * @param byteOffset
   * @param byteStride
   * @param bytesPerElement
   * @param count
   * @returns
   */
  _getValueFromInterleavedBuffer(e, t, n, i, s) {
    const o = new Uint8Array(s * i);
    for (let l = 0; l < s; l++) {
      const u = t + l * n;
      o.set(new Uint8Array(e.arrayBuffer.slice(u, u + i)), l * i);
    }
    return o.buffer;
  }
  _resolveTexture(e, t) {
    return {
      ...e,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: e.id || `texture-${t}`,
      sampler: typeof e.sampler == "number" ? this.getSampler(e.sampler) : VJ(),
      source: typeof e.source == "number" ? this.getImage(e.source) : void 0
    };
  }
  _resolveSampler(e, t) {
    const n = {
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: e.id || `sampler-${t}`,
      ...e,
      parameters: {}
    };
    for (const i in n) {
      const s = this._enumSamplerParameter(i);
      s !== void 0 && (n.parameters[s] = n[i]);
    }
    return n;
  }
  _enumSamplerParameter(e) {
    return UJ[e];
  }
  _resolveImage(e, t) {
    const n = {
      ...e,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: e.id || `image-${t}`,
      image: null,
      bufferView: e.bufferView !== void 0 ? this.getBufferView(e.bufferView) : void 0
    }, i = this.images[t];
    return i && (n.image = i), n;
  }
  _resolveBufferView(e, t) {
    const n = e.buffer, i = this.buffers[n].arrayBuffer;
    let s = this.buffers[n].byteOffset || 0;
    return e.byteOffset && (s += e.byteOffset), {
      // // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: `bufferView-${t}`,
      ...e,
      // ...this.buffers[bufferIndex],
      buffer: this.buffers[n],
      data: new Uint8Array(i, s, e.byteLength)
    };
  }
  _resolveCamera(e, t) {
    const n = {
      ...e,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: e.id || `camera-${t}`
    };
    return n.perspective, n.orthographic, n;
  }
}
function lw(r, e) {
  return new GJ().postProcess(r, e);
}
var po = 1e-6, Ep = typeof Float32Array < "u" ? Float32Array : Array;
function WJ() {
  var r = new Ep(4);
  return Ep != Float32Array && (r[0] = 0, r[1] = 0, r[2] = 0, r[3] = 0), r;
}
function $J(r, e, t) {
  return r[0] = e[0] * t, r[1] = e[1] * t, r[2] = e[2] * t, r[3] = e[3] * t, r;
}
function qJ(r, e, t) {
  var n = e[0], i = e[1], s = e[2], o = e[3];
  return r[0] = t[0] * n + t[4] * i + t[8] * s + t[12] * o, r[1] = t[1] * n + t[5] * i + t[9] * s + t[13] * o, r[2] = t[2] * n + t[6] * i + t[10] * s + t[14] * o, r[3] = t[3] * n + t[7] * i + t[11] * s + t[15] * o, r;
}
(function() {
  var r = WJ();
  return function(e, t, n, i, s, o) {
    var l, u;
    for (t || (t = 4), n || (n = 0), i ? u = Math.min(i * t + n, e.length) : u = e.length, l = n; l < u; l += t)
      r[0] = e[l], r[1] = e[l + 1], r[2] = e[l + 2], r[3] = e[l + 3], s(r, r, o), e[l] = r[0], e[l + 1] = r[1], e[l + 2] = r[2], e[l + 3] = r[3];
    return e;
  };
})();
function Cm() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function cp(r, e) {
  const t = qJ([], e, r);
  return $J(t, t, 1 / t[3]), t;
}
function NS(r, e) {
  const t = r % e;
  return t < 0 ? e + t : t;
}
function XJ(r, e, t) {
  return t * e + (1 - t) * r;
}
function i2(r, e, t) {
  return r < e ? e : r > t ? t : r;
}
function ZJ(r) {
  return Math.log(r) * Math.LOG2E;
}
const cw = Math.log2 || ZJ;
function YJ(r, e) {
  var t = e[0], n = e[1], i = e[2], s = e[3], o = e[4], l = e[5], u = e[6], m = e[7], y = e[8], E = e[9], P = e[10], L = e[11], U = e[12], V = e[13], q = e[14], j = e[15], K = t * l - n * o, Y = t * u - i * o, de = t * m - s * o, ne = n * u - i * l, ae = n * m - s * l, De = i * m - s * u, Ge = y * V - E * U, fe = y * q - P * U, ve = y * j - L * U, me = E * q - P * V, X = E * j - L * V, re = P * j - L * q, Me = K * re - Y * X + de * me + ne * ve - ae * fe + De * Ge;
  return Me ? (Me = 1 / Me, r[0] = (l * re - u * X + m * me) * Me, r[1] = (i * X - n * re - s * me) * Me, r[2] = (V * De - q * ae + j * ne) * Me, r[3] = (P * ae - E * De - L * ne) * Me, r[4] = (u * ve - o * re - m * fe) * Me, r[5] = (t * re - i * ve + s * fe) * Me, r[6] = (q * de - U * De - j * Y) * Me, r[7] = (y * De - P * de + L * Y) * Me, r[8] = (o * X - l * ve + m * Ge) * Me, r[9] = (n * ve - t * X - s * Ge) * Me, r[10] = (U * ae - V * de + j * K) * Me, r[11] = (E * de - y * ae - L * K) * Me, r[12] = (l * fe - o * me - u * Ge) * Me, r[13] = (t * me - n * fe + i * Ge) * Me, r[14] = (V * Y - U * ne - q * K) * Me, r[15] = (y * ne - E * Y + P * K) * Me, r) : null;
}
function r1(r, e, t) {
  var n = e[0], i = e[1], s = e[2], o = e[3], l = e[4], u = e[5], m = e[6], y = e[7], E = e[8], P = e[9], L = e[10], U = e[11], V = e[12], q = e[13], j = e[14], K = e[15], Y = t[0], de = t[1], ne = t[2], ae = t[3];
  return r[0] = Y * n + de * l + ne * E + ae * V, r[1] = Y * i + de * u + ne * P + ae * q, r[2] = Y * s + de * m + ne * L + ae * j, r[3] = Y * o + de * y + ne * U + ae * K, Y = t[4], de = t[5], ne = t[6], ae = t[7], r[4] = Y * n + de * l + ne * E + ae * V, r[5] = Y * i + de * u + ne * P + ae * q, r[6] = Y * s + de * m + ne * L + ae * j, r[7] = Y * o + de * y + ne * U + ae * K, Y = t[8], de = t[9], ne = t[10], ae = t[11], r[8] = Y * n + de * l + ne * E + ae * V, r[9] = Y * i + de * u + ne * P + ae * q, r[10] = Y * s + de * m + ne * L + ae * j, r[11] = Y * o + de * y + ne * U + ae * K, Y = t[12], de = t[13], ne = t[14], ae = t[15], r[12] = Y * n + de * l + ne * E + ae * V, r[13] = Y * i + de * u + ne * P + ae * q, r[14] = Y * s + de * m + ne * L + ae * j, r[15] = Y * o + de * y + ne * U + ae * K, r;
}
function s2(r, e, t) {
  var n = t[0], i = t[1], s = t[2], o, l, u, m, y, E, P, L, U, V, q, j;
  return e === r ? (r[12] = e[0] * n + e[4] * i + e[8] * s + e[12], r[13] = e[1] * n + e[5] * i + e[9] * s + e[13], r[14] = e[2] * n + e[6] * i + e[10] * s + e[14], r[15] = e[3] * n + e[7] * i + e[11] * s + e[15]) : (o = e[0], l = e[1], u = e[2], m = e[3], y = e[4], E = e[5], P = e[6], L = e[7], U = e[8], V = e[9], q = e[10], j = e[11], r[0] = o, r[1] = l, r[2] = u, r[3] = m, r[4] = y, r[5] = E, r[6] = P, r[7] = L, r[8] = U, r[9] = V, r[10] = q, r[11] = j, r[12] = o * n + y * i + U * s + e[12], r[13] = l * n + E * i + V * s + e[13], r[14] = u * n + P * i + q * s + e[14], r[15] = m * n + L * i + j * s + e[15]), r;
}
function cD(r, e, t) {
  var n = t[0], i = t[1], s = t[2];
  return r[0] = e[0] * n, r[1] = e[1] * n, r[2] = e[2] * n, r[3] = e[3] * n, r[4] = e[4] * i, r[5] = e[5] * i, r[6] = e[6] * i, r[7] = e[7] * i, r[8] = e[8] * s, r[9] = e[9] * s, r[10] = e[10] * s, r[11] = e[11] * s, r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15], r;
}
function KJ(r, e, t) {
  var n = Math.sin(t), i = Math.cos(t), s = e[4], o = e[5], l = e[6], u = e[7], m = e[8], y = e[9], E = e[10], P = e[11];
  return e !== r && (r[0] = e[0], r[1] = e[1], r[2] = e[2], r[3] = e[3], r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r[4] = s * i + m * n, r[5] = o * i + y * n, r[6] = l * i + E * n, r[7] = u * i + P * n, r[8] = m * i - s * n, r[9] = y * i - o * n, r[10] = E * i - l * n, r[11] = P * i - u * n, r;
}
function QJ(r, e, t) {
  var n = Math.sin(t), i = Math.cos(t), s = e[0], o = e[1], l = e[2], u = e[3], m = e[4], y = e[5], E = e[6], P = e[7];
  return e !== r && (r[8] = e[8], r[9] = e[9], r[10] = e[10], r[11] = e[11], r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r[0] = s * i + m * n, r[1] = o * i + y * n, r[2] = l * i + E * n, r[3] = u * i + P * n, r[4] = m * i - s * n, r[5] = y * i - o * n, r[6] = E * i - l * n, r[7] = P * i - u * n, r;
}
function JJ(r, e, t, n, i) {
  var s = 1 / Math.tan(e / 2);
  if (r[0] = s / t, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = s, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[11] = -1, r[12] = 0, r[13] = 0, r[15] = 0, i != null && i !== 1 / 0) {
    var o = 1 / (n - i);
    r[10] = (i + n) * o, r[14] = 2 * i * n * o;
  } else
    r[10] = -1, r[14] = -2 * n;
  return r;
}
var eee = JJ;
function US(r, e) {
  var t = r[0], n = r[1], i = r[2], s = r[3], o = r[4], l = r[5], u = r[6], m = r[7], y = r[8], E = r[9], P = r[10], L = r[11], U = r[12], V = r[13], q = r[14], j = r[15], K = e[0], Y = e[1], de = e[2], ne = e[3], ae = e[4], De = e[5], Ge = e[6], fe = e[7], ve = e[8], me = e[9], X = e[10], re = e[11], Me = e[12], ot = e[13], be = e[14], Ue = e[15];
  return Math.abs(t - K) <= po * Math.max(1, Math.abs(t), Math.abs(K)) && Math.abs(n - Y) <= po * Math.max(1, Math.abs(n), Math.abs(Y)) && Math.abs(i - de) <= po * Math.max(1, Math.abs(i), Math.abs(de)) && Math.abs(s - ne) <= po * Math.max(1, Math.abs(s), Math.abs(ne)) && Math.abs(o - ae) <= po * Math.max(1, Math.abs(o), Math.abs(ae)) && Math.abs(l - De) <= po * Math.max(1, Math.abs(l), Math.abs(De)) && Math.abs(u - Ge) <= po * Math.max(1, Math.abs(u), Math.abs(Ge)) && Math.abs(m - fe) <= po * Math.max(1, Math.abs(m), Math.abs(fe)) && Math.abs(y - ve) <= po * Math.max(1, Math.abs(y), Math.abs(ve)) && Math.abs(E - me) <= po * Math.max(1, Math.abs(E), Math.abs(me)) && Math.abs(P - X) <= po * Math.max(1, Math.abs(P), Math.abs(X)) && Math.abs(L - re) <= po * Math.max(1, Math.abs(L), Math.abs(re)) && Math.abs(U - Me) <= po * Math.max(1, Math.abs(U), Math.abs(Me)) && Math.abs(V - ot) <= po * Math.max(1, Math.abs(V), Math.abs(ot)) && Math.abs(q - be) <= po * Math.max(1, Math.abs(q), Math.abs(be)) && Math.abs(j - Ue) <= po * Math.max(1, Math.abs(j), Math.abs(Ue));
}
function tee() {
  var r = new Ep(2);
  return Ep != Float32Array && (r[0] = 0, r[1] = 0), r;
}
function o2(r, e, t) {
  return r[0] = e[0] + t[0], r[1] = e[1] + t[1], r;
}
function ree(r, e, t) {
  return r[0] = e[0] - t[0], r[1] = e[1] - t[1], r;
}
function nee(r, e, t) {
  return r[0] = e[0] * t, r[1] = e[1] * t, r;
}
function iee(r) {
  var e = r[0], t = r[1];
  return Math.sqrt(e * e + t * t);
}
function see(r, e) {
  return r[0] = -e[0], r[1] = -e[1], r;
}
function uD(r, e, t, n) {
  var i = e[0], s = e[1];
  return r[0] = i + n * (t[0] - i), r[1] = s + n * (t[1] - s), r;
}
var oee = ree;
(function() {
  var r = tee();
  return function(e, t, n, i, s, o) {
    var l, u;
    for (t || (t = 2), n || (n = 0), i ? u = Math.min(i * t + n, e.length) : u = e.length, l = n; l < u; l += t)
      r[0] = e[l], r[1] = e[l + 1], s(r, r, o), e[l] = r[0], e[l + 1] = r[1];
    return e;
  };
})();
function aee() {
  var r = new Ep(3);
  return Ep != Float32Array && (r[0] = 0, r[1] = 0, r[2] = 0), r;
}
function lee(r, e, t) {
  return r[0] = e[0] + t[0], r[1] = e[1] + t[1], r[2] = e[2] + t[2], r;
}
function cee(r, e, t) {
  return r[0] = e[0] * t[0], r[1] = e[1] * t[1], r[2] = e[2] * t[2], r;
}
function uee(r, e) {
  return r[0] = -e[0], r[1] = -e[1], r[2] = -e[2], r;
}
var fee = cee;
(function() {
  var r = aee();
  return function(e, t, n, i, s, o) {
    var l, u;
    for (t || (t = 3), n || (n = 0), i ? u = Math.min(i * t + n, e.length) : u = e.length, l = n; l < u; l += t)
      r[0] = e[l], r[1] = e[l + 1], r[2] = e[l + 2], s(r, r, o), e[l] = r[0], e[l + 1] = r[1], e[l + 2] = r[2];
    return e;
  };
})();
function Ku(r, e) {
  if (!r)
    throw new Error(e || "@math.gl/web-mercator: assertion failed.");
}
const pl = Math.PI, fD = pl / 4, sc = pl / 180, a2 = 180 / pl, c0 = 512, zS = 4003e4, Rg = 85.051129, hD = 1.5;
function l2(r) {
  return Math.pow(2, r);
}
function hee(r) {
  return cw(r);
}
function Gu(r) {
  const [e, t] = r;
  Ku(Number.isFinite(e)), Ku(Number.isFinite(t) && t >= -90 && t <= 90, "invalid latitude");
  const n = e * sc, i = t * sc, s = c0 * (n + pl) / (2 * pl), o = c0 * (pl + Math.log(Math.tan(fD + i * 0.5))) / (2 * pl);
  return [s, o];
}
function Xu(r) {
  const [e, t] = r, n = e / c0 * (2 * pl) - pl, i = 2 * (Math.atan(Math.exp(t / c0 * (2 * pl) - pl)) - fD);
  return [n * a2, i * a2];
}
function dee(r) {
  const {
    latitude: e,
    longitude: t,
    highPrecision: n = !1
  } = r;
  Ku(Number.isFinite(e) && Number.isFinite(t));
  const i = c0, s = Math.cos(e * sc), o = i / 360, l = o / s, u = i / zS / s, m = {
    unitsPerMeter: [u, u, u],
    metersPerUnit: [1 / u, 1 / u, 1 / u],
    unitsPerDegree: [o, l, u],
    degreesPerUnit: [1 / o, 1 / l, 1 / u]
  };
  if (n) {
    const y = sc * Math.tan(e * sc) / s, E = o * y / 2, P = i / zS * y, L = P / l * u;
    m.unitsPerDegree2 = [0, E, P], m.unitsPerMeter2 = [L, 0, L];
  }
  return m;
}
function pee(r) {
  const {
    height: e,
    pitch: t,
    bearing: n,
    altitude: i,
    scale: s,
    center: o
  } = r, l = Cm();
  s2(l, l, [0, 0, -i]), KJ(l, l, -t * sc), QJ(l, l, n * sc);
  const u = s / e;
  return cD(l, l, [u, u, u]), o && s2(l, l, uee([], o)), l;
}
function Aee(r) {
  const {
    width: e,
    height: t,
    altitude: n,
    pitch: i = 0,
    offset: s,
    center: o,
    scale: l,
    nearZMultiplier: u = 1,
    farZMultiplier: m = 1
  } = r;
  let {
    fovy: y = f_(hD)
  } = r;
  n !== void 0 && (y = f_(n));
  const E = y * sc, P = i * sc, L = dD(y);
  let U = L;
  o && (U += o[2] * l / Math.cos(P) / t);
  const V = E * (0.5 + (s ? s[1] : 0) / t), q = Math.sin(V) * U / Math.sin(i2(Math.PI / 2 - P - V, 0.01, Math.PI - 0.01)), j = Math.sin(P) * q + U, K = U * 10, Y = Math.min(j * m, K);
  return {
    fov: E,
    aspect: e / t,
    focalDistance: L,
    near: u,
    far: Y
  };
}
function gee(r) {
  const {
    fov: e,
    aspect: t,
    near: n,
    far: i
  } = Aee(r);
  return eee([], e, t, n, i);
}
function f_(r) {
  return 2 * Math.atan(0.5 / r) * a2;
}
function dD(r) {
  return 0.5 / Math.tan(0.5 * r * sc);
}
function mee(r, e) {
  const [t, n, i = 0] = r;
  return Ku(Number.isFinite(t) && Number.isFinite(n) && Number.isFinite(i)), cp(e, [t, n, i, 1]);
}
function VS(r, e, t = 0) {
  const [n, i, s] = r;
  if (Ku(Number.isFinite(n) && Number.isFinite(i), "invalid pixel coordinate"), Number.isFinite(s))
    return cp(e, [n, i, s, 1]);
  const o = cp(e, [n, i, 0, 1]), l = cp(e, [n, i, 1, 1]), u = o[2], m = l[2], y = u === m ? 0 : ((t || 0) - u) / (m - u);
  return uD([], o, l, y);
}
function _ee(r) {
  const {
    width: e,
    height: t,
    bounds: n,
    minExtent: i = 0,
    maxZoom: s = 24,
    offset: o = [0, 0]
  } = r, [[l, u], [m, y]] = n, E = yee(r.padding), P = Gu([l, i2(y, -Rg, Rg)]), L = Gu([m, i2(u, -Rg, Rg)]), U = [Math.max(Math.abs(L[0] - P[0]), i), Math.max(Math.abs(L[1] - P[1]), i)], V = [e - E.left - E.right - Math.abs(o[0]) * 2, t - E.top - E.bottom - Math.abs(o[1]) * 2];
  Ku(V[0] > 0 && V[1] > 0);
  const q = V[0] / U[0], j = V[1] / U[1], K = (E.right - E.left) / 2 / q, Y = (E.top - E.bottom) / 2 / j, de = [(L[0] + P[0]) / 2 + K, (L[1] + P[1]) / 2 + Y], ne = Xu(de), ae = Math.min(s, cw(Math.abs(Math.min(q, j))));
  return Ku(Number.isFinite(ae)), {
    longitude: ne[0],
    latitude: ne[1],
    zoom: ae
  };
}
function yee(r = 0) {
  return typeof r == "number" ? {
    top: r,
    bottom: r,
    left: r,
    right: r
  } : (Ku(Number.isFinite(r.top) && Number.isFinite(r.bottom) && Number.isFinite(r.left) && Number.isFinite(r.right)), r);
}
const jS = Math.PI / 180;
function vee(r, e = 0) {
  const {
    width: t,
    height: n,
    unproject: i
  } = r, s = {
    targetZ: e
  }, o = i([0, n], s), l = i([t, n], s);
  let u, m;
  const y = r.fovy ? 0.5 * r.fovy * jS : Math.atan(0.5 / r.altitude), E = (90 - r.pitch) * jS;
  return y > E - 0.01 ? (u = HS(r, 0, e), m = HS(r, t, e)) : (u = i([0, 0], s), m = i([t, 0], s)), [o, l, m, u];
}
function HS(r, e, t) {
  const {
    pixelUnprojectionMatrix: n
  } = r, i = cp(n, [e, 0, 1, 1]), s = cp(n, [e, r.height, 1, 1]), l = (t * r.distanceScales.unitsPerMeter[2] - i[2]) / (s[2] - i[2]), u = uD([], i, s, l), m = Xu(u);
  return m.push(t), m;
}
class oc {
  constructor(e = {
    width: 1,
    height: 1
  }) {
    Br(this, "latitude", void 0), Br(this, "longitude", void 0), Br(this, "zoom", void 0), Br(this, "pitch", void 0), Br(this, "bearing", void 0), Br(this, "altitude", void 0), Br(this, "fovy", void 0), Br(this, "meterOffset", void 0), Br(this, "center", void 0), Br(this, "width", void 0), Br(this, "height", void 0), Br(this, "scale", void 0), Br(this, "distanceScales", void 0), Br(this, "viewMatrix", void 0), Br(this, "projectionMatrix", void 0), Br(this, "viewProjectionMatrix", void 0), Br(this, "pixelProjectionMatrix", void 0), Br(this, "pixelUnprojectionMatrix", void 0), Br(this, "equals", (j) => j instanceof oc ? j.width === this.width && j.height === this.height && US(j.projectionMatrix, this.projectionMatrix) && US(j.viewMatrix, this.viewMatrix) : !1), Br(this, "project", (j, K = {}) => {
      const {
        topLeft: Y = !0
      } = K, de = this.projectPosition(j), ne = mee(de, this.pixelProjectionMatrix), [ae, De] = ne, Ge = Y ? De : this.height - De;
      return j.length === 2 ? [ae, Ge] : [ae, Ge, ne[2]];
    }), Br(this, "unproject", (j, K = {}) => {
      const {
        topLeft: Y = !0,
        targetZ: de = void 0
      } = K, [ne, ae, De] = j, Ge = Y ? ae : this.height - ae, fe = de && de * this.distanceScales.unitsPerMeter[2], ve = VS([ne, Ge, De], this.pixelUnprojectionMatrix, fe), [me, X, re] = this.unprojectPosition(ve);
      return Number.isFinite(De) ? [me, X, re] : Number.isFinite(de) ? [me, X, de] : [me, X];
    }), Br(this, "projectPosition", (j) => {
      const [K, Y] = Gu(j), de = (j[2] || 0) * this.distanceScales.unitsPerMeter[2];
      return [K, Y, de];
    }), Br(this, "unprojectPosition", (j) => {
      const [K, Y] = Xu(j), de = (j[2] || 0) * this.distanceScales.metersPerUnit[2];
      return [K, Y, de];
    });
    let {
      width: t,
      height: n,
      altitude: i = null,
      fovy: s = null
    } = e;
    const {
      latitude: o = 0,
      longitude: l = 0,
      zoom: u = 0,
      pitch: m = 0,
      bearing: y = 0,
      position: E = null,
      nearZMultiplier: P = 0.02,
      farZMultiplier: L = 1.01
    } = e;
    t = t || 1, n = n || 1, s === null && i === null ? (i = hD, s = f_(i)) : s === null ? s = f_(i) : i === null && (i = dD(s));
    const U = l2(u);
    i = Math.max(0.75, i);
    const V = dee({
      longitude: l,
      latitude: o
    }), q = Gu([l, o]);
    q.push(0), E && lee(q, q, fee([], E, V.unitsPerMeter)), this.projectionMatrix = gee({
      width: t,
      height: n,
      scale: U,
      center: q,
      pitch: m,
      fovy: s,
      nearZMultiplier: P,
      farZMultiplier: L
    }), this.viewMatrix = pee({
      height: n,
      scale: U,
      center: q,
      pitch: m,
      bearing: y,
      altitude: i
    }), this.width = t, this.height = n, this.scale = U, this.latitude = o, this.longitude = l, this.zoom = u, this.pitch = m, this.bearing = y, this.altitude = i, this.fovy = s, this.center = q, this.meterOffset = E || [0, 0, 0], this.distanceScales = V, this._initMatrices(), Object.freeze(this);
  }
  _initMatrices() {
    const {
      width: e,
      height: t,
      projectionMatrix: n,
      viewMatrix: i
    } = this, s = Cm();
    r1(s, s, n), r1(s, s, i), this.viewProjectionMatrix = s;
    const o = Cm();
    cD(o, o, [e / 2, -t / 2, 1]), s2(o, o, [1, -1, 0]), r1(o, o, s);
    const l = YJ(Cm(), o);
    if (!l)
      throw new Error("Pixel project matrix not invertible");
    this.pixelProjectionMatrix = o, this.pixelUnprojectionMatrix = l;
  }
  projectFlat(e) {
    return Gu(e);
  }
  unprojectFlat(e) {
    return Xu(e);
  }
  getMapCenterByLngLatPosition({
    lngLat: e,
    pos: t
  }) {
    const n = VS(t, this.pixelUnprojectionMatrix), i = Gu(e), s = o2([], i, see([], n)), o = o2([], this.center, s);
    return Xu(o);
  }
  fitBounds(e, t = {}) {
    const {
      width: n,
      height: i
    } = this, {
      longitude: s,
      latitude: o,
      zoom: l
    } = _ee(Object.assign({
      width: n,
      height: i,
      bounds: e
    }, t));
    return new oc({
      width: n,
      height: i,
      longitude: s,
      latitude: o,
      zoom: l
    });
  }
  getBounds(e) {
    const t = this.getBoundingRegion(e), n = Math.min(...t.map((l) => l[0])), i = Math.max(...t.map((l) => l[0])), s = Math.min(...t.map((l) => l[1])), o = Math.max(...t.map((l) => l[1]));
    return [[n, s], [i, o]];
  }
  getBoundingRegion(e = {}) {
    return vee(this, e.z || 0);
  }
  getLocationAtPoint({
    lngLat: e,
    pos: t
  }) {
    return this.getMapCenterByLngLatPosition({
      lngLat: e,
      pos: t
    });
  }
}
const GS = 512;
function bee(r) {
  const {
    width: e,
    height: t,
    pitch: n = 0
  } = r;
  let {
    longitude: i,
    latitude: s,
    zoom: o,
    bearing: l = 0
  } = r;
  (i < -180 || i > 180) && (i = NS(i + 180, 360) - 180), (l < -180 || l > 180) && (l = NS(l + 180, 360) - 180);
  const u = cw(t / GS);
  if (o <= u)
    o = u, s = 0;
  else {
    const m = t / 2 / Math.pow(2, o), y = Xu([0, m])[1];
    if (s < y)
      s = y;
    else {
      const E = Xu([0, GS - m])[1];
      s > E && (s = E);
    }
  }
  return {
    width: e,
    height: t,
    longitude: i,
    latitude: s,
    zoom: o,
    pitch: n,
    bearing: l
  };
}
const pD = 0.01, xee = ["longitude", "latitude", "zoom"], AD = {
  curve: 1.414,
  speed: 1.2
};
function wee(r, e, t, n) {
  const {
    startZoom: i,
    startCenterXY: s,
    uDelta: o,
    w0: l,
    u1: u,
    S: m,
    rho: y,
    rho2: E,
    r0: P
  } = gD(r, e, n);
  if (u < pD) {
    const de = {};
    for (const ne of xee) {
      const ae = r[ne], De = e[ne];
      de[ne] = XJ(ae, De, t);
    }
    return de;
  }
  const L = t * m, U = Math.cosh(P) / Math.cosh(P + y * L), V = l * ((Math.cosh(P) * Math.tanh(P + y * L) - Math.sinh(P)) / E) / u, q = 1 / U, j = i + hee(q), K = nee([], o, V);
  o2(K, K, s);
  const Y = Xu(K);
  return {
    longitude: Y[0],
    latitude: Y[1],
    zoom: j
  };
}
function Tee(r, e, t) {
  const n = {
    ...AD,
    ...t
  }, {
    screenSpeed: i,
    speed: s,
    maxDuration: o
  } = n, {
    S: l,
    rho: u
  } = gD(r, e, n), m = 1e3 * l;
  let y;
  return Number.isFinite(i) ? y = m / (i / u) : y = m / s, Number.isFinite(o) && y > o ? 0 : y;
}
function gD(r, e, t) {
  t = Object.assign({}, AD, t);
  const n = t.curve, i = r.zoom, s = [r.longitude, r.latitude], o = l2(i), l = e.zoom, u = [e.longitude, e.latitude], m = l2(l - i), y = Gu(s), E = Gu(u), P = oee([], E, y), L = Math.max(r.width, r.height), U = L / m, V = iee(P) * o, q = Math.max(V, pD), j = n * n, K = (U * U - L * L + j * j * q * q) / (2 * L * j * q), Y = (U * U - L * L - j * j * q * q) / (2 * U * j * q), de = Math.log(Math.sqrt(K * K + 1) - K), ne = Math.log(Math.sqrt(Y * Y + 1) - Y), ae = (ne - de) / n;
  return {
    startZoom: i,
    startCenterXY: y,
    uDelta: P,
    w0: L,
    u1: V,
    S: ae,
    rho: n,
    rho2: j,
    r0: de,
    r1: ne
  };
}
var Wc = typeof document < "u" ? document : {};
function WS(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function Bg(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? WS(Object(t), !0).forEach(function(n) {
      Br(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : WS(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function $S(r, e) {
  var t;
  if (typeof Symbol > "u" || r[Symbol.iterator] == null) {
    if (Array.isArray(r) || (t = Eee(r)) || e) {
      t && (r = t);
      var n = 0, i = function() {
      };
      return { s: i, n: function() {
        return n >= r.length ? { done: !0 } : { done: !1, value: r[n++] };
      }, e: function(m) {
        throw m;
      }, f: i };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var s = !0, o = !1, l;
  return { s: function() {
    t = r[Symbol.iterator]();
  }, n: function() {
    var m = t.next();
    return s = m.done, m;
  }, e: function(m) {
    o = !0, l = m;
  }, f: function() {
    try {
      !s && t.return != null && t.return();
    } finally {
      if (o) throw l;
    }
  } };
}
function Eee(r, e) {
  if (r) {
    if (typeof r == "string") return qS(r, e);
    var t = Object.prototype.toString.call(r).slice(8, -1);
    if (t === "Object" && r.constructor && (t = r.constructor.name), t === "Map" || t === "Set") return Array.from(r);
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)) return qS(r, e);
  }
}
function qS(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var t = 0, n = new Array(e); t < e; t++)
    n[t] = r[t];
  return n;
}
var Cee = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
function n1(r) {
  if (!r)
    return null;
  if (typeof r == "string")
    return r;
  r.toJS && (r = r.toJS());
  var e = {}, t = $S(r.layers), n;
  try {
    for (t.s(); !(n = t.n()).done; ) {
      var i = n.value;
      e[i.id] = i;
    }
  } catch (o) {
    t.e(o);
  } finally {
    t.f();
  }
  var s = r.layers.map(function(o) {
    var l = e[o.ref], u = null;
    if ("interactive" in o && (u = Bg({}, o), delete u.interactive), l) {
      u = u || Bg({}, o), delete u.ref;
      var m = $S(Cee), y;
      try {
        for (m.s(); !(y = m.n()).done; ) {
          var E = y.value;
          E in l && (u[E] = l[E]);
        }
      } catch (P) {
        m.e(P);
      } finally {
        m.f();
      }
    }
    return u || o;
  });
  return Bg(Bg({}, r), {}, {
    layers: s
  });
}
function See() {
}
function Iee(r) {
  r && console.error(r.error);
}
var mD = {
  container: vt.object,
  gl: vt.object,
  mapboxApiAccessToken: vt.string,
  mapboxApiUrl: vt.string,
  attributionControl: vt.bool,
  preserveDrawingBuffer: vt.bool,
  reuseMaps: vt.bool,
  transformRequest: vt.func,
  mapOptions: vt.object,
  mapStyle: vt.oneOfType([vt.string, vt.object]),
  preventStyleDiffing: vt.bool,
  visible: vt.bool,
  asyncRender: vt.bool,
  onLoad: vt.func,
  onError: vt.func,
  width: vt.number,
  height: vt.number,
  viewState: vt.object,
  longitude: vt.number,
  latitude: vt.number,
  zoom: vt.number,
  bearing: vt.number,
  pitch: vt.number,
  altitude: vt.number
}, Sm = {
  container: Wc.body,
  mapboxApiAccessToken: Pee(),
  mapboxApiUrl: "https://api.mapbox.com",
  preserveDrawingBuffer: !1,
  attributionControl: !0,
  reuseMaps: !1,
  mapOptions: {},
  mapStyle: "mapbox://styles/mapbox/light-v8",
  preventStyleDiffing: !1,
  visible: !0,
  asyncRender: !1,
  onLoad: See,
  onError: Iee,
  width: 0,
  height: 0,
  longitude: 0,
  latitude: 0,
  zoom: 0,
  bearing: 0,
  pitch: 0,
  altitude: 1.5
};
function Pee() {
  var r = null;
  if (typeof window < "u" && window.location) {
    var e = window.location.search.match(/access_token=([^&\/]*)/);
    r = e && e[1];
  }
  return !r && typeof process < "u" && (r = r || process.env.MapboxAccessToken || process.env.REACT_APP_MAPBOX_ACCESS_TOKEN), r || "no-token";
}
function XS(r) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "component";
  r.debug && vt.checkPropTypes(mD, r, "prop", e);
}
var mh = (function() {
  function r(e) {
    var t = this;
    if (ef(this, r), Br(this, "props", Sm), Br(this, "width", 0), Br(this, "height", 0), Br(this, "_fireLoadEvent", function() {
      t.props.onLoad({
        type: "load",
        target: t._map
      });
    }), Br(this, "_handleError", function(n) {
      t.props.onError(n);
    }), !e.mapboxgl)
      throw new Error("Mapbox not available");
    this.mapboxgl = e.mapboxgl, r.initialized || (r.initialized = !0, this._checkStyleSheet(this.mapboxgl.version)), this._initialize(e);
  }
  return Ju(r, [{
    key: "finalize",
    value: function() {
      return this._destroy(), this;
    }
  }, {
    key: "setProps",
    value: function(t) {
      return this._update(this.props, t), this;
    }
  }, {
    key: "redraw",
    value: function() {
      var t = this._map;
      t.style && (t._frame && (t._frame.cancel(), t._frame = null), t._render());
    }
  }, {
    key: "getMap",
    value: function() {
      return this._map;
    }
  }, {
    key: "_reuse",
    value: function(t) {
      this._map = r.savedMap;
      var n = this._map.getContainer(), i = t.container;
      for (i.classList.add("mapboxgl-map"); n.childNodes.length > 0; )
        i.appendChild(n.childNodes[0]);
      this._map._container = i, r.savedMap = null, t.mapStyle && this._map.setStyle(n1(t.mapStyle), {
        diff: !1
      }), this._map.isStyleLoaded() ? this._fireLoadEvent() : this._map.once("styledata", this._fireLoadEvent);
    }
  }, {
    key: "_create",
    value: function(t) {
      if (t.reuseMaps && r.savedMap)
        this._reuse(t);
      else {
        if (t.gl) {
          var n = HTMLCanvasElement.prototype.getContext;
          HTMLCanvasElement.prototype.getContext = function() {
            return HTMLCanvasElement.prototype.getContext = n, t.gl;
          };
        }
        var i = {
          container: t.container,
          center: [0, 0],
          zoom: 8,
          pitch: 0,
          bearing: 0,
          maxZoom: 24,
          style: n1(t.mapStyle),
          interactive: !1,
          trackResize: !1,
          attributionControl: t.attributionControl,
          preserveDrawingBuffer: t.preserveDrawingBuffer
        };
        t.transformRequest && (i.transformRequest = t.transformRequest), this._map = new this.mapboxgl.Map(Object.assign({}, i, t.mapOptions)), this._map.once("load", this._fireLoadEvent), this._map.on("error", this._handleError);
      }
      return this;
    }
  }, {
    key: "_destroy",
    value: function() {
      this._map && (this.props.reuseMaps && !r.savedMap ? (r.savedMap = this._map, this._map.off("load", this._fireLoadEvent), this._map.off("error", this._handleError), this._map.off("styledata", this._fireLoadEvent)) : this._map.remove(), this._map = null);
    }
  }, {
    key: "_initialize",
    value: function(t) {
      var n = this;
      t = Object.assign({}, Sm, t), XS(t, "Mapbox"), this.mapboxgl.accessToken = t.mapboxApiAccessToken || Sm.mapboxApiAccessToken, this.mapboxgl.baseApiUrl = t.mapboxApiUrl, this._create(t);
      var i = t, s = i.container;
      Object.defineProperty(s, "offsetWidth", {
        configurable: !0,
        get: function() {
          return n.width;
        }
      }), Object.defineProperty(s, "clientWidth", {
        configurable: !0,
        get: function() {
          return n.width;
        }
      }), Object.defineProperty(s, "offsetHeight", {
        configurable: !0,
        get: function() {
          return n.height;
        }
      }), Object.defineProperty(s, "clientHeight", {
        configurable: !0,
        get: function() {
          return n.height;
        }
      });
      var o = this._map.getCanvas();
      o && (o.style.outline = "none"), this._updateMapViewport({}, t), this._updateMapSize({}, t), this.props = t;
    }
  }, {
    key: "_update",
    value: function(t, n) {
      if (this._map) {
        n = Object.assign({}, this.props, n), XS(n, "Mapbox");
        var i = this._updateMapViewport(t, n), s = this._updateMapSize(t, n);
        this._updateMapStyle(t, n), !n.asyncRender && (i || s) && this.redraw(), this.props = n;
      }
    }
  }, {
    key: "_updateMapStyle",
    value: function(t, n) {
      var i = t.mapStyle !== n.mapStyle;
      i && this._map.setStyle(n1(n.mapStyle), {
        diff: !n.preventStyleDiffing
      });
    }
  }, {
    key: "_updateMapSize",
    value: function(t, n) {
      var i = t.width !== n.width || t.height !== n.height;
      return i && (this.width = n.width, this.height = n.height, this._map.resize()), i;
    }
  }, {
    key: "_updateMapViewport",
    value: function(t, n) {
      var i = this._getViewState(t), s = this._getViewState(n), o = s.latitude !== i.latitude || s.longitude !== i.longitude || s.zoom !== i.zoom || s.pitch !== i.pitch || s.bearing !== i.bearing || s.altitude !== i.altitude;
      return o && (this._map.jumpTo(this._viewStateToMapboxProps(s)), s.altitude !== i.altitude && (this._map.transform.altitude = s.altitude)), o;
    }
  }, {
    key: "_getViewState",
    value: function(t) {
      var n = t.viewState || t, i = n.longitude, s = n.latitude, o = n.zoom, l = n.pitch, u = l === void 0 ? 0 : l, m = n.bearing, y = m === void 0 ? 0 : m, E = n.altitude, P = E === void 0 ? 1.5 : E;
      return {
        longitude: i,
        latitude: s,
        zoom: o,
        pitch: u,
        bearing: y,
        altitude: P
      };
    }
  }, {
    key: "_checkStyleSheet",
    value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "0.47.0";
      if (!(typeof Wc > "u"))
        try {
          var n = Wc.createElement("div");
          n.className = "mapboxgl-map", n.style.display = "none", Wc.body.appendChild(n);
          var i = window.getComputedStyle(n).position !== "static";
          if (!i) {
            var s = Wc.createElement("link");
            s.setAttribute("rel", "stylesheet"), s.setAttribute("type", "text/css"), s.setAttribute("href", "https://api.tiles.mapbox.com/mapbox-gl-js/v".concat(t, "/mapbox-gl.css")), Wc.head.appendChild(s);
          }
        } catch {
        }
    }
  }, {
    key: "_viewStateToMapboxProps",
    value: function(t) {
      return {
        center: [t.longitude, t.latitude],
        zoom: t.zoom,
        bearing: t.bearing,
        pitch: t.pitch
      };
    }
  }]), r;
})();
Br(mh, "initialized", !1);
Br(mh, "propTypes", mD);
Br(mh, "defaultProps", Sm);
Br(mh, "savedMap", null);
var Im = { exports: {} }, Mee = Im.exports, ZS;
function Ree() {
  return ZS || (ZS = 1, (function(r, e) {
    (function(t, n) {
      r.exports = n();
    })(Mee, (function() {
      var t, n, i;
      function s(o, l) {
        if (!t)
          t = l;
        else if (!n)
          n = l;
        else {
          var u = "var sharedChunk = {}; (" + t + ")(sharedChunk); (" + n + ")(sharedChunk);", m = {};
          t(m), i = l(m), typeof window < "u" && (i.workerUrl = window.URL.createObjectURL(new Blob([u], { type: "text/javascript" })));
        }
      }
      return s(["exports"], (function(o) {
        function l(a, c) {
          return a(c = { exports: {} }, c.exports), c.exports;
        }
        var u = m;
        function m(a, c, p, x) {
          this.cx = 3 * a, this.bx = 3 * (p - a) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * c, this.by = 3 * (x - c) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = a, this.p1y = x, this.p2x = p, this.p2y = x;
        }
        m.prototype.sampleCurveX = function(a) {
          return ((this.ax * a + this.bx) * a + this.cx) * a;
        }, m.prototype.sampleCurveY = function(a) {
          return ((this.ay * a + this.by) * a + this.cy) * a;
        }, m.prototype.sampleCurveDerivativeX = function(a) {
          return (3 * this.ax * a + 2 * this.bx) * a + this.cx;
        }, m.prototype.solveCurveX = function(a, c) {
          var p, x, S, M, O;
          for (c === void 0 && (c = 1e-6), S = a, O = 0; O < 8; O++) {
            if (M = this.sampleCurveX(S) - a, Math.abs(M) < c) return S;
            var N = this.sampleCurveDerivativeX(S);
            if (Math.abs(N) < 1e-6) break;
            S -= M / N;
          }
          if ((S = a) < (p = 0)) return p;
          if (S > (x = 1)) return x;
          for (; p < x; ) {
            if (M = this.sampleCurveX(S), Math.abs(M - a) < c) return S;
            a > M ? p = S : x = S, S = 0.5 * (x - p) + p;
          }
          return S;
        }, m.prototype.solve = function(a, c) {
          return this.sampleCurveY(this.solveCurveX(a, c));
        };
        var y = E;
        function E(a, c) {
          this.x = a, this.y = c;
        }
        E.prototype = { clone: function() {
          return new E(this.x, this.y);
        }, add: function(a) {
          return this.clone()._add(a);
        }, sub: function(a) {
          return this.clone()._sub(a);
        }, multByPoint: function(a) {
          return this.clone()._multByPoint(a);
        }, divByPoint: function(a) {
          return this.clone()._divByPoint(a);
        }, mult: function(a) {
          return this.clone()._mult(a);
        }, div: function(a) {
          return this.clone()._div(a);
        }, rotate: function(a) {
          return this.clone()._rotate(a);
        }, rotateAround: function(a, c) {
          return this.clone()._rotateAround(a, c);
        }, matMult: function(a) {
          return this.clone()._matMult(a);
        }, unit: function() {
          return this.clone()._unit();
        }, perp: function() {
          return this.clone()._perp();
        }, round: function() {
          return this.clone()._round();
        }, mag: function() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, equals: function(a) {
          return this.x === a.x && this.y === a.y;
        }, dist: function(a) {
          return Math.sqrt(this.distSqr(a));
        }, distSqr: function(a) {
          var c = a.x - this.x, p = a.y - this.y;
          return c * c + p * p;
        }, angle: function() {
          return Math.atan2(this.y, this.x);
        }, angleTo: function(a) {
          return Math.atan2(this.y - a.y, this.x - a.x);
        }, angleWith: function(a) {
          return this.angleWithSep(a.x, a.y);
        }, angleWithSep: function(a, c) {
          return Math.atan2(this.x * c - this.y * a, this.x * a + this.y * c);
        }, _matMult: function(a) {
          var c = a[2] * this.x + a[3] * this.y;
          return this.x = a[0] * this.x + a[1] * this.y, this.y = c, this;
        }, _add: function(a) {
          return this.x += a.x, this.y += a.y, this;
        }, _sub: function(a) {
          return this.x -= a.x, this.y -= a.y, this;
        }, _mult: function(a) {
          return this.x *= a, this.y *= a, this;
        }, _div: function(a) {
          return this.x /= a, this.y /= a, this;
        }, _multByPoint: function(a) {
          return this.x *= a.x, this.y *= a.y, this;
        }, _divByPoint: function(a) {
          return this.x /= a.x, this.y /= a.y, this;
        }, _unit: function() {
          return this._div(this.mag()), this;
        }, _perp: function() {
          var a = this.y;
          return this.y = this.x, this.x = -a, this;
        }, _rotate: function(a) {
          var c = Math.cos(a), p = Math.sin(a), x = p * this.x + c * this.y;
          return this.x = c * this.x - p * this.y, this.y = x, this;
        }, _rotateAround: function(a, c) {
          var p = Math.cos(a), x = Math.sin(a), S = c.y + x * (this.x - c.x) + p * (this.y - c.y);
          return this.x = c.x + p * (this.x - c.x) - x * (this.y - c.y), this.y = S, this;
        }, _round: function() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        } }, E.convert = function(a) {
          return a instanceof E ? a : Array.isArray(a) ? new E(a[0], a[1]) : a;
        };
        var P = typeof self < "u" ? self : {}, L = Math.pow(2, 53) - 1;
        function U(a, c, p, x) {
          var S = new u(a, c, p, x);
          return function(M) {
            return S.solve(M);
          };
        }
        var V = U(0.25, 0.1, 0.25, 1);
        function q(a, c, p) {
          return Math.min(p, Math.max(c, a));
        }
        function j(a, c, p) {
          var x = p - c, S = ((a - c) % x + x) % x + c;
          return S === c ? p : S;
        }
        function K(a) {
          for (var c = [], p = arguments.length - 1; p-- > 0; ) c[p] = arguments[p + 1];
          for (var x = 0, S = c; x < S.length; x += 1) {
            var M = S[x];
            for (var O in M) a[O] = M[O];
          }
          return a;
        }
        var Y = 1;
        function de() {
          return Y++;
        }
        function ne() {
          return (function a(c) {
            return c ? (c ^ 16 * Math.random() >> c / 4).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, a);
          })();
        }
        function ae(a) {
          return !!a && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(a);
        }
        function De(a, c) {
          a.forEach((function(p) {
            c[p] && (c[p] = c[p].bind(c));
          }));
        }
        function Ge(a, c) {
          return a.indexOf(c, a.length - c.length) !== -1;
        }
        function fe(a, c, p) {
          var x = {};
          for (var S in a) x[S] = c.call(p || this, a[S], S, a);
          return x;
        }
        function ve(a, c, p) {
          var x = {};
          for (var S in a) c.call(p || this, a[S], S, a) && (x[S] = a[S]);
          return x;
        }
        function me(a) {
          return Array.isArray(a) ? a.map(me) : typeof a == "object" && a ? fe(a, me) : a;
        }
        var X = {};
        function re(a) {
          X[a] || (typeof console < "u" && console.warn(a), X[a] = !0);
        }
        function Me(a, c, p) {
          return (p.y - a.y) * (c.x - a.x) > (c.y - a.y) * (p.x - a.x);
        }
        function ot(a) {
          for (var c = 0, p = 0, x = a.length, S = x - 1, M = void 0, O = void 0; p < x; S = p++) c += ((O = a[S]).x - (M = a[p]).x) * (M.y + O.y);
          return c;
        }
        function be() {
          return typeof WorkerGlobalScope < "u" && typeof self < "u" && self instanceof WorkerGlobalScope;
        }
        function Ue(a) {
          var c = {};
          if (a.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (function(x, S, M, O) {
            var N = M || O;
            return c[S] = !N || N.toLowerCase(), "";
          })), c["max-age"]) {
            var p = parseInt(c["max-age"], 10);
            isNaN(p) ? delete c["max-age"] : c["max-age"] = p;
          }
          return c;
        }
        var Xe = null;
        function lt(a) {
          if (Xe == null) {
            var c = a.navigator ? a.navigator.userAgent : null;
            Xe = !!a.safari || !(!c || !(/\b(iPad|iPhone|iPod)\b/.test(c) || c.match("Safari") && !c.match("Chrome")));
          }
          return Xe;
        }
        function at(a) {
          try {
            var c = P[a];
            return c.setItem("_mapbox_test_", 1), c.removeItem("_mapbox_test_"), !0;
          } catch {
            return !1;
          }
        }
        var ct, gt, St, Ot, dt = P.performance && P.performance.now ? P.performance.now.bind(P.performance) : Date.now.bind(Date), _r = P.requestAnimationFrame || P.mozRequestAnimationFrame || P.webkitRequestAnimationFrame || P.msRequestAnimationFrame, sr = P.cancelAnimationFrame || P.mozCancelAnimationFrame || P.webkitCancelAnimationFrame || P.msCancelAnimationFrame, tr = { now: dt, frame: function(a) {
          var c = _r(a);
          return { cancel: function() {
            return sr(c);
          } };
        }, getImageData: function(a, c) {
          c === void 0 && (c = 0);
          var p = P.document.createElement("canvas"), x = p.getContext("2d");
          if (!x) throw new Error("failed to create canvas 2d context");
          return p.width = a.width, p.height = a.height, x.drawImage(a, 0, 0, a.width, a.height), x.getImageData(-c, -c, a.width + 2 * c, a.height + 2 * c);
        }, resolveURL: function(a) {
          return ct || (ct = P.document.createElement("a")), ct.href = a, ct.href;
        }, hardwareConcurrency: P.navigator && P.navigator.hardwareConcurrency || 4, get devicePixelRatio() {
          return P.devicePixelRatio;
        }, get prefersReducedMotion() {
          return !!P.matchMedia && (gt == null && (gt = P.matchMedia("(prefers-reduced-motion: reduce)")), gt.matches);
        } }, Wt = { API_URL: "https://api.mapbox.com", get EVENTS_URL() {
          return this.API_URL ? this.API_URL.indexOf("https://api.mapbox.cn") === 0 ? "https://events.mapbox.cn/events/v2" : this.API_URL.indexOf("https://api.mapbox.com") === 0 ? "https://events.mapbox.com/events/v2" : null : null;
        }, FEEDBACK_URL: "https://apps.mapbox.com/feedback", REQUIRE_ACCESS_TOKEN: !0, ACCESS_TOKEN: null, MAX_PARALLEL_IMAGE_REQUESTS: 16 }, yr = { supported: !1, testSupport: function(a) {
          !An && Ot && (Fr ? Pr(a) : St = a);
        } }, An = !1, Fr = !1;
        function Pr(a) {
          var c = a.createTexture();
          a.bindTexture(a.TEXTURE_2D, c);
          try {
            if (a.texImage2D(a.TEXTURE_2D, 0, a.RGBA, a.RGBA, a.UNSIGNED_BYTE, Ot), a.isContextLost()) return;
            yr.supported = !0;
          } catch {
          }
          a.deleteTexture(c), An = !0;
        }
        P.document && ((Ot = P.document.createElement("img")).onload = function() {
          St && Pr(St), St = null, Fr = !0;
        }, Ot.onerror = function() {
          An = !0, St = null;
        }, Ot.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
        var $n = "01", xr = function(a, c) {
          this._transformRequestFn = a, this._customAccessToken = c, this._createSkuToken();
        };
        function wr(a) {
          return a.indexOf("mapbox:") === 0;
        }
        xr.prototype._createSkuToken = function() {
          var a = (function() {
            for (var c = "", p = 0; p < 10; p++) c += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
            return { token: ["1", $n, c].join(""), tokenExpiresAt: Date.now() + 432e5 };
          })();
          this._skuToken = a.token, this._skuTokenExpiresAt = a.tokenExpiresAt;
        }, xr.prototype._isSkuTokenExpired = function() {
          return Date.now() > this._skuTokenExpiresAt;
        }, xr.prototype.transformRequest = function(a, c) {
          return this._transformRequestFn && this._transformRequestFn(a, c) || { url: a };
        }, xr.prototype.normalizeStyleURL = function(a, c) {
          if (!wr(a)) return a;
          var p = Jn(a);
          return p.path = "/styles/v1" + p.path, this._makeAPIURL(p, this._customAccessToken || c);
        }, xr.prototype.normalizeGlyphsURL = function(a, c) {
          if (!wr(a)) return a;
          var p = Jn(a);
          return p.path = "/fonts/v1" + p.path, this._makeAPIURL(p, this._customAccessToken || c);
        }, xr.prototype.normalizeSourceURL = function(a, c) {
          if (!wr(a)) return a;
          var p = Jn(a);
          return p.path = "/v4/" + p.authority + ".json", p.params.push("secure"), this._makeAPIURL(p, this._customAccessToken || c);
        }, xr.prototype.normalizeSpriteURL = function(a, c, p, x) {
          var S = Jn(a);
          return wr(a) ? (S.path = "/styles/v1" + S.path + "/sprite" + c + p, this._makeAPIURL(S, this._customAccessToken || x)) : (S.path += "" + c + p, wn(S));
        }, xr.prototype.normalizeTileURL = function(a, c) {
          if (this._isSkuTokenExpired() && this._createSkuToken(), a && !wr(a)) return a;
          var p = Jn(a);
          p.path = p.path.replace(/(\.(png|jpg)\d*)(?=$)/, (tr.devicePixelRatio >= 2 || c === 512 ? "@2x" : "") + (yr.supported ? ".webp" : "$1")), p.path = p.path.replace(/^.+\/v4\//, "/"), p.path = "/v4" + p.path;
          var x = this._customAccessToken || (function(S) {
            for (var M = 0, O = S; M < O.length; M += 1) {
              var N = O[M].match(/^access_token=(.*)$/);
              if (N) return N[1];
            }
            return null;
          })(p.params) || Wt.ACCESS_TOKEN;
          return Wt.REQUIRE_ACCESS_TOKEN && x && this._skuToken && p.params.push("sku=" + this._skuToken), this._makeAPIURL(p, x);
        }, xr.prototype.canonicalizeTileURL = function(a, c) {
          var p = Jn(a);
          if (!p.path.match(/(^\/v4\/)/) || !p.path.match(/\.[\w]+$/)) return a;
          var x = "mapbox://tiles/";
          x += p.path.replace("/v4/", "");
          var S = p.params;
          return c && (S = S.filter((function(M) {
            return !M.match(/^access_token=/);
          }))), S.length && (x += "?" + S.join("&")), x;
        }, xr.prototype.canonicalizeTileset = function(a, c) {
          for (var p = !!c && wr(c), x = [], S = 0, M = a.tiles || []; S < M.length; S += 1) {
            var O = M[S];
            zr(O) ? x.push(this.canonicalizeTileURL(O, p)) : x.push(O);
          }
          return x;
        }, xr.prototype._makeAPIURL = function(a, c) {
          var p = "See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes", x = Jn(Wt.API_URL);
          if (a.protocol = x.protocol, a.authority = x.authority, a.protocol === "http") {
            var S = a.params.indexOf("secure");
            S >= 0 && a.params.splice(S, 1);
          }
          if (x.path !== "/" && (a.path = "" + x.path + a.path), !Wt.REQUIRE_ACCESS_TOKEN) return wn(a);
          if (!(c = c || Wt.ACCESS_TOKEN)) throw new Error("An API access token is required to use Mapbox GL. " + p);
          if (c[0] === "s") throw new Error("Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). " + p);
          return a.params = a.params.filter((function(M) {
            return M.indexOf("access_token") === -1;
          })), a.params.push("access_token=" + c), wn(a);
        };
        var gn = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
        function zr(a) {
          return gn.test(a);
        }
        var ci = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
        function Jn(a) {
          var c = a.match(ci);
          if (!c) throw new Error("Unable to parse URL object");
          return { protocol: c[1], authority: c[2], path: c[3] || "/", params: c[4] ? c[4].split("&") : [] };
        }
        function wn(a) {
          var c = a.params.length ? "?" + a.params.join("&") : "";
          return a.protocol + "://" + a.authority + a.path + c;
        }
        function ii(a) {
          if (!a) return null;
          var c = a.split(".");
          if (!c || c.length !== 3) return null;
          try {
            return JSON.parse(decodeURIComponent(P.atob(c[1]).split("").map((function(p) {
              return "%" + ("00" + p.charCodeAt(0).toString(16)).slice(-2);
            })).join("")));
          } catch {
            return null;
          }
        }
        var qn = function(a) {
          this.type = a, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
        };
        qn.prototype.getStorageKey = function(a) {
          var c, p = ii(Wt.ACCESS_TOKEN);
          return c = p && p.u ? P.btoa(encodeURIComponent(p.u).replace(/%([0-9A-F]{2})/g, (function(x, S) {
            return String.fromCharCode(+("0x" + S));
          }))) : Wt.ACCESS_TOKEN || "", a ? "mapbox.eventData." + a + ":" + c : "mapbox.eventData:" + c;
        }, qn.prototype.fetchEventData = function() {
          var a = at("localStorage"), c = this.getStorageKey(), p = this.getStorageKey("uuid");
          if (a) try {
            var x = P.localStorage.getItem(c);
            x && (this.eventData = JSON.parse(x));
            var S = P.localStorage.getItem(p);
            S && (this.anonId = S);
          } catch {
            re("Unable to read from LocalStorage");
          }
        }, qn.prototype.saveEventData = function() {
          var a = at("localStorage"), c = this.getStorageKey(), p = this.getStorageKey("uuid");
          if (a) try {
            P.localStorage.setItem(p, this.anonId), Object.keys(this.eventData).length >= 1 && P.localStorage.setItem(c, JSON.stringify(this.eventData));
          } catch {
            re("Unable to write to LocalStorage");
          }
        }, qn.prototype.processRequests = function(a) {
        }, qn.prototype.postEvent = function(a, c, p, x) {
          var S = this;
          if (Wt.EVENTS_URL) {
            var M = Jn(Wt.EVENTS_URL);
            M.params.push("access_token=" + (x || Wt.ACCESS_TOKEN || ""));
            var O = { event: this.type, created: new Date(a).toISOString(), sdkIdentifier: "mapbox-gl-js", sdkVersion: "1.13.3", skuId: $n, userId: this.anonId }, N = c ? K(O, c) : O, G = { url: wn(M), headers: { "Content-Type": "text/plain" }, body: JSON.stringify([N]) };
            this.pendingRequest = At(G, (function(Z) {
              S.pendingRequest = null, p(Z), S.saveEventData(), S.processRequests(x);
            }));
          }
        }, qn.prototype.queueRequest = function(a, c) {
          this.queue.push(a), this.processRequests(c);
        };
        var Rn, ei, Zt = (function(a) {
          function c() {
            a.call(this, "map.load"), this.success = {}, this.skuToken = "";
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype.postMapLoadEvent = function(p, x, S, M) {
            this.skuToken = S;
            var O = !(!M && !Wt.ACCESS_TOKEN), N = Array.isArray(p) && p.some((function(G) {
              return wr(G) || zr(G);
            }));
            Wt.EVENTS_URL && O && N && this.queueRequest({ id: x, timestamp: Date.now() }, M);
          }, c.prototype.processRequests = function(p) {
            var x = this;
            if (!this.pendingRequest && this.queue.length !== 0) {
              var S = this.queue.shift(), M = S.id, O = S.timestamp;
              M && this.success[M] || (this.anonId || this.fetchEventData(), ae(this.anonId) || (this.anonId = ne()), this.postEvent(O, { skuToken: this.skuToken }, (function(N) {
                N || M && (x.success[M] = !0);
              }), p));
            }
          }, c;
        })(qn), br = new ((function(a) {
          function c(p) {
            a.call(this, "appUserTurnstile"), this._customAccessToken = p;
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype.postTurnstileEvent = function(p, x) {
            Wt.EVENTS_URL && Wt.ACCESS_TOKEN && Array.isArray(p) && p.some((function(S) {
              return wr(S) || zr(S);
            })) && this.queueRequest(Date.now(), x);
          }, c.prototype.processRequests = function(p) {
            var x = this;
            if (!this.pendingRequest && this.queue.length !== 0) {
              this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
              var S = ii(Wt.ACCESS_TOKEN), M = S ? S.u : Wt.ACCESS_TOKEN, O = M !== this.eventData.tokenU;
              ae(this.anonId) || (this.anonId = ne(), O = !0);
              var N = this.queue.shift();
              if (this.eventData.lastSuccess) {
                var G = new Date(this.eventData.lastSuccess), Z = new Date(N), te = (N - this.eventData.lastSuccess) / 864e5;
                O = O || te >= 1 || te < -1 || G.getDate() !== Z.getDate();
              } else O = !0;
              if (!O) return this.processRequests();
              this.postEvent(N, { "enabled.telemetry": !1 }, (function(se) {
                se || (x.eventData.lastSuccess = N, x.eventData.tokenU = M);
              }), p);
            }
          }, c;
        })(qn))(), Nr = br.postTurnstileEvent.bind(br), on = new Zt(), pi = on.postMapLoadEvent.bind(on), Le = 500, Gt = 50;
        function Jt() {
          P.caches && !Rn && (Rn = P.caches.open("mapbox-tiles"));
        }
        function pr(a) {
          var c = a.indexOf("?");
          return c < 0 ? a : a.slice(0, c);
        }
        var st, Ft = 1 / 0;
        function _e() {
          return st == null && (st = P.OffscreenCanvas && new P.OffscreenCanvas(1, 1).getContext("2d") && typeof P.createImageBitmap == "function"), st;
        }
        var Xt = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Image: "Image" };
        typeof Object.freeze == "function" && Object.freeze(Xt);
        var Ct = (function(a) {
          function c(p, x, S) {
            x === 401 && zr(S) && (p += ": you may have provided an invalid Mapbox access token. See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes"), a.call(this, p), this.status = x, this.url = S, this.name = this.constructor.name, this.message = p;
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype.toString = function() {
            return this.name + ": " + this.message + " (" + this.status + "): " + this.url;
          }, c;
        })(Error), $ = be() ? function() {
          return self.worker && self.worker.referrer;
        } : function() {
          return (P.location.protocol === "blob:" ? P.parent : P).location.href;
        }, Et, Rt, Pe = function(a, c) {
          if (!(/^file:/.test(p = a.url) || /^file:/.test($()) && !/^\w+:/.test(p))) {
            if (P.fetch && P.Request && P.AbortController && P.Request.prototype.hasOwnProperty("signal")) return (function(x, S) {
              var M, O = new P.AbortController(), N = new P.Request(x.url, { method: x.method || "GET", body: x.body, credentials: x.credentials, headers: x.headers, referrer: $(), signal: O.signal }), G = !1, Z = !1, te = (M = N.url).indexOf("sku=") > 0 && zr(M);
              x.type === "json" && N.headers.set("Accept", "application/json");
              var se = function(xe, Ve, je) {
                if (!Z) {
                  if (xe && xe.message !== "SecurityError" && re(xe), Ve && je) return he(Ve);
                  var Qe = Date.now();
                  P.fetch(N).then((function(Ye) {
                    if (Ye.ok) {
                      var it = te ? Ye.clone() : null;
                      return he(Ye, it, Qe);
                    }
                    return S(new Ct(Ye.statusText, Ye.status, x.url));
                  })).catch((function(Ye) {
                    Ye.code !== 20 && S(new Error(Ye.message));
                  }));
                }
              }, he = function(xe, Ve, je) {
                (x.type === "arrayBuffer" ? xe.arrayBuffer() : x.type === "json" ? xe.json() : xe.text()).then((function(Qe) {
                  Z || (Ve && je && (function(Ye, it, pt) {
                    if (Jt(), Rn) {
                      var xt = { status: it.status, statusText: it.statusText, headers: new P.Headers() };
                      it.headers.forEach((function(Nt, Kt) {
                        return xt.headers.set(Kt, Nt);
                      }));
                      var Tt = Ue(it.headers.get("Cache-Control") || "");
                      Tt["no-store"] || (Tt["max-age"] && xt.headers.set("Expires", new Date(pt + 1e3 * Tt["max-age"]).toUTCString()), new Date(xt.headers.get("Expires")).getTime() - pt < 42e4 || (function(Nt, Kt) {
                        if (ei === void 0) try {
                          new Response(new ReadableStream()), ei = !0;
                        } catch {
                          ei = !1;
                        }
                        ei ? Kt(Nt.body) : Nt.blob().then(Kt);
                      })(it, (function(Nt) {
                        var Kt = new P.Response(Nt, xt);
                        Jt(), Rn && Rn.then((function(rr) {
                          return rr.put(pr(Ye.url), Kt);
                        })).catch((function(rr) {
                          return re(rr.message);
                        }));
                      })));
                    }
                  })(N, Ve, je), G = !0, S(null, Qe, xe.headers.get("Cache-Control"), xe.headers.get("Expires")));
                })).catch((function(Qe) {
                  Z || S(new Error(Qe.message));
                }));
              };
              return te ? (function(xe, Ve) {
                if (Jt(), !Rn) return Ve(null);
                var je = pr(xe.url);
                Rn.then((function(Qe) {
                  Qe.match(je).then((function(Ye) {
                    var it = (function(pt) {
                      if (!pt) return !1;
                      var xt = new Date(pt.headers.get("Expires") || 0), Tt = Ue(pt.headers.get("Cache-Control") || "");
                      return xt > Date.now() && !Tt["no-cache"];
                    })(Ye);
                    Qe.delete(je), it && Qe.put(je, Ye.clone()), Ve(null, Ye, it);
                  })).catch(Ve);
                })).catch(Ve);
              })(N, se) : se(null, null), { cancel: function() {
                Z = !0, G || O.abort();
              } };
            })(a, c);
            if (be() && self.worker && self.worker.actor) return self.worker.actor.send("getResource", a, c, void 0, !0);
          }
          var p;
          return (function(x, S) {
            var M = new P.XMLHttpRequest();
            for (var O in M.open(x.method || "GET", x.url, !0), x.type === "arrayBuffer" && (M.responseType = "arraybuffer"), x.headers) M.setRequestHeader(O, x.headers[O]);
            return x.type === "json" && (M.responseType = "text", M.setRequestHeader("Accept", "application/json")), M.withCredentials = x.credentials === "include", M.onerror = function() {
              S(new Error(M.statusText));
            }, M.onload = function() {
              if ((M.status >= 200 && M.status < 300 || M.status === 0) && M.response !== null) {
                var N = M.response;
                if (x.type === "json") try {
                  N = JSON.parse(M.response);
                } catch (G) {
                  return S(G);
                }
                S(null, N, M.getResponseHeader("Cache-Control"), M.getResponseHeader("Expires"));
              } else S(new Ct(M.statusText, M.status, x.url));
            }, M.send(x.body), { cancel: function() {
              return M.abort();
            } };
          })(a, c);
        }, tt = function(a, c) {
          return Pe(K(a, { type: "arrayBuffer" }), c);
        }, At = function(a, c) {
          return Pe(K(a, { method: "POST" }), c);
        }, Q = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        Et = [], Rt = 0;
        var ie = function(a, c) {
          if (yr.supported && (a.headers || (a.headers = {}), a.headers.accept = "image/webp,*/*"), Rt >= Wt.MAX_PARALLEL_IMAGE_REQUESTS) {
            var p = { requestParameters: a, callback: c, cancelled: !1, cancel: function() {
              this.cancelled = !0;
            } };
            return Et.push(p), p;
          }
          Rt++;
          var x = !1, S = function() {
            if (!x) for (x = !0, Rt--; Et.length && Rt < Wt.MAX_PARALLEL_IMAGE_REQUESTS; ) {
              var O = Et.shift();
              O.cancelled || (O.cancel = ie(O.requestParameters, O.callback).cancel);
            }
          }, M = tt(a, (function(O, N, G, Z) {
            S(), O ? c(O) : N && (_e() ? (function(te, se) {
              var he = new P.Blob([new Uint8Array(te)], { type: "image/png" });
              P.createImageBitmap(he).then((function(xe) {
                se(null, xe);
              })).catch((function(xe) {
                se(new Error("Could not load image because of " + xe.message + ". Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
              }));
            })(N, c) : (function(te, se, he, xe) {
              var Ve = new P.Image(), je = P.URL;
              Ve.onload = function() {
                se(null, Ve), je.revokeObjectURL(Ve.src), Ve.onload = null, P.requestAnimationFrame((function() {
                  Ve.src = Q;
                }));
              }, Ve.onerror = function() {
                return se(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
              };
              var Qe = new P.Blob([new Uint8Array(te)], { type: "image/png" });
              Ve.cacheControl = he, Ve.expires = xe, Ve.src = te.byteLength ? je.createObjectURL(Qe) : Q;
            })(N, c, G, Z));
          }));
          return { cancel: function() {
            M.cancel(), S();
          } };
        };
        function ce(a, c, p) {
          p[a] && p[a].indexOf(c) !== -1 || (p[a] = p[a] || [], p[a].push(c));
        }
        function we(a, c, p) {
          if (p && p[a]) {
            var x = p[a].indexOf(c);
            x !== -1 && p[a].splice(x, 1);
          }
        }
        var Ne = function(a, c) {
          c === void 0 && (c = {}), K(this, c), this.type = a;
        }, pe = (function(a) {
          function c(p, x) {
            x === void 0 && (x = {}), a.call(this, "error", K({ error: p }, x));
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c;
        })(Ne), Te = function() {
        };
        Te.prototype.on = function(a, c) {
          return this._listeners = this._listeners || {}, ce(a, c, this._listeners), this;
        }, Te.prototype.off = function(a, c) {
          return we(a, c, this._listeners), we(a, c, this._oneTimeListeners), this;
        }, Te.prototype.once = function(a, c) {
          return this._oneTimeListeners = this._oneTimeListeners || {}, ce(a, c, this._oneTimeListeners), this;
        }, Te.prototype.fire = function(a, c) {
          typeof a == "string" && (a = new Ne(a, c || {}));
          var p = a.type;
          if (this.listens(p)) {
            a.target = this;
            for (var x = 0, S = this._listeners && this._listeners[p] ? this._listeners[p].slice() : []; x < S.length; x += 1) S[x].call(this, a);
            for (var M = 0, O = this._oneTimeListeners && this._oneTimeListeners[p] ? this._oneTimeListeners[p].slice() : []; M < O.length; M += 1) {
              var N = O[M];
              we(p, N, this._oneTimeListeners), N.call(this, a);
            }
            var G = this._eventedParent;
            G && (K(a, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), G.fire(a));
          } else a instanceof pe && console.error(a.error);
          return this;
        }, Te.prototype.listens = function(a) {
          return this._listeners && this._listeners[a] && this._listeners[a].length > 0 || this._oneTimeListeners && this._oneTimeListeners[a] && this._oneTimeListeners[a].length > 0 || this._eventedParent && this._eventedParent.listens(a);
        }, Te.prototype.setEventedParent = function(a, c) {
          return this._eventedParent = a, this._eventedParentData = c, this;
        };
        var le = { $version: 8, $root: { version: { required: !0, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, sources: { required: !0, type: "sources" }, sprite: { type: "string" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: !0, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: !0, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster: { type: { required: !0, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster_dem: { type: { required: !0, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {} }, default: "mapbox" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_geojson: { type: { required: !0, type: "enum", values: { geojson: {} } }, data: { type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: !1 }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: !1 }, generateId: { type: "boolean", default: !1 }, promoteId: { type: "promoteId" } }, source_video: { type: { required: !0, type: "enum", values: { video: {} } }, urls: { required: !0, type: "array", value: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: !0, type: "enum", values: { image: {} } }, url: { required: !0, type: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: !0 }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: !0 }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: !1, requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-keep-upright": { type: "boolean", default: !1, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: !0, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: !0, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: !1, requires: ["text-field", "icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {}, within: {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: !1 } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: !1, expression: { interpolated: !1, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: !0, requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, requires: ["fill-extrusion-height"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: !0, transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "line-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: !0, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: !1, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: !0 } }], expression: { interpolated: !0, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: !1, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: !1, expression: { interpolated: !0, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: !0, overridable: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: !0, units: "degrees", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: !1, units: "milliseconds", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "background-pattern" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } }, ge = function(a, c, p, x) {
          this.message = (a ? a + ": " : "") + p, x && (this.identifier = x), c != null && c.__line__ && (this.line = c.__line__);
        };
        function d(a) {
          var c = a.value;
          return c ? [new ge(a.key, c, "constants have been deprecated as of v8")] : [];
        }
        function ee(a) {
          for (var c = [], p = arguments.length - 1; p-- > 0; ) c[p] = arguments[p + 1];
          for (var x = 0, S = c; x < S.length; x += 1) {
            var M = S[x];
            for (var O in M) a[O] = M[O];
          }
          return a;
        }
        function It(a) {
          return a instanceof Number || a instanceof String || a instanceof Boolean ? a.valueOf() : a;
        }
        function nt(a) {
          if (Array.isArray(a)) return a.map(nt);
          if (a instanceof Object && !(a instanceof Number || a instanceof String || a instanceof Boolean)) {
            var c = {};
            for (var p in a) c[p] = nt(a[p]);
            return c;
          }
          return It(a);
        }
        var Mt = (function(a) {
          function c(p, x) {
            a.call(this, x), this.message = x, this.key = p;
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c;
        })(Error), kt = function(a, c) {
          c === void 0 && (c = []), this.parent = a, this.bindings = {};
          for (var p = 0, x = c; p < x.length; p += 1) {
            var S = x[p];
            this.bindings[S[0]] = S[1];
          }
        };
        kt.prototype.concat = function(a) {
          return new kt(this, a);
        }, kt.prototype.get = function(a) {
          if (this.bindings[a]) return this.bindings[a];
          if (this.parent) return this.parent.get(a);
          throw new Error(a + " not found in scope.");
        }, kt.prototype.has = function(a) {
          return !!this.bindings[a] || !!this.parent && this.parent.has(a);
        };
        var zt = { kind: "null" }, _t = { kind: "number" }, Vt = { kind: "string" }, Lt = { kind: "boolean" }, Yt = { kind: "color" }, Hr = { kind: "object" }, ir = { kind: "value" }, nn = { kind: "collator" }, un = { kind: "formatted" }, Yr = { kind: "resolvedImage" };
        function Qr(a, c) {
          return { kind: "array", itemType: a, N: c };
        }
        function $r(a) {
          if (a.kind === "array") {
            var c = $r(a.itemType);
            return typeof a.N == "number" ? "array<" + c + ", " + a.N + ">" : a.itemType.kind === "value" ? "array" : "array<" + c + ">";
          }
          return a.kind;
        }
        var Ai = [zt, _t, Vt, Lt, Yt, un, Hr, Qr(ir), Yr];
        function Kr(a, c) {
          if (c.kind === "error") return null;
          if (a.kind === "array") {
            if (c.kind === "array" && (c.N === 0 && c.itemType.kind === "value" || !Kr(a.itemType, c.itemType)) && (typeof a.N != "number" || a.N === c.N)) return null;
          } else {
            if (a.kind === c.kind) return null;
            if (a.kind === "value") {
              for (var p = 0, x = Ai; p < x.length; p += 1) if (!Kr(x[p], c)) return null;
            }
          }
          return "Expected " + $r(a) + " but found " + $r(c) + " instead.";
        }
        function hr(a, c) {
          return c.some((function(p) {
            return p.kind === a.kind;
          }));
        }
        function ye(a, c) {
          return c.some((function(p) {
            return p === "null" ? a === null : p === "array" ? Array.isArray(a) : p === "object" ? a && !Array.isArray(a) && typeof a == "object" : p === typeof a;
          }));
        }
        var er = l((function(a, c) {
          var p = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
          function x(N) {
            return (N = Math.round(N)) < 0 ? 0 : N > 255 ? 255 : N;
          }
          function S(N) {
            return x(N[N.length - 1] === "%" ? parseFloat(N) / 100 * 255 : parseInt(N));
          }
          function M(N) {
            return (G = N[N.length - 1] === "%" ? parseFloat(N) / 100 : parseFloat(N)) < 0 ? 0 : G > 1 ? 1 : G;
            var G;
          }
          function O(N, G, Z) {
            return Z < 0 ? Z += 1 : Z > 1 && (Z -= 1), 6 * Z < 1 ? N + (G - N) * Z * 6 : 2 * Z < 1 ? G : 3 * Z < 2 ? N + (G - N) * (2 / 3 - Z) * 6 : N;
          }
          try {
            c.parseCSSColor = function(N) {
              var G, Z = N.replace(/ /g, "").toLowerCase();
              if (Z in p) return p[Z].slice();
              if (Z[0] === "#") return Z.length === 4 ? (G = parseInt(Z.substr(1), 16)) >= 0 && G <= 4095 ? [(3840 & G) >> 4 | (3840 & G) >> 8, 240 & G | (240 & G) >> 4, 15 & G | (15 & G) << 4, 1] : null : Z.length === 7 && (G = parseInt(Z.substr(1), 16)) >= 0 && G <= 16777215 ? [(16711680 & G) >> 16, (65280 & G) >> 8, 255 & G, 1] : null;
              var te = Z.indexOf("("), se = Z.indexOf(")");
              if (te !== -1 && se + 1 === Z.length) {
                var he = Z.substr(0, te), xe = Z.substr(te + 1, se - (te + 1)).split(","), Ve = 1;
                switch (he) {
                  case "rgba":
                    if (xe.length !== 4) return null;
                    Ve = M(xe.pop());
                  case "rgb":
                    return xe.length !== 3 ? null : [S(xe[0]), S(xe[1]), S(xe[2]), Ve];
                  case "hsla":
                    if (xe.length !== 4) return null;
                    Ve = M(xe.pop());
                  case "hsl":
                    if (xe.length !== 3) return null;
                    var je = (parseFloat(xe[0]) % 360 + 360) % 360 / 360, Qe = M(xe[1]), Ye = M(xe[2]), it = Ye <= 0.5 ? Ye * (Qe + 1) : Ye + Qe - Ye * Qe, pt = 2 * Ye - it;
                    return [x(255 * O(pt, it, je + 1 / 3)), x(255 * O(pt, it, je)), x(255 * O(pt, it, je - 1 / 3)), Ve];
                  default:
                    return null;
                }
              }
              return null;
            };
          } catch {
          }
        })).parseCSSColor, sn = function(a, c, p, x) {
          x === void 0 && (x = 1), this.r = a, this.g = c, this.b = p, this.a = x;
        };
        sn.parse = function(a) {
          if (a) {
            if (a instanceof sn) return a;
            if (typeof a == "string") {
              var c = er(a);
              if (c) return new sn(c[0] / 255 * c[3], c[1] / 255 * c[3], c[2] / 255 * c[3], c[3]);
            }
          }
        }, sn.prototype.toString = function() {
          var a = this.toArray(), c = a[1], p = a[2], x = a[3];
          return "rgba(" + Math.round(a[0]) + "," + Math.round(c) + "," + Math.round(p) + "," + x + ")";
        }, sn.prototype.toArray = function() {
          var a = this.a;
          return a === 0 ? [0, 0, 0, 0] : [255 * this.r / a, 255 * this.g / a, 255 * this.b / a, a];
        }, sn.black = new sn(0, 0, 0, 1), sn.white = new sn(1, 1, 1, 1), sn.transparent = new sn(0, 0, 0, 0), sn.red = new sn(1, 0, 0, 1);
        var Wi = function(a, c, p) {
          this.sensitivity = a ? c ? "variant" : "case" : c ? "accent" : "base", this.locale = p, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
        };
        Wi.prototype.compare = function(a, c) {
          return this.collator.compare(a, c);
        }, Wi.prototype.resolvedLocale = function() {
          return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
        };
        var ma = function(a, c, p, x, S) {
          this.text = a, this.image = c, this.scale = p, this.fontStack = x, this.textColor = S;
        }, ui = function(a) {
          this.sections = a;
        };
        ui.fromString = function(a) {
          return new ui([new ma(a, null, null, null, null)]);
        }, ui.prototype.isEmpty = function() {
          return this.sections.length === 0 || !this.sections.some((function(a) {
            return a.text.length !== 0 || a.image && a.image.name.length !== 0;
          }));
        }, ui.factory = function(a) {
          return a instanceof ui ? a : ui.fromString(a);
        }, ui.prototype.toString = function() {
          return this.sections.length === 0 ? "" : this.sections.map((function(a) {
            return a.text;
          })).join("");
        }, ui.prototype.serialize = function() {
          for (var a = ["format"], c = 0, p = this.sections; c < p.length; c += 1) {
            var x = p[c];
            if (x.image) a.push(["image", x.image.name]);
            else {
              a.push(x.text);
              var S = {};
              x.fontStack && (S["text-font"] = ["literal", x.fontStack.split(",")]), x.scale && (S["font-scale"] = x.scale), x.textColor && (S["text-color"] = ["rgba"].concat(x.textColor.toArray())), a.push(S);
            }
          }
          return a;
        };
        var Xn = function(a) {
          this.name = a.name, this.available = a.available;
        };
        function Ae(a, c, p, x) {
          return typeof a == "number" && a >= 0 && a <= 255 && typeof c == "number" && c >= 0 && c <= 255 && typeof p == "number" && p >= 0 && p <= 255 ? x === void 0 || typeof x == "number" && x >= 0 && x <= 1 ? null : "Invalid rgba value [" + [a, c, p, x].join(", ") + "]: 'a' must be between 0 and 1." : "Invalid rgba value [" + (typeof x == "number" ? [a, c, p, x] : [a, c, p]).join(", ") + "]: 'r', 'g', and 'b' must be between 0 and 255.";
        }
        function Ko(a) {
          if (a === null || typeof a == "string" || typeof a == "boolean" || typeof a == "number" || a instanceof sn || a instanceof Wi || a instanceof ui || a instanceof Xn) return !0;
          if (Array.isArray(a)) {
            for (var c = 0, p = a; c < p.length; c += 1) if (!Ko(p[c])) return !1;
            return !0;
          }
          if (typeof a == "object") {
            for (var x in a) if (!Ko(a[x])) return !1;
            return !0;
          }
          return !1;
        }
        function Zn(a) {
          if (a === null) return zt;
          if (typeof a == "string") return Vt;
          if (typeof a == "boolean") return Lt;
          if (typeof a == "number") return _t;
          if (a instanceof sn) return Yt;
          if (a instanceof Wi) return nn;
          if (a instanceof ui) return un;
          if (a instanceof Xn) return Yr;
          if (Array.isArray(a)) {
            for (var c, p = a.length, x = 0, S = a; x < S.length; x += 1) {
              var M = Zn(S[x]);
              if (c) {
                if (c === M) continue;
                c = ir;
                break;
              }
              c = M;
            }
            return Qr(c || ir, p);
          }
          return Hr;
        }
        function Qo(a) {
          var c = typeof a;
          return a === null ? "" : c === "string" || c === "number" || c === "boolean" ? String(a) : a instanceof sn || a instanceof ui || a instanceof Xn ? a.toString() : JSON.stringify(a);
        }
        Xn.prototype.toString = function() {
          return this.name;
        }, Xn.fromString = function(a) {
          return a ? new Xn({ name: a, available: !1 }) : null;
        }, Xn.prototype.serialize = function() {
          return ["image", this.name];
        };
        var Oi = function(a, c) {
          this.type = a, this.value = c;
        };
        Oi.parse = function(a, c) {
          if (a.length !== 2) return c.error("'literal' expression requires exactly one argument, but found " + (a.length - 1) + " instead.");
          if (!Ko(a[1])) return c.error("invalid value");
          var p = a[1], x = Zn(p), S = c.expectedType;
          return x.kind !== "array" || x.N !== 0 || !S || S.kind !== "array" || typeof S.N == "number" && S.N !== 0 || (x = S), new Oi(x, p);
        }, Oi.prototype.evaluate = function() {
          return this.value;
        }, Oi.prototype.eachChild = function() {
        }, Oi.prototype.outputDefined = function() {
          return !0;
        }, Oi.prototype.serialize = function() {
          return this.type.kind === "array" || this.type.kind === "object" ? ["literal", this.value] : this.value instanceof sn ? ["rgba"].concat(this.value.toArray()) : this.value instanceof ui ? this.value.serialize() : this.value;
        };
        var fi = function(a) {
          this.name = "ExpressionEvaluationError", this.message = a;
        };
        fi.prototype.toJSON = function() {
          return this.message;
        };
        var Ci = { string: Vt, number: _t, boolean: Lt, object: Hr }, Fn = function(a, c) {
          this.type = a, this.args = c;
        };
        Fn.parse = function(a, c) {
          if (a.length < 2) return c.error("Expected at least one argument.");
          var p, x = 1, S = a[0];
          if (S === "array") {
            var M, O;
            if (a.length > 2) {
              var N = a[1];
              if (typeof N != "string" || !(N in Ci) || N === "object") return c.error('The item type argument of "array" must be one of string, number, boolean', 1);
              M = Ci[N], x++;
            } else M = ir;
            if (a.length > 3) {
              if (a[2] !== null && (typeof a[2] != "number" || a[2] < 0 || a[2] !== Math.floor(a[2]))) return c.error('The length argument to "array" must be a positive integer literal', 2);
              O = a[2], x++;
            }
            p = Qr(M, O);
          } else p = Ci[S];
          for (var G = []; x < a.length; x++) {
            var Z = c.parse(a[x], x, ir);
            if (!Z) return null;
            G.push(Z);
          }
          return new Fn(p, G);
        }, Fn.prototype.evaluate = function(a) {
          for (var c = 0; c < this.args.length; c++) {
            var p = this.args[c].evaluate(a);
            if (!Kr(this.type, Zn(p))) return p;
            if (c === this.args.length - 1) throw new fi("Expected value to be of type " + $r(this.type) + ", but found " + $r(Zn(p)) + " instead.");
          }
          return null;
        }, Fn.prototype.eachChild = function(a) {
          this.args.forEach(a);
        }, Fn.prototype.outputDefined = function() {
          return this.args.every((function(a) {
            return a.outputDefined();
          }));
        }, Fn.prototype.serialize = function() {
          var a = this.type, c = [a.kind];
          if (a.kind === "array") {
            var p = a.itemType;
            if (p.kind === "string" || p.kind === "number" || p.kind === "boolean") {
              c.push(p.kind);
              var x = a.N;
              (typeof x == "number" || this.args.length > 1) && c.push(x);
            }
          }
          return c.concat(this.args.map((function(S) {
            return S.serialize();
          })));
        };
        var ms = function(a) {
          this.type = un, this.sections = a;
        };
        ms.parse = function(a, c) {
          if (a.length < 2) return c.error("Expected at least one argument.");
          var p = a[1];
          if (!Array.isArray(p) && typeof p == "object") return c.error("First argument must be an image or text section.");
          for (var x = [], S = !1, M = 1; M <= a.length - 1; ++M) {
            var O = a[M];
            if (S && typeof O == "object" && !Array.isArray(O)) {
              S = !1;
              var N = null;
              if (O["font-scale"] && !(N = c.parse(O["font-scale"], 1, _t))) return null;
              var G = null;
              if (O["text-font"] && !(G = c.parse(O["text-font"], 1, Qr(Vt)))) return null;
              var Z = null;
              if (O["text-color"] && !(Z = c.parse(O["text-color"], 1, Yt))) return null;
              var te = x[x.length - 1];
              te.scale = N, te.font = G, te.textColor = Z;
            } else {
              var se = c.parse(a[M], 1, ir);
              if (!se) return null;
              var he = se.type.kind;
              if (he !== "string" && he !== "value" && he !== "null" && he !== "resolvedImage") return c.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
              S = !0, x.push({ content: se, scale: null, font: null, textColor: null });
            }
          }
          return new ms(x);
        }, ms.prototype.evaluate = function(a) {
          return new ui(this.sections.map((function(c) {
            var p = c.content.evaluate(a);
            return Zn(p) === Yr ? new ma("", p, null, null, null) : new ma(Qo(p), null, c.scale ? c.scale.evaluate(a) : null, c.font ? c.font.evaluate(a).join(",") : null, c.textColor ? c.textColor.evaluate(a) : null);
          })));
        }, ms.prototype.eachChild = function(a) {
          for (var c = 0, p = this.sections; c < p.length; c += 1) {
            var x = p[c];
            a(x.content), x.scale && a(x.scale), x.font && a(x.font), x.textColor && a(x.textColor);
          }
        }, ms.prototype.outputDefined = function() {
          return !1;
        }, ms.prototype.serialize = function() {
          for (var a = ["format"], c = 0, p = this.sections; c < p.length; c += 1) {
            var x = p[c];
            a.push(x.content.serialize());
            var S = {};
            x.scale && (S["font-scale"] = x.scale.serialize()), x.font && (S["text-font"] = x.font.serialize()), x.textColor && (S["text-color"] = x.textColor.serialize()), a.push(S);
          }
          return a;
        };
        var $i = function(a) {
          this.type = Yr, this.input = a;
        };
        $i.parse = function(a, c) {
          if (a.length !== 2) return c.error("Expected two arguments.");
          var p = c.parse(a[1], 1, Vt);
          return p ? new $i(p) : c.error("No image name provided.");
        }, $i.prototype.evaluate = function(a) {
          var c = this.input.evaluate(a), p = Xn.fromString(c);
          return p && a.availableImages && (p.available = a.availableImages.indexOf(c) > -1), p;
        }, $i.prototype.eachChild = function(a) {
          a(this.input);
        }, $i.prototype.outputDefined = function() {
          return !1;
        }, $i.prototype.serialize = function() {
          return ["image", this.input.serialize()];
        };
        var Ms = { "to-boolean": Lt, "to-color": Yt, "to-number": _t, "to-string": Vt }, On = function(a, c) {
          this.type = a, this.args = c;
        };
        On.parse = function(a, c) {
          if (a.length < 2) return c.error("Expected at least one argument.");
          var p = a[0];
          if ((p === "to-boolean" || p === "to-string") && a.length !== 2) return c.error("Expected one argument.");
          for (var x = Ms[p], S = [], M = 1; M < a.length; M++) {
            var O = c.parse(a[M], M, ir);
            if (!O) return null;
            S.push(O);
          }
          return new On(x, S);
        }, On.prototype.evaluate = function(a) {
          if (this.type.kind === "boolean") return !!this.args[0].evaluate(a);
          if (this.type.kind === "color") {
            for (var c, p, x = 0, S = this.args; x < S.length; x += 1) {
              if (p = null, (c = S[x].evaluate(a)) instanceof sn) return c;
              if (typeof c == "string") {
                var M = a.parseColor(c);
                if (M) return M;
              } else if (Array.isArray(c) && !(p = c.length < 3 || c.length > 4 ? "Invalid rbga value " + JSON.stringify(c) + ": expected an array containing either three or four numeric values." : Ae(c[0], c[1], c[2], c[3]))) return new sn(c[0] / 255, c[1] / 255, c[2] / 255, c[3]);
            }
            throw new fi(p || "Could not parse color from value '" + (typeof c == "string" ? c : String(JSON.stringify(c))) + "'");
          }
          if (this.type.kind === "number") {
            for (var O = null, N = 0, G = this.args; N < G.length; N += 1) {
              if ((O = G[N].evaluate(a)) === null) return 0;
              var Z = Number(O);
              if (!isNaN(Z)) return Z;
            }
            throw new fi("Could not convert " + JSON.stringify(O) + " to number.");
          }
          return this.type.kind === "formatted" ? ui.fromString(Qo(this.args[0].evaluate(a))) : this.type.kind === "resolvedImage" ? Xn.fromString(Qo(this.args[0].evaluate(a))) : Qo(this.args[0].evaluate(a));
        }, On.prototype.eachChild = function(a) {
          this.args.forEach(a);
        }, On.prototype.outputDefined = function() {
          return this.args.every((function(a) {
            return a.outputDefined();
          }));
        }, On.prototype.serialize = function() {
          if (this.type.kind === "formatted") return new ms([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize();
          if (this.type.kind === "resolvedImage") return new $i(this.args[0]).serialize();
          var a = ["to-" + this.type.kind];
          return this.eachChild((function(c) {
            a.push(c.serialize());
          })), a;
        };
        var lf = ["Unknown", "Point", "LineString", "Polygon"], Ee = function() {
          this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
        };
        Ee.prototype.id = function() {
          return this.feature && "id" in this.feature ? this.feature.id : null;
        }, Ee.prototype.geometryType = function() {
          return this.feature ? typeof this.feature.type == "number" ? lf[this.feature.type] : this.feature.type : null;
        }, Ee.prototype.geometry = function() {
          return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
        }, Ee.prototype.canonicalID = function() {
          return this.canonical;
        }, Ee.prototype.properties = function() {
          return this.feature && this.feature.properties || {};
        }, Ee.prototype.parseColor = function(a) {
          var c = this._parseColorCache[a];
          return c || (c = this._parseColorCache[a] = sn.parse(a)), c;
        };
        var ke = function(a, c, p, x) {
          this.name = a, this.type = c, this._evaluate = p, this.args = x;
        };
        ke.prototype.evaluate = function(a) {
          return this._evaluate(a, this.args);
        }, ke.prototype.eachChild = function(a) {
          this.args.forEach(a);
        }, ke.prototype.outputDefined = function() {
          return !1;
        }, ke.prototype.serialize = function() {
          return [this.name].concat(this.args.map((function(a) {
            return a.serialize();
          })));
        }, ke.parse = function(a, c) {
          var p, x = a[0], S = ke.definitions[x];
          if (!S) return c.error('Unknown expression "' + x + '". If you wanted a literal array, use ["literal", [...]].', 0);
          for (var M = Array.isArray(S) ? S[0] : S.type, O = Array.isArray(S) ? [[S[1], S[2]]] : S.overloads, N = O.filter((function(Dr) {
            var cr = Dr[0];
            return !Array.isArray(cr) || cr.length === a.length - 1;
          })), G = null, Z = 0, te = N; Z < te.length; Z += 1) {
            var se = te[Z], he = se[0], xe = se[1];
            G = new Uo(c.registry, c.path, null, c.scope);
            for (var Ve = [], je = !1, Qe = 1; Qe < a.length; Qe++) {
              var Ye = a[Qe], it = Array.isArray(he) ? he[Qe - 1] : he.type, pt = G.parse(Ye, 1 + Ve.length, it);
              if (!pt) {
                je = !0;
                break;
              }
              Ve.push(pt);
            }
            if (!je) if (Array.isArray(he) && he.length !== Ve.length) G.error("Expected " + he.length + " arguments, but found " + Ve.length + " instead.");
            else {
              for (var xt = 0; xt < Ve.length; xt++) {
                var Tt = Array.isArray(he) ? he[xt] : he.type, Nt = Ve[xt];
                G.concat(xt + 1).checkSubtype(Tt, Nt.type);
              }
              if (G.errors.length === 0) return new ke(x, M, xe, Ve);
            }
          }
          if (N.length === 1) (p = c.errors).push.apply(p, G.errors);
          else {
            for (var Kt = (N.length ? N : O).map((function(Dr) {
              var cr;
              return cr = Dr[0], Array.isArray(cr) ? "(" + cr.map($r).join(", ") + ")" : "(" + $r(cr.type) + "...)";
            })).join(" | "), rr = [], Ir = 1; Ir < a.length; Ir++) {
              var lr = c.parse(a[Ir], 1 + rr.length);
              if (!lr) return null;
              rr.push($r(lr.type));
            }
            c.error("Expected arguments of type " + Kt + ", but found (" + rr.join(", ") + ") instead.");
          }
          return null;
        }, ke.register = function(a, c) {
          for (var p in ke.definitions = c, c) a[p] = ke;
        };
        var Ke = function(a, c, p) {
          this.type = nn, this.locale = p, this.caseSensitive = a, this.diacriticSensitive = c;
        };
        function bt(a, c) {
          a[0] = Math.min(a[0], c[0]), a[1] = Math.min(a[1], c[1]), a[2] = Math.max(a[2], c[0]), a[3] = Math.max(a[3], c[1]);
        }
        function Qt(a, c) {
          return !(a[0] <= c[0] || a[2] >= c[2] || a[1] <= c[1] || a[3] >= c[3]);
        }
        function Tr(a, c) {
          var p = (180 + a[0]) / 360, x = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + a[1] * Math.PI / 360))) / 360, S = Math.pow(2, c.z);
          return [Math.round(p * S * 8192), Math.round(x * S * 8192)];
        }
        function Tn(a, c, p) {
          return c[1] > a[1] != p[1] > a[1] && a[0] < (p[0] - c[0]) * (a[1] - c[1]) / (p[1] - c[1]) + c[0];
        }
        function bi(a, c) {
          for (var p, x, S, M, O, N, G, Z = !1, te = 0, se = c.length; te < se; te++) for (var he = c[te], xe = 0, Ve = he.length; xe < Ve - 1; xe++) {
            if ((M = (p = a)[0] - (x = he[xe])[0]) * (G = p[1] - (S = he[xe + 1])[1]) - (N = p[0] - S[0]) * (O = p[1] - x[1]) == 0 && M * N <= 0 && O * G <= 0) return !1;
            Tn(a, he[xe], he[xe + 1]) && (Z = !Z);
          }
          return Z;
        }
        function mn(a, c) {
          for (var p = 0; p < c.length; p++) if (bi(a, c[p])) return !0;
          return !1;
        }
        function Di(a, c, p, x) {
          var S = x[0] - p[0], M = x[1] - p[1], O = (a[0] - p[0]) * M - S * (a[1] - p[1]), N = (c[0] - p[0]) * M - S * (c[1] - p[1]);
          return O > 0 && N < 0 || O < 0 && N > 0;
        }
        function qs(a, c, p) {
          for (var x = 0, S = p; x < S.length; x += 1) for (var M = S[x], O = 0; O < M.length - 1; ++O) if ((se = [(te = M[O + 1])[0] - (Z = M[O])[0], te[1] - Z[1]])[0] * (he = [(G = c)[0] - (N = a)[0], G[1] - N[1]])[1] - se[1] * he[0] != 0 && Di(N, G, Z, te) && Di(Z, te, N, G)) return !0;
          var N, G, Z, te, se, he;
          return !1;
        }
        function wh(a, c) {
          for (var p = 0; p < a.length; ++p) if (!bi(a[p], c)) return !1;
          for (var x = 0; x < a.length - 1; ++x) if (qs(a[x], a[x + 1], c)) return !1;
          return !0;
        }
        function Th(a, c) {
          for (var p = 0; p < c.length; p++) if (wh(a, c[p])) return !0;
          return !1;
        }
        function Tl(a, c, p) {
          for (var x = [], S = 0; S < a.length; S++) {
            for (var M = [], O = 0; O < a[S].length; O++) {
              var N = Tr(a[S][O], p);
              bt(c, N), M.push(N);
            }
            x.push(M);
          }
          return x;
        }
        function au(a, c, p) {
          for (var x = [], S = 0; S < a.length; S++) {
            var M = Tl(a[S], c, p);
            x.push(M);
          }
          return x;
        }
        function Va(a, c, p, x) {
          if (a[0] < p[0] || a[0] > p[2]) {
            var S = 0.5 * x, M = a[0] - p[0] > S ? -x : p[0] - a[0] > S ? x : 0;
            M === 0 && (M = a[0] - p[2] > S ? -x : p[2] - a[0] > S ? x : 0), a[0] += M;
          }
          bt(c, a);
        }
        function lu(a, c, p, x) {
          for (var S = 8192 * Math.pow(2, x.z), M = [8192 * x.x, 8192 * x.y], O = [], N = 0, G = a; N < G.length; N += 1) for (var Z = 0, te = G[N]; Z < te.length; Z += 1) {
            var se = te[Z], he = [se.x + M[0], se.y + M[1]];
            Va(he, c, p, S), O.push(he);
          }
          return O;
        }
        function cu(a, c, p, x) {
          for (var S, M = 8192 * Math.pow(2, x.z), O = [8192 * x.x, 8192 * x.y], N = [], G = 0, Z = a; G < Z.length; G += 1) {
            for (var te = [], se = 0, he = Z[G]; se < he.length; se += 1) {
              var xe = he[se], Ve = [xe.x + O[0], xe.y + O[1]];
              bt(c, Ve), te.push(Ve);
            }
            N.push(te);
          }
          if (c[2] - c[0] <= M / 2) {
            (S = c)[0] = S[1] = 1 / 0, S[2] = S[3] = -1 / 0;
            for (var je = 0, Qe = N; je < Qe.length; je += 1) for (var Ye = 0, it = Qe[je]; Ye < it.length; Ye += 1) Va(it[Ye], c, p, M);
          }
          return N;
        }
        Ke.parse = function(a, c) {
          if (a.length !== 2) return c.error("Expected one argument.");
          var p = a[1];
          if (typeof p != "object" || Array.isArray(p)) return c.error("Collator options argument must be an object.");
          var x = c.parse(p["case-sensitive"] !== void 0 && p["case-sensitive"], 1, Lt);
          if (!x) return null;
          var S = c.parse(p["diacritic-sensitive"] !== void 0 && p["diacritic-sensitive"], 1, Lt);
          if (!S) return null;
          var M = null;
          return p.locale && !(M = c.parse(p.locale, 1, Vt)) ? null : new Ke(x, S, M);
        }, Ke.prototype.evaluate = function(a) {
          return new Wi(this.caseSensitive.evaluate(a), this.diacriticSensitive.evaluate(a), this.locale ? this.locale.evaluate(a) : null);
        }, Ke.prototype.eachChild = function(a) {
          a(this.caseSensitive), a(this.diacriticSensitive), this.locale && a(this.locale);
        }, Ke.prototype.outputDefined = function() {
          return !1;
        }, Ke.prototype.serialize = function() {
          var a = {};
          return a["case-sensitive"] = this.caseSensitive.serialize(), a["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (a.locale = this.locale.serialize()), ["collator", a];
        };
        var oo = function(a, c) {
          this.type = Lt, this.geojson = a, this.geometries = c;
        };
        function _a(a) {
          if (a instanceof ke && (a.name === "get" && a.args.length === 1 || a.name === "feature-state" || a.name === "has" && a.args.length === 1 || a.name === "properties" || a.name === "geometry-type" || a.name === "id" || /^filter-/.test(a.name)) || a instanceof oo) return !1;
          var c = !0;
          return a.eachChild((function(p) {
            c && !_a(p) && (c = !1);
          })), c;
        }
        function Jo(a) {
          if (a instanceof ke && a.name === "feature-state") return !1;
          var c = !0;
          return a.eachChild((function(p) {
            c && !Jo(p) && (c = !1);
          })), c;
        }
        function ja(a, c) {
          if (a instanceof ke && c.indexOf(a.name) >= 0) return !1;
          var p = !0;
          return a.eachChild((function(x) {
            p && !ja(x, c) && (p = !1);
          })), p;
        }
        oo.parse = function(a, c) {
          if (a.length !== 2) return c.error("'within' expression requires exactly one argument, but found " + (a.length - 1) + " instead.");
          if (Ko(a[1])) {
            var p = a[1];
            if (p.type === "FeatureCollection") for (var x = 0; x < p.features.length; ++x) {
              var S = p.features[x].geometry.type;
              if (S === "Polygon" || S === "MultiPolygon") return new oo(p, p.features[x].geometry);
            }
            else if (p.type === "Feature") {
              var M = p.geometry.type;
              if (M === "Polygon" || M === "MultiPolygon") return new oo(p, p.geometry);
            } else if (p.type === "Polygon" || p.type === "MultiPolygon") return new oo(p, p);
          }
          return c.error("'within' expression requires valid geojson object that contains polygon geometry type.");
        }, oo.prototype.evaluate = function(a) {
          if (a.geometry() != null && a.canonicalID() != null) {
            if (a.geometryType() === "Point") return (function(c, p) {
              var x = [1 / 0, 1 / 0, -1 / 0, -1 / 0], S = [1 / 0, 1 / 0, -1 / 0, -1 / 0], M = c.canonicalID();
              if (p.type === "Polygon") {
                var O = Tl(p.coordinates, S, M), N = lu(c.geometry(), x, S, M);
                if (!Qt(x, S)) return !1;
                for (var G = 0, Z = N; G < Z.length; G += 1) if (!bi(Z[G], O)) return !1;
              }
              if (p.type === "MultiPolygon") {
                var te = au(p.coordinates, S, M), se = lu(c.geometry(), x, S, M);
                if (!Qt(x, S)) return !1;
                for (var he = 0, xe = se; he < xe.length; he += 1) if (!mn(xe[he], te)) return !1;
              }
              return !0;
            })(a, this.geometries);
            if (a.geometryType() === "LineString") return (function(c, p) {
              var x = [1 / 0, 1 / 0, -1 / 0, -1 / 0], S = [1 / 0, 1 / 0, -1 / 0, -1 / 0], M = c.canonicalID();
              if (p.type === "Polygon") {
                var O = Tl(p.coordinates, S, M), N = cu(c.geometry(), x, S, M);
                if (!Qt(x, S)) return !1;
                for (var G = 0, Z = N; G < Z.length; G += 1) if (!wh(Z[G], O)) return !1;
              }
              if (p.type === "MultiPolygon") {
                var te = au(p.coordinates, S, M), se = cu(c.geometry(), x, S, M);
                if (!Qt(x, S)) return !1;
                for (var he = 0, xe = se; he < xe.length; he += 1) if (!Th(xe[he], te)) return !1;
              }
              return !0;
            })(a, this.geometries);
          }
          return !1;
        }, oo.prototype.eachChild = function() {
        }, oo.prototype.outputDefined = function() {
          return !0;
        }, oo.prototype.serialize = function() {
          return ["within", this.geojson];
        };
        var No = function(a, c) {
          this.type = c.type, this.name = a, this.boundExpression = c;
        };
        No.parse = function(a, c) {
          if (a.length !== 2 || typeof a[1] != "string") return c.error("'var' expression requires exactly one string literal argument.");
          var p = a[1];
          return c.scope.has(p) ? new No(p, c.scope.get(p)) : c.error('Unknown variable "' + p + '". Make sure "' + p + '" has been bound in an enclosing "let" expression before using it.', 1);
        }, No.prototype.evaluate = function(a) {
          return this.boundExpression.evaluate(a);
        }, No.prototype.eachChild = function() {
        }, No.prototype.outputDefined = function() {
          return !1;
        }, No.prototype.serialize = function() {
          return ["var", this.name];
        };
        var Uo = function(a, c, p, x, S) {
          c === void 0 && (c = []), x === void 0 && (x = new kt()), S === void 0 && (S = []), this.registry = a, this.path = c, this.key = c.map((function(M) {
            return "[" + M + "]";
          })).join(""), this.scope = x, this.errors = S, this.expectedType = p;
        };
        function uu(a, c) {
          for (var p, x = a.length - 1, S = 0, M = x, O = 0; S <= M; ) if ((p = a[O = Math.floor((S + M) / 2)]) <= c) {
            if (O === x || c < a[O + 1]) return O;
            S = O + 1;
          } else {
            if (!(p > c)) throw new fi("Input is not a number.");
            M = O - 1;
          }
          return 0;
        }
        Uo.prototype.parse = function(a, c, p, x, S) {
          return S === void 0 && (S = {}), c ? this.concat(c, p, x)._parse(a, S) : this._parse(a, S);
        }, Uo.prototype._parse = function(a, c) {
          function p(Z, te, se) {
            return se === "assert" ? new Fn(te, [Z]) : se === "coerce" ? new On(te, [Z]) : Z;
          }
          if (a !== null && typeof a != "string" && typeof a != "boolean" && typeof a != "number" || (a = ["literal", a]), Array.isArray(a)) {
            if (a.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
            var x = a[0];
            if (typeof x != "string") return this.error("Expression name must be a string, but found " + typeof x + ' instead. If you wanted a literal array, use ["literal", [...]].', 0), null;
            var S = this.registry[x];
            if (S) {
              var M = S.parse(a, this);
              if (!M) return null;
              if (this.expectedType) {
                var O = this.expectedType, N = M.type;
                if (O.kind !== "string" && O.kind !== "number" && O.kind !== "boolean" && O.kind !== "object" && O.kind !== "array" || N.kind !== "value") if (O.kind !== "color" && O.kind !== "formatted" && O.kind !== "resolvedImage" || N.kind !== "value" && N.kind !== "string") {
                  if (this.checkSubtype(O, N)) return null;
                } else M = p(M, O, c.typeAnnotation || "coerce");
                else M = p(M, O, c.typeAnnotation || "assert");
              }
              if (!(M instanceof Oi) && M.type.kind !== "resolvedImage" && (function Z(te) {
                if (te instanceof No) return Z(te.boundExpression);
                if (te instanceof ke && te.name === "error" || te instanceof Ke || te instanceof oo) return !1;
                var se = te instanceof On || te instanceof Fn, he = !0;
                return te.eachChild((function(xe) {
                  he = se ? he && Z(xe) : he && xe instanceof Oi;
                })), !!he && _a(te) && ja(te, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
              })(M)) {
                var G = new Ee();
                try {
                  M = new Oi(M.type, M.evaluate(G));
                } catch (Z) {
                  return this.error(Z.message), null;
                }
              }
              return M;
            }
            return this.error('Unknown expression "' + x + '". If you wanted a literal array, use ["literal", [...]].', 0);
          }
          return this.error(a === void 0 ? "'undefined' value invalid. Use null instead." : typeof a == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : "Expected an array, but found " + typeof a + " instead.");
        }, Uo.prototype.concat = function(a, c, p) {
          var x = typeof a == "number" ? this.path.concat(a) : this.path, S = p ? this.scope.concat(p) : this.scope;
          return new Uo(this.registry, x, c || null, S, this.errors);
        }, Uo.prototype.error = function(a) {
          for (var c = [], p = arguments.length - 1; p-- > 0; ) c[p] = arguments[p + 1];
          var x = "" + this.key + c.map((function(S) {
            return "[" + S + "]";
          })).join("");
          this.errors.push(new Mt(x, a));
        }, Uo.prototype.checkSubtype = function(a, c) {
          var p = Kr(a, c);
          return p && this.error(p), p;
        };
        var _s = function(a, c, p) {
          this.type = a, this.input = c, this.labels = [], this.outputs = [];
          for (var x = 0, S = p; x < S.length; x += 1) {
            var M = S[x], O = M[1];
            this.labels.push(M[0]), this.outputs.push(O);
          }
        };
        function gi(a, c, p) {
          return a * (1 - p) + c * p;
        }
        _s.parse = function(a, c) {
          if (a.length - 1 < 4) return c.error("Expected at least 4 arguments, but found only " + (a.length - 1) + ".");
          if ((a.length - 1) % 2 != 0) return c.error("Expected an even number of arguments.");
          var p = c.parse(a[1], 1, _t);
          if (!p) return null;
          var x = [], S = null;
          c.expectedType && c.expectedType.kind !== "value" && (S = c.expectedType);
          for (var M = 1; M < a.length; M += 2) {
            var O = M === 1 ? -1 / 0 : a[M], N = a[M + 1], G = M, Z = M + 1;
            if (typeof O != "number") return c.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', G);
            if (x.length && x[x.length - 1][0] >= O) return c.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', G);
            var te = c.parse(N, Z, S);
            if (!te) return null;
            S = S || te.type, x.push([O, te]);
          }
          return new _s(S, p, x);
        }, _s.prototype.evaluate = function(a) {
          var c = this.labels, p = this.outputs;
          if (c.length === 1) return p[0].evaluate(a);
          var x = this.input.evaluate(a);
          if (x <= c[0]) return p[0].evaluate(a);
          var S = c.length;
          return x >= c[S - 1] ? p[S - 1].evaluate(a) : p[uu(c, x)].evaluate(a);
        }, _s.prototype.eachChild = function(a) {
          a(this.input);
          for (var c = 0, p = this.outputs; c < p.length; c += 1) a(p[c]);
        }, _s.prototype.outputDefined = function() {
          return this.outputs.every((function(a) {
            return a.outputDefined();
          }));
        }, _s.prototype.serialize = function() {
          for (var a = ["step", this.input.serialize()], c = 0; c < this.labels.length; c++) c > 0 && a.push(this.labels[c]), a.push(this.outputs[c].serialize());
          return a;
        };
        var Ha = Object.freeze({ __proto__: null, number: gi, color: function(a, c, p) {
          return new sn(gi(a.r, c.r, p), gi(a.g, c.g, p), gi(a.b, c.b, p), gi(a.a, c.a, p));
        }, array: function(a, c, p) {
          return a.map((function(x, S) {
            return gi(x, c[S], p);
          }));
        } }), Eh = 6 / 29 * 3 * (6 / 29), Hp = Math.PI / 180, Gp = 180 / Math.PI;
        function cf(a) {
          return a > 0.008856451679035631 ? Math.pow(a, 1 / 3) : a / Eh + 4 / 29;
        }
        function qi(a) {
          return a > 6 / 29 ? a * a * a : Eh * (a - 4 / 29);
        }
        function ea(a) {
          return 255 * (a <= 31308e-7 ? 12.92 * a : 1.055 * Math.pow(a, 1 / 2.4) - 0.055);
        }
        function rs(a) {
          return (a /= 255) <= 0.04045 ? a / 12.92 : Math.pow((a + 0.055) / 1.055, 2.4);
        }
        function fu(a) {
          var c = rs(a.r), p = rs(a.g), x = rs(a.b), S = cf((0.4124564 * c + 0.3575761 * p + 0.1804375 * x) / 0.95047), M = cf((0.2126729 * c + 0.7151522 * p + 0.072175 * x) / 1);
          return { l: 116 * M - 16, a: 500 * (S - M), b: 200 * (M - cf((0.0193339 * c + 0.119192 * p + 0.9503041 * x) / 1.08883)), alpha: a.a };
        }
        function uf(a) {
          var c = (a.l + 16) / 116, p = isNaN(a.a) ? c : c + a.a / 500, x = isNaN(a.b) ? c : c - a.b / 200;
          return c = 1 * qi(c), p = 0.95047 * qi(p), x = 1.08883 * qi(x), new sn(ea(3.2404542 * p - 1.5371385 * c - 0.4985314 * x), ea(-0.969266 * p + 1.8760108 * c + 0.041556 * x), ea(0.0556434 * p - 0.2040259 * c + 1.0572252 * x), a.alpha);
        }
        function hu(a, c, p) {
          var x = c - a;
          return a + p * (x > 180 || x < -180 ? x - 360 * Math.round(x / 360) : x);
        }
        var Ac = { forward: fu, reverse: uf, interpolate: function(a, c, p) {
          return { l: gi(a.l, c.l, p), a: gi(a.a, c.a, p), b: gi(a.b, c.b, p), alpha: gi(a.alpha, c.alpha, p) };
        } }, gc = { forward: function(a) {
          var c = fu(a), p = c.l, x = c.a, S = c.b, M = Math.atan2(S, x) * Gp;
          return { h: M < 0 ? M + 360 : M, c: Math.sqrt(x * x + S * S), l: p, alpha: a.a };
        }, reverse: function(a) {
          var c = a.h * Hp, p = a.c;
          return uf({ l: a.l, a: Math.cos(c) * p, b: Math.sin(c) * p, alpha: a.alpha });
        }, interpolate: function(a, c, p) {
          return { h: hu(a.h, c.h, p), c: gi(a.c, c.c, p), l: gi(a.l, c.l, p), alpha: gi(a.alpha, c.alpha, p) };
        } }, Ch = Object.freeze({ __proto__: null, lab: Ac, hcl: gc }), Ui = function(a, c, p, x, S) {
          this.type = a, this.operator = c, this.interpolation = p, this.input = x, this.labels = [], this.outputs = [];
          for (var M = 0, O = S; M < O.length; M += 1) {
            var N = O[M], G = N[1];
            this.labels.push(N[0]), this.outputs.push(G);
          }
        };
        function El(a, c, p, x) {
          var S = x - p, M = a - p;
          return S === 0 ? 0 : c === 1 ? M / S : (Math.pow(c, M) - 1) / (Math.pow(c, S) - 1);
        }
        Ui.interpolationFactor = function(a, c, p, x) {
          var S = 0;
          if (a.name === "exponential") S = El(c, a.base, p, x);
          else if (a.name === "linear") S = El(c, 1, p, x);
          else if (a.name === "cubic-bezier") {
            var M = a.controlPoints;
            S = new u(M[0], M[1], M[2], M[3]).solve(El(c, 1, p, x));
          }
          return S;
        }, Ui.parse = function(a, c) {
          var p = a[0], x = a[1], S = a[2], M = a.slice(3);
          if (!Array.isArray(x) || x.length === 0) return c.error("Expected an interpolation type expression.", 1);
          if (x[0] === "linear") x = { name: "linear" };
          else if (x[0] === "exponential") {
            var O = x[1];
            if (typeof O != "number") return c.error("Exponential interpolation requires a numeric base.", 1, 1);
            x = { name: "exponential", base: O };
          } else {
            if (x[0] !== "cubic-bezier") return c.error("Unknown interpolation type " + String(x[0]), 1, 0);
            var N = x.slice(1);
            if (N.length !== 4 || N.some((function(Qe) {
              return typeof Qe != "number" || Qe < 0 || Qe > 1;
            }))) return c.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
            x = { name: "cubic-bezier", controlPoints: N };
          }
          if (a.length - 1 < 4) return c.error("Expected at least 4 arguments, but found only " + (a.length - 1) + ".");
          if ((a.length - 1) % 2 != 0) return c.error("Expected an even number of arguments.");
          if (!(S = c.parse(S, 2, _t))) return null;
          var G = [], Z = null;
          p === "interpolate-hcl" || p === "interpolate-lab" ? Z = Yt : c.expectedType && c.expectedType.kind !== "value" && (Z = c.expectedType);
          for (var te = 0; te < M.length; te += 2) {
            var se = M[te], he = M[te + 1], xe = te + 3, Ve = te + 4;
            if (typeof se != "number") return c.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', xe);
            if (G.length && G[G.length - 1][0] >= se) return c.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', xe);
            var je = c.parse(he, Ve, Z);
            if (!je) return null;
            Z = Z || je.type, G.push([se, je]);
          }
          return Z.kind === "number" || Z.kind === "color" || Z.kind === "array" && Z.itemType.kind === "number" && typeof Z.N == "number" ? new Ui(Z, p, x, S, G) : c.error("Type " + $r(Z) + " is not interpolatable.");
        }, Ui.prototype.evaluate = function(a) {
          var c = this.labels, p = this.outputs;
          if (c.length === 1) return p[0].evaluate(a);
          var x = this.input.evaluate(a);
          if (x <= c[0]) return p[0].evaluate(a);
          var S = c.length;
          if (x >= c[S - 1]) return p[S - 1].evaluate(a);
          var M = uu(c, x), O = Ui.interpolationFactor(this.interpolation, x, c[M], c[M + 1]), N = p[M].evaluate(a), G = p[M + 1].evaluate(a);
          return this.operator === "interpolate" ? Ha[this.type.kind.toLowerCase()](N, G, O) : this.operator === "interpolate-hcl" ? gc.reverse(gc.interpolate(gc.forward(N), gc.forward(G), O)) : Ac.reverse(Ac.interpolate(Ac.forward(N), Ac.forward(G), O));
        }, Ui.prototype.eachChild = function(a) {
          a(this.input);
          for (var c = 0, p = this.outputs; c < p.length; c += 1) a(p[c]);
        }, Ui.prototype.outputDefined = function() {
          return this.outputs.every((function(a) {
            return a.outputDefined();
          }));
        }, Ui.prototype.serialize = function() {
          var a;
          a = this.interpolation.name === "linear" ? ["linear"] : this.interpolation.name === "exponential" ? this.interpolation.base === 1 ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
          for (var c = [this.operator, a, this.input.serialize()], p = 0; p < this.labels.length; p++) c.push(this.labels[p], this.outputs[p].serialize());
          return c;
        };
        var Rs = function(a, c) {
          this.type = a, this.args = c;
        };
        Rs.parse = function(a, c) {
          if (a.length < 2) return c.error("Expectected at least one argument.");
          var p = null, x = c.expectedType;
          x && x.kind !== "value" && (p = x);
          for (var S = [], M = 0, O = a.slice(1); M < O.length; M += 1) {
            var N = c.parse(O[M], 1 + S.length, p, void 0, { typeAnnotation: "omit" });
            if (!N) return null;
            p = p || N.type, S.push(N);
          }
          var G = x && S.some((function(Z) {
            return Kr(x, Z.type);
          }));
          return new Rs(G ? ir : p, S);
        }, Rs.prototype.evaluate = function(a) {
          for (var c, p = null, x = 0, S = 0, M = this.args; S < M.length && (x++, (p = M[S].evaluate(a)) && p instanceof Xn && !p.available && (c || (c = p.name), p = null, x === this.args.length && (p = c)), p === null); S += 1) ;
          return p;
        }, Rs.prototype.eachChild = function(a) {
          this.args.forEach(a);
        }, Rs.prototype.outputDefined = function() {
          return this.args.every((function(a) {
            return a.outputDefined();
          }));
        }, Rs.prototype.serialize = function() {
          var a = ["coalesce"];
          return this.eachChild((function(c) {
            a.push(c.serialize());
          })), a;
        };
        var ta = function(a, c) {
          this.type = c.type, this.bindings = [].concat(a), this.result = c;
        };
        ta.prototype.evaluate = function(a) {
          return this.result.evaluate(a);
        }, ta.prototype.eachChild = function(a) {
          for (var c = 0, p = this.bindings; c < p.length; c += 1) a(p[c][1]);
          a(this.result);
        }, ta.parse = function(a, c) {
          if (a.length < 4) return c.error("Expected at least 3 arguments, but found " + (a.length - 1) + " instead.");
          for (var p = [], x = 1; x < a.length - 1; x += 2) {
            var S = a[x];
            if (typeof S != "string") return c.error("Expected string, but found " + typeof S + " instead.", x);
            if (/[^a-zA-Z0-9_]/.test(S)) return c.error("Variable names must contain only alphanumeric characters or '_'.", x);
            var M = c.parse(a[x + 1], x + 1);
            if (!M) return null;
            p.push([S, M]);
          }
          var O = c.parse(a[a.length - 1], a.length - 1, c.expectedType, p);
          return O ? new ta(p, O) : null;
        }, ta.prototype.outputDefined = function() {
          return this.result.outputDefined();
        }, ta.prototype.serialize = function() {
          for (var a = ["let"], c = 0, p = this.bindings; c < p.length; c += 1) {
            var x = p[c];
            a.push(x[0], x[1].serialize());
          }
          return a.push(this.result.serialize()), a;
        };
        var ya = function(a, c, p) {
          this.type = a, this.index = c, this.input = p;
        };
        ya.parse = function(a, c) {
          if (a.length !== 3) return c.error("Expected 2 arguments, but found " + (a.length - 1) + " instead.");
          var p = c.parse(a[1], 1, _t), x = c.parse(a[2], 2, Qr(c.expectedType || ir));
          return p && x ? new ya(x.type.itemType, p, x) : null;
        }, ya.prototype.evaluate = function(a) {
          var c = this.index.evaluate(a), p = this.input.evaluate(a);
          if (c < 0) throw new fi("Array index out of bounds: " + c + " < 0.");
          if (c >= p.length) throw new fi("Array index out of bounds: " + c + " > " + (p.length - 1) + ".");
          if (c !== Math.floor(c)) throw new fi("Array index must be an integer, but found " + c + " instead.");
          return p[c];
        }, ya.prototype.eachChild = function(a) {
          a(this.index), a(this.input);
        }, ya.prototype.outputDefined = function() {
          return !1;
        }, ya.prototype.serialize = function() {
          return ["at", this.index.serialize(), this.input.serialize()];
        };
        var zo = function(a, c) {
          this.type = Lt, this.needle = a, this.haystack = c;
        };
        zo.parse = function(a, c) {
          if (a.length !== 3) return c.error("Expected 2 arguments, but found " + (a.length - 1) + " instead.");
          var p = c.parse(a[1], 1, ir), x = c.parse(a[2], 2, ir);
          return p && x ? hr(p.type, [Lt, Vt, _t, zt, ir]) ? new zo(p, x) : c.error("Expected first argument to be of type boolean, string, number or null, but found " + $r(p.type) + " instead") : null;
        }, zo.prototype.evaluate = function(a) {
          var c = this.needle.evaluate(a), p = this.haystack.evaluate(a);
          if (!p) return !1;
          if (!ye(c, ["boolean", "string", "number", "null"])) throw new fi("Expected first argument to be of type boolean, string, number or null, but found " + $r(Zn(c)) + " instead.");
          if (!ye(p, ["string", "array"])) throw new fi("Expected second argument to be of type array or string, but found " + $r(Zn(p)) + " instead.");
          return p.indexOf(c) >= 0;
        }, zo.prototype.eachChild = function(a) {
          a(this.needle), a(this.haystack);
        }, zo.prototype.outputDefined = function() {
          return !0;
        }, zo.prototype.serialize = function() {
          return ["in", this.needle.serialize(), this.haystack.serialize()];
        };
        var Bs = function(a, c, p) {
          this.type = _t, this.needle = a, this.haystack = c, this.fromIndex = p;
        };
        Bs.parse = function(a, c) {
          if (a.length <= 2 || a.length >= 5) return c.error("Expected 3 or 4 arguments, but found " + (a.length - 1) + " instead.");
          var p = c.parse(a[1], 1, ir), x = c.parse(a[2], 2, ir);
          if (!p || !x) return null;
          if (!hr(p.type, [Lt, Vt, _t, zt, ir])) return c.error("Expected first argument to be of type boolean, string, number or null, but found " + $r(p.type) + " instead");
          if (a.length === 4) {
            var S = c.parse(a[3], 3, _t);
            return S ? new Bs(p, x, S) : null;
          }
          return new Bs(p, x);
        }, Bs.prototype.evaluate = function(a) {
          var c = this.needle.evaluate(a), p = this.haystack.evaluate(a);
          if (!ye(c, ["boolean", "string", "number", "null"])) throw new fi("Expected first argument to be of type boolean, string, number or null, but found " + $r(Zn(c)) + " instead.");
          if (!ye(p, ["string", "array"])) throw new fi("Expected second argument to be of type array or string, but found " + $r(Zn(p)) + " instead.");
          if (this.fromIndex) {
            var x = this.fromIndex.evaluate(a);
            return p.indexOf(c, x);
          }
          return p.indexOf(c);
        }, Bs.prototype.eachChild = function(a) {
          a(this.needle), a(this.haystack), this.fromIndex && a(this.fromIndex);
        }, Bs.prototype.outputDefined = function() {
          return !1;
        }, Bs.prototype.serialize = function() {
          if (this.fromIndex != null && this.fromIndex !== void 0) {
            var a = this.fromIndex.serialize();
            return ["index-of", this.needle.serialize(), this.haystack.serialize(), a];
          }
          return ["index-of", this.needle.serialize(), this.haystack.serialize()];
        };
        var Os = function(a, c, p, x, S, M) {
          this.inputType = a, this.type = c, this.input = p, this.cases = x, this.outputs = S, this.otherwise = M;
        };
        Os.parse = function(a, c) {
          if (a.length < 5) return c.error("Expected at least 4 arguments, but found only " + (a.length - 1) + ".");
          if (a.length % 2 != 1) return c.error("Expected an even number of arguments.");
          var p, x;
          c.expectedType && c.expectedType.kind !== "value" && (x = c.expectedType);
          for (var S = {}, M = [], O = 2; O < a.length - 1; O += 2) {
            var N = a[O], G = a[O + 1];
            Array.isArray(N) || (N = [N]);
            var Z = c.concat(O);
            if (N.length === 0) return Z.error("Expected at least one branch label.");
            for (var te = 0, se = N; te < se.length; te += 1) {
              var he = se[te];
              if (typeof he != "number" && typeof he != "string") return Z.error("Branch labels must be numbers or strings.");
              if (typeof he == "number" && Math.abs(he) > Number.MAX_SAFE_INTEGER) return Z.error("Branch labels must be integers no larger than " + Number.MAX_SAFE_INTEGER + ".");
              if (typeof he == "number" && Math.floor(he) !== he) return Z.error("Numeric branch labels must be integer values.");
              if (p) {
                if (Z.checkSubtype(p, Zn(he))) return null;
              } else p = Zn(he);
              if (S[String(he)] !== void 0) return Z.error("Branch labels must be unique.");
              S[String(he)] = M.length;
            }
            var xe = c.parse(G, O, x);
            if (!xe) return null;
            x = x || xe.type, M.push(xe);
          }
          var Ve = c.parse(a[1], 1, ir);
          if (!Ve) return null;
          var je = c.parse(a[a.length - 1], a.length - 1, x);
          return je ? Ve.type.kind !== "value" && c.concat(1).checkSubtype(p, Ve.type) ? null : new Os(p, x, Ve, S, M, je) : null;
        }, Os.prototype.evaluate = function(a) {
          var c = this.input.evaluate(a);
          return (Zn(c) === this.inputType && this.outputs[this.cases[c]] || this.otherwise).evaluate(a);
        }, Os.prototype.eachChild = function(a) {
          a(this.input), this.outputs.forEach(a), a(this.otherwise);
        }, Os.prototype.outputDefined = function() {
          return this.outputs.every((function(a) {
            return a.outputDefined();
          })) && this.otherwise.outputDefined();
        }, Os.prototype.serialize = function() {
          for (var a = this, c = ["match", this.input.serialize()], p = [], x = {}, S = 0, M = Object.keys(this.cases).sort(); S < M.length; S += 1) {
            var O = M[S];
            (se = x[this.cases[O]]) === void 0 ? (x[this.cases[O]] = p.length, p.push([this.cases[O], [O]])) : p[se][1].push(O);
          }
          for (var N = function(xe) {
            return a.inputType.kind === "number" ? Number(xe) : xe;
          }, G = 0, Z = p; G < Z.length; G += 1) {
            var te = Z[G], se = te[0], he = te[1];
            c.push(he.length === 1 ? N(he[0]) : he.map(N)), c.push(this.outputs[outputIndex$1].serialize());
          }
          return c.push(this.otherwise.serialize()), c;
        };
        var va = function(a, c, p) {
          this.type = a, this.branches = c, this.otherwise = p;
        };
        va.parse = function(a, c) {
          if (a.length < 4) return c.error("Expected at least 3 arguments, but found only " + (a.length - 1) + ".");
          if (a.length % 2 != 0) return c.error("Expected an odd number of arguments.");
          var p;
          c.expectedType && c.expectedType.kind !== "value" && (p = c.expectedType);
          for (var x = [], S = 1; S < a.length - 1; S += 2) {
            var M = c.parse(a[S], S, Lt);
            if (!M) return null;
            var O = c.parse(a[S + 1], S + 1, p);
            if (!O) return null;
            x.push([M, O]), p = p || O.type;
          }
          var N = c.parse(a[a.length - 1], a.length - 1, p);
          return N ? new va(p, x, N) : null;
        }, va.prototype.evaluate = function(a) {
          for (var c = 0, p = this.branches; c < p.length; c += 1) {
            var x = p[c], S = x[1];
            if (x[0].evaluate(a)) return S.evaluate(a);
          }
          return this.otherwise.evaluate(a);
        }, va.prototype.eachChild = function(a) {
          for (var c = 0, p = this.branches; c < p.length; c += 1) {
            var x = p[c], S = x[1];
            a(x[0]), a(S);
          }
          a(this.otherwise);
        }, va.prototype.outputDefined = function() {
          return this.branches.every((function(a) {
            return a[1].outputDefined();
          })) && this.otherwise.outputDefined();
        }, va.prototype.serialize = function() {
          var a = ["case"];
          return this.eachChild((function(c) {
            a.push(c.serialize());
          })), a;
        };
        var ra = function(a, c, p, x) {
          this.type = a, this.input = c, this.beginIndex = p, this.endIndex = x;
        };
        function du(a, c) {
          return a === "==" || a === "!=" ? c.kind === "boolean" || c.kind === "string" || c.kind === "number" || c.kind === "null" || c.kind === "value" : c.kind === "string" || c.kind === "number" || c.kind === "value";
        }
        function Sh(a, c, p, x) {
          return x.compare(c, p) === 0;
        }
        function Dn(a, c, p) {
          var x = a !== "==" && a !== "!=";
          return (function() {
            function S(M, O, N) {
              this.type = Lt, this.lhs = M, this.rhs = O, this.collator = N, this.hasUntypedArgument = M.type.kind === "value" || O.type.kind === "value";
            }
            return S.parse = function(M, O) {
              if (M.length !== 3 && M.length !== 4) return O.error("Expected two or three arguments.");
              var N = M[0], G = O.parse(M[1], 1, ir);
              if (!G) return null;
              if (!du(N, G.type)) return O.concat(1).error('"' + N + `" comparisons are not supported for type '` + $r(G.type) + "'.");
              var Z = O.parse(M[2], 2, ir);
              if (!Z) return null;
              if (!du(N, Z.type)) return O.concat(2).error('"' + N + `" comparisons are not supported for type '` + $r(Z.type) + "'.");
              if (G.type.kind !== Z.type.kind && G.type.kind !== "value" && Z.type.kind !== "value") return O.error("Cannot compare types '" + $r(G.type) + "' and '" + $r(Z.type) + "'.");
              x && (G.type.kind === "value" && Z.type.kind !== "value" ? G = new Fn(Z.type, [G]) : G.type.kind !== "value" && Z.type.kind === "value" && (Z = new Fn(G.type, [Z])));
              var te = null;
              if (M.length === 4) {
                if (G.type.kind !== "string" && Z.type.kind !== "string" && G.type.kind !== "value" && Z.type.kind !== "value") return O.error("Cannot use collator to compare non-string types.");
                if (!(te = O.parse(M[3], 3, nn))) return null;
              }
              return new S(G, Z, te);
            }, S.prototype.evaluate = function(M) {
              var O = this.lhs.evaluate(M), N = this.rhs.evaluate(M);
              if (x && this.hasUntypedArgument) {
                var G = Zn(O), Z = Zn(N);
                if (G.kind !== Z.kind || G.kind !== "string" && G.kind !== "number") throw new fi('Expected arguments for "' + a + '" to be (string, string) or (number, number), but found (' + G.kind + ", " + Z.kind + ") instead.");
              }
              if (this.collator && !x && this.hasUntypedArgument) {
                var te = Zn(O), se = Zn(N);
                if (te.kind !== "string" || se.kind !== "string") return c(M, O, N);
              }
              return this.collator ? p(M, O, N, this.collator.evaluate(M)) : c(M, O, N);
            }, S.prototype.eachChild = function(M) {
              M(this.lhs), M(this.rhs), this.collator && M(this.collator);
            }, S.prototype.outputDefined = function() {
              return !0;
            }, S.prototype.serialize = function() {
              var M = [a];
              return this.eachChild((function(O) {
                M.push(O.serialize());
              })), M;
            }, S;
          })();
        }
        ra.parse = function(a, c) {
          if (a.length <= 2 || a.length >= 5) return c.error("Expected 3 or 4 arguments, but found " + (a.length - 1) + " instead.");
          var p = c.parse(a[1], 1, ir), x = c.parse(a[2], 2, _t);
          if (!p || !x) return null;
          if (!hr(p.type, [Qr(ir), Vt, ir])) return c.error("Expected first argument to be of type array or string, but found " + $r(p.type) + " instead");
          if (a.length === 4) {
            var S = c.parse(a[3], 3, _t);
            return S ? new ra(p.type, p, x, S) : null;
          }
          return new ra(p.type, p, x);
        }, ra.prototype.evaluate = function(a) {
          var c = this.input.evaluate(a), p = this.beginIndex.evaluate(a);
          if (!ye(c, ["string", "array"])) throw new fi("Expected first argument to be of type array or string, but found " + $r(Zn(c)) + " instead.");
          if (this.endIndex) {
            var x = this.endIndex.evaluate(a);
            return c.slice(p, x);
          }
          return c.slice(p);
        }, ra.prototype.eachChild = function(a) {
          a(this.input), a(this.beginIndex), this.endIndex && a(this.endIndex);
        }, ra.prototype.outputDefined = function() {
          return !1;
        }, ra.prototype.serialize = function() {
          if (this.endIndex != null && this.endIndex !== void 0) {
            var a = this.endIndex.serialize();
            return ["slice", this.input.serialize(), this.beginIndex.serialize(), a];
          }
          return ["slice", this.input.serialize(), this.beginIndex.serialize()];
        };
        var Ih = Dn("==", (function(a, c, p) {
          return c === p;
        }), Sh), pu = Dn("!=", (function(a, c, p) {
          return c !== p;
        }), (function(a, c, p, x) {
          return !Sh(0, c, p, x);
        })), Ph = Dn("<", (function(a, c, p) {
          return c < p;
        }), (function(a, c, p, x) {
          return x.compare(c, p) < 0;
        })), Mh = Dn(">", (function(a, c, p) {
          return c > p;
        }), (function(a, c, p, x) {
          return x.compare(c, p) > 0;
        })), Rh = Dn("<=", (function(a, c, p) {
          return c <= p;
        }), (function(a, c, p, x) {
          return x.compare(c, p) <= 0;
        })), Bh = Dn(">=", (function(a, c, p) {
          return c >= p;
        }), (function(a, c, p, x) {
          return x.compare(c, p) >= 0;
        })), Ga = function(a, c, p, x, S) {
          this.type = Vt, this.number = a, this.locale = c, this.currency = p, this.minFractionDigits = x, this.maxFractionDigits = S;
        };
        Ga.parse = function(a, c) {
          if (a.length !== 3) return c.error("Expected two arguments.");
          var p = c.parse(a[1], 1, _t);
          if (!p) return null;
          var x = a[2];
          if (typeof x != "object" || Array.isArray(x)) return c.error("NumberFormat options argument must be an object.");
          var S = null;
          if (x.locale && !(S = c.parse(x.locale, 1, Vt))) return null;
          var M = null;
          if (x.currency && !(M = c.parse(x.currency, 1, Vt))) return null;
          var O = null;
          if (x["min-fraction-digits"] && !(O = c.parse(x["min-fraction-digits"], 1, _t))) return null;
          var N = null;
          return x["max-fraction-digits"] && !(N = c.parse(x["max-fraction-digits"], 1, _t)) ? null : new Ga(p, S, M, O, N);
        }, Ga.prototype.evaluate = function(a) {
          return new Intl.NumberFormat(this.locale ? this.locale.evaluate(a) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(a) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(a) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(a) : void 0 }).format(this.number.evaluate(a));
        }, Ga.prototype.eachChild = function(a) {
          a(this.number), this.locale && a(this.locale), this.currency && a(this.currency), this.minFractionDigits && a(this.minFractionDigits), this.maxFractionDigits && a(this.maxFractionDigits);
        }, Ga.prototype.outputDefined = function() {
          return !1;
        }, Ga.prototype.serialize = function() {
          var a = {};
          return this.locale && (a.locale = this.locale.serialize()), this.currency && (a.currency = this.currency.serialize()), this.minFractionDigits && (a["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (a["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), a];
        };
        var ba = function(a) {
          this.type = _t, this.input = a;
        };
        ba.parse = function(a, c) {
          if (a.length !== 2) return c.error("Expected 1 argument, but found " + (a.length - 1) + " instead.");
          var p = c.parse(a[1], 1);
          return p ? p.type.kind !== "array" && p.type.kind !== "string" && p.type.kind !== "value" ? c.error("Expected argument of type string or array, but found " + $r(p.type) + " instead.") : new ba(p) : null;
        }, ba.prototype.evaluate = function(a) {
          var c = this.input.evaluate(a);
          if (typeof c == "string" || Array.isArray(c)) return c.length;
          throw new fi("Expected value to be of type string or array, but found " + $r(Zn(c)) + " instead.");
        }, ba.prototype.eachChild = function(a) {
          a(this.input);
        }, ba.prototype.outputDefined = function() {
          return !1;
        }, ba.prototype.serialize = function() {
          var a = ["length"];
          return this.eachChild((function(c) {
            a.push(c.serialize());
          })), a;
        };
        var Wa = { "==": Ih, "!=": pu, ">": Mh, "<": Ph, ">=": Bh, "<=": Rh, array: Fn, at: ya, boolean: Fn, case: va, coalesce: Rs, collator: Ke, format: ms, image: $i, in: zo, "index-of": Bs, interpolate: Ui, "interpolate-hcl": Ui, "interpolate-lab": Ui, length: ba, let: ta, literal: Oi, match: Os, number: Fn, "number-format": Ga, object: Fn, slice: ra, step: _s, string: Fn, "to-boolean": On, "to-color": On, "to-number": On, "to-string": On, var: No, within: oo };
        function mc(a, c) {
          var p = c[0], x = c[1], S = c[2], M = c[3];
          p = p.evaluate(a), x = x.evaluate(a), S = S.evaluate(a);
          var O = M ? M.evaluate(a) : 1, N = Ae(p, x, S, O);
          if (N) throw new fi(N);
          return new sn(p / 255 * O, x / 255 * O, S / 255 * O, O);
        }
        function Oh(a, c) {
          return a in c;
        }
        function ff(a, c) {
          var p = c[a];
          return p === void 0 ? null : p;
        }
        function $a(a) {
          return { type: a };
        }
        function Cl(a) {
          return { result: "success", value: a };
        }
        function qa(a) {
          return { result: "error", value: a };
        }
        function na(a) {
          return a["property-type"] === "data-driven" || a["property-type"] === "cross-faded-data-driven";
        }
        function hf(a) {
          return !!a.expression && a.expression.parameters.indexOf("zoom") > -1;
        }
        function Vo(a) {
          return !!a.expression && a.expression.interpolated;
        }
        function Un(a) {
          return a instanceof Number ? "number" : a instanceof String ? "string" : a instanceof Boolean ? "boolean" : Array.isArray(a) ? "array" : a === null ? "null" : typeof a;
        }
        function Sl(a) {
          return typeof a == "object" && a !== null && !Array.isArray(a);
        }
        function Dh(a) {
          return a;
        }
        function Il(a, c, p) {
          return a !== void 0 ? a : c !== void 0 ? c : p !== void 0 ? p : void 0;
        }
        function df(a, c, p, x, S) {
          return Il(typeof p === S ? x[p] : void 0, a.default, c.default);
        }
        function pf(a, c, p) {
          if (Un(p) !== "number") return Il(a.default, c.default);
          var x = a.stops.length;
          if (x === 1 || p <= a.stops[0][0]) return a.stops[0][1];
          if (p >= a.stops[x - 1][0]) return a.stops[x - 1][1];
          var S = uu(a.stops.map((function(M) {
            return M[0];
          })), p);
          return a.stops[S][1];
        }
        function Au(a, c, p) {
          var x = a.base !== void 0 ? a.base : 1;
          if (Un(p) !== "number") return Il(a.default, c.default);
          var S = a.stops.length;
          if (S === 1 || p <= a.stops[0][0]) return a.stops[0][1];
          if (p >= a.stops[S - 1][0]) return a.stops[S - 1][1];
          var M = uu(a.stops.map((function(se) {
            return se[0];
          })), p), O = (function(se, he, xe, Ve) {
            var je = Ve - xe, Qe = se - xe;
            return je === 0 ? 0 : he === 1 ? Qe / je : (Math.pow(he, Qe) - 1) / (Math.pow(he, je) - 1);
          })(p, x, a.stops[M][0], a.stops[M + 1][0]), N = a.stops[M][1], G = a.stops[M + 1][1], Z = Ha[c.type] || Dh;
          if (a.colorSpace && a.colorSpace !== "rgb") {
            var te = Ch[a.colorSpace];
            Z = function(se, he) {
              return te.reverse(te.interpolate(te.forward(se), te.forward(he), O));
            };
          }
          return typeof N.evaluate == "function" ? { evaluate: function() {
            for (var se = [], he = arguments.length; he--; ) se[he] = arguments[he];
            var xe = N.evaluate.apply(void 0, se), Ve = G.evaluate.apply(void 0, se);
            if (xe !== void 0 && Ve !== void 0) return Z(xe, Ve, O);
          } } : Z(N, G, O);
        }
        function Pl(a, c, p) {
          return c.type === "color" ? p = sn.parse(p) : c.type === "formatted" ? p = ui.fromString(p.toString()) : c.type === "resolvedImage" ? p = Xn.fromString(p.toString()) : Un(p) === c.type || c.type === "enum" && c.values[p] || (p = void 0), Il(p, a.default, c.default);
        }
        ke.register(Wa, { error: [{ kind: "error" }, [Vt], function(a, c) {
          throw new fi(c[0].evaluate(a));
        }], typeof: [Vt, [ir], function(a, c) {
          return $r(Zn(c[0].evaluate(a)));
        }], "to-rgba": [Qr(_t, 4), [Yt], function(a, c) {
          return c[0].evaluate(a).toArray();
        }], rgb: [Yt, [_t, _t, _t], mc], rgba: [Yt, [_t, _t, _t, _t], mc], has: { type: Lt, overloads: [[[Vt], function(a, c) {
          return Oh(c[0].evaluate(a), a.properties());
        }], [[Vt, Hr], function(a, c) {
          var p = c[1];
          return Oh(c[0].evaluate(a), p.evaluate(a));
        }]] }, get: { type: ir, overloads: [[[Vt], function(a, c) {
          return ff(c[0].evaluate(a), a.properties());
        }], [[Vt, Hr], function(a, c) {
          var p = c[1];
          return ff(c[0].evaluate(a), p.evaluate(a));
        }]] }, "feature-state": [ir, [Vt], function(a, c) {
          return ff(c[0].evaluate(a), a.featureState || {});
        }], properties: [Hr, [], function(a) {
          return a.properties();
        }], "geometry-type": [Vt, [], function(a) {
          return a.geometryType();
        }], id: [ir, [], function(a) {
          return a.id();
        }], zoom: [_t, [], function(a) {
          return a.globals.zoom;
        }], "heatmap-density": [_t, [], function(a) {
          return a.globals.heatmapDensity || 0;
        }], "line-progress": [_t, [], function(a) {
          return a.globals.lineProgress || 0;
        }], accumulated: [ir, [], function(a) {
          return a.globals.accumulated === void 0 ? null : a.globals.accumulated;
        }], "+": [_t, $a(_t), function(a, c) {
          for (var p = 0, x = 0, S = c; x < S.length; x += 1) p += S[x].evaluate(a);
          return p;
        }], "*": [_t, $a(_t), function(a, c) {
          for (var p = 1, x = 0, S = c; x < S.length; x += 1) p *= S[x].evaluate(a);
          return p;
        }], "-": { type: _t, overloads: [[[_t, _t], function(a, c) {
          var p = c[1];
          return c[0].evaluate(a) - p.evaluate(a);
        }], [[_t], function(a, c) {
          return -c[0].evaluate(a);
        }]] }, "/": [_t, [_t, _t], function(a, c) {
          var p = c[1];
          return c[0].evaluate(a) / p.evaluate(a);
        }], "%": [_t, [_t, _t], function(a, c) {
          var p = c[1];
          return c[0].evaluate(a) % p.evaluate(a);
        }], ln2: [_t, [], function() {
          return Math.LN2;
        }], pi: [_t, [], function() {
          return Math.PI;
        }], e: [_t, [], function() {
          return Math.E;
        }], "^": [_t, [_t, _t], function(a, c) {
          var p = c[1];
          return Math.pow(c[0].evaluate(a), p.evaluate(a));
        }], sqrt: [_t, [_t], function(a, c) {
          return Math.sqrt(c[0].evaluate(a));
        }], log10: [_t, [_t], function(a, c) {
          return Math.log(c[0].evaluate(a)) / Math.LN10;
        }], ln: [_t, [_t], function(a, c) {
          return Math.log(c[0].evaluate(a));
        }], log2: [_t, [_t], function(a, c) {
          return Math.log(c[0].evaluate(a)) / Math.LN2;
        }], sin: [_t, [_t], function(a, c) {
          return Math.sin(c[0].evaluate(a));
        }], cos: [_t, [_t], function(a, c) {
          return Math.cos(c[0].evaluate(a));
        }], tan: [_t, [_t], function(a, c) {
          return Math.tan(c[0].evaluate(a));
        }], asin: [_t, [_t], function(a, c) {
          return Math.asin(c[0].evaluate(a));
        }], acos: [_t, [_t], function(a, c) {
          return Math.acos(c[0].evaluate(a));
        }], atan: [_t, [_t], function(a, c) {
          return Math.atan(c[0].evaluate(a));
        }], min: [_t, $a(_t), function(a, c) {
          return Math.min.apply(Math, c.map((function(p) {
            return p.evaluate(a);
          })));
        }], max: [_t, $a(_t), function(a, c) {
          return Math.max.apply(Math, c.map((function(p) {
            return p.evaluate(a);
          })));
        }], abs: [_t, [_t], function(a, c) {
          return Math.abs(c[0].evaluate(a));
        }], round: [_t, [_t], function(a, c) {
          var p = c[0].evaluate(a);
          return p < 0 ? -Math.round(-p) : Math.round(p);
        }], floor: [_t, [_t], function(a, c) {
          return Math.floor(c[0].evaluate(a));
        }], ceil: [_t, [_t], function(a, c) {
          return Math.ceil(c[0].evaluate(a));
        }], "filter-==": [Lt, [Vt, ir], function(a, c) {
          var p = c[0], x = c[1];
          return a.properties()[p.value] === x.value;
        }], "filter-id-==": [Lt, [ir], function(a, c) {
          var p = c[0];
          return a.id() === p.value;
        }], "filter-type-==": [Lt, [Vt], function(a, c) {
          var p = c[0];
          return a.geometryType() === p.value;
        }], "filter-<": [Lt, [Vt, ir], function(a, c) {
          var p = c[0], x = c[1], S = a.properties()[p.value], M = x.value;
          return typeof S == typeof M && S < M;
        }], "filter-id-<": [Lt, [ir], function(a, c) {
          var p = c[0], x = a.id(), S = p.value;
          return typeof x == typeof S && x < S;
        }], "filter->": [Lt, [Vt, ir], function(a, c) {
          var p = c[0], x = c[1], S = a.properties()[p.value], M = x.value;
          return typeof S == typeof M && S > M;
        }], "filter-id->": [Lt, [ir], function(a, c) {
          var p = c[0], x = a.id(), S = p.value;
          return typeof x == typeof S && x > S;
        }], "filter-<=": [Lt, [Vt, ir], function(a, c) {
          var p = c[0], x = c[1], S = a.properties()[p.value], M = x.value;
          return typeof S == typeof M && S <= M;
        }], "filter-id-<=": [Lt, [ir], function(a, c) {
          var p = c[0], x = a.id(), S = p.value;
          return typeof x == typeof S && x <= S;
        }], "filter->=": [Lt, [Vt, ir], function(a, c) {
          var p = c[0], x = c[1], S = a.properties()[p.value], M = x.value;
          return typeof S == typeof M && S >= M;
        }], "filter-id->=": [Lt, [ir], function(a, c) {
          var p = c[0], x = a.id(), S = p.value;
          return typeof x == typeof S && x >= S;
        }], "filter-has": [Lt, [ir], function(a, c) {
          return c[0].value in a.properties();
        }], "filter-has-id": [Lt, [], function(a) {
          return a.id() !== null && a.id() !== void 0;
        }], "filter-type-in": [Lt, [Qr(Vt)], function(a, c) {
          return c[0].value.indexOf(a.geometryType()) >= 0;
        }], "filter-id-in": [Lt, [Qr(ir)], function(a, c) {
          return c[0].value.indexOf(a.id()) >= 0;
        }], "filter-in-small": [Lt, [Vt, Qr(ir)], function(a, c) {
          var p = c[0];
          return c[1].value.indexOf(a.properties()[p.value]) >= 0;
        }], "filter-in-large": [Lt, [Vt, Qr(ir)], function(a, c) {
          var p = c[0], x = c[1];
          return (function(S, M, O, N) {
            for (; O <= N; ) {
              var G = O + N >> 1;
              if (M[G] === S) return !0;
              M[G] > S ? N = G - 1 : O = G + 1;
            }
            return !1;
          })(a.properties()[p.value], x.value, 0, x.value.length - 1);
        }], all: { type: Lt, overloads: [[[Lt, Lt], function(a, c) {
          var p = c[1];
          return c[0].evaluate(a) && p.evaluate(a);
        }], [$a(Lt), function(a, c) {
          for (var p = 0, x = c; p < x.length; p += 1) if (!x[p].evaluate(a)) return !1;
          return !0;
        }]] }, any: { type: Lt, overloads: [[[Lt, Lt], function(a, c) {
          var p = c[1];
          return c[0].evaluate(a) || p.evaluate(a);
        }], [$a(Lt), function(a, c) {
          for (var p = 0, x = c; p < x.length; p += 1) if (x[p].evaluate(a)) return !0;
          return !1;
        }]] }, "!": [Lt, [Lt], function(a, c) {
          return !c[0].evaluate(a);
        }], "is-supported-script": [Lt, [Vt], function(a, c) {
          var p = a.globals && a.globals.isSupportedScript;
          return !p || p(c[0].evaluate(a));
        }], upcase: [Vt, [Vt], function(a, c) {
          return c[0].evaluate(a).toUpperCase();
        }], downcase: [Vt, [Vt], function(a, c) {
          return c[0].evaluate(a).toLowerCase();
        }], concat: [Vt, $a(ir), function(a, c) {
          return c.map((function(p) {
            return Qo(p.evaluate(a));
          })).join("");
        }], "resolved-locale": [Vt, [nn], function(a, c) {
          return c[0].evaluate(a).resolvedLocale();
        }] });
        var jo = function(a, c) {
          this.expression = a, this._warningHistory = {}, this._evaluator = new Ee(), this._defaultValue = c ? (function(p) {
            return p.type === "color" && Sl(p.default) ? new sn(0, 0, 0, 0) : p.type === "color" ? sn.parse(p.default) || null : p.default === void 0 ? null : p.default;
          })(c) : null, this._enumValues = c && c.type === "enum" ? c.values : null;
        };
        function Bn(a) {
          return Array.isArray(a) && a.length > 0 && typeof a[0] == "string" && a[0] in Wa;
        }
        function gu(a, c) {
          var p = new Uo(Wa, [], c ? (function(S) {
            var M = { color: Yt, string: Vt, number: _t, enum: Vt, boolean: Lt, formatted: un, resolvedImage: Yr };
            return S.type === "array" ? Qr(M[S.value] || ir, S.length) : M[S.type];
          })(c) : void 0), x = p.parse(a, void 0, void 0, void 0, c && c.type === "string" ? { typeAnnotation: "coerce" } : void 0);
          return x ? Cl(new jo(x, c)) : qa(p.errors);
        }
        jo.prototype.evaluateWithoutErrorHandling = function(a, c, p, x, S, M) {
          return this._evaluator.globals = a, this._evaluator.feature = c, this._evaluator.featureState = p, this._evaluator.canonical = x, this._evaluator.availableImages = S || null, this._evaluator.formattedSection = M, this.expression.evaluate(this._evaluator);
        }, jo.prototype.evaluate = function(a, c, p, x, S, M) {
          this._evaluator.globals = a, this._evaluator.feature = c || null, this._evaluator.featureState = p || null, this._evaluator.canonical = x, this._evaluator.availableImages = S || null, this._evaluator.formattedSection = M || null;
          try {
            var O = this.expression.evaluate(this._evaluator);
            if (O == null || typeof O == "number" && O != O) return this._defaultValue;
            if (this._enumValues && !(O in this._enumValues)) throw new fi("Expected value to be one of " + Object.keys(this._enumValues).map((function(N) {
              return JSON.stringify(N);
            })).join(", ") + ", but found " + JSON.stringify(O) + " instead.");
            return O;
          } catch (N) {
            return this._warningHistory[N.message] || (this._warningHistory[N.message] = !0, typeof console < "u" && console.warn(N.message)), this._defaultValue;
          }
        };
        var Ml = function(a, c) {
          this.kind = a, this._styleExpression = c, this.isStateDependent = a !== "constant" && !Jo(c.expression);
        };
        Ml.prototype.evaluateWithoutErrorHandling = function(a, c, p, x, S, M) {
          return this._styleExpression.evaluateWithoutErrorHandling(a, c, p, x, S, M);
        }, Ml.prototype.evaluate = function(a, c, p, x, S, M) {
          return this._styleExpression.evaluate(a, c, p, x, S, M);
        };
        var Xa = function(a, c, p, x) {
          this.kind = a, this.zoomStops = p, this._styleExpression = c, this.isStateDependent = a !== "camera" && !Jo(c.expression), this.interpolationType = x;
        };
        function Lh(a, c) {
          if ((a = gu(a, c)).result === "error") return a;
          var p = a.value.expression, x = _a(p);
          if (!x && !na(c)) return qa([new Mt("", "data expressions not supported")]);
          var S = ja(p, ["zoom"]);
          if (!S && !hf(c)) return qa([new Mt("", "zoom expressions not supported")]);
          var M = (function O(N) {
            var G = null;
            if (N instanceof ta) G = O(N.result);
            else if (N instanceof Rs) for (var Z = 0, te = N.args; Z < te.length && !(G = O(te[Z])); Z += 1) ;
            else (N instanceof _s || N instanceof Ui) && N.input instanceof ke && N.input.name === "zoom" && (G = N);
            return G instanceof Mt || N.eachChild((function(se) {
              var he = O(se);
              he instanceof Mt ? G = he : !G && he ? G = new Mt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : G && he && G !== he && (G = new Mt("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
            })), G;
          })(p);
          return M || S ? M instanceof Mt ? qa([M]) : M instanceof Ui && !Vo(c) ? qa([new Mt("", '"interpolate" expressions cannot be used with this property')]) : Cl(M ? new Xa(x ? "camera" : "composite", a.value, M.labels, M instanceof Ui ? M.interpolation : void 0) : new Ml(x ? "constant" : "source", a.value)) : qa([new Mt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
        }
        Xa.prototype.evaluateWithoutErrorHandling = function(a, c, p, x, S, M) {
          return this._styleExpression.evaluateWithoutErrorHandling(a, c, p, x, S, M);
        }, Xa.prototype.evaluate = function(a, c, p, x, S, M) {
          return this._styleExpression.evaluate(a, c, p, x, S, M);
        }, Xa.prototype.interpolationFactor = function(a, c, p) {
          return this.interpolationType ? Ui.interpolationFactor(this.interpolationType, a, c, p) : 0;
        };
        var Rl = function(a, c) {
          this._parameters = a, this._specification = c, ee(this, (function p(x, S) {
            var M, O, N, G = S.type === "color", Z = x.stops && typeof x.stops[0][0] == "object", te = Z || !(Z || x.property !== void 0), se = x.type || (Vo(S) ? "exponential" : "interval");
            if (G && ((x = ee({}, x)).stops && (x.stops = x.stops.map((function(lr) {
              return [lr[0], sn.parse(lr[1])];
            }))), x.default = sn.parse(x.default ? x.default : S.default)), x.colorSpace && x.colorSpace !== "rgb" && !Ch[x.colorSpace]) throw new Error("Unknown color space: " + x.colorSpace);
            if (se === "exponential") M = Au;
            else if (se === "interval") M = pf;
            else if (se === "categorical") {
              M = df, O = /* @__PURE__ */ Object.create(null);
              for (var he = 0, xe = x.stops; he < xe.length; he += 1) {
                var Ve = xe[he];
                O[Ve[0]] = Ve[1];
              }
              N = typeof x.stops[0][0];
            } else {
              if (se !== "identity") throw new Error('Unknown function type "' + se + '"');
              M = Pl;
            }
            if (Z) {
              for (var je = {}, Qe = [], Ye = 0; Ye < x.stops.length; Ye++) {
                var it = x.stops[Ye], pt = it[0].zoom;
                je[pt] === void 0 && (je[pt] = { zoom: pt, type: x.type, property: x.property, default: x.default, stops: [] }, Qe.push(pt)), je[pt].stops.push([it[0].value, it[1]]);
              }
              for (var xt = [], Tt = 0, Nt = Qe; Tt < Nt.length; Tt += 1) {
                var Kt = Nt[Tt];
                xt.push([je[Kt].zoom, p(je[Kt], S)]);
              }
              var rr = { name: "linear" };
              return { kind: "composite", interpolationType: rr, interpolationFactor: Ui.interpolationFactor.bind(void 0, rr), zoomStops: xt.map((function(lr) {
                return lr[0];
              })), evaluate: function(lr, Dr) {
                var cr = lr.zoom;
                return Au({ stops: xt, base: x.base }, S, cr).evaluate(cr, Dr);
              } };
            }
            if (te) {
              var Ir = se === "exponential" ? { name: "exponential", base: x.base !== void 0 ? x.base : 1 } : null;
              return { kind: "camera", interpolationType: Ir, interpolationFactor: Ui.interpolationFactor.bind(void 0, Ir), zoomStops: x.stops.map((function(lr) {
                return lr[0];
              })), evaluate: function(lr) {
                return M(x, S, lr.zoom, O, N);
              } };
            }
            return { kind: "source", evaluate: function(lr, Dr) {
              var cr = Dr && Dr.properties ? Dr.properties[x.property] : void 0;
              return cr === void 0 ? Il(x.default, S.default) : M(x, S, cr, O, N);
            } };
          })(this._parameters, this._specification));
        };
        function vo(a) {
          var c = a.key, p = a.value, x = a.valueSpec || {}, S = a.objectElementValidators || {}, M = a.style, O = a.styleSpec, N = [], G = Un(p);
          if (G !== "object") return [new ge(c, p, "object expected, " + G + " found")];
          for (var Z in p) {
            var te = Z.split(".")[0], se = x[te] || x["*"], he = void 0;
            if (S[te]) he = S[te];
            else if (x[te]) he = qr;
            else if (S["*"]) he = S["*"];
            else {
              if (!x["*"]) {
                N.push(new ge(c, p[Z], 'unknown property "' + Z + '"'));
                continue;
              }
              he = qr;
            }
            N = N.concat(he({ key: (c && c + ".") + Z, value: p[Z], valueSpec: se, style: M, styleSpec: O, object: p, objectKey: Z }, p));
          }
          for (var xe in x) S[xe] || x[xe].required && x[xe].default === void 0 && p[xe] === void 0 && N.push(new ge(c, p, 'missing required property "' + xe + '"'));
          return N;
        }
        function kh(a) {
          var c = a.value, p = a.valueSpec, x = a.style, S = a.styleSpec, M = a.key, O = a.arrayElementValidator || qr;
          if (Un(c) !== "array") return [new ge(M, c, "array expected, " + Un(c) + " found")];
          if (p.length && c.length !== p.length) return [new ge(M, c, "array length " + p.length + " expected, length " + c.length + " found")];
          if (p["min-length"] && c.length < p["min-length"]) return [new ge(M, c, "array length at least " + p["min-length"] + " expected, length " + c.length + " found")];
          var N = { type: p.value, values: p.values };
          S.$version < 7 && (N.function = p.function), Un(p.value) === "object" && (N = p.value);
          for (var G = [], Z = 0; Z < c.length; Z++) G = G.concat(O({ array: c, arrayIndex: Z, value: c[Z], valueSpec: N, style: x, styleSpec: S, key: M + "[" + Z + "]" }));
          return G;
        }
        function ys(a) {
          var c = a.key, p = a.value, x = a.valueSpec, S = Un(p);
          return S === "number" && p != p && (S = "NaN"), S !== "number" ? [new ge(c, p, "number expected, " + S + " found")] : "minimum" in x && p < x.minimum ? [new ge(c, p, p + " is less than the minimum value " + x.minimum)] : "maximum" in x && p > x.maximum ? [new ge(c, p, p + " is greater than the maximum value " + x.maximum)] : [];
        }
        function mu(a) {
          var c, p, x, S = a.valueSpec, M = It(a.value.type), O = {}, N = M !== "categorical" && a.value.property === void 0, G = !N, Z = Un(a.value.stops) === "array" && Un(a.value.stops[0]) === "array" && Un(a.value.stops[0][0]) === "object", te = vo({ key: a.key, value: a.value, valueSpec: a.styleSpec.function, style: a.style, styleSpec: a.styleSpec, objectElementValidators: { stops: function(xe) {
            if (M === "identity") return [new ge(xe.key, xe.value, 'identity function may not have a "stops" property')];
            var Ve = [], je = xe.value;
            return Ve = Ve.concat(kh({ key: xe.key, value: je, valueSpec: xe.valueSpec, style: xe.style, styleSpec: xe.styleSpec, arrayElementValidator: se })), Un(je) === "array" && je.length === 0 && Ve.push(new ge(xe.key, je, "array must have at least one stop")), Ve;
          }, default: function(xe) {
            return qr({ key: xe.key, value: xe.value, valueSpec: S, style: xe.style, styleSpec: xe.styleSpec });
          } } });
          return M === "identity" && N && te.push(new ge(a.key, a.value, 'missing required property "property"')), M === "identity" || a.value.stops || te.push(new ge(a.key, a.value, 'missing required property "stops"')), M === "exponential" && a.valueSpec.expression && !Vo(a.valueSpec) && te.push(new ge(a.key, a.value, "exponential functions not supported")), a.styleSpec.$version >= 8 && (G && !na(a.valueSpec) ? te.push(new ge(a.key, a.value, "property functions not supported")) : N && !hf(a.valueSpec) && te.push(new ge(a.key, a.value, "zoom functions not supported"))), M !== "categorical" && !Z || a.value.property !== void 0 || te.push(new ge(a.key, a.value, '"property" property is required')), te;
          function se(xe) {
            var Ve = [], je = xe.value, Qe = xe.key;
            if (Un(je) !== "array") return [new ge(Qe, je, "array expected, " + Un(je) + " found")];
            if (je.length !== 2) return [new ge(Qe, je, "array length 2 expected, length " + je.length + " found")];
            if (Z) {
              if (Un(je[0]) !== "object") return [new ge(Qe, je, "object expected, " + Un(je[0]) + " found")];
              if (je[0].zoom === void 0) return [new ge(Qe, je, "object stop key must have zoom")];
              if (je[0].value === void 0) return [new ge(Qe, je, "object stop key must have value")];
              if (x && x > It(je[0].zoom)) return [new ge(Qe, je[0].zoom, "stop zoom values must appear in ascending order")];
              It(je[0].zoom) !== x && (x = It(je[0].zoom), p = void 0, O = {}), Ve = Ve.concat(vo({ key: Qe + "[0]", value: je[0], valueSpec: { zoom: {} }, style: xe.style, styleSpec: xe.styleSpec, objectElementValidators: { zoom: ys, value: he } }));
            } else Ve = Ve.concat(he({ key: Qe + "[0]", value: je[0], style: xe.style, styleSpec: xe.styleSpec }, je));
            return Bn(nt(je[1])) ? Ve.concat([new ge(Qe + "[1]", je[1], "expressions are not allowed in function stops.")]) : Ve.concat(qr({ key: Qe + "[1]", value: je[1], valueSpec: S, style: xe.style, styleSpec: xe.styleSpec }));
          }
          function he(xe, Ve) {
            var je = Un(xe.value), Qe = It(xe.value), Ye = xe.value !== null ? xe.value : Ve;
            if (c) {
              if (je !== c) return [new ge(xe.key, Ye, je + " stop domain type must match previous stop domain type " + c)];
            } else c = je;
            if (je !== "number" && je !== "string" && je !== "boolean") return [new ge(xe.key, Ye, "stop domain value must be a number, string, or boolean")];
            if (je !== "number" && M !== "categorical") {
              var it = "number expected, " + je + " found";
              return na(S) && M === void 0 && (it += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new ge(xe.key, Ye, it)];
            }
            return M !== "categorical" || je !== "number" || isFinite(Qe) && Math.floor(Qe) === Qe ? M !== "categorical" && je === "number" && p !== void 0 && Qe < p ? [new ge(xe.key, Ye, "stop domain values must appear in ascending order")] : (p = Qe, M === "categorical" && Qe in O ? [new ge(xe.key, Ye, "stop domain values must be unique")] : (O[Qe] = !0, [])) : [new ge(xe.key, Ye, "integer expected, found " + Qe)];
          }
        }
        function Xs(a) {
          var c = (a.expressionContext === "property" ? Lh : gu)(nt(a.value), a.valueSpec);
          if (c.result === "error") return c.value.map((function(x) {
            return new ge("" + a.key + x.key, a.value, x.message);
          }));
          var p = c.value.expression || c.value._styleExpression.expression;
          if (a.expressionContext === "property" && a.propertyKey === "text-font" && !p.outputDefined()) return [new ge(a.key, a.value, 'Invalid data expression for "' + a.propertyKey + '". Output values must be contained as literals within the expression.')];
          if (a.expressionContext === "property" && a.propertyType === "layout" && !Jo(p)) return [new ge(a.key, a.value, '"feature-state" data expressions are not supported with layout properties.')];
          if (a.expressionContext === "filter" && !Jo(p)) return [new ge(a.key, a.value, '"feature-state" data expressions are not supported with filters.')];
          if (a.expressionContext && a.expressionContext.indexOf("cluster") === 0) {
            if (!ja(p, ["zoom", "feature-state"])) return [new ge(a.key, a.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if (a.expressionContext === "cluster-initial" && !_a(p)) return [new ge(a.key, a.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function _c(a) {
          var c = a.key, p = a.value, x = a.valueSpec, S = [];
          return Array.isArray(x.values) ? x.values.indexOf(It(p)) === -1 && S.push(new ge(c, p, "expected one of [" + x.values.join(", ") + "], " + JSON.stringify(p) + " found")) : Object.keys(x.values).indexOf(It(p)) === -1 && S.push(new ge(c, p, "expected one of [" + Object.keys(x.values).join(", ") + "], " + JSON.stringify(p) + " found")), S;
        }
        function Bl(a) {
          if (a === !0 || a === !1) return !0;
          if (!Array.isArray(a) || a.length === 0) return !1;
          switch (a[0]) {
            case "has":
              return a.length >= 2 && a[1] !== "$id" && a[1] !== "$type";
            case "in":
              return a.length >= 3 && (typeof a[1] != "string" || Array.isArray(a[2]));
            case "!in":
            case "!has":
            case "none":
              return !1;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return a.length !== 3 || Array.isArray(a[1]) || Array.isArray(a[2]);
            case "any":
            case "all":
              for (var c = 0, p = a.slice(1); c < p.length; c += 1) {
                var x = p[c];
                if (!Bl(x) && typeof x != "boolean") return !1;
              }
              return !0;
            default:
              return !0;
          }
        }
        Rl.deserialize = function(a) {
          return new Rl(a._parameters, a._specification);
        }, Rl.serialize = function(a) {
          return { _parameters: a._parameters, _specification: a._specification };
        };
        var Af = { type: "boolean", default: !1 };
        function vs(a) {
          if (a == null) return { filter: function() {
            return !0;
          }, needGeometry: !1 };
          Bl(a) || (a = Ol(a));
          var c = gu(a, Af);
          if (c.result === "error") throw new Error(c.value.map((function(p) {
            return p.key + ": " + p.message;
          })).join(", "));
          return { filter: function(p, x, S) {
            return c.value.evaluate(p, x, {}, S);
          }, needGeometry: (function p(x) {
            if (!Array.isArray(x)) return !1;
            if (x[0] === "within") return !0;
            for (var S = 1; S < x.length; S++) if (p(x[S])) return !0;
            return !1;
          })(a) };
        }
        function gf(a, c) {
          return a < c ? -1 : a > c ? 1 : 0;
        }
        function Ol(a) {
          if (!a) return !0;
          var c, p = a[0];
          return a.length <= 1 ? p !== "any" : p === "==" ? xa(a[1], a[2], "==") : p === "!=" ? _u(xa(a[1], a[2], "==")) : p === "<" || p === ">" || p === "<=" || p === ">=" ? xa(a[1], a[2], p) : p === "any" ? (c = a.slice(1), ["any"].concat(c.map(Ol))) : p === "all" ? ["all"].concat(a.slice(1).map(Ol)) : p === "none" ? ["all"].concat(a.slice(1).map(Ol).map(_u)) : p === "in" ? wa(a[1], a.slice(2)) : p === "!in" ? _u(wa(a[1], a.slice(2))) : p === "has" ? Za(a[1]) : p === "!has" ? _u(Za(a[1])) : p !== "within" || a;
        }
        function xa(a, c, p) {
          switch (a) {
            case "$type":
              return ["filter-type-" + p, c];
            case "$id":
              return ["filter-id-" + p, c];
            default:
              return ["filter-" + p, a, c];
          }
        }
        function wa(a, c) {
          if (c.length === 0) return !1;
          switch (a) {
            case "$type":
              return ["filter-type-in", ["literal", c]];
            case "$id":
              return ["filter-id-in", ["literal", c]];
            default:
              return c.length > 200 && !c.some((function(p) {
                return typeof p != typeof c[0];
              })) ? ["filter-in-large", a, ["literal", c.sort(gf)]] : ["filter-in-small", a, ["literal", c]];
          }
        }
        function Za(a) {
          switch (a) {
            case "$type":
              return !0;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", a];
          }
        }
        function _u(a) {
          return ["!", a];
        }
        function yu(a) {
          return Bl(nt(a.value)) ? Xs(ee({}, a, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : (function c(p) {
            var x = p.value, S = p.key;
            if (Un(x) !== "array") return [new ge(S, x, "array expected, " + Un(x) + " found")];
            var M, O = p.styleSpec, N = [];
            if (x.length < 1) return [new ge(S, x, "filter array must have at least 1 element")];
            switch (N = N.concat(_c({ key: S + "[0]", value: x[0], valueSpec: O.filter_operator, style: p.style, styleSpec: p.styleSpec })), It(x[0])) {
              case "<":
              case "<=":
              case ">":
              case ">=":
                x.length >= 2 && It(x[1]) === "$type" && N.push(new ge(S, x, '"$type" cannot be use with operator "' + x[0] + '"'));
              case "==":
              case "!=":
                x.length !== 3 && N.push(new ge(S, x, 'filter array for operator "' + x[0] + '" must have 3 elements'));
              case "in":
              case "!in":
                x.length >= 2 && (M = Un(x[1])) !== "string" && N.push(new ge(S + "[1]", x[1], "string expected, " + M + " found"));
                for (var G = 2; G < x.length; G++) M = Un(x[G]), It(x[1]) === "$type" ? N = N.concat(_c({ key: S + "[" + G + "]", value: x[G], valueSpec: O.geometry_type, style: p.style, styleSpec: p.styleSpec })) : M !== "string" && M !== "number" && M !== "boolean" && N.push(new ge(S + "[" + G + "]", x[G], "string, number, or boolean expected, " + M + " found"));
                break;
              case "any":
              case "all":
              case "none":
                for (var Z = 1; Z < x.length; Z++) N = N.concat(c({ key: S + "[" + Z + "]", value: x[Z], style: p.style, styleSpec: p.styleSpec }));
                break;
              case "has":
              case "!has":
                M = Un(x[1]), x.length !== 2 ? N.push(new ge(S, x, 'filter array for "' + x[0] + '" operator must have 2 elements')) : M !== "string" && N.push(new ge(S + "[1]", x[1], "string expected, " + M + " found"));
                break;
              case "within":
                M = Un(x[1]), x.length !== 2 ? N.push(new ge(S, x, 'filter array for "' + x[0] + '" operator must have 2 elements')) : M !== "object" && N.push(new ge(S + "[1]", x[1], "object expected, " + M + " found"));
            }
            return N;
          })(a);
        }
        function mf(a, c) {
          var p = a.key, x = a.style, S = a.styleSpec, M = a.value, O = a.objectKey, N = S[c + "_" + a.layerType];
          if (!N) return [];
          var G = O.match(/^(.*)-transition$/);
          if (c === "paint" && G && N[G[1]] && N[G[1]].transition) return qr({ key: p, value: M, valueSpec: S.transition, style: x, styleSpec: S });
          var Z, te = a.valueSpec || N[O];
          if (!te) return [new ge(p, M, 'unknown property "' + O + '"')];
          if (Un(M) === "string" && na(te) && !te.tokens && (Z = /^{([^}]+)}$/.exec(M))) return [new ge(p, M, '"' + O + '" does not support interpolation syntax\nUse an identity property function instead: `{ "type": "identity", "property": ' + JSON.stringify(Z[1]) + " }`.")];
          var se = [];
          return a.layerType === "symbol" && (O === "text-field" && x && !x.glyphs && se.push(new ge(p, M, 'use of "text-field" requires a style "glyphs" property')), O === "text-font" && Sl(nt(M)) && It(M.type) === "identity" && se.push(new ge(p, M, '"text-font" does not support identity functions'))), se.concat(qr({ key: a.key, value: M, valueSpec: te, style: x, styleSpec: S, expressionContext: "property", propertyType: c, propertyKey: O }));
        }
        function yc(a) {
          return mf(a, "paint");
        }
        function vc(a) {
          return mf(a, "layout");
        }
        function Fh(a) {
          var c = [], p = a.value, x = a.key, S = a.style, M = a.styleSpec;
          p.type || p.ref || c.push(new ge(x, p, 'either "type" or "ref" is required'));
          var O, N = It(p.type), G = It(p.ref);
          if (p.id) for (var Z = It(p.id), te = 0; te < a.arrayIndex; te++) {
            var se = S.layers[te];
            It(se.id) === Z && c.push(new ge(x, p.id, 'duplicate layer id "' + p.id + '", previously used at line ' + se.id.__line__));
          }
          if ("ref" in p) ["type", "source", "source-layer", "filter", "layout"].forEach((function(Ve) {
            Ve in p && c.push(new ge(x, p[Ve], '"' + Ve + '" is prohibited for ref layers'));
          })), S.layers.forEach((function(Ve) {
            It(Ve.id) === G && (O = Ve);
          })), O ? O.ref ? c.push(new ge(x, p.ref, "ref cannot reference another ref layer")) : N = It(O.type) : c.push(new ge(x, p.ref, 'ref layer "' + G + '" not found'));
          else if (N !== "background") if (p.source) {
            var he = S.sources && S.sources[p.source], xe = he && It(he.type);
            he ? xe === "vector" && N === "raster" ? c.push(new ge(x, p.source, 'layer "' + p.id + '" requires a raster source')) : xe === "raster" && N !== "raster" ? c.push(new ge(x, p.source, 'layer "' + p.id + '" requires a vector source')) : xe !== "vector" || p["source-layer"] ? xe === "raster-dem" && N !== "hillshade" ? c.push(new ge(x, p.source, "raster-dem source can only be used with layer type 'hillshade'.")) : N !== "line" || !p.paint || !p.paint["line-gradient"] || xe === "geojson" && he.lineMetrics || c.push(new ge(x, p, 'layer "' + p.id + '" specifies a line-gradient, which requires a GeoJSON source with `lineMetrics` enabled.')) : c.push(new ge(x, p, 'layer "' + p.id + '" must specify a "source-layer"')) : c.push(new ge(x, p.source, 'source "' + p.source + '" not found'));
          } else c.push(new ge(x, p, 'missing required property "source"'));
          return c = c.concat(vo({ key: x, value: p, valueSpec: M.layer, style: a.style, styleSpec: a.styleSpec, objectElementValidators: { "*": function() {
            return [];
          }, type: function() {
            return qr({ key: x + ".type", value: p.type, valueSpec: M.layer.type, style: a.style, styleSpec: a.styleSpec, object: p, objectKey: "type" });
          }, filter: yu, layout: function(Ve) {
            return vo({ layer: p, key: Ve.key, value: Ve.value, style: Ve.style, styleSpec: Ve.styleSpec, objectElementValidators: { "*": function(je) {
              return vc(ee({ layerType: N }, je));
            } } });
          }, paint: function(Ve) {
            return vo({ layer: p, key: Ve.key, value: Ve.value, style: Ve.style, styleSpec: Ve.styleSpec, objectElementValidators: { "*": function(je) {
              return yc(ee({ layerType: N }, je));
            } } });
          } } }));
        }
        function ia(a) {
          var c = a.value, p = a.key, x = Un(c);
          return x !== "string" ? [new ge(p, c, "string expected, " + x + " found")] : [];
        }
        var Gn = { promoteId: function(a) {
          var c = a.key, p = a.value;
          if (Un(p) === "string") return ia({ key: c, value: p });
          var x = [];
          for (var S in p) x.push.apply(x, ia({ key: c + "." + S, value: p[S] }));
          return x;
        } };
        function Dl(a) {
          var c = a.value, p = a.key, x = a.styleSpec, S = a.style;
          if (!c.type) return [new ge(p, c, '"type" is required')];
          var M, O = It(c.type);
          switch (O) {
            case "vector":
            case "raster":
            case "raster-dem":
              return vo({ key: p, value: c, valueSpec: x["source_" + O.replace("-", "_")], style: a.style, styleSpec: x, objectElementValidators: Gn });
            case "geojson":
              if (M = vo({ key: p, value: c, valueSpec: x.source_geojson, style: S, styleSpec: x, objectElementValidators: Gn }), c.cluster) for (var N in c.clusterProperties) {
                var G = c.clusterProperties[N], Z = G[0], te = typeof Z == "string" ? [Z, ["accumulated"], ["get", N]] : Z;
                M.push.apply(M, Xs({ key: p + "." + N + ".map", value: G[1], expressionContext: "cluster-map" })), M.push.apply(M, Xs({ key: p + "." + N + ".reduce", value: te, expressionContext: "cluster-reduce" }));
              }
              return M;
            case "video":
              return vo({ key: p, value: c, valueSpec: x.source_video, style: S, styleSpec: x });
            case "image":
              return vo({ key: p, value: c, valueSpec: x.source_image, style: S, styleSpec: x });
            case "canvas":
              return [new ge(p, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return _c({ key: p + ".type", value: c.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] } });
          }
        }
        function bo(a) {
          var c = a.value, p = a.styleSpec, x = p.light, S = a.style, M = [], O = Un(c);
          if (c === void 0) return M;
          if (O !== "object") return M.concat([new ge("light", c, "object expected, " + O + " found")]);
          for (var N in c) {
            var G = N.match(/^(.*)-transition$/);
            M = M.concat(G && x[G[1]] && x[G[1]].transition ? qr({ key: N, value: c[N], valueSpec: p.transition, style: S, styleSpec: p }) : x[N] ? qr({ key: N, value: c[N], valueSpec: x[N], style: S, styleSpec: p }) : [new ge(N, c[N], 'unknown property "' + N + '"')]);
          }
          return M;
        }
        var Zs = { "*": function() {
          return [];
        }, array: kh, boolean: function(a) {
          var c = a.value, p = a.key, x = Un(c);
          return x !== "boolean" ? [new ge(p, c, "boolean expected, " + x + " found")] : [];
        }, number: ys, color: function(a) {
          var c = a.key, p = a.value, x = Un(p);
          return x !== "string" ? [new ge(c, p, "color expected, " + x + " found")] : er(p) === null ? [new ge(c, p, 'color expected, "' + p + '" found')] : [];
        }, constants: d, enum: _c, filter: yu, function: mu, layer: Fh, object: vo, source: Dl, light: bo, string: ia, formatted: function(a) {
          return ia(a).length === 0 ? [] : Xs(a);
        }, resolvedImage: function(a) {
          return ia(a).length === 0 ? [] : Xs(a);
        } };
        function qr(a) {
          var c = a.value, p = a.valueSpec, x = a.styleSpec;
          return p.expression && Sl(It(c)) ? mu(a) : p.expression && Bn(nt(c)) ? Xs(a) : p.type && Zs[p.type] ? Zs[p.type](a) : vo(ee({}, a, { valueSpec: p.type ? x[p.type] : p }));
        }
        function zn(a) {
          var c = a.value, p = a.key, x = ia(a);
          return x.length || (c.indexOf("{fontstack}") === -1 && x.push(new ge(p, c, '"glyphs" url must include a "{fontstack}" token')), c.indexOf("{range}") === -1 && x.push(new ge(p, c, '"glyphs" url must include a "{range}" token'))), x;
        }
        function ns(a, c) {
          c === void 0 && (c = le);
          var p = [];
          return p = p.concat(qr({ key: "", value: a, valueSpec: c.$root, styleSpec: c, style: a, objectElementValidators: { glyphs: zn, "*": function() {
            return [];
          } } })), a.constants && (p = p.concat(d({ key: "constants", value: a.constants }))), bc(p);
        }
        function bc(a) {
          return [].concat(a).sort((function(c, p) {
            return c.line - p.line;
          }));
        }
        function Ll(a) {
          return function() {
            for (var c = [], p = arguments.length; p--; ) c[p] = arguments[p];
            return bc(a.apply(this, c));
          };
        }
        ns.source = Ll(Dl), ns.light = Ll(bo), ns.layer = Ll(Fh), ns.filter = Ll(yu), ns.paintProperty = Ll(yc), ns.layoutProperty = Ll(vc);
        var xc = ns, Nh = xc.light, Wp = xc.paintProperty, wc = xc.layoutProperty;
        function Tc(a, c) {
          var p = !1;
          if (c && c.length) for (var x = 0, S = c; x < S.length; x += 1) a.fire(new pe(new Error(S[x].message))), p = !0;
          return p;
        }
        var ao = xi;
        function xi(a, c, p) {
          var x = this.cells = [];
          if (a instanceof ArrayBuffer) {
            this.arrayBuffer = a;
            var S = new Int32Array(this.arrayBuffer);
            a = S[0], this.d = (c = S[1]) + 2 * (p = S[2]);
            for (var M = 0; M < this.d * this.d; M++) {
              var O = S[3 + M], N = S[3 + M + 1];
              x.push(O === N ? null : S.subarray(O, N));
            }
            var G = S[3 + x.length + 1];
            this.keys = S.subarray(S[3 + x.length], G), this.bboxes = S.subarray(G), this.insert = this._insertReadonly;
          } else {
            this.d = c + 2 * p;
            for (var Z = 0; Z < this.d * this.d; Z++) x.push([]);
            this.keys = [], this.bboxes = [];
          }
          this.n = c, this.extent = a, this.padding = p, this.scale = c / a, this.uid = 0;
          var te = p / c * a;
          this.min = -te, this.max = a + te;
        }
        xi.prototype.insert = function(a, c, p, x, S) {
          this._forEachCell(c, p, x, S, this._insertCell, this.uid++), this.keys.push(a), this.bboxes.push(c), this.bboxes.push(p), this.bboxes.push(x), this.bboxes.push(S);
        }, xi.prototype._insertReadonly = function() {
          throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
        }, xi.prototype._insertCell = function(a, c, p, x, S, M) {
          this.cells[S].push(M);
        }, xi.prototype.query = function(a, c, p, x, S) {
          var M = this.min, O = this.max;
          if (a <= M && c <= M && O <= p && O <= x && !S) return Array.prototype.slice.call(this.keys);
          var N = [];
          return this._forEachCell(a, c, p, x, this._queryCell, N, {}, S), N;
        }, xi.prototype._queryCell = function(a, c, p, x, S, M, O, N) {
          var G = this.cells[S];
          if (G !== null) for (var Z = this.keys, te = this.bboxes, se = 0; se < G.length; se++) {
            var he = G[se];
            if (O[he] === void 0) {
              var xe = 4 * he;
              (N ? N(te[xe + 0], te[xe + 1], te[xe + 2], te[xe + 3]) : a <= te[xe + 2] && c <= te[xe + 3] && p >= te[xe + 0] && x >= te[xe + 1]) ? (O[he] = !0, M.push(Z[he])) : O[he] = !1;
            }
          }
        }, xi.prototype._forEachCell = function(a, c, p, x, S, M, O, N) {
          for (var G = this._convertToCellCoord(a), Z = this._convertToCellCoord(c), te = this._convertToCellCoord(p), se = this._convertToCellCoord(x), he = G; he <= te; he++) for (var xe = Z; xe <= se; xe++) {
            var Ve = this.d * xe + he;
            if ((!N || N(this._convertFromCellCoord(he), this._convertFromCellCoord(xe), this._convertFromCellCoord(he + 1), this._convertFromCellCoord(xe + 1))) && S.call(this, a, c, p, x, Ve, M, O, N)) return;
          }
        }, xi.prototype._convertFromCellCoord = function(a) {
          return (a - this.padding) / this.scale;
        }, xi.prototype._convertToCellCoord = function(a) {
          return Math.max(0, Math.min(this.d - 1, Math.floor(a * this.scale) + this.padding));
        }, xi.prototype.toArrayBuffer = function() {
          if (this.arrayBuffer) return this.arrayBuffer;
          for (var a = this.cells, c = 3 + this.cells.length + 1 + 1, p = 0, x = 0; x < this.cells.length; x++) p += this.cells[x].length;
          var S = new Int32Array(c + p + this.keys.length + this.bboxes.length);
          S[0] = this.extent, S[1] = this.n, S[2] = this.padding;
          for (var M = c, O = 0; O < a.length; O++) {
            var N = a[O];
            S[3 + O] = M, S.set(N, M), M += N.length;
          }
          return S[3 + a.length] = M, S.set(this.keys, M), S[3 + a.length + 1] = M += this.keys.length, S.set(this.bboxes, M), M += this.bboxes.length, S.buffer;
        };
        var Ya = P.ImageData, Uh = P.ImageBitmap, wi = {};
        function ur(a, c, p) {
          p === void 0 && (p = {}), Object.defineProperty(c, "_classRegistryKey", { value: a, writeable: !1 }), wi[a] = { klass: c, omit: p.omit || [], shallow: p.shallow || [] };
        }
        for (var Ds in ur("Object", Object), ao.serialize = function(a, c) {
          var p = a.toArrayBuffer();
          return c && c.push(p), { buffer: p };
        }, ao.deserialize = function(a) {
          return new ao(a.buffer);
        }, ur("Grid", ao), ur("Color", sn), ur("Error", Error), ur("ResolvedImage", Xn), ur("StylePropertyFunction", Rl), ur("StyleExpression", jo, { omit: ["_evaluator"] }), ur("ZoomDependentExpression", Xa), ur("ZoomConstantExpression", Ml), ur("CompoundExpression", ke, { omit: ["_evaluate"] }), Wa) Wa[Ds]._classRegistryKey || ur("Expression_" + Ds, Wa[Ds]);
        function vu(a) {
          return a && typeof ArrayBuffer < "u" && (a instanceof ArrayBuffer || a.constructor && a.constructor.name === "ArrayBuffer");
        }
        function kl(a) {
          return Uh && a instanceof Uh;
        }
        function xo(a, c) {
          if (a == null || typeof a == "boolean" || typeof a == "number" || typeof a == "string" || a instanceof Boolean || a instanceof Number || a instanceof String || a instanceof Date || a instanceof RegExp) return a;
          if (vu(a) || kl(a)) return c && c.push(a), a;
          if (ArrayBuffer.isView(a)) {
            var p = a;
            return c && c.push(p.buffer), p;
          }
          if (a instanceof Ya) return c && c.push(a.data.buffer), a;
          if (Array.isArray(a)) {
            for (var x = [], S = 0, M = a; S < M.length; S += 1) x.push(xo(M[S], c));
            return x;
          }
          if (typeof a == "object") {
            var O = a.constructor, N = O._classRegistryKey;
            if (!N) throw new Error("can't serialize object of unregistered class");
            var G = O.serialize ? O.serialize(a, c) : {};
            if (!O.serialize) {
              for (var Z in a) if (a.hasOwnProperty(Z) && !(wi[N].omit.indexOf(Z) >= 0)) {
                var te = a[Z];
                G[Z] = wi[N].shallow.indexOf(Z) >= 0 ? te : xo(te, c);
              }
              a instanceof Error && (G.message = a.message);
            }
            if (G.$name) throw new Error("$name property is reserved for worker serialization logic.");
            return N !== "Object" && (G.$name = N), G;
          }
          throw new Error("can't serialize object of type " + typeof a);
        }
        function bs(a) {
          if (a == null || typeof a == "boolean" || typeof a == "number" || typeof a == "string" || a instanceof Boolean || a instanceof Number || a instanceof String || a instanceof Date || a instanceof RegExp || vu(a) || kl(a) || ArrayBuffer.isView(a) || a instanceof Ya) return a;
          if (Array.isArray(a)) return a.map(bs);
          if (typeof a == "object") {
            var c = a.$name || "Object", p = wi[c].klass;
            if (!p) throw new Error("can't deserialize unregistered class " + c);
            if (p.deserialize) return p.deserialize(a);
            for (var x = Object.create(p.prototype), S = 0, M = Object.keys(a); S < M.length; S += 1) {
              var O = M[S];
              if (O !== "$name") {
                var N = a[O];
                x[O] = wi[c].shallow.indexOf(O) >= 0 ? N : bs(N);
              }
            }
            return x;
          }
          throw new Error("can't deserialize object of type " + typeof a);
        }
        var _f = function() {
          this.first = !0;
        };
        _f.prototype.update = function(a, c) {
          var p = Math.floor(a);
          return this.first ? (this.first = !1, this.lastIntegerZoom = p, this.lastIntegerZoomTime = 0, this.lastZoom = a, this.lastFloorZoom = p, !0) : (this.lastFloorZoom > p ? (this.lastIntegerZoom = p + 1, this.lastIntegerZoomTime = c) : this.lastFloorZoom < p && (this.lastIntegerZoom = p, this.lastIntegerZoomTime = c), a !== this.lastZoom && (this.lastZoom = a, this.lastFloorZoom = p, !0));
        };
        var nr = { "Latin-1 Supplement": function(a) {
          return a >= 128 && a <= 255;
        }, Arabic: function(a) {
          return a >= 1536 && a <= 1791;
        }, "Arabic Supplement": function(a) {
          return a >= 1872 && a <= 1919;
        }, "Arabic Extended-A": function(a) {
          return a >= 2208 && a <= 2303;
        }, "Hangul Jamo": function(a) {
          return a >= 4352 && a <= 4607;
        }, "Unified Canadian Aboriginal Syllabics": function(a) {
          return a >= 5120 && a <= 5759;
        }, Khmer: function(a) {
          return a >= 6016 && a <= 6143;
        }, "Unified Canadian Aboriginal Syllabics Extended": function(a) {
          return a >= 6320 && a <= 6399;
        }, "General Punctuation": function(a) {
          return a >= 8192 && a <= 8303;
        }, "Letterlike Symbols": function(a) {
          return a >= 8448 && a <= 8527;
        }, "Number Forms": function(a) {
          return a >= 8528 && a <= 8591;
        }, "Miscellaneous Technical": function(a) {
          return a >= 8960 && a <= 9215;
        }, "Control Pictures": function(a) {
          return a >= 9216 && a <= 9279;
        }, "Optical Character Recognition": function(a) {
          return a >= 9280 && a <= 9311;
        }, "Enclosed Alphanumerics": function(a) {
          return a >= 9312 && a <= 9471;
        }, "Geometric Shapes": function(a) {
          return a >= 9632 && a <= 9727;
        }, "Miscellaneous Symbols": function(a) {
          return a >= 9728 && a <= 9983;
        }, "Miscellaneous Symbols and Arrows": function(a) {
          return a >= 11008 && a <= 11263;
        }, "CJK Radicals Supplement": function(a) {
          return a >= 11904 && a <= 12031;
        }, "Kangxi Radicals": function(a) {
          return a >= 12032 && a <= 12255;
        }, "Ideographic Description Characters": function(a) {
          return a >= 12272 && a <= 12287;
        }, "CJK Symbols and Punctuation": function(a) {
          return a >= 12288 && a <= 12351;
        }, Hiragana: function(a) {
          return a >= 12352 && a <= 12447;
        }, Katakana: function(a) {
          return a >= 12448 && a <= 12543;
        }, Bopomofo: function(a) {
          return a >= 12544 && a <= 12591;
        }, "Hangul Compatibility Jamo": function(a) {
          return a >= 12592 && a <= 12687;
        }, Kanbun: function(a) {
          return a >= 12688 && a <= 12703;
        }, "Bopomofo Extended": function(a) {
          return a >= 12704 && a <= 12735;
        }, "CJK Strokes": function(a) {
          return a >= 12736 && a <= 12783;
        }, "Katakana Phonetic Extensions": function(a) {
          return a >= 12784 && a <= 12799;
        }, "Enclosed CJK Letters and Months": function(a) {
          return a >= 12800 && a <= 13055;
        }, "CJK Compatibility": function(a) {
          return a >= 13056 && a <= 13311;
        }, "CJK Unified Ideographs Extension A": function(a) {
          return a >= 13312 && a <= 19903;
        }, "Yijing Hexagram Symbols": function(a) {
          return a >= 19904 && a <= 19967;
        }, "CJK Unified Ideographs": function(a) {
          return a >= 19968 && a <= 40959;
        }, "Yi Syllables": function(a) {
          return a >= 40960 && a <= 42127;
        }, "Yi Radicals": function(a) {
          return a >= 42128 && a <= 42191;
        }, "Hangul Jamo Extended-A": function(a) {
          return a >= 43360 && a <= 43391;
        }, "Hangul Syllables": function(a) {
          return a >= 44032 && a <= 55215;
        }, "Hangul Jamo Extended-B": function(a) {
          return a >= 55216 && a <= 55295;
        }, "Private Use Area": function(a) {
          return a >= 57344 && a <= 63743;
        }, "CJK Compatibility Ideographs": function(a) {
          return a >= 63744 && a <= 64255;
        }, "Arabic Presentation Forms-A": function(a) {
          return a >= 64336 && a <= 65023;
        }, "Vertical Forms": function(a) {
          return a >= 65040 && a <= 65055;
        }, "CJK Compatibility Forms": function(a) {
          return a >= 65072 && a <= 65103;
        }, "Small Form Variants": function(a) {
          return a >= 65104 && a <= 65135;
        }, "Arabic Presentation Forms-B": function(a) {
          return a >= 65136 && a <= 65279;
        }, "Halfwidth and Fullwidth Forms": function(a) {
          return a >= 65280 && a <= 65519;
        } };
        function wo(a) {
          for (var c = 0, p = a; c < p.length; c += 1) if (Ec(p[c].charCodeAt(0))) return !0;
          return !1;
        }
        function Ec(a) {
          return !(a !== 746 && a !== 747 && (a < 4352 || !(nr["Bopomofo Extended"](a) || nr.Bopomofo(a) || nr["CJK Compatibility Forms"](a) && !(a >= 65097 && a <= 65103) || nr["CJK Compatibility Ideographs"](a) || nr["CJK Compatibility"](a) || nr["CJK Radicals Supplement"](a) || nr["CJK Strokes"](a) || !(!nr["CJK Symbols and Punctuation"](a) || a >= 12296 && a <= 12305 || a >= 12308 && a <= 12319 || a === 12336) || nr["CJK Unified Ideographs Extension A"](a) || nr["CJK Unified Ideographs"](a) || nr["Enclosed CJK Letters and Months"](a) || nr["Hangul Compatibility Jamo"](a) || nr["Hangul Jamo Extended-A"](a) || nr["Hangul Jamo Extended-B"](a) || nr["Hangul Jamo"](a) || nr["Hangul Syllables"](a) || nr.Hiragana(a) || nr["Ideographic Description Characters"](a) || nr.Kanbun(a) || nr["Kangxi Radicals"](a) || nr["Katakana Phonetic Extensions"](a) || nr.Katakana(a) && a !== 12540 || !(!nr["Halfwidth and Fullwidth Forms"](a) || a === 65288 || a === 65289 || a === 65293 || a >= 65306 && a <= 65310 || a === 65339 || a === 65341 || a === 65343 || a >= 65371 && a <= 65503 || a === 65507 || a >= 65512 && a <= 65519) || !(!nr["Small Form Variants"](a) || a >= 65112 && a <= 65118 || a >= 65123 && a <= 65126) || nr["Unified Canadian Aboriginal Syllabics"](a) || nr["Unified Canadian Aboriginal Syllabics Extended"](a) || nr["Vertical Forms"](a) || nr["Yijing Hexagram Symbols"](a) || nr["Yi Syllables"](a) || nr["Yi Radicals"](a))));
        }
        function yf(a) {
          return !(Ec(a) || (function(c) {
            return !!(nr["Latin-1 Supplement"](c) && (c === 167 || c === 169 || c === 174 || c === 177 || c === 188 || c === 189 || c === 190 || c === 215 || c === 247) || nr["General Punctuation"](c) && (c === 8214 || c === 8224 || c === 8225 || c === 8240 || c === 8241 || c === 8251 || c === 8252 || c === 8258 || c === 8263 || c === 8264 || c === 8265 || c === 8273) || nr["Letterlike Symbols"](c) || nr["Number Forms"](c) || nr["Miscellaneous Technical"](c) && (c >= 8960 && c <= 8967 || c >= 8972 && c <= 8991 || c >= 8996 && c <= 9e3 || c === 9003 || c >= 9085 && c <= 9114 || c >= 9150 && c <= 9165 || c === 9167 || c >= 9169 && c <= 9179 || c >= 9186 && c <= 9215) || nr["Control Pictures"](c) && c !== 9251 || nr["Optical Character Recognition"](c) || nr["Enclosed Alphanumerics"](c) || nr["Geometric Shapes"](c) || nr["Miscellaneous Symbols"](c) && !(c >= 9754 && c <= 9759) || nr["Miscellaneous Symbols and Arrows"](c) && (c >= 11026 && c <= 11055 || c >= 11088 && c <= 11097 || c >= 11192 && c <= 11243) || nr["CJK Symbols and Punctuation"](c) || nr.Katakana(c) || nr["Private Use Area"](c) || nr["CJK Compatibility Forms"](c) || nr["Small Form Variants"](c) || nr["Halfwidth and Fullwidth Forms"](c) || c === 8734 || c === 8756 || c === 8757 || c >= 9984 && c <= 10087 || c >= 10102 && c <= 10131 || c === 65532 || c === 65533);
          })(a));
        }
        function lo(a) {
          return a >= 1424 && a <= 2303 || nr["Arabic Presentation Forms-A"](a) || nr["Arabic Presentation Forms-B"](a);
        }
        function Ls(a, c) {
          return !(!c && lo(a) || a >= 2304 && a <= 3583 || a >= 3840 && a <= 4255 || nr.Khmer(a));
        }
        function bu(a) {
          for (var c = 0, p = a; c < p.length; c += 1) if (lo(p[c].charCodeAt(0))) return !0;
          return !1;
        }
        var xu = null, Si = "unavailable", To = null, zh = function(a) {
          a && typeof a == "string" && a.indexOf("NetworkError") > -1 && (Si = "error"), xu && xu(a);
        };
        function Ta() {
          wu.fire(new Ne("pluginStateChange", { pluginStatus: Si, pluginURL: To }));
        }
        var wu = new Te(), vf = function() {
          return Si;
        }, Eo = function() {
          if (Si !== "deferred" || !To) throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
          Si = "loading", Ta(), To && tt({ url: To }, (function(a) {
            a ? zh(a) : (Si = "loaded", Ta());
          }));
        }, is = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: function() {
          return Si === "loaded" || is.applyArabicShaping != null;
        }, isLoading: function() {
          return Si === "loading";
        }, setState: function(a) {
          Si = a.pluginStatus, To = a.pluginURL;
        }, isParsed: function() {
          return is.applyArabicShaping != null && is.processBidirectionalText != null && is.processStyledBidirectionalText != null;
        }, getPluginURL: function() {
          return To;
        } }, cn = function(a, c) {
          this.zoom = a, c ? (this.now = c.now, this.fadeDuration = c.fadeDuration, this.zoomHistory = c.zoomHistory, this.transition = c.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new _f(), this.transition = {});
        };
        cn.prototype.isSupportedScript = function(a) {
          return (function(c, p) {
            for (var x = 0, S = c; x < S.length; x += 1) if (!Ls(S[x].charCodeAt(0), p)) return !1;
            return !0;
          })(a, is.isLoaded());
        }, cn.prototype.crossFadingFactor = function() {
          return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
        }, cn.prototype.getCrossfadeParameters = function() {
          var a = this.zoom, c = a - Math.floor(a), p = this.crossFadingFactor();
          return a > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: c + (1 - c) * p } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - p) * c };
        };
        var ks = function(a, c) {
          this.property = a, this.value = c, this.expression = (function(p, x) {
            if (Sl(p)) return new Rl(p, x);
            if (Bn(p)) {
              var S = Lh(p, x);
              if (S.result === "error") throw new Error(S.value.map((function(O) {
                return O.key + ": " + O.message;
              })).join(", "));
              return S.value;
            }
            var M = p;
            return typeof p == "string" && x.type === "color" && (M = sn.parse(p)), { kind: "constant", evaluate: function() {
              return M;
            } };
          })(c === void 0 ? a.specification.default : c, a.specification);
        };
        ks.prototype.isDataDriven = function() {
          return this.expression.kind === "source" || this.expression.kind === "composite";
        }, ks.prototype.possiblyEvaluate = function(a, c, p) {
          return this.property.possiblyEvaluate(this, a, c, p);
        };
        var Fs = function(a) {
          this.property = a, this.value = new ks(a, void 0);
        };
        Fs.prototype.transitioned = function(a, c) {
          return new Ea(this.property, this.value, c, K({}, a.transition, this.transition), a.now);
        }, Fs.prototype.untransitioned = function() {
          return new Ea(this.property, this.value, null, {}, 0);
        };
        var Li = function(a) {
          this._properties = a, this._values = Object.create(a.defaultTransitionablePropertyValues);
        };
        Li.prototype.getValue = function(a) {
          return me(this._values[a].value.value);
        }, Li.prototype.setValue = function(a, c) {
          this._values.hasOwnProperty(a) || (this._values[a] = new Fs(this._values[a].property)), this._values[a].value = new ks(this._values[a].property, c === null ? void 0 : me(c));
        }, Li.prototype.getTransition = function(a) {
          return me(this._values[a].transition);
        }, Li.prototype.setTransition = function(a, c) {
          this._values.hasOwnProperty(a) || (this._values[a] = new Fs(this._values[a].property)), this._values[a].transition = me(c) || void 0;
        }, Li.prototype.serialize = function() {
          for (var a = {}, c = 0, p = Object.keys(this._values); c < p.length; c += 1) {
            var x = p[c], S = this.getValue(x);
            S !== void 0 && (a[x] = S);
            var M = this.getTransition(x);
            M !== void 0 && (a[x + "-transition"] = M);
          }
          return a;
        }, Li.prototype.transitioned = function(a, c) {
          for (var p = new Co(this._properties), x = 0, S = Object.keys(this._values); x < S.length; x += 1) {
            var M = S[x];
            p._values[M] = this._values[M].transitioned(a, c._values[M]);
          }
          return p;
        }, Li.prototype.untransitioned = function() {
          for (var a = new Co(this._properties), c = 0, p = Object.keys(this._values); c < p.length; c += 1) {
            var x = p[c];
            a._values[x] = this._values[x].untransitioned();
          }
          return a;
        };
        var Ea = function(a, c, p, x, S) {
          this.property = a, this.value = c, this.begin = S + x.delay || 0, this.end = this.begin + x.duration || 0, a.specification.transition && (x.delay || x.duration) && (this.prior = p);
        };
        Ea.prototype.possiblyEvaluate = function(a, c, p) {
          var x = a.now || 0, S = this.value.possiblyEvaluate(a, c, p), M = this.prior;
          if (M) {
            if (x > this.end) return this.prior = null, S;
            if (this.value.isDataDriven()) return this.prior = null, S;
            if (x < this.begin) return M.possiblyEvaluate(a, c, p);
            var O = (x - this.begin) / (this.end - this.begin);
            return this.property.interpolate(M.possiblyEvaluate(a, c, p), S, (function(N) {
              if (N <= 0) return 0;
              if (N >= 1) return 1;
              var G = N * N, Z = G * N;
              return 4 * (N < 0.5 ? Z : 3 * (N - G) + Z - 0.75);
            })(O));
          }
          return S;
        };
        var Co = function(a) {
          this._properties = a, this._values = Object.create(a.defaultTransitioningPropertyValues);
        };
        Co.prototype.possiblyEvaluate = function(a, c, p) {
          for (var x = new Cc(this._properties), S = 0, M = Object.keys(this._values); S < M.length; S += 1) {
            var O = M[S];
            x._values[O] = this._values[O].possiblyEvaluate(a, c, p);
          }
          return x;
        }, Co.prototype.hasTransition = function() {
          for (var a = 0, c = Object.keys(this._values); a < c.length; a += 1) if (this._values[c[a]].prior) return !0;
          return !1;
        };
        var co = function(a) {
          this._properties = a, this._values = Object.create(a.defaultPropertyValues);
        };
        co.prototype.getValue = function(a) {
          return me(this._values[a].value);
        }, co.prototype.setValue = function(a, c) {
          this._values[a] = new ks(this._values[a].property, c === null ? void 0 : me(c));
        }, co.prototype.serialize = function() {
          for (var a = {}, c = 0, p = Object.keys(this._values); c < p.length; c += 1) {
            var x = p[c], S = this.getValue(x);
            S !== void 0 && (a[x] = S);
          }
          return a;
        }, co.prototype.possiblyEvaluate = function(a, c, p) {
          for (var x = new Cc(this._properties), S = 0, M = Object.keys(this._values); S < M.length; S += 1) {
            var O = M[S];
            x._values[O] = this._values[O].possiblyEvaluate(a, c, p);
          }
          return x;
        };
        var cs = function(a, c, p) {
          this.property = a, this.value = c, this.parameters = p;
        };
        cs.prototype.isConstant = function() {
          return this.value.kind === "constant";
        }, cs.prototype.constantOr = function(a) {
          return this.value.kind === "constant" ? this.value.value : a;
        }, cs.prototype.evaluate = function(a, c, p, x) {
          return this.property.evaluate(this.value, this.parameters, a, c, p, x);
        };
        var Cc = function(a) {
          this._properties = a, this._values = Object.create(a.defaultPossiblyEvaluatedValues);
        };
        Cc.prototype.get = function(a) {
          return this._values[a];
        };
        var Mr = function(a) {
          this.specification = a;
        };
        Mr.prototype.possiblyEvaluate = function(a, c) {
          return a.expression.evaluate(c);
        }, Mr.prototype.interpolate = function(a, c, p) {
          var x = Ha[this.specification.type];
          return x ? x(a, c, p) : a;
        };
        var Ar = function(a, c) {
          this.specification = a, this.overrides = c;
        };
        Ar.prototype.possiblyEvaluate = function(a, c, p, x) {
          return new cs(this, a.expression.kind === "constant" || a.expression.kind === "camera" ? { kind: "constant", value: a.expression.evaluate(c, null, {}, p, x) } : a.expression, c);
        }, Ar.prototype.interpolate = function(a, c, p) {
          if (a.value.kind !== "constant" || c.value.kind !== "constant") return a;
          if (a.value.value === void 0 || c.value.value === void 0) return new cs(this, { kind: "constant", value: void 0 }, a.parameters);
          var x = Ha[this.specification.type];
          return x ? new cs(this, { kind: "constant", value: x(a.value.value, c.value.value, p) }, a.parameters) : a;
        }, Ar.prototype.evaluate = function(a, c, p, x, S, M) {
          return a.kind === "constant" ? a.value : a.evaluate(c, p, x, S, M);
        };
        var Tu = (function(a) {
          function c() {
            a.apply(this, arguments);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype.possiblyEvaluate = function(p, x, S, M) {
            if (p.value === void 0) return new cs(this, { kind: "constant", value: void 0 }, x);
            if (p.expression.kind === "constant") {
              var O = p.expression.evaluate(x, null, {}, S, M), N = p.property.specification.type === "resolvedImage" && typeof O != "string" ? O.name : O, G = this._calculate(N, N, N, x);
              return new cs(this, { kind: "constant", value: G }, x);
            }
            if (p.expression.kind === "camera") {
              var Z = this._calculate(p.expression.evaluate({ zoom: x.zoom - 1 }), p.expression.evaluate({ zoom: x.zoom }), p.expression.evaluate({ zoom: x.zoom + 1 }), x);
              return new cs(this, { kind: "constant", value: Z }, x);
            }
            return new cs(this, p.expression, x);
          }, c.prototype.evaluate = function(p, x, S, M, O, N) {
            if (p.kind === "source") {
              var G = p.evaluate(x, S, M, O, N);
              return this._calculate(G, G, G, x);
            }
            return p.kind === "composite" ? this._calculate(p.evaluate({ zoom: Math.floor(x.zoom) - 1 }, S, M), p.evaluate({ zoom: Math.floor(x.zoom) }, S, M), p.evaluate({ zoom: Math.floor(x.zoom) + 1 }, S, M), x) : p.value;
          }, c.prototype._calculate = function(p, x, S, M) {
            return M.zoom > M.zoomHistory.lastIntegerZoom ? { from: p, to: x } : { from: S, to: x };
          }, c.prototype.interpolate = function(p) {
            return p;
          }, c;
        })(Ar), us = function(a) {
          this.specification = a;
        };
        us.prototype.possiblyEvaluate = function(a, c, p, x) {
          if (a.value !== void 0) {
            if (a.expression.kind === "constant") {
              var S = a.expression.evaluate(c, null, {}, p, x);
              return this._calculate(S, S, S, c);
            }
            return this._calculate(a.expression.evaluate(new cn(Math.floor(c.zoom - 1), c)), a.expression.evaluate(new cn(Math.floor(c.zoom), c)), a.expression.evaluate(new cn(Math.floor(c.zoom + 1), c)), c);
          }
        }, us.prototype._calculate = function(a, c, p, x) {
          return x.zoom > x.zoomHistory.lastIntegerZoom ? { from: a, to: c } : { from: p, to: c };
        }, us.prototype.interpolate = function(a) {
          return a;
        };
        var So = function(a) {
          this.specification = a;
        };
        So.prototype.possiblyEvaluate = function(a, c, p, x) {
          return !!a.expression.evaluate(c, null, {}, p, x);
        }, So.prototype.interpolate = function() {
          return !1;
        };
        var Xi = function(a) {
          for (var c in this.properties = a, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [], a) {
            var p = a[c];
            p.specification.overridable && this.overridableProperties.push(c);
            var x = this.defaultPropertyValues[c] = new ks(p, void 0), S = this.defaultTransitionablePropertyValues[c] = new Fs(p);
            this.defaultTransitioningPropertyValues[c] = S.untransitioned(), this.defaultPossiblyEvaluatedValues[c] = x.possiblyEvaluate({});
          }
        };
        ur("DataDrivenProperty", Ar), ur("DataConstantProperty", Mr), ur("CrossFadedDataDrivenProperty", Tu), ur("CrossFadedProperty", us), ur("ColorRampProperty", So);
        var Ho = (function(a) {
          function c(p, x) {
            if (a.call(this), this.id = p.id, this.type = p.type, this._featureFilter = { filter: function() {
              return !0;
            }, needGeometry: !1 }, p.type !== "custom" && (this.metadata = (p = p).metadata, this.minzoom = p.minzoom, this.maxzoom = p.maxzoom, p.type !== "background" && (this.source = p.source, this.sourceLayer = p["source-layer"], this.filter = p.filter), x.layout && (this._unevaluatedLayout = new co(x.layout)), x.paint)) {
              for (var S in this._transitionablePaint = new Li(x.paint), p.paint) this.setPaintProperty(S, p.paint[S], { validate: !1 });
              for (var M in p.layout) this.setLayoutProperty(M, p.layout[M], { validate: !1 });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Cc(x.paint);
            }
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype.getCrossfadeParameters = function() {
            return this._crossfadeParameters;
          }, c.prototype.getLayoutProperty = function(p) {
            return p === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(p);
          }, c.prototype.setLayoutProperty = function(p, x, S) {
            S === void 0 && (S = {}), x != null && this._validate(wc, "layers." + this.id + ".layout." + p, p, x, S) || (p !== "visibility" ? this._unevaluatedLayout.setValue(p, x) : this.visibility = x);
          }, c.prototype.getPaintProperty = function(p) {
            return Ge(p, "-transition") ? this._transitionablePaint.getTransition(p.slice(0, -11)) : this._transitionablePaint.getValue(p);
          }, c.prototype.setPaintProperty = function(p, x, S) {
            if (S === void 0 && (S = {}), x != null && this._validate(Wp, "layers." + this.id + ".paint." + p, p, x, S)) return !1;
            if (Ge(p, "-transition")) return this._transitionablePaint.setTransition(p.slice(0, -11), x || void 0), !1;
            var M = this._transitionablePaint._values[p], O = M.property.specification["property-type"] === "cross-faded-data-driven", N = M.value.isDataDriven(), G = M.value;
            this._transitionablePaint.setValue(p, x), this._handleSpecialPaintPropertyUpdate(p);
            var Z = this._transitionablePaint._values[p].value;
            return Z.isDataDriven() || N || O || this._handleOverridablePaintPropertyUpdate(p, G, Z);
          }, c.prototype._handleSpecialPaintPropertyUpdate = function(p) {
          }, c.prototype._handleOverridablePaintPropertyUpdate = function(p, x, S) {
            return !1;
          }, c.prototype.isHidden = function(p) {
            return !!(this.minzoom && p < this.minzoom) || !!(this.maxzoom && p >= this.maxzoom) || this.visibility === "none";
          }, c.prototype.updateTransitions = function(p) {
            this._transitioningPaint = this._transitionablePaint.transitioned(p, this._transitioningPaint);
          }, c.prototype.hasTransition = function() {
            return this._transitioningPaint.hasTransition();
          }, c.prototype.recalculate = function(p, x) {
            p.getCrossfadeParameters && (this._crossfadeParameters = p.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(p, void 0, x)), this.paint = this._transitioningPaint.possiblyEvaluate(p, void 0, x);
          }, c.prototype.serialize = function() {
            var p = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
            return this.visibility && (p.layout = p.layout || {}, p.layout.visibility = this.visibility), ve(p, (function(x, S) {
              return !(x === void 0 || S === "layout" && !Object.keys(x).length || S === "paint" && !Object.keys(x).length);
            }));
          }, c.prototype._validate = function(p, x, S, M, O) {
            return O === void 0 && (O = {}), (!O || O.validate !== !1) && Tc(this, p.call(xc, { key: x, layerType: this.type, objectKey: S, value: M, styleSpec: le, style: { glyphs: !0, sprite: !0 } }));
          }, c.prototype.is3D = function() {
            return !1;
          }, c.prototype.isTileClipped = function() {
            return !1;
          }, c.prototype.hasOffscreenPass = function() {
            return !1;
          }, c.prototype.resize = function() {
          }, c.prototype.isStateDependent = function() {
            for (var p in this.paint._values) {
              var x = this.paint.get(p);
              if (x instanceof cs && na(x.property.specification) && (x.value.kind === "source" || x.value.kind === "composite") && x.value.isStateDependent) return !0;
            }
            return !1;
          }, c;
        })(Te), Eu = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array }, Sc = function(a, c) {
          this._structArray = a, this._pos1 = c * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
        }, Xr = function() {
          this.isTransferred = !1, this.capacity = -1, this.resize(0);
        };
        function zi(a, c) {
          c === void 0 && (c = 1);
          var p = 0, x = 0;
          return { members: a.map((function(S) {
            var M = Eu[S.type].BYTES_PER_ELEMENT, O = p = Vh(p, Math.max(c, M)), N = S.components || 1;
            return x = Math.max(x, M), p += M * N, { name: S.name, type: S.type, components: N, offset: O };
          })), size: Vh(p, Math.max(x, c)), alignment: c };
        }
        function Vh(a, c) {
          return Math.ceil(a / c) * c;
        }
        Xr.serialize = function(a, c) {
          return a._trim(), c && (a.isTransferred = !0, c.push(a.arrayBuffer)), { length: a.length, arrayBuffer: a.arrayBuffer };
        }, Xr.deserialize = function(a) {
          var c = Object.create(this.prototype);
          return c.arrayBuffer = a.arrayBuffer, c.length = a.length, c.capacity = a.arrayBuffer.byteLength / c.bytesPerElement, c._refreshViews(), c;
        }, Xr.prototype._trim = function() {
          this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
        }, Xr.prototype.clear = function() {
          this.length = 0;
        }, Xr.prototype.resize = function(a) {
          this.reserve(a), this.length = a;
        }, Xr.prototype.reserve = function(a) {
          if (a > this.capacity) {
            this.capacity = Math.max(a, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
            var c = this.uint8;
            this._refreshViews(), c && this.uint8.set(c);
          }
        }, Xr.prototype._refreshViews = function() {
          throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
        };
        var Io = (function(a) {
          function c() {
            a.apply(this, arguments);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }, c.prototype.emplaceBack = function(p, x) {
            var S = this.length;
            return this.resize(S + 1), this.emplace(S, p, x);
          }, c.prototype.emplace = function(p, x, S) {
            var M = 2 * p;
            return this.int16[M + 0] = x, this.int16[M + 1] = S, p;
          }, c;
        })(Xr);
        Io.prototype.bytesPerElement = 4, ur("StructArrayLayout2i4", Io);
        var Ns = (function(a) {
          function c() {
            a.apply(this, arguments);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }, c.prototype.emplaceBack = function(p, x, S, M) {
            var O = this.length;
            return this.resize(O + 1), this.emplace(O, p, x, S, M);
          }, c.prototype.emplace = function(p, x, S, M, O) {
            var N = 4 * p;
            return this.int16[N + 0] = x, this.int16[N + 1] = S, this.int16[N + 2] = M, this.int16[N + 3] = O, p;
          }, c;
        })(Xr);
        Ns.prototype.bytesPerElement = 8, ur("StructArrayLayout4i8", Ns);
        var sa = (function(a) {
          function c() {
            a.apply(this, arguments);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }, c.prototype.emplaceBack = function(p, x, S, M, O, N) {
            var G = this.length;
            return this.resize(G + 1), this.emplace(G, p, x, S, M, O, N);
          }, c.prototype.emplace = function(p, x, S, M, O, N, G) {
            var Z = 6 * p;
            return this.int16[Z + 0] = x, this.int16[Z + 1] = S, this.int16[Z + 2] = M, this.int16[Z + 3] = O, this.int16[Z + 4] = N, this.int16[Z + 5] = G, p;
          }, c;
        })(Xr);
        sa.prototype.bytesPerElement = 12, ur("StructArrayLayout2i4i12", sa);
        var Us = (function(a) {
          function c() {
            a.apply(this, arguments);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }, c.prototype.emplaceBack = function(p, x, S, M, O, N) {
            var G = this.length;
            return this.resize(G + 1), this.emplace(G, p, x, S, M, O, N);
          }, c.prototype.emplace = function(p, x, S, M, O, N, G) {
            var Z = 4 * p, te = 8 * p;
            return this.int16[Z + 0] = x, this.int16[Z + 1] = S, this.uint8[te + 4] = M, this.uint8[te + 5] = O, this.uint8[te + 6] = N, this.uint8[te + 7] = G, p;
          }, c;
        })(Xr);
        Us.prototype.bytesPerElement = 8, ur("StructArrayLayout2i4ub8", Us);
        var Fl = (function(a) {
          function c() {
            a.apply(this, arguments);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }, c.prototype.emplaceBack = function(p, x) {
            var S = this.length;
            return this.resize(S + 1), this.emplace(S, p, x);
          }, c.prototype.emplace = function(p, x, S) {
            var M = 2 * p;
            return this.float32[M + 0] = x, this.float32[M + 1] = S, p;
          }, c;
        })(Xr);
        Fl.prototype.bytesPerElement = 8, ur("StructArrayLayout2f8", Fl);
        var Po = (function(a) {
          function c() {
            a.apply(this, arguments);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }, c.prototype.emplaceBack = function(p, x, S, M, O, N, G, Z, te, se) {
            var he = this.length;
            return this.resize(he + 1), this.emplace(he, p, x, S, M, O, N, G, Z, te, se);
          }, c.prototype.emplace = function(p, x, S, M, O, N, G, Z, te, se, he) {
            var xe = 10 * p;
            return this.uint16[xe + 0] = x, this.uint16[xe + 1] = S, this.uint16[xe + 2] = M, this.uint16[xe + 3] = O, this.uint16[xe + 4] = N, this.uint16[xe + 5] = G, this.uint16[xe + 6] = Z, this.uint16[xe + 7] = te, this.uint16[xe + 8] = se, this.uint16[xe + 9] = he, p;
          }, c;
        })(Xr);
        Po.prototype.bytesPerElement = 20, ur("StructArrayLayout10ui20", Po);
        var Ic = (function(a) {
          function c() {
            a.apply(this, arguments);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }, c.prototype.emplaceBack = function(p, x, S, M, O, N, G, Z, te, se, he, xe) {
            var Ve = this.length;
            return this.resize(Ve + 1), this.emplace(Ve, p, x, S, M, O, N, G, Z, te, se, he, xe);
          }, c.prototype.emplace = function(p, x, S, M, O, N, G, Z, te, se, he, xe, Ve) {
            var je = 12 * p;
            return this.int16[je + 0] = x, this.int16[je + 1] = S, this.int16[je + 2] = M, this.int16[je + 3] = O, this.uint16[je + 4] = N, this.uint16[je + 5] = G, this.uint16[je + 6] = Z, this.uint16[je + 7] = te, this.int16[je + 8] = se, this.int16[je + 9] = he, this.int16[je + 10] = xe, this.int16[je + 11] = Ve, p;
          }, c;
        })(Xr);
        Ic.prototype.bytesPerElement = 24, ur("StructArrayLayout4i4ui4i24", Ic);
        var Ka = (function(a) {
          function c() {
            a.apply(this, arguments);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }, c.prototype.emplaceBack = function(p, x, S) {
            var M = this.length;
            return this.resize(M + 1), this.emplace(M, p, x, S);
          }, c.prototype.emplace = function(p, x, S, M) {
            var O = 3 * p;
            return this.float32[O + 0] = x, this.float32[O + 1] = S, this.float32[O + 2] = M, p;
          }, c;
        })(Xr);
        Ka.prototype.bytesPerElement = 12, ur("StructArrayLayout3f12", Ka);
        var Nl = (function(a) {
          function c() {
            a.apply(this, arguments);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }, c.prototype.emplaceBack = function(p) {
            var x = this.length;
            return this.resize(x + 1), this.emplace(x, p);
          }, c.prototype.emplace = function(p, x) {
            return this.uint32[1 * p + 0] = x, p;
          }, c;
        })(Xr);
        Nl.prototype.bytesPerElement = 4, ur("StructArrayLayout1ul4", Nl);
        var bf = (function(a) {
          function c() {
            a.apply(this, arguments);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }, c.prototype.emplaceBack = function(p, x, S, M, O, N, G, Z, te) {
            var se = this.length;
            return this.resize(se + 1), this.emplace(se, p, x, S, M, O, N, G, Z, te);
          }, c.prototype.emplace = function(p, x, S, M, O, N, G, Z, te, se) {
            var he = 10 * p, xe = 5 * p;
            return this.int16[he + 0] = x, this.int16[he + 1] = S, this.int16[he + 2] = M, this.int16[he + 3] = O, this.int16[he + 4] = N, this.int16[he + 5] = G, this.uint32[xe + 3] = Z, this.uint16[he + 8] = te, this.uint16[he + 9] = se, p;
          }, c;
        })(Xr);
        bf.prototype.bytesPerElement = 20, ur("StructArrayLayout6i1ul2ui20", bf);
        var Ul = (function(a) {
          function c() {
            a.apply(this, arguments);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }, c.prototype.emplaceBack = function(p, x, S, M, O, N) {
            var G = this.length;
            return this.resize(G + 1), this.emplace(G, p, x, S, M, O, N);
          }, c.prototype.emplace = function(p, x, S, M, O, N, G) {
            var Z = 6 * p;
            return this.int16[Z + 0] = x, this.int16[Z + 1] = S, this.int16[Z + 2] = M, this.int16[Z + 3] = O, this.int16[Z + 4] = N, this.int16[Z + 5] = G, p;
          }, c;
        })(Xr);
        Ul.prototype.bytesPerElement = 12, ur("StructArrayLayout2i2i2i12", Ul);
        var Qa = (function(a) {
          function c() {
            a.apply(this, arguments);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }, c.prototype.emplaceBack = function(p, x, S, M, O) {
            var N = this.length;
            return this.resize(N + 1), this.emplace(N, p, x, S, M, O);
          }, c.prototype.emplace = function(p, x, S, M, O, N) {
            var G = 4 * p, Z = 8 * p;
            return this.float32[G + 0] = x, this.float32[G + 1] = S, this.float32[G + 2] = M, this.int16[Z + 6] = O, this.int16[Z + 7] = N, p;
          }, c;
        })(Xr);
        Qa.prototype.bytesPerElement = 16, ur("StructArrayLayout2f1f2i16", Qa);
        var xf = (function(a) {
          function c() {
            a.apply(this, arguments);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }, c.prototype.emplaceBack = function(p, x, S, M) {
            var O = this.length;
            return this.resize(O + 1), this.emplace(O, p, x, S, M);
          }, c.prototype.emplace = function(p, x, S, M, O) {
            var N = 12 * p, G = 3 * p;
            return this.uint8[N + 0] = x, this.uint8[N + 1] = S, this.float32[G + 1] = M, this.float32[G + 2] = O, p;
          }, c;
        })(Xr);
        xf.prototype.bytesPerElement = 12, ur("StructArrayLayout2ub2f12", xf);
        var xs = (function(a) {
          function c() {
            a.apply(this, arguments);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }, c.prototype.emplaceBack = function(p, x, S) {
            var M = this.length;
            return this.resize(M + 1), this.emplace(M, p, x, S);
          }, c.prototype.emplace = function(p, x, S, M) {
            var O = 3 * p;
            return this.uint16[O + 0] = x, this.uint16[O + 1] = S, this.uint16[O + 2] = M, p;
          }, c;
        })(Xr);
        xs.prototype.bytesPerElement = 6, ur("StructArrayLayout3ui6", xs);
        var ss = (function(a) {
          function c() {
            a.apply(this, arguments);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }, c.prototype.emplaceBack = function(p, x, S, M, O, N, G, Z, te, se, he, xe, Ve, je, Qe, Ye, it) {
            var pt = this.length;
            return this.resize(pt + 1), this.emplace(pt, p, x, S, M, O, N, G, Z, te, se, he, xe, Ve, je, Qe, Ye, it);
          }, c.prototype.emplace = function(p, x, S, M, O, N, G, Z, te, se, he, xe, Ve, je, Qe, Ye, it, pt) {
            var xt = 24 * p, Tt = 12 * p, Nt = 48 * p;
            return this.int16[xt + 0] = x, this.int16[xt + 1] = S, this.uint16[xt + 2] = M, this.uint16[xt + 3] = O, this.uint32[Tt + 2] = N, this.uint32[Tt + 3] = G, this.uint32[Tt + 4] = Z, this.uint16[xt + 10] = te, this.uint16[xt + 11] = se, this.uint16[xt + 12] = he, this.float32[Tt + 7] = xe, this.float32[Tt + 8] = Ve, this.uint8[Nt + 36] = je, this.uint8[Nt + 37] = Qe, this.uint8[Nt + 38] = Ye, this.uint32[Tt + 10] = it, this.int16[xt + 22] = pt, p;
          }, c;
        })(Xr);
        ss.prototype.bytesPerElement = 48, ur("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", ss);
        var Ur = (function(a) {
          function c() {
            a.apply(this, arguments);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }, c.prototype.emplaceBack = function(p, x, S, M, O, N, G, Z, te, se, he, xe, Ve, je, Qe, Ye, it, pt, xt, Tt, Nt, Kt, rr, Ir, lr, Dr, cr, an) {
            var jr = this.length;
            return this.resize(jr + 1), this.emplace(jr, p, x, S, M, O, N, G, Z, te, se, he, xe, Ve, je, Qe, Ye, it, pt, xt, Tt, Nt, Kt, rr, Ir, lr, Dr, cr, an);
          }, c.prototype.emplace = function(p, x, S, M, O, N, G, Z, te, se, he, xe, Ve, je, Qe, Ye, it, pt, xt, Tt, Nt, Kt, rr, Ir, lr, Dr, cr, an, jr) {
            var mr = 34 * p, yn = 17 * p;
            return this.int16[mr + 0] = x, this.int16[mr + 1] = S, this.int16[mr + 2] = M, this.int16[mr + 3] = O, this.int16[mr + 4] = N, this.int16[mr + 5] = G, this.int16[mr + 6] = Z, this.int16[mr + 7] = te, this.uint16[mr + 8] = se, this.uint16[mr + 9] = he, this.uint16[mr + 10] = xe, this.uint16[mr + 11] = Ve, this.uint16[mr + 12] = je, this.uint16[mr + 13] = Qe, this.uint16[mr + 14] = Ye, this.uint16[mr + 15] = it, this.uint16[mr + 16] = pt, this.uint16[mr + 17] = xt, this.uint16[mr + 18] = Tt, this.uint16[mr + 19] = Nt, this.uint16[mr + 20] = Kt, this.uint16[mr + 21] = rr, this.uint16[mr + 22] = Ir, this.uint32[yn + 12] = lr, this.float32[yn + 13] = Dr, this.float32[yn + 14] = cr, this.float32[yn + 15] = an, this.float32[yn + 16] = jr, p;
          }, c;
        })(Xr);
        Ur.prototype.bytesPerElement = 68, ur("StructArrayLayout8i15ui1ul4f68", Ur);
        var Ii = (function(a) {
          function c() {
            a.apply(this, arguments);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }, c.prototype.emplaceBack = function(p) {
            var x = this.length;
            return this.resize(x + 1), this.emplace(x, p);
          }, c.prototype.emplace = function(p, x) {
            return this.float32[1 * p + 0] = x, p;
          }, c;
        })(Xr);
        Ii.prototype.bytesPerElement = 4, ur("StructArrayLayout1f4", Ii);
        var Er = (function(a) {
          function c() {
            a.apply(this, arguments);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }, c.prototype.emplaceBack = function(p, x, S) {
            var M = this.length;
            return this.resize(M + 1), this.emplace(M, p, x, S);
          }, c.prototype.emplace = function(p, x, S, M) {
            var O = 3 * p;
            return this.int16[O + 0] = x, this.int16[O + 1] = S, this.int16[O + 2] = M, p;
          }, c;
        })(Xr);
        Er.prototype.bytesPerElement = 6, ur("StructArrayLayout3i6", Er);
        var Vi = (function(a) {
          function c() {
            a.apply(this, arguments);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }, c.prototype.emplaceBack = function(p, x, S) {
            var M = this.length;
            return this.resize(M + 1), this.emplace(M, p, x, S);
          }, c.prototype.emplace = function(p, x, S, M) {
            var O = 4 * p;
            return this.uint32[2 * p + 0] = x, this.uint16[O + 2] = S, this.uint16[O + 3] = M, p;
          }, c;
        })(Xr);
        Vi.prototype.bytesPerElement = 8, ur("StructArrayLayout1ul2ui8", Vi);
        var zl = (function(a) {
          function c() {
            a.apply(this, arguments);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }, c.prototype.emplaceBack = function(p, x) {
            var S = this.length;
            return this.resize(S + 1), this.emplace(S, p, x);
          }, c.prototype.emplace = function(p, x, S) {
            var M = 2 * p;
            return this.uint16[M + 0] = x, this.uint16[M + 1] = S, p;
          }, c;
        })(Xr);
        zl.prototype.bytesPerElement = 4, ur("StructArrayLayout2ui4", zl);
        var Pc = (function(a) {
          function c() {
            a.apply(this, arguments);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }, c.prototype.emplaceBack = function(p) {
            var x = this.length;
            return this.resize(x + 1), this.emplace(x, p);
          }, c.prototype.emplace = function(p, x) {
            return this.uint16[1 * p + 0] = x, p;
          }, c;
        })(Xr);
        Pc.prototype.bytesPerElement = 2, ur("StructArrayLayout1ui2", Pc);
        var Mo = (function(a) {
          function c() {
            a.apply(this, arguments);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }, c.prototype.emplaceBack = function(p, x, S, M) {
            var O = this.length;
            return this.resize(O + 1), this.emplace(O, p, x, S, M);
          }, c.prototype.emplace = function(p, x, S, M, O) {
            var N = 4 * p;
            return this.float32[N + 0] = x, this.float32[N + 1] = S, this.float32[N + 2] = M, this.float32[N + 3] = O, p;
          }, c;
        })(Xr);
        Mo.prototype.bytesPerElement = 16, ur("StructArrayLayout4f16", Mo);
        var g = (function(a) {
          function c() {
            a.apply(this, arguments);
          }
          a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c;
          var p = { anchorPointX: { configurable: !0 }, anchorPointY: { configurable: !0 }, x1: { configurable: !0 }, y1: { configurable: !0 }, x2: { configurable: !0 }, y2: { configurable: !0 }, featureIndex: { configurable: !0 }, sourceLayerIndex: { configurable: !0 }, bucketIndex: { configurable: !0 }, anchorPoint: { configurable: !0 } };
          return p.anchorPointX.get = function() {
            return this._structArray.int16[this._pos2 + 0];
          }, p.anchorPointY.get = function() {
            return this._structArray.int16[this._pos2 + 1];
          }, p.x1.get = function() {
            return this._structArray.int16[this._pos2 + 2];
          }, p.y1.get = function() {
            return this._structArray.int16[this._pos2 + 3];
          }, p.x2.get = function() {
            return this._structArray.int16[this._pos2 + 4];
          }, p.y2.get = function() {
            return this._structArray.int16[this._pos2 + 5];
          }, p.featureIndex.get = function() {
            return this._structArray.uint32[this._pos4 + 3];
          }, p.sourceLayerIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 8];
          }, p.bucketIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 9];
          }, p.anchorPoint.get = function() {
            return new y(this.anchorPointX, this.anchorPointY);
          }, Object.defineProperties(c.prototype, p), c;
        })(Sc);
        g.prototype.size = 20;
        var v = (function(a) {
          function c() {
            a.apply(this, arguments);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype.get = function(p) {
            return new g(this, p);
          }, c;
        })(bf);
        ur("CollisionBoxArray", v);
        var _ = (function(a) {
          function c() {
            a.apply(this, arguments);
          }
          a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c;
          var p = { anchorX: { configurable: !0 }, anchorY: { configurable: !0 }, glyphStartIndex: { configurable: !0 }, numGlyphs: { configurable: !0 }, vertexStartIndex: { configurable: !0 }, lineStartIndex: { configurable: !0 }, lineLength: { configurable: !0 }, segment: { configurable: !0 }, lowerSize: { configurable: !0 }, upperSize: { configurable: !0 }, lineOffsetX: { configurable: !0 }, lineOffsetY: { configurable: !0 }, writingMode: { configurable: !0 }, placedOrientation: { configurable: !0 }, hidden: { configurable: !0 }, crossTileID: { configurable: !0 }, associatedIconIndex: { configurable: !0 } };
          return p.anchorX.get = function() {
            return this._structArray.int16[this._pos2 + 0];
          }, p.anchorY.get = function() {
            return this._structArray.int16[this._pos2 + 1];
          }, p.glyphStartIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 2];
          }, p.numGlyphs.get = function() {
            return this._structArray.uint16[this._pos2 + 3];
          }, p.vertexStartIndex.get = function() {
            return this._structArray.uint32[this._pos4 + 2];
          }, p.lineStartIndex.get = function() {
            return this._structArray.uint32[this._pos4 + 3];
          }, p.lineLength.get = function() {
            return this._structArray.uint32[this._pos4 + 4];
          }, p.segment.get = function() {
            return this._structArray.uint16[this._pos2 + 10];
          }, p.lowerSize.get = function() {
            return this._structArray.uint16[this._pos2 + 11];
          }, p.upperSize.get = function() {
            return this._structArray.uint16[this._pos2 + 12];
          }, p.lineOffsetX.get = function() {
            return this._structArray.float32[this._pos4 + 7];
          }, p.lineOffsetY.get = function() {
            return this._structArray.float32[this._pos4 + 8];
          }, p.writingMode.get = function() {
            return this._structArray.uint8[this._pos1 + 36];
          }, p.placedOrientation.get = function() {
            return this._structArray.uint8[this._pos1 + 37];
          }, p.placedOrientation.set = function(x) {
            this._structArray.uint8[this._pos1 + 37] = x;
          }, p.hidden.get = function() {
            return this._structArray.uint8[this._pos1 + 38];
          }, p.hidden.set = function(x) {
            this._structArray.uint8[this._pos1 + 38] = x;
          }, p.crossTileID.get = function() {
            return this._structArray.uint32[this._pos4 + 10];
          }, p.crossTileID.set = function(x) {
            this._structArray.uint32[this._pos4 + 10] = x;
          }, p.associatedIconIndex.get = function() {
            return this._structArray.int16[this._pos2 + 22];
          }, Object.defineProperties(c.prototype, p), c;
        })(Sc);
        _.prototype.size = 48;
        var w = (function(a) {
          function c() {
            a.apply(this, arguments);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype.get = function(p) {
            return new _(this, p);
          }, c;
        })(ss);
        ur("PlacedSymbolArray", w);
        var R = (function(a) {
          function c() {
            a.apply(this, arguments);
          }
          a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c;
          var p = { anchorX: { configurable: !0 }, anchorY: { configurable: !0 }, rightJustifiedTextSymbolIndex: { configurable: !0 }, centerJustifiedTextSymbolIndex: { configurable: !0 }, leftJustifiedTextSymbolIndex: { configurable: !0 }, verticalPlacedTextSymbolIndex: { configurable: !0 }, placedIconSymbolIndex: { configurable: !0 }, verticalPlacedIconSymbolIndex: { configurable: !0 }, key: { configurable: !0 }, textBoxStartIndex: { configurable: !0 }, textBoxEndIndex: { configurable: !0 }, verticalTextBoxStartIndex: { configurable: !0 }, verticalTextBoxEndIndex: { configurable: !0 }, iconBoxStartIndex: { configurable: !0 }, iconBoxEndIndex: { configurable: !0 }, verticalIconBoxStartIndex: { configurable: !0 }, verticalIconBoxEndIndex: { configurable: !0 }, featureIndex: { configurable: !0 }, numHorizontalGlyphVertices: { configurable: !0 }, numVerticalGlyphVertices: { configurable: !0 }, numIconVertices: { configurable: !0 }, numVerticalIconVertices: { configurable: !0 }, useRuntimeCollisionCircles: { configurable: !0 }, crossTileID: { configurable: !0 }, textBoxScale: { configurable: !0 }, textOffset0: { configurable: !0 }, textOffset1: { configurable: !0 }, collisionCircleDiameter: { configurable: !0 } };
          return p.anchorX.get = function() {
            return this._structArray.int16[this._pos2 + 0];
          }, p.anchorY.get = function() {
            return this._structArray.int16[this._pos2 + 1];
          }, p.rightJustifiedTextSymbolIndex.get = function() {
            return this._structArray.int16[this._pos2 + 2];
          }, p.centerJustifiedTextSymbolIndex.get = function() {
            return this._structArray.int16[this._pos2 + 3];
          }, p.leftJustifiedTextSymbolIndex.get = function() {
            return this._structArray.int16[this._pos2 + 4];
          }, p.verticalPlacedTextSymbolIndex.get = function() {
            return this._structArray.int16[this._pos2 + 5];
          }, p.placedIconSymbolIndex.get = function() {
            return this._structArray.int16[this._pos2 + 6];
          }, p.verticalPlacedIconSymbolIndex.get = function() {
            return this._structArray.int16[this._pos2 + 7];
          }, p.key.get = function() {
            return this._structArray.uint16[this._pos2 + 8];
          }, p.textBoxStartIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 9];
          }, p.textBoxEndIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 10];
          }, p.verticalTextBoxStartIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 11];
          }, p.verticalTextBoxEndIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 12];
          }, p.iconBoxStartIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 13];
          }, p.iconBoxEndIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 14];
          }, p.verticalIconBoxStartIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 15];
          }, p.verticalIconBoxEndIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 16];
          }, p.featureIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 17];
          }, p.numHorizontalGlyphVertices.get = function() {
            return this._structArray.uint16[this._pos2 + 18];
          }, p.numVerticalGlyphVertices.get = function() {
            return this._structArray.uint16[this._pos2 + 19];
          }, p.numIconVertices.get = function() {
            return this._structArray.uint16[this._pos2 + 20];
          }, p.numVerticalIconVertices.get = function() {
            return this._structArray.uint16[this._pos2 + 21];
          }, p.useRuntimeCollisionCircles.get = function() {
            return this._structArray.uint16[this._pos2 + 22];
          }, p.crossTileID.get = function() {
            return this._structArray.uint32[this._pos4 + 12];
          }, p.crossTileID.set = function(x) {
            this._structArray.uint32[this._pos4 + 12] = x;
          }, p.textBoxScale.get = function() {
            return this._structArray.float32[this._pos4 + 13];
          }, p.textOffset0.get = function() {
            return this._structArray.float32[this._pos4 + 14];
          }, p.textOffset1.get = function() {
            return this._structArray.float32[this._pos4 + 15];
          }, p.collisionCircleDiameter.get = function() {
            return this._structArray.float32[this._pos4 + 16];
          }, Object.defineProperties(c.prototype, p), c;
        })(Sc);
        R.prototype.size = 68;
        var D = (function(a) {
          function c() {
            a.apply(this, arguments);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype.get = function(p) {
            return new R(this, p);
          }, c;
        })(Ur);
        ur("SymbolInstanceArray", D);
        var k = (function(a) {
          function c() {
            a.apply(this, arguments);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype.getoffsetX = function(p) {
            return this.float32[1 * p + 0];
          }, c;
        })(Ii);
        ur("GlyphOffsetArray", k);
        var H = (function(a) {
          function c() {
            a.apply(this, arguments);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype.getx = function(p) {
            return this.int16[3 * p + 0];
          }, c.prototype.gety = function(p) {
            return this.int16[3 * p + 1];
          }, c.prototype.gettileUnitDistanceFromAnchor = function(p) {
            return this.int16[3 * p + 2];
          }, c;
        })(Er);
        ur("SymbolLineVertexArray", H);
        var J = (function(a) {
          function c() {
            a.apply(this, arguments);
          }
          a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c;
          var p = { featureIndex: { configurable: !0 }, sourceLayerIndex: { configurable: !0 }, bucketIndex: { configurable: !0 } };
          return p.featureIndex.get = function() {
            return this._structArray.uint32[this._pos4 + 0];
          }, p.sourceLayerIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 2];
          }, p.bucketIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 3];
          }, Object.defineProperties(c.prototype, p), c;
        })(Sc);
        J.prototype.size = 8;
        var oe = (function(a) {
          function c() {
            a.apply(this, arguments);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype.get = function(p) {
            return new J(this, p);
          }, c;
        })(Vi);
        ur("FeatureIndexArray", oe);
        var Ce = zi([{ name: "a_pos", components: 2, type: "Int16" }], 4).members, Se = function(a) {
          a === void 0 && (a = []), this.segments = a;
        };
        function Oe(a, c) {
          return 256 * (a = q(Math.floor(a), 0, 255)) + q(Math.floor(c), 0, 255);
        }
        Se.prototype.prepareSegment = function(a, c, p, x) {
          var S = this.segments[this.segments.length - 1];
          return a > Se.MAX_VERTEX_ARRAY_LENGTH && re("Max vertices per segment is " + Se.MAX_VERTEX_ARRAY_LENGTH + ": bucket requested " + a), (!S || S.vertexLength + a > Se.MAX_VERTEX_ARRAY_LENGTH || S.sortKey !== x) && (S = { vertexOffset: c.length, primitiveOffset: p.length, vertexLength: 0, primitiveLength: 0 }, x !== void 0 && (S.sortKey = x), this.segments.push(S)), S;
        }, Se.prototype.get = function() {
          return this.segments;
        }, Se.prototype.destroy = function() {
          for (var a = 0, c = this.segments; a < c.length; a += 1) {
            var p = c[a];
            for (var x in p.vaos) p.vaos[x].destroy();
          }
        }, Se.simpleSegment = function(a, c, p, x) {
          return new Se([{ vertexOffset: a, primitiveOffset: c, vertexLength: p, primitiveLength: x, vaos: {}, sortKey: 0 }]);
        }, Se.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, ur("SegmentVector", Se);
        var He = zi([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]), ze = l((function(a) {
          a.exports = function(c, p) {
            var x, S, M, O, N, G, Z, te;
            for (S = c.length - (x = 3 & c.length), M = p, N = 3432918353, G = 461845907, te = 0; te < S; ) Z = 255 & c.charCodeAt(te) | (255 & c.charCodeAt(++te)) << 8 | (255 & c.charCodeAt(++te)) << 16 | (255 & c.charCodeAt(++te)) << 24, ++te, M = 27492 + (65535 & (O = 5 * (65535 & (M = (M ^= Z = (65535 & (Z = (Z = (65535 & Z) * N + (((Z >>> 16) * N & 65535) << 16) & 4294967295) << 15 | Z >>> 17)) * G + (((Z >>> 16) * G & 65535) << 16) & 4294967295) << 13 | M >>> 19)) + ((5 * (M >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (O >>> 16) & 65535) << 16);
            switch (Z = 0, x) {
              case 3:
                Z ^= (255 & c.charCodeAt(te + 2)) << 16;
              case 2:
                Z ^= (255 & c.charCodeAt(te + 1)) << 8;
              case 1:
                M ^= Z = (65535 & (Z = (Z = (65535 & (Z ^= 255 & c.charCodeAt(te))) * N + (((Z >>> 16) * N & 65535) << 16) & 4294967295) << 15 | Z >>> 17)) * G + (((Z >>> 16) * G & 65535) << 16) & 4294967295;
            }
            return M ^= c.length, M = 2246822507 * (65535 & (M ^= M >>> 16)) + ((2246822507 * (M >>> 16) & 65535) << 16) & 4294967295, M = 3266489909 * (65535 & (M ^= M >>> 13)) + ((3266489909 * (M >>> 16) & 65535) << 16) & 4294967295, (M ^= M >>> 16) >>> 0;
          };
        })), h = l((function(a) {
          a.exports = function(c, p) {
            for (var x, S = c.length, M = p ^ S, O = 0; S >= 4; ) x = 1540483477 * (65535 & (x = 255 & c.charCodeAt(O) | (255 & c.charCodeAt(++O)) << 8 | (255 & c.charCodeAt(++O)) << 16 | (255 & c.charCodeAt(++O)) << 24)) + ((1540483477 * (x >>> 16) & 65535) << 16), M = 1540483477 * (65535 & M) + ((1540483477 * (M >>> 16) & 65535) << 16) ^ (x = 1540483477 * (65535 & (x ^= x >>> 24)) + ((1540483477 * (x >>> 16) & 65535) << 16)), S -= 4, ++O;
            switch (S) {
              case 3:
                M ^= (255 & c.charCodeAt(O + 2)) << 16;
              case 2:
                M ^= (255 & c.charCodeAt(O + 1)) << 8;
              case 1:
                M = 1540483477 * (65535 & (M ^= 255 & c.charCodeAt(O))) + ((1540483477 * (M >>> 16) & 65535) << 16);
            }
            return M = 1540483477 * (65535 & (M ^= M >>> 13)) + ((1540483477 * (M >>> 16) & 65535) << 16), (M ^= M >>> 15) >>> 0;
          };
        })), f = ze, A = h;
        f.murmur3 = ze, f.murmur2 = A;
        var b = function() {
          this.ids = [], this.positions = [], this.indexed = !1;
        };
        b.prototype.add = function(a, c, p, x) {
          this.ids.push(C(a)), this.positions.push(c, p, x);
        }, b.prototype.getPositions = function(a) {
          for (var c = C(a), p = 0, x = this.ids.length - 1; p < x; ) {
            var S = p + x >> 1;
            this.ids[S] >= c ? x = S : p = S + 1;
          }
          for (var M = []; this.ids[p] === c; ) M.push({ index: this.positions[3 * p], start: this.positions[3 * p + 1], end: this.positions[3 * p + 2] }), p++;
          return M;
        }, b.serialize = function(a, c) {
          var p = new Float64Array(a.ids), x = new Uint32Array(a.positions);
          return (function S(M, O, N, G) {
            for (; N < G; ) {
              for (var Z = M[N + G >> 1], te = N - 1, se = G + 1; ; ) {
                do
                  te++;
                while (M[te] < Z);
                do
                  se--;
                while (M[se] > Z);
                if (te >= se) break;
                I(M, te, se), I(O, 3 * te, 3 * se), I(O, 3 * te + 1, 3 * se + 1), I(O, 3 * te + 2, 3 * se + 2);
              }
              se - N < G - se ? (S(M, O, N, se), N = se + 1) : (S(M, O, se + 1, G), G = se);
            }
          })(p, x, 0, p.length - 1), c && c.push(p.buffer, x.buffer), { ids: p, positions: x };
        }, b.deserialize = function(a) {
          var c = new b();
          return c.ids = a.ids, c.positions = a.positions, c.indexed = !0, c;
        };
        var T = Math.pow(2, 53) - 1;
        function C(a) {
          var c = +a;
          return !isNaN(c) && c <= T ? c : f(String(a));
        }
        function I(a, c, p) {
          var x = a[c];
          a[c] = a[p], a[p] = x;
        }
        ur("FeaturePositionMap", b);
        var B = function(a, c) {
          this.gl = a.gl, this.location = c;
        }, F = (function(a) {
          function c(p, x) {
            a.call(this, p, x), this.current = 0;
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype.set = function(p) {
            this.current !== p && (this.current = p, this.gl.uniform1i(this.location, p));
          }, c;
        })(B), z = (function(a) {
          function c(p, x) {
            a.call(this, p, x), this.current = 0;
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype.set = function(p) {
            this.current !== p && (this.current = p, this.gl.uniform1f(this.location, p));
          }, c;
        })(B), W = (function(a) {
          function c(p, x) {
            a.call(this, p, x), this.current = [0, 0];
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype.set = function(p) {
            p[0] === this.current[0] && p[1] === this.current[1] || (this.current = p, this.gl.uniform2f(this.location, p[0], p[1]));
          }, c;
        })(B), ue = (function(a) {
          function c(p, x) {
            a.call(this, p, x), this.current = [0, 0, 0];
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype.set = function(p) {
            p[0] === this.current[0] && p[1] === this.current[1] && p[2] === this.current[2] || (this.current = p, this.gl.uniform3f(this.location, p[0], p[1], p[2]));
          }, c;
        })(B), Ie = (function(a) {
          function c(p, x) {
            a.call(this, p, x), this.current = [0, 0, 0, 0];
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype.set = function(p) {
            p[0] === this.current[0] && p[1] === this.current[1] && p[2] === this.current[2] && p[3] === this.current[3] || (this.current = p, this.gl.uniform4f(this.location, p[0], p[1], p[2], p[3]));
          }, c;
        })(B), Re = (function(a) {
          function c(p, x) {
            a.call(this, p, x), this.current = sn.transparent;
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype.set = function(p) {
            p.r === this.current.r && p.g === this.current.g && p.b === this.current.b && p.a === this.current.a || (this.current = p, this.gl.uniform4f(this.location, p.r, p.g, p.b, p.a));
          }, c;
        })(B), Be = new Float32Array(16), Ze = (function(a) {
          function c(p, x) {
            a.call(this, p, x), this.current = Be;
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype.set = function(p) {
            if (p[12] !== this.current[12] || p[0] !== this.current[0]) return this.current = p, void this.gl.uniformMatrix4fv(this.location, !1, p);
            for (var x = 1; x < 16; x++) if (p[x] !== this.current[x]) {
              this.current = p, this.gl.uniformMatrix4fv(this.location, !1, p);
              break;
            }
          }, c;
        })(B);
        function We(a) {
          return [Oe(255 * a.r, 255 * a.g), Oe(255 * a.b, 255 * a.a)];
        }
        var rt = function(a, c, p) {
          this.value = a, this.uniformNames = c.map((function(x) {
            return "u_" + x;
          })), this.type = p;
        };
        rt.prototype.setUniform = function(a, c, p) {
          a.set(p.constantOr(this.value));
        }, rt.prototype.getBinding = function(a, c, p) {
          return this.type === "color" ? new Re(a, c) : new z(a, c);
        };
        var et = function(a, c) {
          this.uniformNames = c.map((function(p) {
            return "u_" + p;
          })), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
        };
        et.prototype.setConstantPatternPositions = function(a, c) {
          this.pixelRatioFrom = c.pixelRatio, this.pixelRatioTo = a.pixelRatio, this.patternFrom = c.tlbr, this.patternTo = a.tlbr;
        }, et.prototype.setUniform = function(a, c, p, x) {
          var S = x === "u_pattern_to" ? this.patternTo : x === "u_pattern_from" ? this.patternFrom : x === "u_pixel_ratio_to" ? this.pixelRatioTo : x === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
          S && a.set(S);
        }, et.prototype.getBinding = function(a, c, p) {
          return p.substr(0, 9) === "u_pattern" ? new Ie(a, c) : new z(a, c);
        };
        var Je = function(a, c, p, x) {
          this.expression = a, this.type = p, this.maxValue = 0, this.paintVertexAttributes = c.map((function(S) {
            return { name: "a_" + S, type: "Float32", components: p === "color" ? 2 : 1, offset: 0 };
          })), this.paintVertexArray = new x();
        };
        Je.prototype.populatePaintArray = function(a, c, p, x, S) {
          var M = this.paintVertexArray.length, O = this.expression.evaluate(new cn(0), c, {}, x, [], S);
          this.paintVertexArray.resize(a), this._setPaintValue(M, a, O);
        }, Je.prototype.updatePaintArray = function(a, c, p, x) {
          var S = this.expression.evaluate({ zoom: 0 }, p, x);
          this._setPaintValue(a, c, S);
        }, Je.prototype._setPaintValue = function(a, c, p) {
          if (this.type === "color") for (var x = We(p), S = a; S < c; S++) this.paintVertexArray.emplace(S, x[0], x[1]);
          else {
            for (var M = a; M < c; M++) this.paintVertexArray.emplace(M, p);
            this.maxValue = Math.max(this.maxValue, Math.abs(p));
          }
        }, Je.prototype.upload = function(a) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = a.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }, Je.prototype.destroy = function() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        };
        var $e = function(a, c, p, x, S, M) {
          this.expression = a, this.uniformNames = c.map((function(O) {
            return "u_" + O + "_t";
          })), this.type = p, this.useIntegerZoom = x, this.zoom = S, this.maxValue = 0, this.paintVertexAttributes = c.map((function(O) {
            return { name: "a_" + O, type: "Float32", components: p === "color" ? 4 : 2, offset: 0 };
          })), this.paintVertexArray = new M();
        };
        $e.prototype.populatePaintArray = function(a, c, p, x, S) {
          var M = this.expression.evaluate(new cn(this.zoom), c, {}, x, [], S), O = this.expression.evaluate(new cn(this.zoom + 1), c, {}, x, [], S), N = this.paintVertexArray.length;
          this.paintVertexArray.resize(a), this._setPaintValue(N, a, M, O);
        }, $e.prototype.updatePaintArray = function(a, c, p, x) {
          var S = this.expression.evaluate({ zoom: this.zoom }, p, x), M = this.expression.evaluate({ zoom: this.zoom + 1 }, p, x);
          this._setPaintValue(a, c, S, M);
        }, $e.prototype._setPaintValue = function(a, c, p, x) {
          if (this.type === "color") for (var S = We(p), M = We(x), O = a; O < c; O++) this.paintVertexArray.emplace(O, S[0], S[1], M[0], M[1]);
          else {
            for (var N = a; N < c; N++) this.paintVertexArray.emplace(N, p, x);
            this.maxValue = Math.max(this.maxValue, Math.abs(p), Math.abs(x));
          }
        }, $e.prototype.upload = function(a) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = a.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }, $e.prototype.destroy = function() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }, $e.prototype.setUniform = function(a, c) {
          var p = this.useIntegerZoom ? Math.floor(c.zoom) : c.zoom, x = q(this.expression.interpolationFactor(p, this.zoom, this.zoom + 1), 0, 1);
          a.set(x);
        }, $e.prototype.getBinding = function(a, c, p) {
          return new z(a, c);
        };
        var Bt = function(a, c, p, x, S, M) {
          this.expression = a, this.type = c, this.useIntegerZoom = p, this.zoom = x, this.layerId = M, this.zoomInPaintVertexArray = new S(), this.zoomOutPaintVertexArray = new S();
        };
        Bt.prototype.populatePaintArray = function(a, c, p) {
          var x = this.zoomInPaintVertexArray.length;
          this.zoomInPaintVertexArray.resize(a), this.zoomOutPaintVertexArray.resize(a), this._setPaintValues(x, a, c.patterns && c.patterns[this.layerId], p);
        }, Bt.prototype.updatePaintArray = function(a, c, p, x, S) {
          this._setPaintValues(a, c, p.patterns && p.patterns[this.layerId], S);
        }, Bt.prototype._setPaintValues = function(a, c, p, x) {
          if (x && p) {
            var S = x[p.min], M = x[p.mid], O = x[p.max];
            if (S && M && O) for (var N = a; N < c; N++) this.zoomInPaintVertexArray.emplace(N, M.tl[0], M.tl[1], M.br[0], M.br[1], S.tl[0], S.tl[1], S.br[0], S.br[1], M.pixelRatio, S.pixelRatio), this.zoomOutPaintVertexArray.emplace(N, M.tl[0], M.tl[1], M.br[0], M.br[1], O.tl[0], O.tl[1], O.br[0], O.br[1], M.pixelRatio, O.pixelRatio);
          }
        }, Bt.prototype.upload = function(a) {
          this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = a.createVertexBuffer(this.zoomInPaintVertexArray, He.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = a.createVertexBuffer(this.zoomOutPaintVertexArray, He.members, this.expression.isStateDependent));
        }, Bt.prototype.destroy = function() {
          this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
        };
        var Ht = function(a, c, p) {
          this.binders = {}, this._buffers = [];
          var x = [];
          for (var S in a.paint._values) if (p(S)) {
            var M = a.paint.get(S);
            if (M instanceof cs && na(M.property.specification)) {
              var O = Or(S, a.type), N = M.value, G = M.property.specification.type, Z = M.property.useIntegerZoom, te = M.property.specification["property-type"], se = te === "cross-faded" || te === "cross-faded-data-driven";
              if (N.kind === "constant") this.binders[S] = se ? new et(N.value, O) : new rt(N.value, O, G), x.push("/u_" + S);
              else if (N.kind === "source" || se) {
                var he = Cr(S, G, "source");
                this.binders[S] = se ? new Bt(N, G, Z, c, he, a.id) : new Je(N, O, G, he), x.push("/a_" + S);
              } else {
                var xe = Cr(S, G, "composite");
                this.binders[S] = new $e(N, O, G, Z, c, xe), x.push("/z_" + S);
              }
            }
          }
          this.cacheKey = x.sort().join("");
        };
        Ht.prototype.getMaxValue = function(a) {
          var c = this.binders[a];
          return c instanceof Je || c instanceof $e ? c.maxValue : 0;
        }, Ht.prototype.populatePaintArrays = function(a, c, p, x, S) {
          for (var M in this.binders) {
            var O = this.binders[M];
            (O instanceof Je || O instanceof $e || O instanceof Bt) && O.populatePaintArray(a, c, p, x, S);
          }
        }, Ht.prototype.setConstantPatternPositions = function(a, c) {
          for (var p in this.binders) {
            var x = this.binders[p];
            x instanceof et && x.setConstantPatternPositions(a, c);
          }
        }, Ht.prototype.updatePaintArrays = function(a, c, p, x, S) {
          var M = !1;
          for (var O in a) for (var N = 0, G = c.getPositions(O); N < G.length; N += 1) {
            var Z = G[N], te = p.feature(Z.index);
            for (var se in this.binders) {
              var he = this.binders[se];
              if ((he instanceof Je || he instanceof $e || he instanceof Bt) && he.expression.isStateDependent === !0) {
                var xe = x.paint.get(se);
                he.expression = xe.value, he.updatePaintArray(Z.start, Z.end, te, a[O], S), M = !0;
              }
            }
          }
          return M;
        }, Ht.prototype.defines = function() {
          var a = [];
          for (var c in this.binders) {
            var p = this.binders[c];
            (p instanceof rt || p instanceof et) && a.push.apply(a, p.uniformNames.map((function(x) {
              return "#define HAS_UNIFORM_" + x;
            })));
          }
          return a;
        }, Ht.prototype.getBinderAttributes = function() {
          var a = [];
          for (var c in this.binders) {
            var p = this.binders[c];
            if (p instanceof Je || p instanceof $e) for (var x = 0; x < p.paintVertexAttributes.length; x++) a.push(p.paintVertexAttributes[x].name);
            else if (p instanceof Bt) for (var S = 0; S < He.members.length; S++) a.push(He.members[S].name);
          }
          return a;
        }, Ht.prototype.getBinderUniforms = function() {
          var a = [];
          for (var c in this.binders) {
            var p = this.binders[c];
            if (p instanceof rt || p instanceof et || p instanceof $e) for (var x = 0, S = p.uniformNames; x < S.length; x += 1) a.push(S[x]);
          }
          return a;
        }, Ht.prototype.getPaintVertexBuffers = function() {
          return this._buffers;
        }, Ht.prototype.getUniforms = function(a, c) {
          var p = [];
          for (var x in this.binders) {
            var S = this.binders[x];
            if (S instanceof rt || S instanceof et || S instanceof $e) for (var M = 0, O = S.uniformNames; M < O.length; M += 1) {
              var N = O[M];
              if (c[N]) {
                var G = S.getBinding(a, c[N], N);
                p.push({ name: N, property: x, binding: G });
              }
            }
          }
          return p;
        }, Ht.prototype.setUniforms = function(a, c, p, x) {
          for (var S = 0, M = c; S < M.length; S += 1) {
            var O = M[S], N = O.name, G = O.property;
            this.binders[G].setUniform(O.binding, x, p.get(G), N);
          }
        }, Ht.prototype.updatePaintBuffers = function(a) {
          for (var c in this._buffers = [], this.binders) {
            var p = this.binders[c];
            if (a && p instanceof Bt) {
              var x = a.fromScale === 2 ? p.zoomInPaintVertexBuffer : p.zoomOutPaintVertexBuffer;
              x && this._buffers.push(x);
            } else (p instanceof Je || p instanceof $e) && p.paintVertexBuffer && this._buffers.push(p.paintVertexBuffer);
          }
        }, Ht.prototype.upload = function(a) {
          for (var c in this.binders) {
            var p = this.binders[c];
            (p instanceof Je || p instanceof $e || p instanceof Bt) && p.upload(a);
          }
          this.updatePaintBuffers();
        }, Ht.prototype.destroy = function() {
          for (var a in this.binders) {
            var c = this.binders[a];
            (c instanceof Je || c instanceof $e || c instanceof Bt) && c.destroy();
          }
        };
        var Ut = function(a, c, p) {
          p === void 0 && (p = function() {
            return !0;
          }), this.programConfigurations = {};
          for (var x = 0, S = a; x < S.length; x += 1) {
            var M = S[x];
            this.programConfigurations[M.id] = new Ht(M, c, p);
          }
          this.needsUpload = !1, this._featureMap = new b(), this._bufferOffset = 0;
        };
        function Or(a, c) {
          return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[a] || [a.replace(c + "-", "").replace(/-/g, "_")];
        }
        function Cr(a, c, p) {
          var x = { color: { source: Fl, composite: Mo }, number: { source: Ii, composite: Fl } }, S = (function(M) {
            return { "line-pattern": { source: Po, composite: Po }, "fill-pattern": { source: Po, composite: Po }, "fill-extrusion-pattern": { source: Po, composite: Po } }[M];
          })(a);
          return S && S[p] || x[c][p];
        }
        Ut.prototype.populatePaintArrays = function(a, c, p, x, S, M) {
          for (var O in this.programConfigurations) this.programConfigurations[O].populatePaintArrays(a, c, x, S, M);
          c.id !== void 0 && this._featureMap.add(c.id, p, this._bufferOffset, a), this._bufferOffset = a, this.needsUpload = !0;
        }, Ut.prototype.updatePaintArrays = function(a, c, p, x) {
          for (var S = 0, M = p; S < M.length; S += 1) {
            var O = M[S];
            this.needsUpload = this.programConfigurations[O.id].updatePaintArrays(a, this._featureMap, c, O, x) || this.needsUpload;
          }
        }, Ut.prototype.get = function(a) {
          return this.programConfigurations[a];
        }, Ut.prototype.upload = function(a) {
          if (this.needsUpload) {
            for (var c in this.programConfigurations) this.programConfigurations[c].upload(a);
            this.needsUpload = !1;
          }
        }, Ut.prototype.destroy = function() {
          for (var a in this.programConfigurations) this.programConfigurations[a].destroy();
        }, ur("ConstantBinder", rt), ur("CrossFadedConstantBinder", et), ur("SourceExpressionBinder", Je), ur("CrossFadedCompositeBinder", Bt), ur("CompositeExpressionBinder", $e), ur("ProgramConfiguration", Ht, { omit: ["_buffers"] }), ur("ProgramConfigurationSet", Ut);
        var Gr = Math.pow(2, 14) - 1, Sr = -Gr - 1;
        function ar(a) {
          for (var c = 8192 / a.extent, p = a.loadGeometry(), x = 0; x < p.length; x++) for (var S = p[x], M = 0; M < S.length; M++) {
            var O = S[M], N = Math.round(O.x * c), G = Math.round(O.y * c);
            O.x = q(N, Sr, Gr), O.y = q(G, Sr, Gr), (N < O.x || N > O.x + 1 || G < O.y || G > O.y + 1) && re("Geometry exceeds allowed extent, reduce your vector tile buffer size");
          }
          return p;
        }
        function jt(a, c) {
          return { type: a.type, id: a.id, properties: a.properties, geometry: c ? ar(a) : [] };
        }
        function Wr(a, c, p, x, S) {
          a.emplaceBack(2 * c + (x + 1) / 2, 2 * p + (S + 1) / 2);
        }
        var fn = function(a) {
          this.zoom = a.zoom, this.overscaling = a.overscaling, this.layers = a.layers, this.layerIds = this.layers.map((function(c) {
            return c.id;
          })), this.index = a.index, this.hasPattern = !1, this.layoutVertexArray = new Io(), this.indexArray = new xs(), this.segments = new Se(), this.programConfigurations = new Ut(a.layers, a.zoom), this.stateDependentLayerIds = this.layers.filter((function(c) {
            return c.isStateDependent();
          })).map((function(c) {
            return c.id;
          }));
        };
        function Zr(a, c) {
          for (var p = 0; p < a.length; p++) if (Ca(c, a[p])) return !0;
          for (var x = 0; x < c.length; x++) if (Ca(a, c[x])) return !0;
          return !!wf(a, c);
        }
        function _n(a, c, p) {
          return !!Ca(a, c) || !!Vl(c, a, p);
        }
        function si(a, c) {
          if (a.length === 1) return Tf(c, a[0]);
          for (var p = 0; p < c.length; p++) for (var x = c[p], S = 0; S < x.length; S++) if (Ca(a, x[S])) return !0;
          for (var M = 0; M < a.length; M++) if (Tf(c, a[M])) return !0;
          for (var O = 0; O < c.length; O++) if (wf(a, c[O])) return !0;
          return !1;
        }
        function Ys(a, c, p) {
          if (a.length > 1) {
            if (wf(a, c)) return !0;
            for (var x = 0; x < c.length; x++) if (Vl(c[x], a, p)) return !0;
          }
          for (var S = 0; S < a.length; S++) if (Vl(a[S], c, p)) return !0;
          return !1;
        }
        function wf(a, c) {
          if (a.length === 0 || c.length === 0) return !1;
          for (var p = 0; p < a.length - 1; p++) for (var x = a[p], S = a[p + 1], M = 0; M < c.length - 1; M++) if (Cu(x, S, c[M], c[M + 1])) return !0;
          return !1;
        }
        function Cu(a, c, p, x) {
          return Me(a, p, x) !== Me(c, p, x) && Me(a, c, p) !== Me(a, c, x);
        }
        function Vl(a, c, p) {
          var x = p * p;
          if (c.length === 1) return a.distSqr(c[0]) < x;
          for (var S = 1; S < c.length; S++) if (Su(a, c[S - 1], c[S]) < x) return !0;
          return !1;
        }
        function Su(a, c, p) {
          var x = c.distSqr(p);
          if (x === 0) return a.distSqr(c);
          var S = ((a.x - c.x) * (p.x - c.x) + (a.y - c.y) * (p.y - c.y)) / x;
          return a.distSqr(S < 0 ? c : S > 1 ? p : p.sub(c)._mult(S)._add(c));
        }
        function Tf(a, c) {
          for (var p, x, S, M = !1, O = 0; O < a.length; O++) for (var N = 0, G = (p = a[O]).length - 1; N < p.length; G = N++) (x = p[N]).y > c.y != (S = p[G]).y > c.y && c.x < (S.x - x.x) * (c.y - x.y) / (S.y - x.y) + x.x && (M = !M);
          return M;
        }
        function Ca(a, c) {
          for (var p = !1, x = 0, S = a.length - 1; x < a.length; S = x++) {
            var M = a[x], O = a[S];
            M.y > c.y != O.y > c.y && c.x < (O.x - M.x) * (c.y - M.y) / (O.y - M.y) + M.x && (p = !p);
          }
          return p;
        }
        function Ef(a, c, p) {
          var x = p[0], S = p[2];
          if (a.x < x.x && c.x < x.x || a.x > S.x && c.x > S.x || a.y < x.y && c.y < x.y || a.y > S.y && c.y > S.y) return !1;
          var M = Me(a, c, p[0]);
          return M !== Me(a, c, p[1]) || M !== Me(a, c, p[2]) || M !== Me(a, c, p[3]);
        }
        function Sa(a, c, p) {
          var x = c.paint.get(a).value;
          return x.kind === "constant" ? x.value : p.programConfigurations.get(c.id).getMaxValue(a);
        }
        function Zi(a) {
          return Math.sqrt(a[0] * a[0] + a[1] * a[1]);
        }
        function Ja(a, c, p, x, S) {
          if (!c[0] && !c[1]) return a;
          var M = y.convert(c)._mult(S);
          p === "viewport" && M._rotate(-x);
          for (var O = [], N = 0; N < a.length; N++) O.push(a[N].sub(M));
          return O;
        }
        fn.prototype.populate = function(a, c, p) {
          var x = this.layers[0], S = [], M = null;
          x.type === "circle" && (M = x.layout.get("circle-sort-key"));
          for (var O = 0, N = a; O < N.length; O += 1) {
            var G = N[O], Z = G.feature, te = G.id, se = G.index, he = G.sourceLayerIndex, xe = this.layers[0]._featureFilter.needGeometry, Ve = jt(Z, xe);
            if (this.layers[0]._featureFilter.filter(new cn(this.zoom), Ve, p)) {
              var je = M ? M.evaluate(Ve, {}, p) : void 0, Qe = { id: te, properties: Z.properties, type: Z.type, sourceLayerIndex: he, index: se, geometry: xe ? Ve.geometry : ar(Z), patterns: {}, sortKey: je };
              S.push(Qe);
            }
          }
          M && S.sort((function(rr, Ir) {
            return rr.sortKey - Ir.sortKey;
          }));
          for (var Ye = 0, it = S; Ye < it.length; Ye += 1) {
            var pt = it[Ye], xt = pt.geometry, Tt = pt.index, Nt = pt.sourceLayerIndex, Kt = a[Tt].feature;
            this.addFeature(pt, xt, Tt, p), c.featureIndex.insert(Kt, xt, Tt, Nt, this.index);
          }
        }, fn.prototype.update = function(a, c, p) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(a, c, this.stateDependentLayers, p);
        }, fn.prototype.isEmpty = function() {
          return this.layoutVertexArray.length === 0;
        }, fn.prototype.uploadPending = function() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }, fn.prototype.upload = function(a) {
          this.uploaded || (this.layoutVertexBuffer = a.createVertexBuffer(this.layoutVertexArray, Ce), this.indexBuffer = a.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(a), this.uploaded = !0;
        }, fn.prototype.destroy = function() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }, fn.prototype.addFeature = function(a, c, p, x) {
          for (var S = 0, M = c; S < M.length; S += 1) for (var O = 0, N = M[S]; O < N.length; O += 1) {
            var G = N[O], Z = G.x, te = G.y;
            if (!(Z < 0 || Z >= 8192 || te < 0 || te >= 8192)) {
              var se = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, a.sortKey), he = se.vertexLength;
              Wr(this.layoutVertexArray, Z, te, -1, -1), Wr(this.layoutVertexArray, Z, te, 1, -1), Wr(this.layoutVertexArray, Z, te, 1, 1), Wr(this.layoutVertexArray, Z, te, -1, 1), this.indexArray.emplaceBack(he, he + 1, he + 2), this.indexArray.emplaceBack(he, he + 3, he + 2), se.vertexLength += 4, se.primitiveLength += 2;
            }
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, a, p, {}, x);
        }, ur("CircleBucket", fn, { omit: ["layers"] });
        var jl = new Xi({ "circle-sort-key": new Ar(le.layout_circle["circle-sort-key"]) }), Mc = { paint: new Xi({ "circle-radius": new Ar(le.paint_circle["circle-radius"]), "circle-color": new Ar(le.paint_circle["circle-color"]), "circle-blur": new Ar(le.paint_circle["circle-blur"]), "circle-opacity": new Ar(le.paint_circle["circle-opacity"]), "circle-translate": new Mr(le.paint_circle["circle-translate"]), "circle-translate-anchor": new Mr(le.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Mr(le.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Mr(le.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new Ar(le.paint_circle["circle-stroke-width"]), "circle-stroke-color": new Ar(le.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new Ar(le.paint_circle["circle-stroke-opacity"]) }), layout: jl }, Mn = typeof Float32Array < "u" ? Float32Array : Array;
        function Ro(a) {
          return a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = 1, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = 1, a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0, a[15] = 1, a;
        }
        function Ks(a, c, p) {
          var x = c[0], S = c[1], M = c[2], O = c[3], N = c[4], G = c[5], Z = c[6], te = c[7], se = c[8], he = c[9], xe = c[10], Ve = c[11], je = c[12], Qe = c[13], Ye = c[14], it = c[15], pt = p[0], xt = p[1], Tt = p[2], Nt = p[3];
          return a[0] = pt * x + xt * N + Tt * se + Nt * je, a[1] = pt * S + xt * G + Tt * he + Nt * Qe, a[2] = pt * M + xt * Z + Tt * xe + Nt * Ye, a[3] = pt * O + xt * te + Tt * Ve + Nt * it, a[4] = (pt = p[4]) * x + (xt = p[5]) * N + (Tt = p[6]) * se + (Nt = p[7]) * je, a[5] = pt * S + xt * G + Tt * he + Nt * Qe, a[6] = pt * M + xt * Z + Tt * xe + Nt * Ye, a[7] = pt * O + xt * te + Tt * Ve + Nt * it, a[8] = (pt = p[8]) * x + (xt = p[9]) * N + (Tt = p[10]) * se + (Nt = p[11]) * je, a[9] = pt * S + xt * G + Tt * he + Nt * Qe, a[10] = pt * M + xt * Z + Tt * xe + Nt * Ye, a[11] = pt * O + xt * te + Tt * Ve + Nt * it, a[12] = (pt = p[12]) * x + (xt = p[13]) * N + (Tt = p[14]) * se + (Nt = p[15]) * je, a[13] = pt * S + xt * G + Tt * he + Nt * Qe, a[14] = pt * M + xt * Z + Tt * xe + Nt * Ye, a[15] = pt * O + xt * te + Tt * Ve + Nt * it, a;
        }
        Math.hypot || (Math.hypot = function() {
          for (var a = arguments, c = 0, p = arguments.length; p--; ) c += a[p] * a[p];
          return Math.sqrt(c);
        });
        var Rc, Ry = Ks;
        function jh(a, c, p) {
          var x = c[0], S = c[1], M = c[2], O = c[3];
          return a[0] = p[0] * x + p[4] * S + p[8] * M + p[12] * O, a[1] = p[1] * x + p[5] * S + p[9] * M + p[13] * O, a[2] = p[2] * x + p[6] * S + p[10] * M + p[14] * O, a[3] = p[3] * x + p[7] * S + p[11] * M + p[15] * O, a;
        }
        Rc = new Mn(3), Mn != Float32Array && (Rc[0] = 0, Rc[1] = 0, Rc[2] = 0), (function() {
          var a = new Mn(4);
          Mn != Float32Array && (a[0] = 0, a[1] = 0, a[2] = 0, a[3] = 0);
        })();
        var By = ((function() {
          var a = new Mn(2);
          Mn != Float32Array && (a[0] = 0, a[1] = 0);
        })(), (function(a) {
          function c(p) {
            a.call(this, p, Mc);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype.createBucket = function(p) {
            return new fn(p);
          }, c.prototype.queryRadius = function(p) {
            var x = p;
            return Sa("circle-radius", this, x) + Sa("circle-stroke-width", this, x) + Zi(this.paint.get("circle-translate"));
          }, c.prototype.queryIntersectsFeature = function(p, x, S, M, O, N, G, Z) {
            for (var te = Ja(p, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), N.angle, G), se = this.paint.get("circle-radius").evaluate(x, S) + this.paint.get("circle-stroke-width").evaluate(x, S), he = this.paint.get("circle-pitch-alignment") === "map", xe = he ? te : (function(Kt, rr) {
              return Kt.map((function(Ir) {
                return Cf(Ir, rr);
              }));
            })(te, Z), Ve = he ? se * G : se, je = 0, Qe = M; je < Qe.length; je += 1) for (var Ye = 0, it = Qe[je]; Ye < it.length; Ye += 1) {
              var pt = it[Ye], xt = he ? pt : Cf(pt, Z), Tt = Ve, Nt = jh([], [pt.x, pt.y, 0, 1], Z);
              if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? Tt *= Nt[3] / N.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (Tt *= N.cameraToCenterDistance / Nt[3]), _n(xe, xt, Tt)) return !0;
            }
            return !1;
          }, c;
        })(Ho));
        function Cf(a, c) {
          var p = jh([], [a.x, a.y, 0, 1], c);
          return new y(p[0] / p[3], p[1] / p[3]);
        }
        var B0 = (function(a) {
          function c() {
            a.apply(this, arguments);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c;
        })(fn);
        function Iu(a, c, p, x) {
          var S = c.width, M = c.height;
          if (x) {
            if (x instanceof Uint8ClampedArray) x = new Uint8Array(x.buffer);
            else if (x.length !== S * M * p) throw new RangeError("mismatched image size");
          } else x = new Uint8Array(S * M * p);
          return a.width = S, a.height = M, a.data = x, a;
        }
        function Hh(a, c, p) {
          var x = c.width, S = c.height;
          if (x !== a.width || S !== a.height) {
            var M = Iu({}, { width: x, height: S }, p);
            Oy(a, M, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(a.width, x), height: Math.min(a.height, S) }, p), a.width = x, a.height = S, a.data = M.data;
          }
        }
        function Oy(a, c, p, x, S, M) {
          if (S.width === 0 || S.height === 0) return c;
          if (S.width > a.width || S.height > a.height || p.x > a.width - S.width || p.y > a.height - S.height) throw new RangeError("out of range source coordinates for image copy");
          if (S.width > c.width || S.height > c.height || x.x > c.width - S.width || x.y > c.height - S.height) throw new RangeError("out of range destination coordinates for image copy");
          for (var O = a.data, N = c.data, G = 0; G < S.height; G++) for (var Z = ((p.y + G) * a.width + p.x) * M, te = ((x.y + G) * c.width + x.x) * M, se = 0; se < S.width * M; se++) N[te + se] = O[Z + se];
          return c;
        }
        ur("HeatmapBucket", B0, { omit: ["layers"] });
        var Sf = function(a, c) {
          Iu(this, a, 1, c);
        };
        Sf.prototype.resize = function(a) {
          Hh(this, a, 1);
        }, Sf.prototype.clone = function() {
          return new Sf({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }, Sf.copy = function(a, c, p, x, S) {
          Oy(a, c, p, x, S, 1);
        };
        var uo = function(a, c) {
          Iu(this, a, 4, c);
        };
        uo.prototype.resize = function(a) {
          Hh(this, a, 4);
        }, uo.prototype.replace = function(a, c) {
          c ? this.data.set(a) : this.data = a instanceof Uint8ClampedArray ? new Uint8Array(a.buffer) : a;
        }, uo.prototype.clone = function() {
          return new uo({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }, uo.copy = function(a, c, p, x, S) {
          Oy(a, c, p, x, S, 4);
        }, ur("AlphaImage", Sf), ur("RGBAImage", uo);
        var XF = { paint: new Xi({ "heatmap-radius": new Ar(le.paint_heatmap["heatmap-radius"]), "heatmap-weight": new Ar(le.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Mr(le.paint_heatmap["heatmap-intensity"]), "heatmap-color": new So(le.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Mr(le.paint_heatmap["heatmap-opacity"]) }) };
        function jT(a) {
          var c = {}, p = a.resolution || 256, x = a.clips ? a.clips.length : 1, S = a.image || new uo({ width: p, height: x }), M = function(Ve, je, Qe) {
            c[a.evaluationKey] = Qe;
            var Ye = a.expression.evaluate(c);
            S.data[Ve + je + 0] = Math.floor(255 * Ye.r / Ye.a), S.data[Ve + je + 1] = Math.floor(255 * Ye.g / Ye.a), S.data[Ve + je + 2] = Math.floor(255 * Ye.b / Ye.a), S.data[Ve + je + 3] = Math.floor(255 * Ye.a);
          };
          if (a.clips) for (var O = 0, N = 0; O < x; ++O, N += 4 * p) for (var G = 0, Z = 0; G < p; G++, Z += 4) {
            var te = G / (p - 1), se = a.clips[O];
            M(N, Z, se.start * (1 - te) + se.end * te);
          }
          else for (var he = 0, xe = 0; he < p; he++, xe += 4) M(0, xe, he / (p - 1));
          return S;
        }
        var ZF = (function(a) {
          function c(p) {
            a.call(this, p, XF), this._updateColorRamp();
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype.createBucket = function(p) {
            return new B0(p);
          }, c.prototype._handleSpecialPaintPropertyUpdate = function(p) {
            p === "heatmap-color" && this._updateColorRamp();
          }, c.prototype._updateColorRamp = function() {
            this.colorRamp = jT({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
          }, c.prototype.resize = function() {
            this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
          }, c.prototype.queryRadius = function() {
            return 0;
          }, c.prototype.queryIntersectsFeature = function() {
            return !1;
          }, c.prototype.hasOffscreenPass = function() {
            return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
          }, c;
        })(Ho), YF = { paint: new Xi({ "hillshade-illumination-direction": new Mr(le.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new Mr(le.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Mr(le.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Mr(le.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Mr(le.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Mr(le.paint_hillshade["hillshade-accent-color"]) }) }, KF = (function(a) {
          function c(p) {
            a.call(this, p, YF);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype.hasOffscreenPass = function() {
            return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
          }, c;
        })(Ho), QF = zi([{ name: "a_pos", components: 2, type: "Int16" }], 4).members, Dy = O0, JF = O0;
        function O0(a, c, p) {
          p = p || 2;
          var x, S, M, O, N, G, Z, te = c && c.length, se = te ? c[0] * p : a.length, he = HT(a, 0, se, p, !0), xe = [];
          if (!he || he.next === he.prev) return xe;
          if (te && (he = (function(je, Qe, Ye, it) {
            var pt, xt, Tt, Nt = [];
            for (pt = 0, xt = Qe.length; pt < xt; pt++) (Tt = HT(je, Qe[pt] * it, pt < xt - 1 ? Qe[pt + 1] * it : je.length, it, !1)) === Tt.next && (Tt.steiner = !0), Nt.push(a8(Tt));
            for (Nt.sort(i8), pt = 0; pt < Nt.length; pt++) s8(Nt[pt], Ye), Ye = Pu(Ye, Ye.next);
            return Ye;
          })(a, c, he, p)), a.length > 80 * p) {
            x = M = a[0], S = O = a[1];
            for (var Ve = p; Ve < se; Ve += p) (N = a[Ve]) < x && (x = N), (G = a[Ve + 1]) < S && (S = G), N > M && (M = N), G > O && (O = G);
            Z = (Z = Math.max(M - x, O - S)) !== 0 ? 1 / Z : 0;
          }
          return $p(he, xe, p, x, S, Z), xe;
        }
        function HT(a, c, p, x, S) {
          var M, O;
          if (S === Fy(a, c, p, x) > 0) for (M = c; M < p; M += x) O = $T(M, a[M], a[M + 1], O);
          else for (M = p - x; M >= c; M -= x) O = $T(M, a[M], a[M + 1], O);
          return O && D0(O, O.next) && (Xp(O), O = O.next), O;
        }
        function Pu(a, c) {
          if (!a) return a;
          c || (c = a);
          var p, x = a;
          do
            if (p = !1, x.steiner || !D0(x, x.next) && ji(x.prev, x, x.next) !== 0) x = x.next;
            else {
              if (Xp(x), (x = c = x.prev) === x.next) break;
              p = !0;
            }
          while (p || x !== c);
          return c;
        }
        function $p(a, c, p, x, S, M, O) {
          if (a) {
            !O && M && (function(te, se, he, xe) {
              var Ve = te;
              do
                Ve.z === null && (Ve.z = Ly(Ve.x, Ve.y, se, he, xe)), Ve.prevZ = Ve.prev, Ve.nextZ = Ve.next, Ve = Ve.next;
              while (Ve !== te);
              Ve.prevZ.nextZ = null, Ve.prevZ = null, (function(je) {
                var Qe, Ye, it, pt, xt, Tt, Nt, Kt, rr = 1;
                do {
                  for (Ye = je, je = null, xt = null, Tt = 0; Ye; ) {
                    for (Tt++, it = Ye, Nt = 0, Qe = 0; Qe < rr && (Nt++, it = it.nextZ); Qe++) ;
                    for (Kt = rr; Nt > 0 || Kt > 0 && it; ) Nt !== 0 && (Kt === 0 || !it || Ye.z <= it.z) ? (pt = Ye, Ye = Ye.nextZ, Nt--) : (pt = it, it = it.nextZ, Kt--), xt ? xt.nextZ = pt : je = pt, pt.prevZ = xt, xt = pt;
                    Ye = it;
                  }
                  xt.nextZ = null, rr *= 2;
                } while (Tt > 1);
              })(Ve);
            })(a, x, S, M);
            for (var N, G, Z = a; a.prev !== a.next; ) if (N = a.prev, G = a.next, M ? t8(a, x, S, M) : e8(a)) c.push(N.i / p), c.push(a.i / p), c.push(G.i / p), Xp(a), a = G.next, Z = G.next;
            else if ((a = G) === Z) {
              O ? O === 1 ? $p(a = r8(Pu(a), c, p), c, p, x, S, M, 2) : O === 2 && n8(a, c, p, x, S, M) : $p(Pu(a), c, p, x, S, M, 1);
              break;
            }
          }
        }
        function e8(a) {
          var c = a.prev, p = a, x = a.next;
          if (ji(c, p, x) >= 0) return !1;
          for (var S = a.next.next; S !== a.prev; ) {
            if (Gh(c.x, c.y, p.x, p.y, x.x, x.y, S.x, S.y) && ji(S.prev, S, S.next) >= 0) return !1;
            S = S.next;
          }
          return !0;
        }
        function t8(a, c, p, x) {
          var S = a.prev, M = a, O = a.next;
          if (ji(S, M, O) >= 0) return !1;
          for (var N = S.x > M.x ? S.x > O.x ? S.x : O.x : M.x > O.x ? M.x : O.x, G = S.y > M.y ? S.y > O.y ? S.y : O.y : M.y > O.y ? M.y : O.y, Z = Ly(S.x < M.x ? S.x < O.x ? S.x : O.x : M.x < O.x ? M.x : O.x, S.y < M.y ? S.y < O.y ? S.y : O.y : M.y < O.y ? M.y : O.y, c, p, x), te = Ly(N, G, c, p, x), se = a.prevZ, he = a.nextZ; se && se.z >= Z && he && he.z <= te; ) {
            if (se !== a.prev && se !== a.next && Gh(S.x, S.y, M.x, M.y, O.x, O.y, se.x, se.y) && ji(se.prev, se, se.next) >= 0 || (se = se.prevZ, he !== a.prev && he !== a.next && Gh(S.x, S.y, M.x, M.y, O.x, O.y, he.x, he.y) && ji(he.prev, he, he.next) >= 0)) return !1;
            he = he.nextZ;
          }
          for (; se && se.z >= Z; ) {
            if (se !== a.prev && se !== a.next && Gh(S.x, S.y, M.x, M.y, O.x, O.y, se.x, se.y) && ji(se.prev, se, se.next) >= 0) return !1;
            se = se.prevZ;
          }
          for (; he && he.z <= te; ) {
            if (he !== a.prev && he !== a.next && Gh(S.x, S.y, M.x, M.y, O.x, O.y, he.x, he.y) && ji(he.prev, he, he.next) >= 0) return !1;
            he = he.nextZ;
          }
          return !0;
        }
        function r8(a, c, p) {
          var x = a;
          do {
            var S = x.prev, M = x.next.next;
            !D0(S, M) && GT(S, x, x.next, M) && qp(S, M) && qp(M, S) && (c.push(S.i / p), c.push(x.i / p), c.push(M.i / p), Xp(x), Xp(x.next), x = a = M), x = x.next;
          } while (x !== a);
          return Pu(x);
        }
        function n8(a, c, p, x, S, M) {
          var O = a;
          do {
            for (var N = O.next.next; N !== O.prev; ) {
              if (O.i !== N.i && l8(O, N)) {
                var G = WT(O, N);
                return O = Pu(O, O.next), G = Pu(G, G.next), $p(O, c, p, x, S, M), void $p(G, c, p, x, S, M);
              }
              N = N.next;
            }
            O = O.next;
          } while (O !== a);
        }
        function i8(a, c) {
          return a.x - c.x;
        }
        function s8(a, c) {
          if (c = (function(x, S) {
            var M, O = S, N = x.x, G = x.y, Z = -1 / 0;
            do {
              if (G <= O.y && G >= O.next.y && O.next.y !== O.y) {
                var te = O.x + (G - O.y) * (O.next.x - O.x) / (O.next.y - O.y);
                if (te <= N && te > Z) {
                  if (Z = te, te === N) {
                    if (G === O.y) return O;
                    if (G === O.next.y) return O.next;
                  }
                  M = O.x < O.next.x ? O : O.next;
                }
              }
              O = O.next;
            } while (O !== S);
            if (!M) return null;
            if (N === Z) return M;
            var se, he = M, xe = M.x, Ve = M.y, je = 1 / 0;
            O = M;
            do
              N >= O.x && O.x >= xe && N !== O.x && Gh(G < Ve ? N : Z, G, xe, Ve, G < Ve ? Z : N, G, O.x, O.y) && (se = Math.abs(G - O.y) / (N - O.x), qp(O, x) && (se < je || se === je && (O.x > M.x || O.x === M.x && o8(M, O))) && (M = O, je = se)), O = O.next;
            while (O !== he);
            return M;
          })(a, c)) {
            var p = WT(c, a);
            Pu(c, c.next), Pu(p, p.next);
          }
        }
        function o8(a, c) {
          return ji(a.prev, a, c.prev) < 0 && ji(c.next, a, a.next) < 0;
        }
        function Ly(a, c, p, x, S) {
          return (a = 1431655765 & ((a = 858993459 & ((a = 252645135 & ((a = 16711935 & ((a = 32767 * (a - p) * S) | a << 8)) | a << 4)) | a << 2)) | a << 1)) | (c = 1431655765 & ((c = 858993459 & ((c = 252645135 & ((c = 16711935 & ((c = 32767 * (c - x) * S) | c << 8)) | c << 4)) | c << 2)) | c << 1)) << 1;
        }
        function a8(a) {
          var c = a, p = a;
          do
            (c.x < p.x || c.x === p.x && c.y < p.y) && (p = c), c = c.next;
          while (c !== a);
          return p;
        }
        function Gh(a, c, p, x, S, M, O, N) {
          return (S - O) * (c - N) - (a - O) * (M - N) >= 0 && (a - O) * (x - N) - (p - O) * (c - N) >= 0 && (p - O) * (M - N) - (S - O) * (x - N) >= 0;
        }
        function l8(a, c) {
          return a.next.i !== c.i && a.prev.i !== c.i && !(function(p, x) {
            var S = p;
            do {
              if (S.i !== p.i && S.next.i !== p.i && S.i !== x.i && S.next.i !== x.i && GT(S, S.next, p, x)) return !0;
              S = S.next;
            } while (S !== p);
            return !1;
          })(a, c) && (qp(a, c) && qp(c, a) && (function(p, x) {
            var S = p, M = !1, O = (p.x + x.x) / 2, N = (p.y + x.y) / 2;
            do
              S.y > N != S.next.y > N && S.next.y !== S.y && O < (S.next.x - S.x) * (N - S.y) / (S.next.y - S.y) + S.x && (M = !M), S = S.next;
            while (S !== p);
            return M;
          })(a, c) && (ji(a.prev, a, c.prev) || ji(a, c.prev, c)) || D0(a, c) && ji(a.prev, a, a.next) > 0 && ji(c.prev, c, c.next) > 0);
        }
        function ji(a, c, p) {
          return (c.y - a.y) * (p.x - c.x) - (c.x - a.x) * (p.y - c.y);
        }
        function D0(a, c) {
          return a.x === c.x && a.y === c.y;
        }
        function GT(a, c, p, x) {
          var S = k0(ji(a, c, p)), M = k0(ji(a, c, x)), O = k0(ji(p, x, a)), N = k0(ji(p, x, c));
          return S !== M && O !== N || !(S !== 0 || !L0(a, p, c)) || !(M !== 0 || !L0(a, x, c)) || !(O !== 0 || !L0(p, a, x)) || !(N !== 0 || !L0(p, c, x));
        }
        function L0(a, c, p) {
          return c.x <= Math.max(a.x, p.x) && c.x >= Math.min(a.x, p.x) && c.y <= Math.max(a.y, p.y) && c.y >= Math.min(a.y, p.y);
        }
        function k0(a) {
          return a > 0 ? 1 : a < 0 ? -1 : 0;
        }
        function qp(a, c) {
          return ji(a.prev, a, a.next) < 0 ? ji(a, c, a.next) >= 0 && ji(a, a.prev, c) >= 0 : ji(a, c, a.prev) < 0 || ji(a, a.next, c) < 0;
        }
        function WT(a, c) {
          var p = new ky(a.i, a.x, a.y), x = new ky(c.i, c.x, c.y), S = a.next, M = c.prev;
          return a.next = c, c.prev = a, p.next = S, S.prev = p, x.next = p, p.prev = x, M.next = x, x.prev = M, x;
        }
        function $T(a, c, p, x) {
          var S = new ky(a, c, p);
          return x ? (S.next = x.next, S.prev = x, x.next.prev = S, x.next = S) : (S.prev = S, S.next = S), S;
        }
        function Xp(a) {
          a.next.prev = a.prev, a.prev.next = a.next, a.prevZ && (a.prevZ.nextZ = a.nextZ), a.nextZ && (a.nextZ.prevZ = a.prevZ);
        }
        function ky(a, c, p) {
          this.i = a, this.x = c, this.y = p, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1;
        }
        function Fy(a, c, p, x) {
          for (var S = 0, M = c, O = p - x; M < p; M += x) S += (a[O] - a[M]) * (a[M + 1] + a[O + 1]), O = M;
          return S;
        }
        function c8(a, c, p, x, S) {
          (function M(O, N, G, Z, te) {
            for (; Z > G; ) {
              if (Z - G > 600) {
                var se = Z - G + 1, he = N - G + 1, xe = Math.log(se), Ve = 0.5 * Math.exp(2 * xe / 3), je = 0.5 * Math.sqrt(xe * Ve * (se - Ve) / se) * (he - se / 2 < 0 ? -1 : 1);
                M(O, N, Math.max(G, Math.floor(N - he * Ve / se + je)), Math.min(Z, Math.floor(N + (se - he) * Ve / se + je)), te);
              }
              var Qe = O[N], Ye = G, it = Z;
              for (Zp(O, G, N), te(O[Z], Qe) > 0 && Zp(O, G, Z); Ye < it; ) {
                for (Zp(O, Ye, it), Ye++, it--; te(O[Ye], Qe) < 0; ) Ye++;
                for (; te(O[it], Qe) > 0; ) it--;
              }
              te(O[G], Qe) === 0 ? Zp(O, G, it) : Zp(O, ++it, Z), it <= N && (G = it + 1), N <= it && (Z = it - 1);
            }
          })(a, c, p, x || a.length - 1, S || u8);
        }
        function Zp(a, c, p) {
          var x = a[c];
          a[c] = a[p], a[p] = x;
        }
        function u8(a, c) {
          return a < c ? -1 : a > c ? 1 : 0;
        }
        function Ny(a, c) {
          var p = a.length;
          if (p <= 1) return [a];
          for (var x, S, M = [], O = 0; O < p; O++) {
            var N = ot(a[O]);
            N !== 0 && (a[O].area = Math.abs(N), S === void 0 && (S = N < 0), S === N < 0 ? (x && M.push(x), x = [a[O]]) : x.push(a[O]));
          }
          if (x && M.push(x), c > 1) for (var G = 0; G < M.length; G++) M[G].length <= c || (c8(M[G], c, 1, M[G].length - 1, f8), M[G] = M[G].slice(0, c));
          return M;
        }
        function f8(a, c) {
          return c.area - a.area;
        }
        function Uy(a, c, p) {
          for (var x = p.patternDependencies, S = !1, M = 0, O = c; M < O.length; M += 1) {
            var N = O[M].paint.get(a + "-pattern");
            N.isConstant() || (S = !0);
            var G = N.constantOr(null);
            G && (S = !0, x[G.to] = !0, x[G.from] = !0);
          }
          return S;
        }
        function zy(a, c, p, x, S) {
          for (var M = S.patternDependencies, O = 0, N = c; O < N.length; O += 1) {
            var G = N[O], Z = G.paint.get(a + "-pattern").value;
            if (Z.kind !== "constant") {
              var te = Z.evaluate({ zoom: x - 1 }, p, {}, S.availableImages), se = Z.evaluate({ zoom: x }, p, {}, S.availableImages), he = Z.evaluate({ zoom: x + 1 }, p, {}, S.availableImages);
              se = se && se.name ? se.name : se, he = he && he.name ? he.name : he, M[te = te && te.name ? te.name : te] = !0, M[se] = !0, M[he] = !0, p.patterns[G.id] = { min: te, mid: se, max: he };
            }
          }
          return p;
        }
        O0.deviation = function(a, c, p, x) {
          var S = c && c.length, M = Math.abs(Fy(a, 0, S ? c[0] * p : a.length, p));
          if (S) for (var O = 0, N = c.length; O < N; O++) M -= Math.abs(Fy(a, c[O] * p, O < N - 1 ? c[O + 1] * p : a.length, p));
          var G = 0;
          for (O = 0; O < x.length; O += 3) {
            var Z = x[O] * p, te = x[O + 1] * p, se = x[O + 2] * p;
            G += Math.abs((a[Z] - a[se]) * (a[te + 1] - a[Z + 1]) - (a[Z] - a[te]) * (a[se + 1] - a[Z + 1]));
          }
          return M === 0 && G === 0 ? 0 : Math.abs((G - M) / M);
        }, O0.flatten = function(a) {
          for (var c = a[0][0].length, p = { vertices: [], holes: [], dimensions: c }, x = 0, S = 0; S < a.length; S++) {
            for (var M = 0; M < a[S].length; M++) for (var O = 0; O < c; O++) p.vertices.push(a[S][M][O]);
            S > 0 && p.holes.push(x += a[S - 1].length);
          }
          return p;
        }, Dy.default = JF;
        var el = function(a) {
          this.zoom = a.zoom, this.overscaling = a.overscaling, this.layers = a.layers, this.layerIds = this.layers.map((function(c) {
            return c.id;
          })), this.index = a.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new Io(), this.indexArray = new xs(), this.indexArray2 = new zl(), this.programConfigurations = new Ut(a.layers, a.zoom), this.segments = new Se(), this.segments2 = new Se(), this.stateDependentLayerIds = this.layers.filter((function(c) {
            return c.isStateDependent();
          })).map((function(c) {
            return c.id;
          }));
        };
        el.prototype.populate = function(a, c, p) {
          this.hasPattern = Uy("fill", this.layers, c);
          for (var x = this.layers[0].layout.get("fill-sort-key"), S = [], M = 0, O = a; M < O.length; M += 1) {
            var N = O[M], G = N.feature, Z = N.id, te = N.index, se = N.sourceLayerIndex, he = this.layers[0]._featureFilter.needGeometry, xe = jt(G, he);
            if (this.layers[0]._featureFilter.filter(new cn(this.zoom), xe, p)) {
              var Ve = x ? x.evaluate(xe, {}, p, c.availableImages) : void 0, je = { id: Z, properties: G.properties, type: G.type, sourceLayerIndex: se, index: te, geometry: he ? xe.geometry : ar(G), patterns: {}, sortKey: Ve };
              S.push(je);
            }
          }
          x && S.sort((function(Kt, rr) {
            return Kt.sortKey - rr.sortKey;
          }));
          for (var Qe = 0, Ye = S; Qe < Ye.length; Qe += 1) {
            var it = Ye[Qe], pt = it.geometry, xt = it.index, Tt = it.sourceLayerIndex;
            if (this.hasPattern) {
              var Nt = zy("fill", this.layers, it, this.zoom, c);
              this.patternFeatures.push(Nt);
            } else this.addFeature(it, pt, xt, p, {});
            c.featureIndex.insert(a[xt].feature, pt, xt, Tt, this.index);
          }
        }, el.prototype.update = function(a, c, p) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(a, c, this.stateDependentLayers, p);
        }, el.prototype.addFeatures = function(a, c, p) {
          for (var x = 0, S = this.patternFeatures; x < S.length; x += 1) {
            var M = S[x];
            this.addFeature(M, M.geometry, M.index, c, p);
          }
        }, el.prototype.isEmpty = function() {
          return this.layoutVertexArray.length === 0;
        }, el.prototype.uploadPending = function() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }, el.prototype.upload = function(a) {
          this.uploaded || (this.layoutVertexBuffer = a.createVertexBuffer(this.layoutVertexArray, QF), this.indexBuffer = a.createIndexBuffer(this.indexArray), this.indexBuffer2 = a.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(a), this.uploaded = !0;
        }, el.prototype.destroy = function() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
        }, el.prototype.addFeature = function(a, c, p, x, S) {
          for (var M = 0, O = Ny(c, 500); M < O.length; M += 1) {
            for (var N = O[M], G = 0, Z = 0, te = N; Z < te.length; Z += 1) G += te[Z].length;
            for (var se = this.segments.prepareSegment(G, this.layoutVertexArray, this.indexArray), he = se.vertexLength, xe = [], Ve = [], je = 0, Qe = N; je < Qe.length; je += 1) {
              var Ye = Qe[je];
              if (Ye.length !== 0) {
                Ye !== N[0] && Ve.push(xe.length / 2);
                var it = this.segments2.prepareSegment(Ye.length, this.layoutVertexArray, this.indexArray2), pt = it.vertexLength;
                this.layoutVertexArray.emplaceBack(Ye[0].x, Ye[0].y), this.indexArray2.emplaceBack(pt + Ye.length - 1, pt), xe.push(Ye[0].x), xe.push(Ye[0].y);
                for (var xt = 1; xt < Ye.length; xt++) this.layoutVertexArray.emplaceBack(Ye[xt].x, Ye[xt].y), this.indexArray2.emplaceBack(pt + xt - 1, pt + xt), xe.push(Ye[xt].x), xe.push(Ye[xt].y);
                it.vertexLength += Ye.length, it.primitiveLength += Ye.length;
              }
            }
            for (var Tt = Dy(xe, Ve), Nt = 0; Nt < Tt.length; Nt += 3) this.indexArray.emplaceBack(he + Tt[Nt], he + Tt[Nt + 1], he + Tt[Nt + 2]);
            se.vertexLength += G, se.primitiveLength += Tt.length / 3;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, a, p, S, x);
        }, ur("FillBucket", el, { omit: ["layers", "patternFeatures"] });
        var h8 = new Xi({ "fill-sort-key": new Ar(le.layout_fill["fill-sort-key"]) }), d8 = { paint: new Xi({ "fill-antialias": new Mr(le.paint_fill["fill-antialias"]), "fill-opacity": new Ar(le.paint_fill["fill-opacity"]), "fill-color": new Ar(le.paint_fill["fill-color"]), "fill-outline-color": new Ar(le.paint_fill["fill-outline-color"]), "fill-translate": new Mr(le.paint_fill["fill-translate"]), "fill-translate-anchor": new Mr(le.paint_fill["fill-translate-anchor"]), "fill-pattern": new Tu(le.paint_fill["fill-pattern"]) }), layout: h8 }, p8 = (function(a) {
          function c(p) {
            a.call(this, p, d8);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype.recalculate = function(p, x) {
            a.prototype.recalculate.call(this, p, x);
            var S = this.paint._values["fill-outline-color"];
            S.value.kind === "constant" && S.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }, c.prototype.createBucket = function(p) {
            return new el(p);
          }, c.prototype.queryRadius = function() {
            return Zi(this.paint.get("fill-translate"));
          }, c.prototype.queryIntersectsFeature = function(p, x, S, M, O, N, G) {
            return si(Ja(p, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), N.angle, G), M);
          }, c.prototype.isTileClipped = function() {
            return !0;
          }, c;
        })(Ho), A8 = zi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4).members, qT = Wh;
        function Wh(a, c, p, x, S) {
          this.properties = {}, this.extent = p, this.type = 0, this._pbf = a, this._geometry = -1, this._keys = x, this._values = S, a.readFields(g8, this, c);
        }
        function g8(a, c, p) {
          a == 1 ? c.id = p.readVarint() : a == 2 ? (function(x, S) {
            for (var M = x.readVarint() + x.pos; x.pos < M; ) {
              var O = S._keys[x.readVarint()], N = S._values[x.readVarint()];
              S.properties[O] = N;
            }
          })(p, c) : a == 3 ? c.type = p.readVarint() : a == 4 && (c._geometry = p.pos);
        }
        function m8(a) {
          for (var c, p, x = 0, S = 0, M = a.length, O = M - 1; S < M; O = S++) x += ((p = a[O]).x - (c = a[S]).x) * (c.y + p.y);
          return x;
        }
        Wh.types = ["Unknown", "Point", "LineString", "Polygon"], Wh.prototype.loadGeometry = function() {
          var a = this._pbf;
          a.pos = this._geometry;
          for (var c, p = a.readVarint() + a.pos, x = 1, S = 0, M = 0, O = 0, N = []; a.pos < p; ) {
            if (S <= 0) {
              var G = a.readVarint();
              x = 7 & G, S = G >> 3;
            }
            if (S--, x === 1 || x === 2) M += a.readSVarint(), O += a.readSVarint(), x === 1 && (c && N.push(c), c = []), c.push(new y(M, O));
            else {
              if (x !== 7) throw new Error("unknown command " + x);
              c && c.push(c[0].clone());
            }
          }
          return c && N.push(c), N;
        }, Wh.prototype.bbox = function() {
          var a = this._pbf;
          a.pos = this._geometry;
          for (var c = a.readVarint() + a.pos, p = 1, x = 0, S = 0, M = 0, O = 1 / 0, N = -1 / 0, G = 1 / 0, Z = -1 / 0; a.pos < c; ) {
            if (x <= 0) {
              var te = a.readVarint();
              p = 7 & te, x = te >> 3;
            }
            if (x--, p === 1 || p === 2) (S += a.readSVarint()) < O && (O = S), S > N && (N = S), (M += a.readSVarint()) < G && (G = M), M > Z && (Z = M);
            else if (p !== 7) throw new Error("unknown command " + p);
          }
          return [O, G, N, Z];
        }, Wh.prototype.toGeoJSON = function(a, c, p) {
          var x, S, M = this.extent * Math.pow(2, p), O = this.extent * a, N = this.extent * c, G = this.loadGeometry(), Z = Wh.types[this.type];
          function te(xe) {
            for (var Ve = 0; Ve < xe.length; Ve++) {
              var je = xe[Ve];
              xe[Ve] = [360 * (je.x + O) / M - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (je.y + N) / M) * Math.PI / 180)) - 90];
            }
          }
          switch (this.type) {
            case 1:
              var se = [];
              for (x = 0; x < G.length; x++) se[x] = G[x][0];
              te(G = se);
              break;
            case 2:
              for (x = 0; x < G.length; x++) te(G[x]);
              break;
            case 3:
              for (G = (function(xe) {
                var Ve = xe.length;
                if (Ve <= 1) return [xe];
                for (var je, Qe, Ye = [], it = 0; it < Ve; it++) {
                  var pt = m8(xe[it]);
                  pt !== 0 && (Qe === void 0 && (Qe = pt < 0), Qe === pt < 0 ? (je && Ye.push(je), je = [xe[it]]) : je.push(xe[it]));
                }
                return je && Ye.push(je), Ye;
              })(G), x = 0; x < G.length; x++) for (S = 0; S < G[x].length; S++) te(G[x][S]);
          }
          G.length === 1 ? G = G[0] : Z = "Multi" + Z;
          var he = { type: "Feature", geometry: { type: Z, coordinates: G }, properties: this.properties };
          return "id" in this && (he.id = this.id), he;
        };
        var XT = ZT;
        function ZT(a, c) {
          this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = a, this._keys = [], this._values = [], this._features = [], a.readFields(_8, this, c), this.length = this._features.length;
        }
        function _8(a, c, p) {
          a === 15 ? c.version = p.readVarint() : a === 1 ? c.name = p.readString() : a === 5 ? c.extent = p.readVarint() : a === 2 ? c._features.push(p.pos) : a === 3 ? c._keys.push(p.readString()) : a === 4 && c._values.push((function(x) {
            for (var S = null, M = x.readVarint() + x.pos; x.pos < M; ) {
              var O = x.readVarint() >> 3;
              S = O === 1 ? x.readString() : O === 2 ? x.readFloat() : O === 3 ? x.readDouble() : O === 4 ? x.readVarint64() : O === 5 ? x.readVarint() : O === 6 ? x.readSVarint() : O === 7 ? x.readBoolean() : null;
            }
            return S;
          })(p));
        }
        function y8(a, c, p) {
          if (a === 3) {
            var x = new XT(p, p.readVarint() + p.pos);
            x.length && (c[x.name] = x);
          }
        }
        ZT.prototype.feature = function(a) {
          if (a < 0 || a >= this._features.length) throw new Error("feature index out of bounds");
          this._pbf.pos = this._features[a];
          var c = this._pbf.readVarint() + this._pbf.pos;
          return new qT(this._pbf, c, this.extent, this._keys, this._values);
        };
        var $h = { VectorTile: function(a, c) {
          this.layers = a.readFields(y8, {}, c);
        }, VectorTileFeature: qT, VectorTileLayer: XT }, v8 = $h.VectorTileFeature.types, Vy = Math.pow(2, 13);
        function Yp(a, c, p, x, S, M, O, N) {
          a.emplaceBack(c, p, 2 * Math.floor(x * Vy) + O, S * Vy * 2, M * Vy * 2, Math.round(N));
        }
        var tl = function(a) {
          this.zoom = a.zoom, this.overscaling = a.overscaling, this.layers = a.layers, this.layerIds = this.layers.map((function(c) {
            return c.id;
          })), this.index = a.index, this.hasPattern = !1, this.layoutVertexArray = new sa(), this.indexArray = new xs(), this.programConfigurations = new Ut(a.layers, a.zoom), this.segments = new Se(), this.stateDependentLayerIds = this.layers.filter((function(c) {
            return c.isStateDependent();
          })).map((function(c) {
            return c.id;
          }));
        };
        function b8(a, c) {
          return a.x === c.x && (a.x < 0 || a.x > 8192) || a.y === c.y && (a.y < 0 || a.y > 8192);
        }
        tl.prototype.populate = function(a, c, p) {
          this.features = [], this.hasPattern = Uy("fill-extrusion", this.layers, c);
          for (var x = 0, S = a; x < S.length; x += 1) {
            var M = S[x], O = M.feature, N = M.id, G = M.index, Z = M.sourceLayerIndex, te = this.layers[0]._featureFilter.needGeometry, se = jt(O, te);
            if (this.layers[0]._featureFilter.filter(new cn(this.zoom), se, p)) {
              var he = { id: N, sourceLayerIndex: Z, index: G, geometry: te ? se.geometry : ar(O), properties: O.properties, type: O.type, patterns: {} };
              this.hasPattern ? this.features.push(zy("fill-extrusion", this.layers, he, this.zoom, c)) : this.addFeature(he, he.geometry, G, p, {}), c.featureIndex.insert(O, he.geometry, G, Z, this.index, !0);
            }
          }
        }, tl.prototype.addFeatures = function(a, c, p) {
          for (var x = 0, S = this.features; x < S.length; x += 1) {
            var M = S[x];
            this.addFeature(M, M.geometry, M.index, c, p);
          }
        }, tl.prototype.update = function(a, c, p) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(a, c, this.stateDependentLayers, p);
        }, tl.prototype.isEmpty = function() {
          return this.layoutVertexArray.length === 0;
        }, tl.prototype.uploadPending = function() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }, tl.prototype.upload = function(a) {
          this.uploaded || (this.layoutVertexBuffer = a.createVertexBuffer(this.layoutVertexArray, A8), this.indexBuffer = a.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(a), this.uploaded = !0;
        }, tl.prototype.destroy = function() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }, tl.prototype.addFeature = function(a, c, p, x, S) {
          for (var M = 0, O = Ny(c, 500); M < O.length; M += 1) {
            for (var N = O[M], G = 0, Z = 0, te = N; Z < te.length; Z += 1) G += te[Z].length;
            for (var se = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray), he = 0, xe = N; he < xe.length; he += 1) {
              var Ve = xe[he];
              if (Ve.length !== 0 && !((yn = Ve).every((function(en) {
                return en.x < 0;
              })) || yn.every((function(en) {
                return en.x > 8192;
              })) || yn.every((function(en) {
                return en.y < 0;
              })) || yn.every((function(en) {
                return en.y > 8192;
              })))) for (var je = 0, Qe = 0; Qe < Ve.length; Qe++) {
                var Ye = Ve[Qe];
                if (Qe >= 1) {
                  var it = Ve[Qe - 1];
                  if (!b8(Ye, it)) {
                    se.vertexLength + 4 > Se.MAX_VERTEX_ARRAY_LENGTH && (se = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                    var pt = Ye.sub(it)._perp()._unit(), xt = it.dist(Ye);
                    je + xt > 32768 && (je = 0), Yp(this.layoutVertexArray, Ye.x, Ye.y, pt.x, pt.y, 0, 0, je), Yp(this.layoutVertexArray, Ye.x, Ye.y, pt.x, pt.y, 0, 1, je), Yp(this.layoutVertexArray, it.x, it.y, pt.x, pt.y, 0, 0, je += xt), Yp(this.layoutVertexArray, it.x, it.y, pt.x, pt.y, 0, 1, je);
                    var Tt = se.vertexLength;
                    this.indexArray.emplaceBack(Tt, Tt + 2, Tt + 1), this.indexArray.emplaceBack(Tt + 1, Tt + 2, Tt + 3), se.vertexLength += 4, se.primitiveLength += 2;
                  }
                }
              }
            }
            if (se.vertexLength + G > Se.MAX_VERTEX_ARRAY_LENGTH && (se = this.segments.prepareSegment(G, this.layoutVertexArray, this.indexArray)), v8[a.type] === "Polygon") {
              for (var Nt = [], Kt = [], rr = se.vertexLength, Ir = 0, lr = N; Ir < lr.length; Ir += 1) {
                var Dr = lr[Ir];
                if (Dr.length !== 0) {
                  Dr !== N[0] && Kt.push(Nt.length / 2);
                  for (var cr = 0; cr < Dr.length; cr++) {
                    var an = Dr[cr];
                    Yp(this.layoutVertexArray, an.x, an.y, 0, 0, 1, 1, 0), Nt.push(an.x), Nt.push(an.y);
                  }
                }
              }
              for (var jr = Dy(Nt, Kt), mr = 0; mr < jr.length; mr += 3) this.indexArray.emplaceBack(rr + jr[mr], rr + jr[mr + 2], rr + jr[mr + 1]);
              se.primitiveLength += jr.length / 3, se.vertexLength += G;
            }
          }
          var yn;
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, a, p, S, x);
        }, ur("FillExtrusionBucket", tl, { omit: ["layers", "features"] });
        var x8 = { paint: new Xi({ "fill-extrusion-opacity": new Mr(le["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new Ar(le["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Mr(le["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Mr(le["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new Tu(le["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new Ar(le["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new Ar(le["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new Mr(le["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) }) }, w8 = (function(a) {
          function c(p) {
            a.call(this, p, x8);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype.createBucket = function(p) {
            return new tl(p);
          }, c.prototype.queryRadius = function() {
            return Zi(this.paint.get("fill-extrusion-translate"));
          }, c.prototype.is3D = function() {
            return !0;
          }, c.prototype.queryIntersectsFeature = function(p, x, S, M, O, N, G, Z) {
            var te = Ja(p, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), N.angle, G), se = this.paint.get("fill-extrusion-height").evaluate(x, S), he = this.paint.get("fill-extrusion-base").evaluate(x, S), xe = (function(je, Qe, Ye, it) {
              for (var pt = [], xt = 0, Tt = je; xt < Tt.length; xt += 1) {
                var Nt = Tt[xt], Kt = [Nt.x, Nt.y, 0, 1];
                jh(Kt, Kt, Qe), pt.push(new y(Kt[0] / Kt[3], Kt[1] / Kt[3]));
              }
              return pt;
            })(te, Z), Ve = (function(je, Qe, Ye, it) {
              for (var pt = [], xt = [], Tt = it[8] * Qe, Nt = it[9] * Qe, Kt = it[10] * Qe, rr = it[11] * Qe, Ir = it[8] * Ye, lr = it[9] * Ye, Dr = it[10] * Ye, cr = it[11] * Ye, an = 0, jr = je; an < jr.length; an += 1) {
                for (var mr = [], yn = [], en = 0, Cn = jr[an]; en < Cn.length; en += 1) {
                  var Lr = Cn[en], In = Lr.x, ai = Lr.y, Ti = it[0] * In + it[4] * ai + it[12], mi = it[1] * In + it[5] * ai + it[13], li = it[2] * In + it[6] * ai + it[14], Ei = it[3] * In + it[7] * ai + it[15], Yi = li + Kt, Ki = Ei + rr, Vs = Ti + Ir, as = mi + lr, js = li + Dr, Pi = Ei + cr, ls = new y((Ti + Tt) / Ki, (mi + Nt) / Ki);
                  ls.z = Yi / Ki, mr.push(ls);
                  var bn = new y(Vs / Pi, as / Pi);
                  bn.z = js / Pi, yn.push(bn);
                }
                pt.push(mr), xt.push(yn);
              }
              return [pt, xt];
            })(M, he, se, Z);
            return (function(je, Qe, Ye) {
              var it = 1 / 0;
              si(Ye, Qe) && (it = YT(Ye, Qe[0]));
              for (var pt = 0; pt < Qe.length; pt++) for (var xt = Qe[pt], Tt = je[pt], Nt = 0; Nt < xt.length - 1; Nt++) {
                var Kt = xt[Nt], rr = [Kt, xt[Nt + 1], Tt[Nt + 1], Tt[Nt], Kt];
                Zr(Ye, rr) && (it = Math.min(it, YT(Ye, rr)));
              }
              return it !== 1 / 0 && it;
            })(Ve[0], Ve[1], xe);
          }, c;
        })(Ho);
        function Kp(a, c) {
          return a.x * c.x + a.y * c.y;
        }
        function YT(a, c) {
          if (a.length === 1) {
            for (var p, x = 0, S = c[x++]; !p || S.equals(p); ) if (!(p = c[x++])) return 1 / 0;
            for (; x < c.length; x++) {
              var M = c[x], O = a[0], N = p.sub(S), G = M.sub(S), Z = O.sub(S), te = Kp(N, N), se = Kp(N, G), he = Kp(G, G), xe = Kp(Z, N), Ve = Kp(Z, G), je = te * he - se * se, Qe = (he * xe - se * Ve) / je, Ye = (te * Ve - se * xe) / je, it = S.z * (1 - Qe - Ye) + p.z * Qe + M.z * Ye;
              if (isFinite(it)) return it;
            }
            return 1 / 0;
          }
          for (var pt = 1 / 0, xt = 0, Tt = c; xt < Tt.length; xt += 1) pt = Math.min(pt, Tt[xt].z);
          return pt;
        }
        var T8 = zi([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4).members, E8 = zi([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]).members, C8 = $h.VectorTileFeature.types, S8 = Math.cos(Math.PI / 180 * 37.5), KT = Math.pow(2, 14) / 0.5, Qs = function(a) {
          var c = this;
          this.zoom = a.zoom, this.overscaling = a.overscaling, this.layers = a.layers, this.layerIds = this.layers.map((function(p) {
            return p.id;
          })), this.index = a.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((function(p) {
            c.gradients[p.id] = {};
          })), this.layoutVertexArray = new Us(), this.layoutVertexArray2 = new Fl(), this.indexArray = new xs(), this.programConfigurations = new Ut(a.layers, a.zoom), this.segments = new Se(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((function(p) {
            return p.isStateDependent();
          })).map((function(p) {
            return p.id;
          }));
        };
        Qs.prototype.populate = function(a, c, p) {
          this.hasPattern = Uy("line", this.layers, c);
          for (var x = this.layers[0].layout.get("line-sort-key"), S = [], M = 0, O = a; M < O.length; M += 1) {
            var N = O[M], G = N.feature, Z = N.id, te = N.index, se = N.sourceLayerIndex, he = this.layers[0]._featureFilter.needGeometry, xe = jt(G, he);
            if (this.layers[0]._featureFilter.filter(new cn(this.zoom), xe, p)) {
              var Ve = x ? x.evaluate(xe, {}, p) : void 0, je = { id: Z, properties: G.properties, type: G.type, sourceLayerIndex: se, index: te, geometry: he ? xe.geometry : ar(G), patterns: {}, sortKey: Ve };
              S.push(je);
            }
          }
          x && S.sort((function(Kt, rr) {
            return Kt.sortKey - rr.sortKey;
          }));
          for (var Qe = 0, Ye = S; Qe < Ye.length; Qe += 1) {
            var it = Ye[Qe], pt = it.geometry, xt = it.index, Tt = it.sourceLayerIndex;
            if (this.hasPattern) {
              var Nt = zy("line", this.layers, it, this.zoom, c);
              this.patternFeatures.push(Nt);
            } else this.addFeature(it, pt, xt, p, {});
            c.featureIndex.insert(a[xt].feature, pt, xt, Tt, this.index);
          }
        }, Qs.prototype.update = function(a, c, p) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(a, c, this.stateDependentLayers, p);
        }, Qs.prototype.addFeatures = function(a, c, p) {
          for (var x = 0, S = this.patternFeatures; x < S.length; x += 1) {
            var M = S[x];
            this.addFeature(M, M.geometry, M.index, c, p);
          }
        }, Qs.prototype.isEmpty = function() {
          return this.layoutVertexArray.length === 0;
        }, Qs.prototype.uploadPending = function() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }, Qs.prototype.upload = function(a) {
          this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = a.createVertexBuffer(this.layoutVertexArray2, E8)), this.layoutVertexBuffer = a.createVertexBuffer(this.layoutVertexArray, T8), this.indexBuffer = a.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(a), this.uploaded = !0;
        }, Qs.prototype.destroy = function() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }, Qs.prototype.lineFeatureClips = function(a) {
          if (a.properties && a.properties.hasOwnProperty("mapbox_clip_start") && a.properties.hasOwnProperty("mapbox_clip_end")) return { start: +a.properties.mapbox_clip_start, end: +a.properties.mapbox_clip_end };
        }, Qs.prototype.addFeature = function(a, c, p, x, S) {
          var M = this.layers[0].layout, O = M.get("line-join").evaluate(a, {}), N = M.get("line-cap"), G = M.get("line-miter-limit"), Z = M.get("line-round-limit");
          this.lineClips = this.lineFeatureClips(a);
          for (var te = 0, se = c; te < se.length; te += 1) this.addLine(se[te], a, O, N, G, Z);
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, a, p, S, x);
        }, Qs.prototype.addLine = function(a, c, p, x, S, M) {
          if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
            this.lineClipsArray.push(this.lineClips);
            for (var O = 0; O < a.length - 1; O++) this.totalDistance += a[O].dist(a[O + 1]);
            this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
          }
          for (var N = C8[c.type] === "Polygon", G = a.length; G >= 2 && a[G - 1].equals(a[G - 2]); ) G--;
          for (var Z = 0; Z < G - 1 && a[Z].equals(a[Z + 1]); ) Z++;
          if (!(G < (N ? 3 : 2))) {
            p === "bevel" && (S = 1.05);
            var te, se = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, he = this.segments.prepareSegment(10 * G, this.layoutVertexArray, this.indexArray), xe = void 0, Ve = void 0, je = void 0, Qe = void 0;
            this.e1 = this.e2 = -1, N && (Qe = a[Z].sub(te = a[G - 2])._unit()._perp());
            for (var Ye = Z; Ye < G; Ye++) if (!(Ve = Ye === G - 1 ? N ? a[Z + 1] : void 0 : a[Ye + 1]) || !a[Ye].equals(Ve)) {
              Qe && (je = Qe), te && (xe = te), te = a[Ye], Qe = Ve ? Ve.sub(te)._unit()._perp() : je;
              var it = (je = je || Qe).add(Qe);
              it.x === 0 && it.y === 0 || it._unit();
              var pt = je.x * Qe.x + je.y * Qe.y, xt = it.x * Qe.x + it.y * Qe.y, Tt = xt !== 0 ? 1 / xt : 1 / 0, Nt = 2 * Math.sqrt(2 - 2 * xt), Kt = xt < S8 && xe && Ve, rr = je.x * Qe.y - je.y * Qe.x > 0;
              if (Kt && Ye > Z) {
                var Ir = te.dist(xe);
                if (Ir > 2 * se) {
                  var lr = te.sub(te.sub(xe)._mult(se / Ir)._round());
                  this.updateDistance(xe, lr), this.addCurrentVertex(lr, je, 0, 0, he), xe = lr;
                }
              }
              var Dr = xe && Ve, cr = Dr ? p : N ? "butt" : x;
              if (Dr && cr === "round" && (Tt < M ? cr = "miter" : Tt <= 2 && (cr = "fakeround")), cr === "miter" && Tt > S && (cr = "bevel"), cr === "bevel" && (Tt > 2 && (cr = "flipbevel"), Tt < S && (cr = "miter")), xe && this.updateDistance(xe, te), cr === "miter") it._mult(Tt), this.addCurrentVertex(te, it, 0, 0, he);
              else if (cr === "flipbevel") {
                if (Tt > 100) it = Qe.mult(-1);
                else {
                  var an = Tt * je.add(Qe).mag() / je.sub(Qe).mag();
                  it._perp()._mult(an * (rr ? -1 : 1));
                }
                this.addCurrentVertex(te, it, 0, 0, he), this.addCurrentVertex(te, it.mult(-1), 0, 0, he);
              } else if (cr === "bevel" || cr === "fakeround") {
                var jr = -Math.sqrt(Tt * Tt - 1), mr = rr ? jr : 0, yn = rr ? 0 : jr;
                if (xe && this.addCurrentVertex(te, je, mr, yn, he), cr === "fakeround") for (var en = Math.round(180 * Nt / Math.PI / 20), Cn = 1; Cn < en; Cn++) {
                  var Lr = Cn / en;
                  if (Lr !== 0.5) {
                    var In = Lr - 0.5;
                    Lr += Lr * In * (Lr - 1) * ((1.0904 + pt * (pt * (3.55645 - 1.43519 * pt) - 3.2452)) * In * In + (0.848013 + pt * (0.215638 * pt - 1.06021)));
                  }
                  var ai = Qe.sub(je)._mult(Lr)._add(je)._unit()._mult(rr ? -1 : 1);
                  this.addHalfVertex(te, ai.x, ai.y, !1, rr, 0, he);
                }
                Ve && this.addCurrentVertex(te, Qe, -mr, -yn, he);
              } else if (cr === "butt") this.addCurrentVertex(te, it, 0, 0, he);
              else if (cr === "square") {
                var Ti = xe ? 1 : -1;
                this.addCurrentVertex(te, it, Ti, Ti, he);
              } else cr === "round" && (xe && (this.addCurrentVertex(te, je, 0, 0, he), this.addCurrentVertex(te, je, 1, 1, he, !0)), Ve && (this.addCurrentVertex(te, Qe, -1, -1, he, !0), this.addCurrentVertex(te, Qe, 0, 0, he)));
              if (Kt && Ye < G - 1) {
                var mi = te.dist(Ve);
                if (mi > 2 * se) {
                  var li = te.add(Ve.sub(te)._mult(se / mi)._round());
                  this.updateDistance(te, li), this.addCurrentVertex(li, Qe, 0, 0, he), te = li;
                }
              }
            }
          }
        }, Qs.prototype.addCurrentVertex = function(a, c, p, x, S, M) {
          M === void 0 && (M = !1);
          var O = c.y * x - c.x, N = -c.y - c.x * x;
          this.addHalfVertex(a, c.x + c.y * p, c.y - c.x * p, M, !1, p, S), this.addHalfVertex(a, O, N, M, !0, -x, S), this.distance > KT / 2 && this.totalDistance === 0 && (this.distance = 0, this.addCurrentVertex(a, c, p, x, S, M));
        }, Qs.prototype.addHalfVertex = function(a, c, p, x, S, M, O) {
          var N = 0.5 * (this.lineClips ? this.scaledDistance * (KT - 1) : this.scaledDistance);
          this.layoutVertexArray.emplaceBack((a.x << 1) + (x ? 1 : 0), (a.y << 1) + (S ? 1 : 0), Math.round(63 * c) + 128, Math.round(63 * p) + 128, 1 + (M === 0 ? 0 : M < 0 ? -1 : 1) | (63 & N) << 2, N >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
          var G = O.vertexLength++;
          this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, G), O.primitiveLength++), S ? this.e2 = G : this.e1 = G;
        }, Qs.prototype.updateScaledDistance = function() {
          this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
        }, Qs.prototype.updateDistance = function(a, c) {
          this.distance += a.dist(c), this.updateScaledDistance();
        }, ur("LineBucket", Qs, { omit: ["layers", "patternFeatures"] });
        var I8 = new Xi({ "line-cap": new Mr(le.layout_line["line-cap"]), "line-join": new Ar(le.layout_line["line-join"]), "line-miter-limit": new Mr(le.layout_line["line-miter-limit"]), "line-round-limit": new Mr(le.layout_line["line-round-limit"]), "line-sort-key": new Ar(le.layout_line["line-sort-key"]) }), QT = { paint: new Xi({ "line-opacity": new Ar(le.paint_line["line-opacity"]), "line-color": new Ar(le.paint_line["line-color"]), "line-translate": new Mr(le.paint_line["line-translate"]), "line-translate-anchor": new Mr(le.paint_line["line-translate-anchor"]), "line-width": new Ar(le.paint_line["line-width"]), "line-gap-width": new Ar(le.paint_line["line-gap-width"]), "line-offset": new Ar(le.paint_line["line-offset"]), "line-blur": new Ar(le.paint_line["line-blur"]), "line-dasharray": new us(le.paint_line["line-dasharray"]), "line-pattern": new Tu(le.paint_line["line-pattern"]), "line-gradient": new So(le.paint_line["line-gradient"]) }), layout: I8 }, JT = new ((function(a) {
          function c() {
            a.apply(this, arguments);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype.possiblyEvaluate = function(p, x) {
            return x = new cn(Math.floor(x.zoom), { now: x.now, fadeDuration: x.fadeDuration, zoomHistory: x.zoomHistory, transition: x.transition }), a.prototype.possiblyEvaluate.call(this, p, x);
          }, c.prototype.evaluate = function(p, x, S, M) {
            return x = K({}, x, { zoom: Math.floor(x.zoom) }), a.prototype.evaluate.call(this, p, x, S, M);
          }, c;
        })(Ar))(QT.paint.properties["line-width"].specification);
        JT.useIntegerZoom = !0;
        var P8 = (function(a) {
          function c(p) {
            a.call(this, p, QT), this.gradientVersion = 0;
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype._handleSpecialPaintPropertyUpdate = function(p) {
            p === "line-gradient" && (this.stepInterpolant = this._transitionablePaint._values["line-gradient"].value.expression._styleExpression.expression instanceof _s, this.gradientVersion = (this.gradientVersion + 1) % L);
          }, c.prototype.gradientExpression = function() {
            return this._transitionablePaint._values["line-gradient"].value.expression;
          }, c.prototype.recalculate = function(p, x) {
            a.prototype.recalculate.call(this, p, x), this.paint._values["line-floorwidth"] = JT.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, p);
          }, c.prototype.createBucket = function(p) {
            return new Qs(p);
          }, c.prototype.queryRadius = function(p) {
            var x = p, S = e3(Sa("line-width", this, x), Sa("line-gap-width", this, x)), M = Sa("line-offset", this, x);
            return S / 2 + Math.abs(M) + Zi(this.paint.get("line-translate"));
          }, c.prototype.queryIntersectsFeature = function(p, x, S, M, O, N, G) {
            var Z = Ja(p, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), N.angle, G), te = G / 2 * e3(this.paint.get("line-width").evaluate(x, S), this.paint.get("line-gap-width").evaluate(x, S)), se = this.paint.get("line-offset").evaluate(x, S);
            return se && (M = (function(he, xe) {
              for (var Ve = [], je = new y(0, 0), Qe = 0; Qe < he.length; Qe++) {
                for (var Ye = he[Qe], it = [], pt = 0; pt < Ye.length; pt++) {
                  var xt = Ye[pt], Tt = Ye[pt + 1], Nt = pt === 0 ? je : xt.sub(Ye[pt - 1])._unit()._perp(), Kt = pt === Ye.length - 1 ? je : Tt.sub(xt)._unit()._perp(), rr = Nt._add(Kt)._unit();
                  rr._mult(1 / (rr.x * Kt.x + rr.y * Kt.y)), it.push(rr._mult(xe)._add(xt));
                }
                Ve.push(it);
              }
              return Ve;
            })(M, se * G)), (function(he, xe, Ve) {
              for (var je = 0; je < xe.length; je++) {
                var Qe = xe[je];
                if (he.length >= 3) {
                  for (var Ye = 0; Ye < Qe.length; Ye++) if (Ca(he, Qe[Ye])) return !0;
                }
                if (Ys(he, Qe, Ve)) return !0;
              }
              return !1;
            })(Z, M, te);
          }, c.prototype.isTileClipped = function() {
            return !0;
          }, c;
        })(Ho);
        function e3(a, c) {
          return c > 0 ? c + 2 * a : a;
        }
        var M8 = zi([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), R8 = zi([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4), B8 = (zi([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4), zi([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }])), t3 = (zi([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]), zi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4)), O8 = zi([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
        function D8(a, c, p) {
          return a.sections.forEach((function(x) {
            x.text = (function(S, M, O) {
              var N = M.layout.get("text-transform").evaluate(O, {});
              return N === "uppercase" ? S = S.toLocaleUpperCase() : N === "lowercase" && (S = S.toLocaleLowerCase()), is.applyArabicShaping && (S = is.applyArabicShaping(S)), S;
            })(x.text, c, p);
          })), a;
        }
        zi([{ name: "triangle", components: 3, type: "Uint16" }]), zi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), zi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }]), zi([{ type: "Float32", name: "offsetX" }]), zi([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]);
        var Qp = { "!": "", "#": "", $: "", "%": "", "&": "", "(": "", ")": "", "*": "", "+": "", ",": "", "-": "", ".": "", "/": "", ":": "", ";": "", "<": "", "=": "", ">": "", "?": "", "@": "", "[": "", "\\": "", "]": "", "^": "", _: "", "`": "", "{": "", "|": "", "}": "", "~": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "" }, r3 = function(a, c, p, x, S) {
          var M, O, N = 8 * S - x - 1, G = (1 << N) - 1, Z = G >> 1, te = -7, se = S - 1, he = -1, xe = a[c + se];
          for (se += he, M = xe & (1 << -te) - 1, xe >>= -te, te += N; te > 0; M = 256 * M + a[c + se], se += he, te -= 8) ;
          for (O = M & (1 << -te) - 1, M >>= -te, te += x; te > 0; O = 256 * O + a[c + se], se += he, te -= 8) ;
          if (M === 0) M = 1 - Z;
          else {
            if (M === G) return O ? NaN : 1 / 0 * (xe ? -1 : 1);
            O += Math.pow(2, x), M -= Z;
          }
          return (xe ? -1 : 1) * O * Math.pow(2, M - x);
        }, n3 = function(a, c, p, x, S, M) {
          var O, N, G, Z = 8 * M - S - 1, te = (1 << Z) - 1, se = te >> 1, he = S === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, xe = 0, Ve = 1, je = c < 0 || c === 0 && 1 / c < 0 ? 1 : 0;
          for (c = Math.abs(c), isNaN(c) || c === 1 / 0 ? (N = isNaN(c) ? 1 : 0, O = te) : (O = Math.floor(Math.log(c) / Math.LN2), c * (G = Math.pow(2, -O)) < 1 && (O--, G *= 2), (c += O + se >= 1 ? he / G : he * Math.pow(2, 1 - se)) * G >= 2 && (O++, G /= 2), O + se >= te ? (N = 0, O = te) : O + se >= 1 ? (N = (c * G - 1) * Math.pow(2, S), O += se) : (N = c * Math.pow(2, se - 1) * Math.pow(2, S), O = 0)); S >= 8; a[p + xe] = 255 & N, xe += Ve, N /= 256, S -= 8) ;
          for (O = O << S | N, Z += S; Z > 0; a[p + xe] = 255 & O, xe += Ve, O /= 256, Z -= 8) ;
          a[p + xe - Ve] |= 128 * je;
        }, F0 = Yn;
        function Yn(a) {
          this.buf = ArrayBuffer.isView && ArrayBuffer.isView(a) ? a : new Uint8Array(a || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
        }
        Yn.Varint = 0, Yn.Fixed64 = 1, Yn.Bytes = 2, Yn.Fixed32 = 5;
        var i3 = typeof TextDecoder > "u" ? null : new TextDecoder("utf8");
        function Bc(a) {
          return a.type === Yn.Bytes ? a.readVarint() + a.pos : a.pos + 1;
        }
        function qh(a, c, p) {
          return p ? 4294967296 * c + (a >>> 0) : 4294967296 * (c >>> 0) + (a >>> 0);
        }
        function s3(a, c, p) {
          var x = c <= 16383 ? 1 : c <= 2097151 ? 2 : c <= 268435455 ? 3 : Math.floor(Math.log(c) / (7 * Math.LN2));
          p.realloc(x);
          for (var S = p.pos - 1; S >= a; S--) p.buf[S + x] = p.buf[S];
        }
        function L8(a, c) {
          for (var p = 0; p < a.length; p++) c.writeVarint(a[p]);
        }
        function k8(a, c) {
          for (var p = 0; p < a.length; p++) c.writeSVarint(a[p]);
        }
        function F8(a, c) {
          for (var p = 0; p < a.length; p++) c.writeFloat(a[p]);
        }
        function N8(a, c) {
          for (var p = 0; p < a.length; p++) c.writeDouble(a[p]);
        }
        function U8(a, c) {
          for (var p = 0; p < a.length; p++) c.writeBoolean(a[p]);
        }
        function z8(a, c) {
          for (var p = 0; p < a.length; p++) c.writeFixed32(a[p]);
        }
        function V8(a, c) {
          for (var p = 0; p < a.length; p++) c.writeSFixed32(a[p]);
        }
        function j8(a, c) {
          for (var p = 0; p < a.length; p++) c.writeFixed64(a[p]);
        }
        function H8(a, c) {
          for (var p = 0; p < a.length; p++) c.writeSFixed64(a[p]);
        }
        function N0(a, c) {
          return (a[c] | a[c + 1] << 8 | a[c + 2] << 16) + 16777216 * a[c + 3];
        }
        function Xh(a, c, p) {
          a[p] = c, a[p + 1] = c >>> 8, a[p + 2] = c >>> 16, a[p + 3] = c >>> 24;
        }
        function o3(a, c) {
          return (a[c] | a[c + 1] << 8 | a[c + 2] << 16) + (a[c + 3] << 24);
        }
        function G8(a, c, p) {
          a === 1 && p.readMessage(W8, c);
        }
        function W8(a, c, p) {
          if (a === 3) {
            var x = p.readMessage($8, {}), S = x.width, M = x.height, O = x.left, N = x.top, G = x.advance;
            c.push({ id: x.id, bitmap: new Sf({ width: S + 6, height: M + 6 }, x.bitmap), metrics: { width: S, height: M, left: O, top: N, advance: G } });
          }
        }
        function $8(a, c, p) {
          a === 1 ? c.id = p.readVarint() : a === 2 ? c.bitmap = p.readBytes() : a === 3 ? c.width = p.readVarint() : a === 4 ? c.height = p.readVarint() : a === 5 ? c.left = p.readSVarint() : a === 6 ? c.top = p.readSVarint() : a === 7 && (c.advance = p.readVarint());
        }
        function a3(a) {
          for (var c = 0, p = 0, x = 0, S = a; x < S.length; x += 1) {
            var M = S[x];
            c += M.w * M.h, p = Math.max(p, M.w);
          }
          a.sort((function(je, Qe) {
            return Qe.h - je.h;
          }));
          for (var O = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(c / 0.95)), p), h: 1 / 0 }], N = 0, G = 0, Z = 0, te = a; Z < te.length; Z += 1) for (var se = te[Z], he = O.length - 1; he >= 0; he--) {
            var xe = O[he];
            if (!(se.w > xe.w || se.h > xe.h)) {
              if (se.x = xe.x, se.y = xe.y, G = Math.max(G, se.y + se.h), N = Math.max(N, se.x + se.w), se.w === xe.w && se.h === xe.h) {
                var Ve = O.pop();
                he < O.length && (O[he] = Ve);
              } else se.h === xe.h ? (xe.x += se.w, xe.w -= se.w) : se.w === xe.w ? (xe.y += se.h, xe.h -= se.h) : (O.push({ x: xe.x + se.w, y: xe.y, w: xe.w - se.w, h: se.h }), xe.y += se.h, xe.h -= se.h);
              break;
            }
          }
          return { w: N, h: G, fill: c / (N * G) || 0 };
        }
        Yn.prototype = { destroy: function() {
          this.buf = null;
        }, readFields: function(a, c, p) {
          for (p = p || this.length; this.pos < p; ) {
            var x = this.readVarint(), S = x >> 3, M = this.pos;
            this.type = 7 & x, a(S, c, this), this.pos === M && this.skip(x);
          }
          return c;
        }, readMessage: function(a, c) {
          return this.readFields(a, c, this.readVarint() + this.pos);
        }, readFixed32: function() {
          var a = N0(this.buf, this.pos);
          return this.pos += 4, a;
        }, readSFixed32: function() {
          var a = o3(this.buf, this.pos);
          return this.pos += 4, a;
        }, readFixed64: function() {
          var a = N0(this.buf, this.pos) + 4294967296 * N0(this.buf, this.pos + 4);
          return this.pos += 8, a;
        }, readSFixed64: function() {
          var a = N0(this.buf, this.pos) + 4294967296 * o3(this.buf, this.pos + 4);
          return this.pos += 8, a;
        }, readFloat: function() {
          var a = r3(this.buf, this.pos, !0, 23, 4);
          return this.pos += 4, a;
        }, readDouble: function() {
          var a = r3(this.buf, this.pos, !0, 52, 8);
          return this.pos += 8, a;
        }, readVarint: function(a) {
          var c, p, x = this.buf;
          return c = 127 & (p = x[this.pos++]), p < 128 ? c : (c |= (127 & (p = x[this.pos++])) << 7, p < 128 ? c : (c |= (127 & (p = x[this.pos++])) << 14, p < 128 ? c : (c |= (127 & (p = x[this.pos++])) << 21, p < 128 ? c : (function(S, M, O) {
            var N, G, Z = O.buf;
            if (N = (112 & (G = Z[O.pos++])) >> 4, G < 128 || (N |= (127 & (G = Z[O.pos++])) << 3, G < 128) || (N |= (127 & (G = Z[O.pos++])) << 10, G < 128) || (N |= (127 & (G = Z[O.pos++])) << 17, G < 128) || (N |= (127 & (G = Z[O.pos++])) << 24, G < 128) || (N |= (1 & (G = Z[O.pos++])) << 31, G < 128)) return qh(S, N, M);
            throw new Error("Expected varint not more than 10 bytes");
          })(c |= (15 & (p = x[this.pos])) << 28, a, this))));
        }, readVarint64: function() {
          return this.readVarint(!0);
        }, readSVarint: function() {
          var a = this.readVarint();
          return a % 2 == 1 ? (a + 1) / -2 : a / 2;
        }, readBoolean: function() {
          return !!this.readVarint();
        }, readString: function() {
          var a = this.readVarint() + this.pos, c = this.pos;
          return this.pos = a, a - c >= 12 && i3 ? (function(p, x, S) {
            return i3.decode(p.subarray(x, S));
          })(this.buf, c, a) : (function(p, x, S) {
            for (var M = "", O = x; O < S; ) {
              var N, G, Z, te = p[O], se = null, he = te > 239 ? 4 : te > 223 ? 3 : te > 191 ? 2 : 1;
              if (O + he > S) break;
              he === 1 ? te < 128 && (se = te) : he === 2 ? (192 & (N = p[O + 1])) == 128 && (se = (31 & te) << 6 | 63 & N) <= 127 && (se = null) : he === 3 ? (G = p[O + 2], (192 & (N = p[O + 1])) == 128 && (192 & G) == 128 && ((se = (15 & te) << 12 | (63 & N) << 6 | 63 & G) <= 2047 || se >= 55296 && se <= 57343) && (se = null)) : he === 4 && (G = p[O + 2], Z = p[O + 3], (192 & (N = p[O + 1])) == 128 && (192 & G) == 128 && (192 & Z) == 128 && ((se = (15 & te) << 18 | (63 & N) << 12 | (63 & G) << 6 | 63 & Z) <= 65535 || se >= 1114112) && (se = null)), se === null ? (se = 65533, he = 1) : se > 65535 && (se -= 65536, M += String.fromCharCode(se >>> 10 & 1023 | 55296), se = 56320 | 1023 & se), M += String.fromCharCode(se), O += he;
            }
            return M;
          })(this.buf, c, a);
        }, readBytes: function() {
          var a = this.readVarint() + this.pos, c = this.buf.subarray(this.pos, a);
          return this.pos = a, c;
        }, readPackedVarint: function(a, c) {
          if (this.type !== Yn.Bytes) return a.push(this.readVarint(c));
          var p = Bc(this);
          for (a = a || []; this.pos < p; ) a.push(this.readVarint(c));
          return a;
        }, readPackedSVarint: function(a) {
          if (this.type !== Yn.Bytes) return a.push(this.readSVarint());
          var c = Bc(this);
          for (a = a || []; this.pos < c; ) a.push(this.readSVarint());
          return a;
        }, readPackedBoolean: function(a) {
          if (this.type !== Yn.Bytes) return a.push(this.readBoolean());
          var c = Bc(this);
          for (a = a || []; this.pos < c; ) a.push(this.readBoolean());
          return a;
        }, readPackedFloat: function(a) {
          if (this.type !== Yn.Bytes) return a.push(this.readFloat());
          var c = Bc(this);
          for (a = a || []; this.pos < c; ) a.push(this.readFloat());
          return a;
        }, readPackedDouble: function(a) {
          if (this.type !== Yn.Bytes) return a.push(this.readDouble());
          var c = Bc(this);
          for (a = a || []; this.pos < c; ) a.push(this.readDouble());
          return a;
        }, readPackedFixed32: function(a) {
          if (this.type !== Yn.Bytes) return a.push(this.readFixed32());
          var c = Bc(this);
          for (a = a || []; this.pos < c; ) a.push(this.readFixed32());
          return a;
        }, readPackedSFixed32: function(a) {
          if (this.type !== Yn.Bytes) return a.push(this.readSFixed32());
          var c = Bc(this);
          for (a = a || []; this.pos < c; ) a.push(this.readSFixed32());
          return a;
        }, readPackedFixed64: function(a) {
          if (this.type !== Yn.Bytes) return a.push(this.readFixed64());
          var c = Bc(this);
          for (a = a || []; this.pos < c; ) a.push(this.readFixed64());
          return a;
        }, readPackedSFixed64: function(a) {
          if (this.type !== Yn.Bytes) return a.push(this.readSFixed64());
          var c = Bc(this);
          for (a = a || []; this.pos < c; ) a.push(this.readSFixed64());
          return a;
        }, skip: function(a) {
          var c = 7 & a;
          if (c === Yn.Varint) for (; this.buf[this.pos++] > 127; ) ;
          else if (c === Yn.Bytes) this.pos = this.readVarint() + this.pos;
          else if (c === Yn.Fixed32) this.pos += 4;
          else {
            if (c !== Yn.Fixed64) throw new Error("Unimplemented type: " + c);
            this.pos += 8;
          }
        }, writeTag: function(a, c) {
          this.writeVarint(a << 3 | c);
        }, realloc: function(a) {
          for (var c = this.length || 16; c < this.pos + a; ) c *= 2;
          if (c !== this.length) {
            var p = new Uint8Array(c);
            p.set(this.buf), this.buf = p, this.length = c;
          }
        }, finish: function() {
          return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
        }, writeFixed32: function(a) {
          this.realloc(4), Xh(this.buf, a, this.pos), this.pos += 4;
        }, writeSFixed32: function(a) {
          this.realloc(4), Xh(this.buf, a, this.pos), this.pos += 4;
        }, writeFixed64: function(a) {
          this.realloc(8), Xh(this.buf, -1 & a, this.pos), Xh(this.buf, Math.floor(a * (1 / 4294967296)), this.pos + 4), this.pos += 8;
        }, writeSFixed64: function(a) {
          this.realloc(8), Xh(this.buf, -1 & a, this.pos), Xh(this.buf, Math.floor(a * (1 / 4294967296)), this.pos + 4), this.pos += 8;
        }, writeVarint: function(a) {
          (a = +a || 0) > 268435455 || a < 0 ? (function(c, p) {
            var x, S;
            if (c >= 0 ? (x = c % 4294967296 | 0, S = c / 4294967296 | 0) : (S = ~(-c / 4294967296), 4294967295 ^ (x = ~(-c % 4294967296)) ? x = x + 1 | 0 : (x = 0, S = S + 1 | 0)), c >= 18446744073709552e3 || c < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
            p.realloc(10), (function(M, O, N) {
              N.buf[N.pos++] = 127 & M | 128, M >>>= 7, N.buf[N.pos++] = 127 & M | 128, M >>>= 7, N.buf[N.pos++] = 127 & M | 128, M >>>= 7, N.buf[N.pos++] = 127 & M | 128, N.buf[N.pos] = 127 & (M >>>= 7);
            })(x, 0, p), (function(M, O) {
              var N = (7 & M) << 4;
              O.buf[O.pos++] |= N | ((M >>>= 3) ? 128 : 0), M && (O.buf[O.pos++] = 127 & M | ((M >>>= 7) ? 128 : 0), M && (O.buf[O.pos++] = 127 & M | ((M >>>= 7) ? 128 : 0), M && (O.buf[O.pos++] = 127 & M | ((M >>>= 7) ? 128 : 0), M && (O.buf[O.pos++] = 127 & M | ((M >>>= 7) ? 128 : 0), M && (O.buf[O.pos++] = 127 & M)))));
            })(S, p);
          })(a, this) : (this.realloc(4), this.buf[this.pos++] = 127 & a | (a > 127 ? 128 : 0), a <= 127 || (this.buf[this.pos++] = 127 & (a >>>= 7) | (a > 127 ? 128 : 0), a <= 127 || (this.buf[this.pos++] = 127 & (a >>>= 7) | (a > 127 ? 128 : 0), a <= 127 || (this.buf[this.pos++] = a >>> 7 & 127))));
        }, writeSVarint: function(a) {
          this.writeVarint(a < 0 ? 2 * -a - 1 : 2 * a);
        }, writeBoolean: function(a) {
          this.writeVarint(!!a);
        }, writeString: function(a) {
          a = String(a), this.realloc(4 * a.length), this.pos++;
          var c = this.pos;
          this.pos = (function(x, S, M) {
            for (var O, N, G = 0; G < S.length; G++) {
              if ((O = S.charCodeAt(G)) > 55295 && O < 57344) {
                if (!N) {
                  O > 56319 || G + 1 === S.length ? (x[M++] = 239, x[M++] = 191, x[M++] = 189) : N = O;
                  continue;
                }
                if (O < 56320) {
                  x[M++] = 239, x[M++] = 191, x[M++] = 189, N = O;
                  continue;
                }
                O = N - 55296 << 10 | O - 56320 | 65536, N = null;
              } else N && (x[M++] = 239, x[M++] = 191, x[M++] = 189, N = null);
              O < 128 ? x[M++] = O : (O < 2048 ? x[M++] = O >> 6 | 192 : (O < 65536 ? x[M++] = O >> 12 | 224 : (x[M++] = O >> 18 | 240, x[M++] = O >> 12 & 63 | 128), x[M++] = O >> 6 & 63 | 128), x[M++] = 63 & O | 128);
            }
            return M;
          })(this.buf, a, this.pos);
          var p = this.pos - c;
          p >= 128 && s3(c, p, this), this.pos = c - 1, this.writeVarint(p), this.pos += p;
        }, writeFloat: function(a) {
          this.realloc(4), n3(this.buf, a, this.pos, !0, 23, 4), this.pos += 4;
        }, writeDouble: function(a) {
          this.realloc(8), n3(this.buf, a, this.pos, !0, 52, 8), this.pos += 8;
        }, writeBytes: function(a) {
          var c = a.length;
          this.writeVarint(c), this.realloc(c);
          for (var p = 0; p < c; p++) this.buf[this.pos++] = a[p];
        }, writeRawMessage: function(a, c) {
          this.pos++;
          var p = this.pos;
          a(c, this);
          var x = this.pos - p;
          x >= 128 && s3(p, x, this), this.pos = p - 1, this.writeVarint(x), this.pos += x;
        }, writeMessage: function(a, c, p) {
          this.writeTag(a, Yn.Bytes), this.writeRawMessage(c, p);
        }, writePackedVarint: function(a, c) {
          c.length && this.writeMessage(a, L8, c);
        }, writePackedSVarint: function(a, c) {
          c.length && this.writeMessage(a, k8, c);
        }, writePackedBoolean: function(a, c) {
          c.length && this.writeMessage(a, U8, c);
        }, writePackedFloat: function(a, c) {
          c.length && this.writeMessage(a, F8, c);
        }, writePackedDouble: function(a, c) {
          c.length && this.writeMessage(a, N8, c);
        }, writePackedFixed32: function(a, c) {
          c.length && this.writeMessage(a, z8, c);
        }, writePackedSFixed32: function(a, c) {
          c.length && this.writeMessage(a, V8, c);
        }, writePackedFixed64: function(a, c) {
          c.length && this.writeMessage(a, j8, c);
        }, writePackedSFixed64: function(a, c) {
          c.length && this.writeMessage(a, H8, c);
        }, writeBytesField: function(a, c) {
          this.writeTag(a, Yn.Bytes), this.writeBytes(c);
        }, writeFixed32Field: function(a, c) {
          this.writeTag(a, Yn.Fixed32), this.writeFixed32(c);
        }, writeSFixed32Field: function(a, c) {
          this.writeTag(a, Yn.Fixed32), this.writeSFixed32(c);
        }, writeFixed64Field: function(a, c) {
          this.writeTag(a, Yn.Fixed64), this.writeFixed64(c);
        }, writeSFixed64Field: function(a, c) {
          this.writeTag(a, Yn.Fixed64), this.writeSFixed64(c);
        }, writeVarintField: function(a, c) {
          this.writeTag(a, Yn.Varint), this.writeVarint(c);
        }, writeSVarintField: function(a, c) {
          this.writeTag(a, Yn.Varint), this.writeSVarint(c);
        }, writeStringField: function(a, c) {
          this.writeTag(a, Yn.Bytes), this.writeString(c);
        }, writeFloatField: function(a, c) {
          this.writeTag(a, Yn.Fixed32), this.writeFloat(c);
        }, writeDoubleField: function(a, c) {
          this.writeTag(a, Yn.Fixed64), this.writeDouble(c);
        }, writeBooleanField: function(a, c) {
          this.writeVarintField(a, !!c);
        } };
        var U0 = function(a, c) {
          var p = c.pixelRatio, x = c.version, S = c.stretchX, M = c.stretchY, O = c.content;
          this.paddedRect = a, this.pixelRatio = p, this.stretchX = S, this.stretchY = M, this.content = O, this.version = x;
        }, Jp = { tl: { configurable: !0 }, br: { configurable: !0 }, tlbr: { configurable: !0 }, displaySize: { configurable: !0 } };
        Jp.tl.get = function() {
          return [this.paddedRect.x + 1, this.paddedRect.y + 1];
        }, Jp.br.get = function() {
          return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
        }, Jp.tlbr.get = function() {
          return this.tl.concat(this.br);
        }, Jp.displaySize.get = function() {
          return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
        }, Object.defineProperties(U0.prototype, Jp);
        var eA = function(a, c) {
          var p = {}, x = {};
          this.haveRenderCallbacks = [];
          var S = [];
          this.addImages(a, p, S), this.addImages(c, x, S);
          var M = a3(S), O = new uo({ width: M.w || 1, height: M.h || 1 });
          for (var N in a) {
            var G = a[N], Z = p[N].paddedRect;
            uo.copy(G.data, O, { x: 0, y: 0 }, { x: Z.x + 1, y: Z.y + 1 }, G.data);
          }
          for (var te in c) {
            var se = c[te], he = x[te].paddedRect, xe = he.x + 1, Ve = he.y + 1, je = se.data.width, Qe = se.data.height;
            uo.copy(se.data, O, { x: 0, y: 0 }, { x: xe, y: Ve }, se.data), uo.copy(se.data, O, { x: 0, y: Qe - 1 }, { x: xe, y: Ve - 1 }, { width: je, height: 1 }), uo.copy(se.data, O, { x: 0, y: 0 }, { x: xe, y: Ve + Qe }, { width: je, height: 1 }), uo.copy(se.data, O, { x: je - 1, y: 0 }, { x: xe - 1, y: Ve }, { width: 1, height: Qe }), uo.copy(se.data, O, { x: 0, y: 0 }, { x: xe + je, y: Ve }, { width: 1, height: Qe });
          }
          this.image = O, this.iconPositions = p, this.patternPositions = x;
        };
        eA.prototype.addImages = function(a, c, p) {
          for (var x in a) {
            var S = a[x], M = { x: 0, y: 0, w: S.data.width + 2, h: S.data.height + 2 };
            p.push(M), c[x] = new U0(M, S), S.hasRenderCallback && this.haveRenderCallbacks.push(x);
          }
        }, eA.prototype.patchUpdatedImages = function(a, c) {
          for (var p in a.dispatchRenderCallbacks(this.haveRenderCallbacks), a.updatedImages) this.patchUpdatedImage(this.iconPositions[p], a.getImage(p), c), this.patchUpdatedImage(this.patternPositions[p], a.getImage(p), c);
        }, eA.prototype.patchUpdatedImage = function(a, c, p) {
          if (a && c && a.version !== c.version) {
            a.version = c.version;
            var x = a.tl;
            p.update(c.data, void 0, { x: x[0], y: x[1] });
          }
        }, ur("ImagePosition", U0), ur("ImageAtlas", eA);
        var Go = { horizontal: 1, vertical: 2, horizontalOnly: 3 }, Zh = function() {
          this.scale = 1, this.fontStack = "", this.imageName = null;
        };
        Zh.forText = function(a, c) {
          var p = new Zh();
          return p.scale = a || 1, p.fontStack = c, p;
        }, Zh.forImage = function(a) {
          var c = new Zh();
          return c.imageName = a, c;
        };
        var zs = function() {
          this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
        };
        function z0(a, c, p, x, S, M, O, N, G, Z, te, se, he, xe, Ve, je) {
          var Qe, Ye = zs.fromFeature(a, S);
          se === Go.vertical && Ye.verticalizePunctuation();
          var it = is.processBidirectionalText, pt = is.processStyledBidirectionalText;
          if (it && Ye.sections.length === 1) {
            Qe = [];
            for (var xt = 0, Tt = it(Ye.toString(), jy(Ye, Z, M, c, x, xe, Ve)); xt < Tt.length; xt += 1) {
              var Nt = Tt[xt], Kt = new zs();
              Kt.text = Nt, Kt.sections = Ye.sections;
              for (var rr = 0; rr < Nt.length; rr++) Kt.sectionIndex.push(0);
              Qe.push(Kt);
            }
          } else if (pt) {
            Qe = [];
            for (var Ir = 0, lr = pt(Ye.text, Ye.sectionIndex, jy(Ye, Z, M, c, x, xe, Ve)); Ir < lr.length; Ir += 1) {
              var Dr = lr[Ir], cr = new zs();
              cr.text = Dr[0], cr.sectionIndex = Dr[1], cr.sections = Ye.sections, Qe.push(cr);
            }
          } else Qe = (function(mr, yn) {
            for (var en = [], Cn = mr.text, Lr = 0, In = 0, ai = yn; In < ai.length; In += 1) {
              var Ti = ai[In];
              en.push(mr.substring(Lr, Ti)), Lr = Ti;
            }
            return Lr < Cn.length && en.push(mr.substring(Lr, Cn.length)), en;
          })(Ye, jy(Ye, Z, M, c, x, xe, Ve));
          var an = [], jr = { positionedLines: an, text: Ye.toString(), top: te[1], bottom: te[1], left: te[0], right: te[0], writingMode: se, iconsInText: !1, verticalizable: !1 };
          return (function(mr, yn, en, Cn, Lr, In, ai, Ti, mi, li, Ei, Yi) {
            for (var Ki = 0, Vs = -17, as = 0, js = 0, Pi = Ti === "right" ? 1 : Ti === "left" ? 0 : 0.5, ls = 0, bn = 0, Vn = Lr; bn < Vn.length; bn += 1) {
              var Ln = Vn[bn];
              Ln.trim();
              var Sn = Ln.getMaxScale(), Js = 24 * (Sn - 1), ws = { positionedGlyphs: [], lineOffset: 0 };
              mr.positionedLines[ls] = ws;
              var ti = ws.positionedGlyphs, ki = 0;
              if (Ln.length()) {
                for (var Ts = 0; Ts < Ln.length(); Ts++) {
                  var Pn = Ln.getSection(Ts), Hl = Ln.getSectionIndex(Ts), Wo = Ln.getCharCode(Ts), Gl = 0, Mi = null, Wl = null, Ia = null, nd = 24, Rf = !(mi === Go.horizontal || !Ei && !Ec(Wo) || Ei && (V0[Wo] || (kc = Wo, nr.Arabic(kc) || nr["Arabic Supplement"](kc) || nr["Arabic Extended-A"](kc) || nr["Arabic Presentation Forms-A"](kc) || nr["Arabic Presentation Forms-B"](kc))));
                  if (Pn.imageName) {
                    var id = Cn[Pn.imageName];
                    if (!id) continue;
                    Ia = Pn.imageName, mr.iconsInText = mr.iconsInText || !0, Wl = id.paddedRect;
                    var Lc = id.displaySize;
                    Pn.scale = 24 * Pn.scale / Yi, Gl = Js + (24 - Lc[1] * Pn.scale), nd = (Mi = { width: Lc[0], height: Lc[1], left: 1, top: -3, advance: Rf ? Lc[1] : Lc[0] }).advance;
                    var sd = Rf ? Lc[0] * Pn.scale - 24 * Sn : Lc[1] * Pn.scale - 24 * Sn;
                    sd > 0 && sd > ki && (ki = sd);
                  } else {
                    var Y0 = en[Pn.fontStack], od = Y0 && Y0[Wo];
                    if (od && od.rect) Wl = od.rect, Mi = od.metrics;
                    else {
                      var nA = yn[Pn.fontStack], K0 = nA && nA[Wo];
                      if (!K0) continue;
                      Mi = K0.metrics;
                    }
                    Gl = 24 * (Sn - Pn.scale);
                  }
                  Rf ? (mr.verticalizable = !0, ti.push({ glyph: Wo, imageName: Ia, x: Ki, y: Vs + Gl, vertical: Rf, scale: Pn.scale, fontStack: Pn.fontStack, sectionIndex: Hl, metrics: Mi, rect: Wl }), Ki += nd * Pn.scale + li) : (ti.push({ glyph: Wo, imageName: Ia, x: Ki, y: Vs + Gl, vertical: Rf, scale: Pn.scale, fontStack: Pn.fontStack, sectionIndex: Hl, metrics: Mi, rect: Wl }), Ki += Mi.advance * Pn.scale + li);
                }
                ti.length !== 0 && (as = Math.max(Ki - li, as), X8(ti, 0, ti.length - 1, Pi, ki)), Ki = 0;
                var Q0 = In * Sn + ki;
                ws.lineOffset = Math.max(ki, Js), Vs += Q0, js = Math.max(Q0, js), ++ls;
              } else Vs += In, ++ls;
            }
            var kc, iA = Vs - -17, ad = Hy(ai), Ru = ad.horizontalAlign, ld = ad.verticalAlign;
            (function(J0, eg, sA, oA, tg, aA, lA, cA, rg) {
              var cd, ng = (eg - sA) * tg;
              cd = aA !== lA ? -cA * oA - -17 : (-oA * rg + 0.5) * lA;
              for (var ud = 0, uA = J0; ud < uA.length; ud += 1) for (var Bf = 0, fA = uA[ud].positionedGlyphs; Bf < fA.length; Bf += 1) {
                var fd = fA[Bf];
                fd.x += ng, fd.y += cd;
              }
            })(mr.positionedLines, Pi, Ru, ld, as, js, In, iA, Lr.length), mr.top += -ld * iA, mr.bottom = mr.top + iA, mr.left += -Ru * as, mr.right = mr.left + as;
          })(jr, c, p, x, Qe, O, N, G, se, Z, he, je), !(function(mr) {
            for (var yn = 0, en = mr; yn < en.length; yn += 1) if (en[yn].positionedGlyphs.length !== 0) return !1;
            return !0;
          })(an) && jr;
        }
        zs.fromFeature = function(a, c) {
          for (var p = new zs(), x = 0; x < a.sections.length; x++) {
            var S = a.sections[x];
            S.image ? p.addImageSection(S) : p.addTextSection(S, c);
          }
          return p;
        }, zs.prototype.length = function() {
          return this.text.length;
        }, zs.prototype.getSection = function(a) {
          return this.sections[this.sectionIndex[a]];
        }, zs.prototype.getSectionIndex = function(a) {
          return this.sectionIndex[a];
        }, zs.prototype.getCharCode = function(a) {
          return this.text.charCodeAt(a);
        }, zs.prototype.verticalizePunctuation = function() {
          this.text = (function(a) {
            for (var c = "", p = 0; p < a.length; p++) {
              var x = a.charCodeAt(p + 1) || null, S = a.charCodeAt(p - 1) || null;
              c += x && yf(x) && !Qp[a[p + 1]] || S && yf(S) && !Qp[a[p - 1]] || !Qp[a[p]] ? a[p] : Qp[a[p]];
            }
            return c;
          })(this.text);
        }, zs.prototype.trim = function() {
          for (var a = 0, c = 0; c < this.text.length && V0[this.text.charCodeAt(c)]; c++) a++;
          for (var p = this.text.length, x = this.text.length - 1; x >= 0 && x >= a && V0[this.text.charCodeAt(x)]; x--) p--;
          this.text = this.text.substring(a, p), this.sectionIndex = this.sectionIndex.slice(a, p);
        }, zs.prototype.substring = function(a, c) {
          var p = new zs();
          return p.text = this.text.substring(a, c), p.sectionIndex = this.sectionIndex.slice(a, c), p.sections = this.sections, p;
        }, zs.prototype.toString = function() {
          return this.text;
        }, zs.prototype.getMaxScale = function() {
          var a = this;
          return this.sectionIndex.reduce((function(c, p) {
            return Math.max(c, a.sections[p].scale);
          }), 0);
        }, zs.prototype.addTextSection = function(a, c) {
          this.text += a.text, this.sections.push(Zh.forText(a.scale, a.fontStack || c));
          for (var p = this.sections.length - 1, x = 0; x < a.text.length; ++x) this.sectionIndex.push(p);
        }, zs.prototype.addImageSection = function(a) {
          var c = a.image ? a.image.name : "";
          if (c.length !== 0) {
            var p = this.getNextImageSectionCharCode();
            p ? (this.text += String.fromCharCode(p), this.sections.push(Zh.forImage(c)), this.sectionIndex.push(this.sections.length - 1)) : re("Reached maximum number of images 6401");
          } else re("Can't add FormattedSection with an empty image.");
        }, zs.prototype.getNextImageSectionCharCode = function() {
          return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
        };
        var V0 = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 }, Bo = {};
        function l3(a, c, p, x, S, M) {
          if (c.imageName) {
            var O = x[c.imageName];
            return O ? O.displaySize[0] * c.scale * 24 / M + S : 0;
          }
          var N = p[c.fontStack], G = N && N[a];
          return G ? G.metrics.advance * c.scale + S : 0;
        }
        function c3(a, c, p, x) {
          var S = Math.pow(a - c, 2);
          return x ? a < c ? S / 2 : 2 * S : S + Math.abs(p) * p;
        }
        function q8(a, c, p) {
          var x = 0;
          return a === 10 && (x -= 1e4), p && (x += 150), a !== 40 && a !== 65288 || (x += 50), c !== 41 && c !== 65289 || (x += 50), x;
        }
        function u3(a, c, p, x, S, M) {
          for (var O = null, N = c3(c, p, S, M), G = 0, Z = x; G < Z.length; G += 1) {
            var te = Z[G], se = c3(c - te.x, p, S, M) + te.badness;
            se <= N && (O = te, N = se);
          }
          return { index: a, x: c, priorBreak: O, badness: N };
        }
        function jy(a, c, p, x, S, M, O) {
          if (M !== "point") return [];
          if (!a) return [];
          for (var N, G = [], Z = (function(Qe, Ye, it, pt, xt, Tt) {
            for (var Nt = 0, Kt = 0; Kt < Qe.length(); Kt++) {
              var rr = Qe.getSection(Kt);
              Nt += l3(Qe.getCharCode(Kt), rr, pt, xt, Ye, Tt);
            }
            return Nt / Math.max(1, Math.ceil(Nt / it));
          })(a, c, p, x, S, O), te = a.text.indexOf("") >= 0, se = 0, he = 0; he < a.length(); he++) {
            var xe = a.getSection(he), Ve = a.getCharCode(he);
            if (V0[Ve] || (se += l3(Ve, xe, x, S, c, O)), he < a.length() - 1) {
              var je = !((N = Ve) < 11904 || !(nr["Bopomofo Extended"](N) || nr.Bopomofo(N) || nr["CJK Compatibility Forms"](N) || nr["CJK Compatibility Ideographs"](N) || nr["CJK Compatibility"](N) || nr["CJK Radicals Supplement"](N) || nr["CJK Strokes"](N) || nr["CJK Symbols and Punctuation"](N) || nr["CJK Unified Ideographs Extension A"](N) || nr["CJK Unified Ideographs"](N) || nr["Enclosed CJK Letters and Months"](N) || nr["Halfwidth and Fullwidth Forms"](N) || nr.Hiragana(N) || nr["Ideographic Description Characters"](N) || nr["Kangxi Radicals"](N) || nr["Katakana Phonetic Extensions"](N) || nr.Katakana(N) || nr["Vertical Forms"](N) || nr["Yi Radicals"](N) || nr["Yi Syllables"](N)));
              (Bo[Ve] || je || xe.imageName) && G.push(u3(he + 1, se, Z, G, q8(Ve, a.getCharCode(he + 1), je && te), !1));
            }
          }
          return (function Qe(Ye) {
            return Ye ? Qe(Ye.priorBreak).concat(Ye.index) : [];
          })(u3(a.length(), se, Z, G, 0, !0));
        }
        function Hy(a) {
          var c = 0.5, p = 0.5;
          switch (a) {
            case "right":
            case "top-right":
            case "bottom-right":
              c = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              c = 0;
          }
          switch (a) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              p = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              p = 0;
          }
          return { horizontalAlign: c, verticalAlign: p };
        }
        function X8(a, c, p, x, S) {
          if (x || S) for (var M = a[p], O = (a[p].x + M.metrics.advance * M.scale) * x, N = c; N <= p; N++) a[N].x -= O, a[N].y += S;
        }
        function f3(a, c, p, x, S, M) {
          var O, N = a.image;
          if (N.content) {
            var G = N.content, Z = N.pixelRatio || 1;
            O = [G[0] / Z, G[1] / Z, N.displaySize[0] - G[2] / Z, N.displaySize[1] - G[3] / Z];
          }
          var te, se, he, xe, Ve = c.left * M, je = c.right * M;
          p === "width" || p === "both" ? (xe = S[0] + Ve - x[3], se = S[0] + je + x[1]) : se = (xe = S[0] + (Ve + je - N.displaySize[0]) / 2) + N.displaySize[0];
          var Qe = c.top * M, Ye = c.bottom * M;
          return p === "height" || p === "both" ? (te = S[1] + Qe - x[0], he = S[1] + Ye + x[2]) : he = (te = S[1] + (Qe + Ye - N.displaySize[1]) / 2) + N.displaySize[1], { image: N, top: te, right: se, bottom: he, left: xe, collisionPadding: O };
        }
        Bo[10] = !0, Bo[32] = !0, Bo[38] = !0, Bo[40] = !0, Bo[41] = !0, Bo[43] = !0, Bo[45] = !0, Bo[47] = !0, Bo[173] = !0, Bo[183] = !0, Bo[8203] = !0, Bo[8208] = !0, Bo[8211] = !0, Bo[8231] = !0;
        var Yh = (function(a) {
          function c(p, x, S, M) {
            a.call(this, p, x), this.angle = S, M !== void 0 && (this.segment = M);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype.clone = function() {
            return new c(this.x, this.y, this.angle, this.segment);
          }, c;
        })(y);
        function Gy(a, c) {
          var p = c.expression;
          if (p.kind === "constant") return { kind: "constant", layoutSize: p.evaluate(new cn(a + 1)) };
          if (p.kind === "source") return { kind: "source" };
          for (var x = p.zoomStops, S = p.interpolationType, M = 0; M < x.length && x[M] <= a; ) M++;
          for (var O = M = Math.max(0, M - 1); O < x.length && x[O] < a + 1; ) O++;
          O = Math.min(x.length - 1, O);
          var N = x[M], G = x[O];
          return p.kind === "composite" ? { kind: "composite", minZoom: N, maxZoom: G, interpolationType: S } : { kind: "camera", minZoom: N, maxZoom: G, minSize: p.evaluate(new cn(N)), maxSize: p.evaluate(new cn(G)), interpolationType: S };
        }
        function h3(a, c, p) {
          var x = c.uSize, S = p.lowerSize;
          return a.kind === "source" ? S / 128 : a.kind === "composite" ? gi(S / 128, p.upperSize / 128, c.uSizeT) : x;
        }
        function d3(a, c) {
          var p = 0, x = 0;
          if (a.kind === "constant") x = a.layoutSize;
          else if (a.kind !== "source") {
            var S = a.interpolationType, M = S ? q(Ui.interpolationFactor(S, c, a.minZoom, a.maxZoom), 0, 1) : 0;
            a.kind === "camera" ? x = gi(a.minSize, a.maxSize, M) : p = M;
          }
          return { uSizeT: p, uSize: x };
        }
        ur("Anchor", Yh);
        var Z8 = Object.freeze({ __proto__: null, getSizeData: Gy, evaluateSizeForFeature: h3, evaluateSizeForZoom: d3, SIZE_PACK_FACTOR: 128 });
        function p3(a, c, p, x, S) {
          if (c.segment === void 0) return !0;
          for (var M = c, O = c.segment + 1, N = 0; N > -p / 2; ) {
            if (--O < 0) return !1;
            N -= a[O].dist(M), M = a[O];
          }
          N += a[O].dist(a[O + 1]), O++;
          for (var G = [], Z = 0; N < p / 2; ) {
            var te = a[O], se = a[O + 1];
            if (!se) return !1;
            var he = a[O - 1].angleTo(te) - te.angleTo(se);
            for (he = Math.abs((he + 3 * Math.PI) % (2 * Math.PI) - Math.PI), G.push({ distance: N, angleDelta: he }), Z += he; N - G[0].distance > x; ) Z -= G.shift().angleDelta;
            if (Z > S) return !1;
            O++, N += te.dist(se);
          }
          return !0;
        }
        function A3(a) {
          for (var c = 0, p = 0; p < a.length - 1; p++) c += a[p].dist(a[p + 1]);
          return c;
        }
        function g3(a, c, p) {
          return a ? 0.6 * c * p : 0;
        }
        function m3(a, c) {
          return Math.max(a ? a.right - a.left : 0, c ? c.right - c.left : 0);
        }
        function Y8(a, c, p, x, S, M) {
          for (var O = g3(p, S, M), N = m3(p, x) * M, G = 0, Z = A3(a) / 2, te = 0; te < a.length - 1; te++) {
            var se = a[te], he = a[te + 1], xe = se.dist(he);
            if (G + xe > Z) {
              var Ve = (Z - G) / xe, je = gi(se.x, he.x, Ve), Qe = gi(se.y, he.y, Ve), Ye = new Yh(je, Qe, he.angleTo(se), te);
              return Ye._round(), !O || p3(a, Ye, N, O, c) ? Ye : void 0;
            }
            G += xe;
          }
        }
        function K8(a, c, p, x, S, M, O, N, G) {
          var Z = g3(x, M, O), te = m3(x, S), se = te * O, he = a[0].x === 0 || a[0].x === G || a[0].y === 0 || a[0].y === G;
          return c - se < c / 4 && (c = se + c / 4), (function xe(Ve, je, Qe, Ye, it, pt, xt, Tt, Nt) {
            for (var Kt = pt / 2, rr = A3(Ve), Ir = 0, lr = je - Qe, Dr = [], cr = 0; cr < Ve.length - 1; cr++) {
              for (var an = Ve[cr], jr = Ve[cr + 1], mr = an.dist(jr), yn = jr.angleTo(an); lr + Qe < Ir + mr; ) {
                var en = ((lr += Qe) - Ir) / mr, Cn = gi(an.x, jr.x, en), Lr = gi(an.y, jr.y, en);
                if (Cn >= 0 && Cn < Nt && Lr >= 0 && Lr < Nt && lr - Kt >= 0 && lr + Kt <= rr) {
                  var In = new Yh(Cn, Lr, yn, cr);
                  In._round(), Ye && !p3(Ve, In, pt, Ye, it) || Dr.push(In);
                }
              }
              Ir += mr;
            }
            return Tt || Dr.length || xt || (Dr = xe(Ve, Ir / 2, Qe, Ye, it, pt, xt, !0, Nt)), Dr;
          })(a, he ? c / 2 * N % c : (te / 2 + 2 * M) * O * N % c, c, Z, p, se, he, !1, G);
        }
        function _3(a, c, p, x, S) {
          for (var M = [], O = 0; O < a.length; O++) for (var N = a[O], G = void 0, Z = 0; Z < N.length - 1; Z++) {
            var te = N[Z], se = N[Z + 1];
            te.x < c && se.x < c || (te.x < c ? te = new y(c, te.y + (c - te.x) / (se.x - te.x) * (se.y - te.y))._round() : se.x < c && (se = new y(c, te.y + (c - te.x) / (se.x - te.x) * (se.y - te.y))._round()), te.y < p && se.y < p || (te.y < p ? te = new y(te.x + (p - te.y) / (se.y - te.y) * (se.x - te.x), p)._round() : se.y < p && (se = new y(te.x + (p - te.y) / (se.y - te.y) * (se.x - te.x), p)._round()), te.x >= x && se.x >= x || (te.x >= x ? te = new y(x, te.y + (x - te.x) / (se.x - te.x) * (se.y - te.y))._round() : se.x >= x && (se = new y(x, te.y + (x - te.x) / (se.x - te.x) * (se.y - te.y))._round()), te.y >= S && se.y >= S || (te.y >= S ? te = new y(te.x + (S - te.y) / (se.y - te.y) * (se.x - te.x), S)._round() : se.y >= S && (se = new y(te.x + (S - te.y) / (se.y - te.y) * (se.x - te.x), S)._round()), G && te.equals(G[G.length - 1]) || M.push(G = [te]), G.push(se)))));
          }
          return M;
        }
        function y3(a, c, p, x) {
          var S = [], M = a.image, O = M.pixelRatio, N = M.paddedRect.w - 2, G = M.paddedRect.h - 2, Z = a.right - a.left, te = a.bottom - a.top, se = M.stretchX || [[0, N]], he = M.stretchY || [[0, G]], xe = function(Cn, Lr) {
            return Cn + Lr[1] - Lr[0];
          }, Ve = se.reduce(xe, 0), je = he.reduce(xe, 0), Qe = N - Ve, Ye = G - je, it = 0, pt = Ve, xt = 0, Tt = je, Nt = 0, Kt = Qe, rr = 0, Ir = Ye;
          if (M.content && x) {
            var lr = M.content;
            it = j0(se, 0, lr[0]), xt = j0(he, 0, lr[1]), pt = j0(se, lr[0], lr[2]), Tt = j0(he, lr[1], lr[3]), Nt = lr[0] - it, rr = lr[1] - xt, Kt = lr[2] - lr[0] - pt, Ir = lr[3] - lr[1] - Tt;
          }
          var Dr = function(Cn, Lr, In, ai) {
            var Ti = H0(Cn.stretch - it, pt, Z, a.left), mi = G0(Cn.fixed - Nt, Kt, Cn.stretch, Ve), li = H0(Lr.stretch - xt, Tt, te, a.top), Ei = G0(Lr.fixed - rr, Ir, Lr.stretch, je), Yi = H0(In.stretch - it, pt, Z, a.left), Ki = G0(In.fixed - Nt, Kt, In.stretch, Ve), Vs = H0(ai.stretch - xt, Tt, te, a.top), as = G0(ai.fixed - rr, Ir, ai.stretch, je), js = new y(Ti, li), Pi = new y(Yi, li), ls = new y(Yi, Vs), bn = new y(Ti, Vs), Vn = new y(mi / O, Ei / O), Ln = new y(Ki / O, as / O), Sn = c * Math.PI / 180;
            if (Sn) {
              var Js = Math.sin(Sn), ws = Math.cos(Sn), ti = [ws, -Js, Js, ws];
              js._matMult(ti), Pi._matMult(ti), bn._matMult(ti), ls._matMult(ti);
            }
            var ki = Cn.stretch + Cn.fixed, Ts = Lr.stretch + Lr.fixed;
            return { tl: js, tr: Pi, bl: bn, br: ls, tex: { x: M.paddedRect.x + 1 + ki, y: M.paddedRect.y + 1 + Ts, w: In.stretch + In.fixed - ki, h: ai.stretch + ai.fixed - Ts }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: Vn, pixelOffsetBR: Ln, minFontScaleX: Kt / O / Z, minFontScaleY: Ir / O / te, isSDF: p };
          };
          if (x && (M.stretchX || M.stretchY)) for (var cr = v3(se, Qe, Ve), an = v3(he, Ye, je), jr = 0; jr < cr.length - 1; jr++) for (var mr = cr[jr], yn = cr[jr + 1], en = 0; en < an.length - 1; en++) S.push(Dr(mr, an[en], yn, an[en + 1]));
          else S.push(Dr({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: N + 1 }, { fixed: 0, stretch: G + 1 }));
          return S;
        }
        function j0(a, c, p) {
          for (var x = 0, S = 0, M = a; S < M.length; S += 1) {
            var O = M[S];
            x += Math.max(c, Math.min(p, O[1])) - Math.max(c, Math.min(p, O[0]));
          }
          return x;
        }
        function v3(a, c, p) {
          for (var x = [{ fixed: -1, stretch: 0 }], S = 0, M = a; S < M.length; S += 1) {
            var O = M[S], N = O[0], G = O[1], Z = x[x.length - 1];
            x.push({ fixed: N - Z.stretch, stretch: Z.stretch }), x.push({ fixed: N - Z.stretch, stretch: Z.stretch + (G - N) });
          }
          return x.push({ fixed: c + 1, stretch: p }), x;
        }
        function H0(a, c, p, x) {
          return a / c * p + x;
        }
        function G0(a, c, p, x) {
          return a - c * p / x;
        }
        var W0 = function(a, c, p, x, S, M, O, N, G, Z) {
          if (this.boxStartIndex = a.length, G) {
            var te = M.top, se = M.bottom, he = M.collisionPadding;
            he && (te -= he[1], se += he[3]);
            var xe = se - te;
            xe > 0 && (xe = Math.max(10, xe), this.circleDiameter = xe);
          } else {
            var Ve = M.top * O - N, je = M.bottom * O + N, Qe = M.left * O - N, Ye = M.right * O + N, it = M.collisionPadding;
            if (it && (Qe -= it[0] * O, Ve -= it[1] * O, Ye += it[2] * O, je += it[3] * O), Z) {
              var pt = new y(Qe, Ve), xt = new y(Ye, Ve), Tt = new y(Qe, je), Nt = new y(Ye, je), Kt = Z * Math.PI / 180;
              pt._rotate(Kt), xt._rotate(Kt), Tt._rotate(Kt), Nt._rotate(Kt), Qe = Math.min(pt.x, xt.x, Tt.x, Nt.x), Ye = Math.max(pt.x, xt.x, Tt.x, Nt.x), Ve = Math.min(pt.y, xt.y, Tt.y, Nt.y), je = Math.max(pt.y, xt.y, Tt.y, Nt.y);
            }
            a.emplaceBack(c.x, c.y, Qe, Ve, Ye, je, p, x, S);
          }
          this.boxEndIndex = a.length;
        }, Kh = function(a, c) {
          if (a === void 0 && (a = []), c === void 0 && (c = Q8), this.data = a, this.length = this.data.length, this.compare = c, this.length > 0) for (var p = (this.length >> 1) - 1; p >= 0; p--) this._down(p);
        };
        function Q8(a, c) {
          return a < c ? -1 : a > c ? 1 : 0;
        }
        function J8(a, c, p) {
          p === void 0 && (p = !1);
          for (var x = 1 / 0, S = 1 / 0, M = -1 / 0, O = -1 / 0, N = a[0], G = 0; G < N.length; G++) {
            var Z = N[G];
            (!G || Z.x < x) && (x = Z.x), (!G || Z.y < S) && (S = Z.y), (!G || Z.x > M) && (M = Z.x), (!G || Z.y > O) && (O = Z.y);
          }
          var te = Math.min(M - x, O - S), se = te / 2, he = new Kh([], eN);
          if (te === 0) return new y(x, S);
          for (var xe = x; xe < M; xe += te) for (var Ve = S; Ve < O; Ve += te) he.push(new Qh(xe + se, Ve + se, se, a));
          for (var je = (function(it) {
            for (var pt = 0, xt = 0, Tt = 0, Nt = it[0], Kt = 0, rr = Nt.length, Ir = rr - 1; Kt < rr; Ir = Kt++) {
              var lr = Nt[Kt], Dr = Nt[Ir], cr = lr.x * Dr.y - Dr.x * lr.y;
              xt += (lr.x + Dr.x) * cr, Tt += (lr.y + Dr.y) * cr, pt += 3 * cr;
            }
            return new Qh(xt / pt, Tt / pt, 0, it);
          })(a), Qe = he.length; he.length; ) {
            var Ye = he.pop();
            (Ye.d > je.d || !je.d) && (je = Ye, p && console.log("found best %d after %d probes", Math.round(1e4 * Ye.d) / 1e4, Qe)), Ye.max - je.d <= c || (he.push(new Qh(Ye.p.x - (se = Ye.h / 2), Ye.p.y - se, se, a)), he.push(new Qh(Ye.p.x + se, Ye.p.y - se, se, a)), he.push(new Qh(Ye.p.x - se, Ye.p.y + se, se, a)), he.push(new Qh(Ye.p.x + se, Ye.p.y + se, se, a)), Qe += 4);
          }
          return p && (console.log("num probes: " + Qe), console.log("best distance: " + je.d)), je.p;
        }
        function eN(a, c) {
          return c.max - a.max;
        }
        function Qh(a, c, p, x) {
          this.p = new y(a, c), this.h = p, this.d = (function(S, M) {
            for (var O = !1, N = 1 / 0, G = 0; G < M.length; G++) for (var Z = M[G], te = 0, se = Z.length, he = se - 1; te < se; he = te++) {
              var xe = Z[te], Ve = Z[he];
              xe.y > S.y != Ve.y > S.y && S.x < (Ve.x - xe.x) * (S.y - xe.y) / (Ve.y - xe.y) + xe.x && (O = !O), N = Math.min(N, Su(S, xe, Ve));
            }
            return (O ? 1 : -1) * Math.sqrt(N);
          })(this.p, x), this.max = this.d + this.h * Math.SQRT2;
        }
        Kh.prototype.push = function(a) {
          this.data.push(a), this.length++, this._up(this.length - 1);
        }, Kh.prototype.pop = function() {
          if (this.length !== 0) {
            var a = this.data[0], c = this.data.pop();
            return this.length--, this.length > 0 && (this.data[0] = c, this._down(0)), a;
          }
        }, Kh.prototype.peek = function() {
          return this.data[0];
        }, Kh.prototype._up = function(a) {
          for (var c = this.data, p = this.compare, x = c[a]; a > 0; ) {
            var S = a - 1 >> 1, M = c[S];
            if (p(x, M) >= 0) break;
            c[a] = M, a = S;
          }
          c[a] = x;
        }, Kh.prototype._down = function(a) {
          for (var c = this.data, p = this.compare, x = this.length >> 1, S = c[a]; a < x; ) {
            var M = 1 + (a << 1), O = c[M], N = M + 1;
            if (N < this.length && p(c[N], O) < 0 && (M = N, O = c[N]), p(O, S) >= 0) break;
            c[a] = O, a = M;
          }
          c[a] = S;
        };
        var Wy = Number.POSITIVE_INFINITY;
        function b3(a, c) {
          return c[1] !== Wy ? (function(p, x, S) {
            var M = 0, O = 0;
            switch (x = Math.abs(x), S = Math.abs(S), p) {
              case "top-right":
              case "top-left":
              case "top":
                O = S - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                O = 7 - S;
            }
            switch (p) {
              case "top-right":
              case "bottom-right":
              case "right":
                M = -x;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                M = x;
            }
            return [M, O];
          })(a, c[0], c[1]) : (function(p, x) {
            var S = 0, M = 0;
            x < 0 && (x = 0);
            var O = x / Math.sqrt(2);
            switch (p) {
              case "top-right":
              case "top-left":
                M = O - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                M = 7 - O;
                break;
              case "bottom":
                M = 7 - x;
                break;
              case "top":
                M = x - 7;
            }
            switch (p) {
              case "top-right":
              case "bottom-right":
                S = -O;
                break;
              case "top-left":
              case "bottom-left":
                S = O;
                break;
              case "left":
                S = x;
                break;
              case "right":
                S = -x;
            }
            return [S, M];
          })(a, c[0]);
        }
        function $y(a) {
          switch (a) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function x3(a, c, p, x, S, M, O, N, G, Z, te, se, he, xe, Ve) {
          var je = (function(xt, Tt, Nt, Kt, rr, Ir, lr, Dr) {
            for (var cr = Kt.layout.get("text-rotate").evaluate(Ir, {}) * Math.PI / 180, an = [], jr = 0, mr = Tt.positionedLines; jr < mr.length; jr += 1) for (var yn = mr[jr], en = 0, Cn = yn.positionedGlyphs; en < Cn.length; en += 1) {
              var Lr = Cn[en];
              if (Lr.rect) {
                var In = Lr.rect || {}, ai = 4, Ti = !0, mi = 1, li = 0, Ei = (rr || Dr) && Lr.vertical, Yi = Lr.metrics.advance * Lr.scale / 2;
                if (Dr && Tt.verticalizable && (li = yn.lineOffset / 2 - (Lr.imageName ? -(24 - Lr.metrics.width * Lr.scale) / 2 : 24 * (Lr.scale - 1))), Lr.imageName) {
                  var Ki = lr[Lr.imageName];
                  Ti = Ki.sdf, ai = 1 / (mi = Ki.pixelRatio);
                }
                var Vs = rr ? [Lr.x + Yi, Lr.y] : [0, 0], as = rr ? [0, 0] : [Lr.x + Yi + Nt[0], Lr.y + Nt[1] - li], js = [0, 0];
                Ei && (js = as, as = [0, 0]);
                var Pi = (Lr.metrics.left - ai) * Lr.scale - Yi + as[0], ls = (-Lr.metrics.top - ai) * Lr.scale + as[1], bn = Pi + In.w * Lr.scale / mi, Vn = ls + In.h * Lr.scale / mi, Ln = new y(Pi, ls), Sn = new y(bn, ls), Js = new y(Pi, Vn), ws = new y(bn, Vn);
                if (Ei) {
                  var ti = new y(-Yi, Yi - -17), ki = -Math.PI / 2, Ts = 12 - Yi, Pn = new y(22 - Ts, -(Lr.imageName ? Ts : 0)), Hl = new (Function.prototype.bind.apply(y, [null].concat(js)))();
                  Ln._rotateAround(ki, ti)._add(Pn)._add(Hl), Sn._rotateAround(ki, ti)._add(Pn)._add(Hl), Js._rotateAround(ki, ti)._add(Pn)._add(Hl), ws._rotateAround(ki, ti)._add(Pn)._add(Hl);
                }
                if (cr) {
                  var Wo = Math.sin(cr), Gl = Math.cos(cr), Mi = [Gl, -Wo, Wo, Gl];
                  Ln._matMult(Mi), Sn._matMult(Mi), Js._matMult(Mi), ws._matMult(Mi);
                }
                var Wl = new y(0, 0), Ia = new y(0, 0);
                an.push({ tl: Ln, tr: Sn, bl: Js, br: ws, tex: In, writingMode: Tt.writingMode, glyphOffset: Vs, sectionIndex: Lr.sectionIndex, isSDF: Ti, pixelOffsetTL: Wl, pixelOffsetBR: Ia, minFontScaleX: 0, minFontScaleY: 0 });
              }
            }
            return an;
          })(0, p, N, S, M, O, x, a.allowVerticalPlacement), Qe = a.textSizeData, Ye = null;
          Qe.kind === "source" ? (Ye = [128 * S.layout.get("text-size").evaluate(O, {})])[0] > 32640 && re(a.layerIds[0] + ': Value for "text-size" is >= 255. Reduce your "text-size".') : Qe.kind === "composite" && ((Ye = [128 * xe.compositeTextSizes[0].evaluate(O, {}, Ve), 128 * xe.compositeTextSizes[1].evaluate(O, {}, Ve)])[0] > 32640 || Ye[1] > 32640) && re(a.layerIds[0] + ': Value for "text-size" is >= 255. Reduce your "text-size".'), a.addSymbols(a.text, je, Ye, N, M, O, Z, c, G.lineStartIndex, G.lineLength, he, Ve);
          for (var it = 0, pt = te; it < pt.length; it += 1) se[pt[it]] = a.text.placedSymbolArray.length - 1;
          return 4 * je.length;
        }
        function w3(a) {
          for (var c in a) return a[c];
          return null;
        }
        function tN(a, c, p, x) {
          var S = a.compareText;
          if (c in S) {
            for (var M = S[c], O = M.length - 1; O >= 0; O--) if (x.dist(M[O]) < p) return !0;
          } else S[c] = [];
          return S[c].push(x), !1;
        }
        var rN = $h.VectorTileFeature.types, nN = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
        function $0(a, c, p, x, S, M, O, N, G, Z, te, se, he) {
          var xe = N ? Math.min(32640, Math.round(N[0])) : 0, Ve = N ? Math.min(32640, Math.round(N[1])) : 0;
          a.emplaceBack(c, p, Math.round(32 * x), Math.round(32 * S), M, O, (xe << 1) + (G ? 1 : 0), Ve, 16 * Z, 16 * te, 256 * se, 256 * he);
        }
        function qy(a, c, p) {
          a.emplaceBack(c.x, c.y, p), a.emplaceBack(c.x, c.y, p), a.emplaceBack(c.x, c.y, p), a.emplaceBack(c.x, c.y, p);
        }
        function iN(a) {
          for (var c = 0, p = a.sections; c < p.length; c += 1) if (bu(p[c].text)) return !0;
          return !1;
        }
        var Jh = function(a) {
          this.layoutVertexArray = new Ic(), this.indexArray = new xs(), this.programConfigurations = a, this.segments = new Se(), this.dynamicLayoutVertexArray = new Ka(), this.opacityVertexArray = new Nl(), this.placedSymbolArray = new w();
        };
        Jh.prototype.isEmpty = function() {
          return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
        }, Jh.prototype.upload = function(a, c, p, x) {
          this.isEmpty() || (p && (this.layoutVertexBuffer = a.createVertexBuffer(this.layoutVertexArray, M8.members), this.indexBuffer = a.createIndexBuffer(this.indexArray, c), this.dynamicLayoutVertexBuffer = a.createVertexBuffer(this.dynamicLayoutVertexArray, R8.members, !0), this.opacityVertexBuffer = a.createVertexBuffer(this.opacityVertexArray, nN, !0), this.opacityVertexBuffer.itemSize = 1), (p || x) && this.programConfigurations.upload(a));
        }, Jh.prototype.destroy = function() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
        }, ur("SymbolBuffers", Jh);
        var tA = function(a, c, p) {
          this.layoutVertexArray = new a(), this.layoutAttributes = c, this.indexArray = new p(), this.segments = new Se(), this.collisionVertexArray = new xf();
        };
        tA.prototype.upload = function(a) {
          this.layoutVertexBuffer = a.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = a.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = a.createVertexBuffer(this.collisionVertexArray, B8.members, !0);
        }, tA.prototype.destroy = function() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
        }, ur("CollisionBuffers", tA);
        var Nn = function(a) {
          this.collisionBoxArray = a.collisionBoxArray, this.zoom = a.zoom, this.overscaling = a.overscaling, this.layers = a.layers, this.layerIds = this.layers.map((function(M) {
            return M.id;
          })), this.index = a.index, this.pixelRatio = a.pixelRatio, this.sourceLayerIndex = a.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = Ro([]), this.placementViewportMatrix = Ro([]);
          var c = this.layers[0]._unevaluatedLayout._values;
          this.textSizeData = Gy(this.zoom, c["text-size"]), this.iconSizeData = Gy(this.zoom, c["icon-size"]);
          var p = this.layers[0].layout, x = p.get("symbol-sort-key"), S = p.get("symbol-z-order");
          this.canOverlap = p.get("text-allow-overlap") || p.get("icon-allow-overlap") || p.get("text-ignore-placement") || p.get("icon-ignore-placement"), this.sortFeaturesByKey = S !== "viewport-y" && x.constantOr(1) !== void 0, this.sortFeaturesByY = (S === "viewport-y" || S === "auto" && !this.sortFeaturesByKey) && this.canOverlap, p.get("symbol-placement") === "point" && (this.writingModes = p.get("text-writing-mode").map((function(M) {
            return Go[M];
          }))), this.stateDependentLayerIds = this.layers.filter((function(M) {
            return M.isStateDependent();
          })).map((function(M) {
            return M.id;
          })), this.sourceID = a.sourceID;
        };
        Nn.prototype.createArrays = function() {
          this.text = new Jh(new Ut(this.layers, this.zoom, (function(a) {
            return /^text/.test(a);
          }))), this.icon = new Jh(new Ut(this.layers, this.zoom, (function(a) {
            return /^icon/.test(a);
          }))), this.glyphOffsetArray = new k(), this.lineVertexArray = new H(), this.symbolInstances = new D();
        }, Nn.prototype.calculateGlyphDependencies = function(a, c, p, x, S) {
          for (var M = 0; M < a.length; M++) if (c[a.charCodeAt(M)] = !0, (p || x) && S) {
            var O = Qp[a.charAt(M)];
            O && (c[O.charCodeAt(0)] = !0);
          }
        }, Nn.prototype.populate = function(a, c, p) {
          var x = this.layers[0], S = x.layout, M = S.get("text-font"), O = S.get("text-field"), N = S.get("icon-image"), G = (O.value.kind !== "constant" || O.value.value instanceof ui && !O.value.value.isEmpty() || O.value.value.toString().length > 0) && (M.value.kind !== "constant" || M.value.value.length > 0), Z = N.value.kind !== "constant" || !!N.value.value || Object.keys(N.parameters).length > 0, te = S.get("symbol-sort-key");
          if (this.features = [], G || Z) {
            for (var se = c.iconDependencies, he = c.glyphDependencies, xe = c.availableImages, Ve = new cn(this.zoom), je = 0, Qe = a; je < Qe.length; je += 1) {
              var Ye = Qe[je], it = Ye.feature, pt = Ye.id, xt = Ye.index, Tt = Ye.sourceLayerIndex, Nt = x._featureFilter.needGeometry, Kt = jt(it, Nt);
              if (x._featureFilter.filter(Ve, Kt, p)) {
                Nt || (Kt.geometry = ar(it));
                var rr = void 0;
                if (G) {
                  var Ir = x.getValueAndResolveTokens("text-field", Kt, p, xe), lr = ui.factory(Ir);
                  iN(lr) && (this.hasRTLText = !0), (!this.hasRTLText || vf() === "unavailable" || this.hasRTLText && is.isParsed()) && (rr = D8(lr, x, Kt));
                }
                var Dr = void 0;
                if (Z) {
                  var cr = x.getValueAndResolveTokens("icon-image", Kt, p, xe);
                  Dr = cr instanceof Xn ? cr : Xn.fromString(cr);
                }
                if (rr || Dr) {
                  var an = this.sortFeaturesByKey ? te.evaluate(Kt, {}, p) : void 0;
                  if (this.features.push({ id: pt, text: rr, icon: Dr, index: xt, sourceLayerIndex: Tt, geometry: Kt.geometry, properties: it.properties, type: rN[it.type], sortKey: an }), Dr && (se[Dr.name] = !0), rr) {
                    var jr = M.evaluate(Kt, {}, p).join(","), mr = S.get("text-rotation-alignment") === "map" && S.get("symbol-placement") !== "point";
                    this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(Go.vertical) >= 0;
                    for (var yn = 0, en = rr.sections; yn < en.length; yn += 1) {
                      var Cn = en[yn];
                      if (Cn.image) se[Cn.image.name] = !0;
                      else {
                        var Lr = wo(rr.toString()), In = Cn.fontStack || jr, ai = he[In] = he[In] || {};
                        this.calculateGlyphDependencies(Cn.text, ai, mr, this.allowVerticalPlacement, Lr);
                      }
                    }
                  }
                }
              }
            }
            S.get("symbol-placement") === "line" && (this.features = (function(Ti) {
              var mi = {}, li = {}, Ei = [], Yi = 0;
              function Ki(ti) {
                Ei.push(Ti[ti]), Yi++;
              }
              function Vs(ti, ki, Ts) {
                var Pn = li[ti];
                return delete li[ti], li[ki] = Pn, Ei[Pn].geometry[0].pop(), Ei[Pn].geometry[0] = Ei[Pn].geometry[0].concat(Ts[0]), Pn;
              }
              function as(ti, ki, Ts) {
                var Pn = mi[ki];
                return delete mi[ki], mi[ti] = Pn, Ei[Pn].geometry[0].shift(), Ei[Pn].geometry[0] = Ts[0].concat(Ei[Pn].geometry[0]), Pn;
              }
              function js(ti, ki, Ts) {
                var Pn = Ts ? ki[0][ki[0].length - 1] : ki[0][0];
                return ti + ":" + Pn.x + ":" + Pn.y;
              }
              for (var Pi = 0; Pi < Ti.length; Pi++) {
                var ls = Ti[Pi], bn = ls.geometry, Vn = ls.text ? ls.text.toString() : null;
                if (Vn) {
                  var Ln = js(Vn, bn), Sn = js(Vn, bn, !0);
                  if (Ln in li && Sn in mi && li[Ln] !== mi[Sn]) {
                    var Js = as(Ln, Sn, bn), ws = Vs(Ln, Sn, Ei[Js].geometry);
                    delete mi[Ln], delete li[Sn], li[js(Vn, Ei[ws].geometry, !0)] = ws, Ei[Js].geometry = null;
                  } else Ln in li ? Vs(Ln, Sn, bn) : Sn in mi ? as(Ln, Sn, bn) : (Ki(Pi), mi[Ln] = Yi - 1, li[Sn] = Yi - 1);
                } else Ki(Pi);
              }
              return Ei.filter((function(ti) {
                return ti.geometry;
              }));
            })(this.features)), this.sortFeaturesByKey && this.features.sort((function(Ti, mi) {
              return Ti.sortKey - mi.sortKey;
            }));
          }
        }, Nn.prototype.update = function(a, c, p) {
          this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(a, c, this.layers, p), this.icon.programConfigurations.updatePaintArrays(a, c, this.layers, p));
        }, Nn.prototype.isEmpty = function() {
          return this.symbolInstances.length === 0 && !this.hasRTLText;
        }, Nn.prototype.uploadPending = function() {
          return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
        }, Nn.prototype.upload = function(a) {
          !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(a), this.iconCollisionBox.upload(a)), this.text.upload(a, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(a, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
        }, Nn.prototype.destroyDebugData = function() {
          this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
        }, Nn.prototype.destroy = function() {
          this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
        }, Nn.prototype.addToLineVertexArray = function(a, c) {
          var p = this.lineVertexArray.length;
          if (a.segment !== void 0) {
            for (var x = a.dist(c[a.segment + 1]), S = a.dist(c[a.segment]), M = {}, O = a.segment + 1; O < c.length; O++) M[O] = { x: c[O].x, y: c[O].y, tileUnitDistanceFromAnchor: x }, O < c.length - 1 && (x += c[O + 1].dist(c[O]));
            for (var N = a.segment || 0; N >= 0; N--) M[N] = { x: c[N].x, y: c[N].y, tileUnitDistanceFromAnchor: S }, N > 0 && (S += c[N - 1].dist(c[N]));
            for (var G = 0; G < c.length; G++) {
              var Z = M[G];
              this.lineVertexArray.emplaceBack(Z.x, Z.y, Z.tileUnitDistanceFromAnchor);
            }
          }
          return { lineStartIndex: p, lineLength: this.lineVertexArray.length - p };
        }, Nn.prototype.addSymbols = function(a, c, p, x, S, M, O, N, G, Z, te, se) {
          for (var he = a.indexArray, xe = a.layoutVertexArray, Ve = a.segments.prepareSegment(4 * c.length, xe, he, this.canOverlap ? M.sortKey : void 0), je = this.glyphOffsetArray.length, Qe = Ve.vertexLength, Ye = this.allowVerticalPlacement && O === Go.vertical ? Math.PI / 2 : 0, it = M.text && M.text.sections, pt = 0; pt < c.length; pt++) {
            var xt = c[pt], Tt = xt.tl, Nt = xt.tr, Kt = xt.bl, rr = xt.br, Ir = xt.tex, lr = xt.pixelOffsetTL, Dr = xt.pixelOffsetBR, cr = xt.minFontScaleX, an = xt.minFontScaleY, jr = xt.glyphOffset, mr = xt.isSDF, yn = xt.sectionIndex, en = Ve.vertexLength, Cn = jr[1];
            $0(xe, N.x, N.y, Tt.x, Cn + Tt.y, Ir.x, Ir.y, p, mr, lr.x, lr.y, cr, an), $0(xe, N.x, N.y, Nt.x, Cn + Nt.y, Ir.x + Ir.w, Ir.y, p, mr, Dr.x, lr.y, cr, an), $0(xe, N.x, N.y, Kt.x, Cn + Kt.y, Ir.x, Ir.y + Ir.h, p, mr, lr.x, Dr.y, cr, an), $0(xe, N.x, N.y, rr.x, Cn + rr.y, Ir.x + Ir.w, Ir.y + Ir.h, p, mr, Dr.x, Dr.y, cr, an), qy(a.dynamicLayoutVertexArray, N, Ye), he.emplaceBack(en, en + 1, en + 2), he.emplaceBack(en + 1, en + 2, en + 3), Ve.vertexLength += 4, Ve.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(jr[0]), pt !== c.length - 1 && yn === c[pt + 1].sectionIndex || a.programConfigurations.populatePaintArrays(xe.length, M, M.index, {}, se, it && it[yn]);
          }
          a.placedSymbolArray.emplaceBack(N.x, N.y, je, this.glyphOffsetArray.length - je, Qe, G, Z, N.segment, p ? p[0] : 0, p ? p[1] : 0, x[0], x[1], O, 0, !1, 0, te);
        }, Nn.prototype._addCollisionDebugVertex = function(a, c, p, x, S, M) {
          return c.emplaceBack(0, 0), a.emplaceBack(p.x, p.y, x, S, Math.round(M.x), Math.round(M.y));
        }, Nn.prototype.addCollisionDebugVertices = function(a, c, p, x, S, M, O) {
          var N = S.segments.prepareSegment(4, S.layoutVertexArray, S.indexArray), G = N.vertexLength, Z = S.layoutVertexArray, te = S.collisionVertexArray, se = O.anchorX, he = O.anchorY;
          this._addCollisionDebugVertex(Z, te, M, se, he, new y(a, c)), this._addCollisionDebugVertex(Z, te, M, se, he, new y(p, c)), this._addCollisionDebugVertex(Z, te, M, se, he, new y(p, x)), this._addCollisionDebugVertex(Z, te, M, se, he, new y(a, x)), N.vertexLength += 4;
          var xe = S.indexArray;
          xe.emplaceBack(G, G + 1), xe.emplaceBack(G + 1, G + 2), xe.emplaceBack(G + 2, G + 3), xe.emplaceBack(G + 3, G), N.primitiveLength += 4;
        }, Nn.prototype.addDebugCollisionBoxes = function(a, c, p, x) {
          for (var S = a; S < c; S++) {
            var M = this.collisionBoxArray.get(S);
            this.addCollisionDebugVertices(M.x1, M.y1, M.x2, M.y2, x ? this.textCollisionBox : this.iconCollisionBox, M.anchorPoint, p);
          }
        }, Nn.prototype.generateCollisionDebugBuffers = function() {
          this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new tA(Ul, t3.members, zl), this.iconCollisionBox = new tA(Ul, t3.members, zl);
          for (var a = 0; a < this.symbolInstances.length; a++) {
            var c = this.symbolInstances.get(a);
            this.addDebugCollisionBoxes(c.textBoxStartIndex, c.textBoxEndIndex, c, !0), this.addDebugCollisionBoxes(c.verticalTextBoxStartIndex, c.verticalTextBoxEndIndex, c, !0), this.addDebugCollisionBoxes(c.iconBoxStartIndex, c.iconBoxEndIndex, c, !1), this.addDebugCollisionBoxes(c.verticalIconBoxStartIndex, c.verticalIconBoxEndIndex, c, !1);
          }
        }, Nn.prototype._deserializeCollisionBoxesForSymbol = function(a, c, p, x, S, M, O, N, G) {
          for (var Z = {}, te = c; te < p; te++) {
            var se = a.get(te);
            Z.textBox = { x1: se.x1, y1: se.y1, x2: se.x2, y2: se.y2, anchorPointX: se.anchorPointX, anchorPointY: se.anchorPointY }, Z.textFeatureIndex = se.featureIndex;
            break;
          }
          for (var he = x; he < S; he++) {
            var xe = a.get(he);
            Z.verticalTextBox = { x1: xe.x1, y1: xe.y1, x2: xe.x2, y2: xe.y2, anchorPointX: xe.anchorPointX, anchorPointY: xe.anchorPointY }, Z.verticalTextFeatureIndex = xe.featureIndex;
            break;
          }
          for (var Ve = M; Ve < O; Ve++) {
            var je = a.get(Ve);
            Z.iconBox = { x1: je.x1, y1: je.y1, x2: je.x2, y2: je.y2, anchorPointX: je.anchorPointX, anchorPointY: je.anchorPointY }, Z.iconFeatureIndex = je.featureIndex;
            break;
          }
          for (var Qe = N; Qe < G; Qe++) {
            var Ye = a.get(Qe);
            Z.verticalIconBox = { x1: Ye.x1, y1: Ye.y1, x2: Ye.x2, y2: Ye.y2, anchorPointX: Ye.anchorPointX, anchorPointY: Ye.anchorPointY }, Z.verticalIconFeatureIndex = Ye.featureIndex;
            break;
          }
          return Z;
        }, Nn.prototype.deserializeCollisionBoxes = function(a) {
          this.collisionArrays = [];
          for (var c = 0; c < this.symbolInstances.length; c++) {
            var p = this.symbolInstances.get(c);
            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(a, p.textBoxStartIndex, p.textBoxEndIndex, p.verticalTextBoxStartIndex, p.verticalTextBoxEndIndex, p.iconBoxStartIndex, p.iconBoxEndIndex, p.verticalIconBoxStartIndex, p.verticalIconBoxEndIndex));
          }
        }, Nn.prototype.hasTextData = function() {
          return this.text.segments.get().length > 0;
        }, Nn.prototype.hasIconData = function() {
          return this.icon.segments.get().length > 0;
        }, Nn.prototype.hasDebugData = function() {
          return this.textCollisionBox && this.iconCollisionBox;
        }, Nn.prototype.hasTextCollisionBoxData = function() {
          return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
        }, Nn.prototype.hasIconCollisionBoxData = function() {
          return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
        }, Nn.prototype.addIndicesForPlacedSymbol = function(a, c) {
          for (var p = a.placedSymbolArray.get(c), x = p.vertexStartIndex + 4 * p.numGlyphs, S = p.vertexStartIndex; S < x; S += 4) a.indexArray.emplaceBack(S, S + 1, S + 2), a.indexArray.emplaceBack(S + 1, S + 2, S + 3);
        }, Nn.prototype.getSortedSymbolIndexes = function(a) {
          if (this.sortedAngle === a && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
          for (var c = Math.sin(a), p = Math.cos(a), x = [], S = [], M = [], O = 0; O < this.symbolInstances.length; ++O) {
            M.push(O);
            var N = this.symbolInstances.get(O);
            x.push(0 | Math.round(c * N.anchorX + p * N.anchorY)), S.push(N.featureIndex);
          }
          return M.sort((function(G, Z) {
            return x[G] - x[Z] || S[Z] - S[G];
          })), M;
        }, Nn.prototype.addToSortKeyRanges = function(a, c) {
          var p = this.sortKeyRanges[this.sortKeyRanges.length - 1];
          p && p.sortKey === c ? p.symbolInstanceEnd = a + 1 : this.sortKeyRanges.push({ sortKey: c, symbolInstanceStart: a, symbolInstanceEnd: a + 1 });
        }, Nn.prototype.sortFeatures = function(a) {
          var c = this;
          if (this.sortFeaturesByY && this.sortedAngle !== a && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
            this.symbolInstanceIndexes = this.getSortedSymbolIndexes(a), this.sortedAngle = a, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
            for (var p = 0, x = this.symbolInstanceIndexes; p < x.length; p += 1) {
              var S = this.symbolInstances.get(x[p]);
              this.featureSortOrder.push(S.featureIndex), [S.rightJustifiedTextSymbolIndex, S.centerJustifiedTextSymbolIndex, S.leftJustifiedTextSymbolIndex].forEach((function(M, O, N) {
                M >= 0 && N.indexOf(M) === O && c.addIndicesForPlacedSymbol(c.text, M);
              })), S.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, S.verticalPlacedTextSymbolIndex), S.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, S.placedIconSymbolIndex), S.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, S.verticalPlacedIconSymbolIndex);
            }
            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
          }
        }, ur("SymbolBucket", Nn, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Nn.MAX_GLYPHS = 65535, Nn.addDynamicAttributes = qy;
        var sN = new Xi({ "symbol-placement": new Mr(le.layout_symbol["symbol-placement"]), "symbol-spacing": new Mr(le.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Mr(le.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new Ar(le.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Mr(le.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new Mr(le.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new Mr(le.layout_symbol["icon-ignore-placement"]), "icon-optional": new Mr(le.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Mr(le.layout_symbol["icon-rotation-alignment"]), "icon-size": new Ar(le.layout_symbol["icon-size"]), "icon-text-fit": new Mr(le.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Mr(le.layout_symbol["icon-text-fit-padding"]), "icon-image": new Ar(le.layout_symbol["icon-image"]), "icon-rotate": new Ar(le.layout_symbol["icon-rotate"]), "icon-padding": new Mr(le.layout_symbol["icon-padding"]), "icon-keep-upright": new Mr(le.layout_symbol["icon-keep-upright"]), "icon-offset": new Ar(le.layout_symbol["icon-offset"]), "icon-anchor": new Ar(le.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Mr(le.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Mr(le.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Mr(le.layout_symbol["text-rotation-alignment"]), "text-field": new Ar(le.layout_symbol["text-field"]), "text-font": new Ar(le.layout_symbol["text-font"]), "text-size": new Ar(le.layout_symbol["text-size"]), "text-max-width": new Ar(le.layout_symbol["text-max-width"]), "text-line-height": new Mr(le.layout_symbol["text-line-height"]), "text-letter-spacing": new Ar(le.layout_symbol["text-letter-spacing"]), "text-justify": new Ar(le.layout_symbol["text-justify"]), "text-radial-offset": new Ar(le.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Mr(le.layout_symbol["text-variable-anchor"]), "text-anchor": new Ar(le.layout_symbol["text-anchor"]), "text-max-angle": new Mr(le.layout_symbol["text-max-angle"]), "text-writing-mode": new Mr(le.layout_symbol["text-writing-mode"]), "text-rotate": new Ar(le.layout_symbol["text-rotate"]), "text-padding": new Mr(le.layout_symbol["text-padding"]), "text-keep-upright": new Mr(le.layout_symbol["text-keep-upright"]), "text-transform": new Ar(le.layout_symbol["text-transform"]), "text-offset": new Ar(le.layout_symbol["text-offset"]), "text-allow-overlap": new Mr(le.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new Mr(le.layout_symbol["text-ignore-placement"]), "text-optional": new Mr(le.layout_symbol["text-optional"]) }), Xy = { paint: new Xi({ "icon-opacity": new Ar(le.paint_symbol["icon-opacity"]), "icon-color": new Ar(le.paint_symbol["icon-color"]), "icon-halo-color": new Ar(le.paint_symbol["icon-halo-color"]), "icon-halo-width": new Ar(le.paint_symbol["icon-halo-width"]), "icon-halo-blur": new Ar(le.paint_symbol["icon-halo-blur"]), "icon-translate": new Mr(le.paint_symbol["icon-translate"]), "icon-translate-anchor": new Mr(le.paint_symbol["icon-translate-anchor"]), "text-opacity": new Ar(le.paint_symbol["text-opacity"]), "text-color": new Ar(le.paint_symbol["text-color"], { runtimeType: Yt, getOverride: function(a) {
          return a.textColor;
        }, hasOverride: function(a) {
          return !!a.textColor;
        } }), "text-halo-color": new Ar(le.paint_symbol["text-halo-color"]), "text-halo-width": new Ar(le.paint_symbol["text-halo-width"]), "text-halo-blur": new Ar(le.paint_symbol["text-halo-blur"]), "text-translate": new Mr(le.paint_symbol["text-translate"]), "text-translate-anchor": new Mr(le.paint_symbol["text-translate-anchor"]) }), layout: sN }, ed = function(a) {
          this.type = a.property.overrides ? a.property.overrides.runtimeType : zt, this.defaultValue = a;
        };
        ed.prototype.evaluate = function(a) {
          if (a.formattedSection) {
            var c = this.defaultValue.property.overrides;
            if (c && c.hasOverride(a.formattedSection)) return c.getOverride(a.formattedSection);
          }
          return a.feature && a.featureState ? this.defaultValue.evaluate(a.feature, a.featureState) : this.defaultValue.property.specification.default;
        }, ed.prototype.eachChild = function(a) {
          this.defaultValue.isConstant() || a(this.defaultValue.value._styleExpression.expression);
        }, ed.prototype.outputDefined = function() {
          return !1;
        }, ed.prototype.serialize = function() {
          return null;
        }, ur("FormatSectionOverride", ed, { omit: ["defaultValue"] });
        var oN = (function(a) {
          function c(p) {
            a.call(this, p, Xy);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype.recalculate = function(p, x) {
            if (a.prototype.recalculate.call(this, p, x), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
              var S = this.layout.get("text-writing-mode");
              if (S) {
                for (var M = [], O = 0, N = S; O < N.length; O += 1) {
                  var G = N[O];
                  M.indexOf(G) < 0 && M.push(G);
                }
                this.layout._values["text-writing-mode"] = M;
              } else this.layout._values["text-writing-mode"] = ["horizontal"];
            }
            this._setPaintOverrides();
          }, c.prototype.getValueAndResolveTokens = function(p, x, S, M) {
            var O = this.layout.get(p).evaluate(x, {}, S, M), N = this._unevaluatedLayout._values[p];
            return N.isDataDriven() || Bn(N.value) || !O ? O : (function(G, Z) {
              return Z.replace(/{([^{}]+)}/g, (function(te, se) {
                return se in G ? String(G[se]) : "";
              }));
            })(x.properties, O);
          }, c.prototype.createBucket = function(p) {
            return new Nn(p);
          }, c.prototype.queryRadius = function() {
            return 0;
          }, c.prototype.queryIntersectsFeature = function() {
            return !1;
          }, c.prototype._setPaintOverrides = function() {
            for (var p = 0, x = Xy.paint.overridableProperties; p < x.length; p += 1) {
              var S = x[p];
              if (c.hasPaintOverride(this.layout, S)) {
                var M, O = this.paint.get(S), N = new ed(O), G = new jo(N, O.property.specification);
                M = O.value.kind === "constant" || O.value.kind === "source" ? new Ml("source", G) : new Xa("composite", G, O.value.zoomStops, O.value._interpolationType), this.paint._values[S] = new cs(O.property, M, O.parameters);
              }
            }
          }, c.prototype._handleOverridablePaintPropertyUpdate = function(p, x, S) {
            return !(!this.layout || x.isDataDriven() || S.isDataDriven()) && c.hasPaintOverride(this.layout, p);
          }, c.hasPaintOverride = function(p, x) {
            var S = p.get("text-field"), M = Xy.paint.properties[x], O = !1, N = function(te) {
              for (var se = 0, he = te; se < he.length; se += 1) if (M.overrides && M.overrides.hasOverride(he[se])) return void (O = !0);
            };
            if (S.value.kind === "constant" && S.value.value instanceof ui) N(S.value.value.sections);
            else if (S.value.kind === "source") {
              var G = function(te) {
                O || (te instanceof Oi && Zn(te.value) === un ? N(te.value.sections) : te instanceof ms ? N(te.sections) : te.eachChild(G));
              }, Z = S.value;
              Z._styleExpression && G(Z._styleExpression.expression);
            }
            return O;
          }, c;
        })(Ho), aN = { paint: new Xi({ "background-color": new Mr(le.paint_background["background-color"]), "background-pattern": new us(le.paint_background["background-pattern"]), "background-opacity": new Mr(le.paint_background["background-opacity"]) }) }, lN = (function(a) {
          function c(p) {
            a.call(this, p, aN);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c;
        })(Ho), cN = { paint: new Xi({ "raster-opacity": new Mr(le.paint_raster["raster-opacity"]), "raster-hue-rotate": new Mr(le.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Mr(le.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Mr(le.paint_raster["raster-brightness-max"]), "raster-saturation": new Mr(le.paint_raster["raster-saturation"]), "raster-contrast": new Mr(le.paint_raster["raster-contrast"]), "raster-resampling": new Mr(le.paint_raster["raster-resampling"]), "raster-fade-duration": new Mr(le.paint_raster["raster-fade-duration"]) }) }, uN = (function(a) {
          function c(p) {
            a.call(this, p, cN);
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c;
        })(Ho), fN = (function(a) {
          function c(p) {
            a.call(this, p, {}), this.implementation = p;
          }
          return a && (c.__proto__ = a), (c.prototype = Object.create(a && a.prototype)).constructor = c, c.prototype.is3D = function() {
            return this.implementation.renderingMode === "3d";
          }, c.prototype.hasOffscreenPass = function() {
            return this.implementation.prerender !== void 0;
          }, c.prototype.recalculate = function() {
          }, c.prototype.updateTransitions = function() {
          }, c.prototype.hasTransition = function() {
          }, c.prototype.serialize = function() {
          }, c.prototype.onAdd = function(p) {
            this.implementation.onAdd && this.implementation.onAdd(p, p.painter.context.gl);
          }, c.prototype.onRemove = function(p) {
            this.implementation.onRemove && this.implementation.onRemove(p, p.painter.context.gl);
          }, c;
        })(Ho), hN = { circle: By, heatmap: ZF, hillshade: KF, fill: p8, "fill-extrusion": w8, line: P8, symbol: oN, background: lN, raster: uN }, T3 = P.HTMLImageElement, E3 = P.HTMLCanvasElement, C3 = P.HTMLVideoElement, S3 = P.ImageData, q0 = P.ImageBitmap, If = function(a, c, p, x) {
          this.context = a, this.format = p, this.texture = a.gl.createTexture(), this.update(c, x);
        };
        If.prototype.update = function(a, c, p) {
          var x = a.width, S = a.height, M = !(this.size && this.size[0] === x && this.size[1] === S || p), O = this.context, N = O.gl;
          if (this.useMipmap = !!(c && c.useMipmap), N.bindTexture(N.TEXTURE_2D, this.texture), O.pixelStoreUnpackFlipY.set(!1), O.pixelStoreUnpack.set(1), O.pixelStoreUnpackPremultiplyAlpha.set(this.format === N.RGBA && (!c || c.premultiply !== !1)), M) this.size = [x, S], a instanceof T3 || a instanceof E3 || a instanceof C3 || a instanceof S3 || q0 && a instanceof q0 ? N.texImage2D(N.TEXTURE_2D, 0, this.format, this.format, N.UNSIGNED_BYTE, a) : N.texImage2D(N.TEXTURE_2D, 0, this.format, x, S, 0, this.format, N.UNSIGNED_BYTE, a.data);
          else {
            var G = p || { x: 0, y: 0 }, Z = G.x, te = G.y;
            a instanceof T3 || a instanceof E3 || a instanceof C3 || a instanceof S3 || q0 && a instanceof q0 ? N.texSubImage2D(N.TEXTURE_2D, 0, Z, te, N.RGBA, N.UNSIGNED_BYTE, a) : N.texSubImage2D(N.TEXTURE_2D, 0, Z, te, x, S, N.RGBA, N.UNSIGNED_BYTE, a.data);
          }
          this.useMipmap && this.isSizePowerOfTwo() && N.generateMipmap(N.TEXTURE_2D);
        }, If.prototype.bind = function(a, c, p) {
          var x = this.context.gl;
          x.bindTexture(x.TEXTURE_2D, this.texture), p !== x.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (p = x.LINEAR), a !== this.filter && (x.texParameteri(x.TEXTURE_2D, x.TEXTURE_MAG_FILTER, a), x.texParameteri(x.TEXTURE_2D, x.TEXTURE_MIN_FILTER, p || a), this.filter = a), c !== this.wrap && (x.texParameteri(x.TEXTURE_2D, x.TEXTURE_WRAP_S, c), x.texParameteri(x.TEXTURE_2D, x.TEXTURE_WRAP_T, c), this.wrap = c);
        }, If.prototype.isSizePowerOfTwo = function() {
          return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
        }, If.prototype.destroy = function() {
          this.context.gl.deleteTexture(this.texture), this.texture = null;
        };
        var Zy = function(a) {
          var c = this;
          this._callback = a, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = function() {
            c._triggered = !1, c._callback();
          });
        };
        Zy.prototype.trigger = function() {
          var a = this;
          this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout((function() {
            a._triggered = !1, a._callback();
          }), 0));
        }, Zy.prototype.remove = function() {
          delete this._channel, this._callback = function() {
          };
        };
        var td = function(a, c, p) {
          this.target = a, this.parent = c, this.mapId = p, this.callbacks = {}, this.tasks = {}, this.taskQueue = [], this.cancelCallbacks = {}, De(["receive", "process"], this), this.invoker = new Zy(this.process), this.target.addEventListener("message", this.receive, !1), this.globalScope = be() ? a : P;
        };
        function I3(a, c, p) {
          var x = 2 * Math.PI * 6378137 / 256 / Math.pow(2, p);
          return [a * x - 2 * Math.PI * 6378137 / 2, c * x - 2 * Math.PI * 6378137 / 2];
        }
        td.prototype.send = function(a, c, p, x, S) {
          var M = this;
          S === void 0 && (S = !1);
          var O = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
          p && (this.callbacks[O] = p);
          var N = lt(this.globalScope) ? void 0 : [];
          return this.target.postMessage({ id: O, type: a, hasCallback: !!p, targetMapId: x, mustQueue: S, sourceMapId: this.mapId, data: xo(c, N) }, N), { cancel: function() {
            p && delete M.callbacks[O], M.target.postMessage({ id: O, type: "<cancel>", targetMapId: x, sourceMapId: M.mapId });
          } };
        }, td.prototype.receive = function(a) {
          var c = a.data, p = c.id;
          if (p && (!c.targetMapId || this.mapId === c.targetMapId)) if (c.type === "<cancel>") {
            delete this.tasks[p];
            var x = this.cancelCallbacks[p];
            delete this.cancelCallbacks[p], x && x();
          } else be() || c.mustQueue ? (this.tasks[p] = c, this.taskQueue.push(p), this.invoker.trigger()) : this.processTask(p, c);
        }, td.prototype.process = function() {
          if (this.taskQueue.length) {
            var a = this.taskQueue.shift(), c = this.tasks[a];
            delete this.tasks[a], this.taskQueue.length && this.invoker.trigger(), c && this.processTask(a, c);
          }
        }, td.prototype.processTask = function(a, c) {
          var p = this;
          if (c.type === "<response>") {
            var x = this.callbacks[a];
            delete this.callbacks[a], x && (c.error ? x(bs(c.error)) : x(null, bs(c.data)));
          } else {
            var S = !1, M = lt(this.globalScope) ? void 0 : [], O = c.hasCallback ? function(te, se) {
              S = !0, delete p.cancelCallbacks[a], p.target.postMessage({ id: a, type: "<response>", sourceMapId: p.mapId, error: te ? xo(te) : null, data: xo(se, M) }, M);
            } : function(te) {
              S = !0;
            }, N = null, G = bs(c.data);
            if (this.parent[c.type]) N = this.parent[c.type](c.sourceMapId, G, O);
            else if (this.parent.getWorkerSource) {
              var Z = c.type.split(".");
              N = this.parent.getWorkerSource(c.sourceMapId, Z[0], G.source)[Z[1]](G, O);
            } else O(new Error("Could not find function " + c.type));
            !S && N && N.cancel && (this.cancelCallbacks[a] = N.cancel);
          }
        }, td.prototype.remove = function() {
          this.invoker.remove(), this.target.removeEventListener("message", this.receive, !1);
        };
        var Hi = function(a, c) {
          a && (c ? this.setSouthWest(a).setNorthEast(c) : a.length === 4 ? this.setSouthWest([a[0], a[1]]).setNorthEast([a[2], a[3]]) : this.setSouthWest(a[0]).setNorthEast(a[1]));
        };
        Hi.prototype.setNorthEast = function(a) {
          return this._ne = a instanceof oi ? new oi(a.lng, a.lat) : oi.convert(a), this;
        }, Hi.prototype.setSouthWest = function(a) {
          return this._sw = a instanceof oi ? new oi(a.lng, a.lat) : oi.convert(a), this;
        }, Hi.prototype.extend = function(a) {
          var c, p, x = this._sw, S = this._ne;
          if (a instanceof oi) c = a, p = a;
          else {
            if (!(a instanceof Hi)) return Array.isArray(a) ? a.length === 4 || a.every(Array.isArray) ? this.extend(Hi.convert(a)) : this.extend(oi.convert(a)) : this;
            if (p = a._ne, !(c = a._sw) || !p) return this;
          }
          return x || S ? (x.lng = Math.min(c.lng, x.lng), x.lat = Math.min(c.lat, x.lat), S.lng = Math.max(p.lng, S.lng), S.lat = Math.max(p.lat, S.lat)) : (this._sw = new oi(c.lng, c.lat), this._ne = new oi(p.lng, p.lat)), this;
        }, Hi.prototype.getCenter = function() {
          return new oi((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
        }, Hi.prototype.getSouthWest = function() {
          return this._sw;
        }, Hi.prototype.getNorthEast = function() {
          return this._ne;
        }, Hi.prototype.getNorthWest = function() {
          return new oi(this.getWest(), this.getNorth());
        }, Hi.prototype.getSouthEast = function() {
          return new oi(this.getEast(), this.getSouth());
        }, Hi.prototype.getWest = function() {
          return this._sw.lng;
        }, Hi.prototype.getSouth = function() {
          return this._sw.lat;
        }, Hi.prototype.getEast = function() {
          return this._ne.lng;
        }, Hi.prototype.getNorth = function() {
          return this._ne.lat;
        }, Hi.prototype.toArray = function() {
          return [this._sw.toArray(), this._ne.toArray()];
        }, Hi.prototype.toString = function() {
          return "LngLatBounds(" + this._sw.toString() + ", " + this._ne.toString() + ")";
        }, Hi.prototype.isEmpty = function() {
          return !(this._sw && this._ne);
        }, Hi.prototype.contains = function(a) {
          var c = oi.convert(a), p = c.lng, x = c.lat, S = this._sw.lng <= p && p <= this._ne.lng;
          return this._sw.lng > this._ne.lng && (S = this._sw.lng >= p && p >= this._ne.lng), this._sw.lat <= x && x <= this._ne.lat && S;
        }, Hi.convert = function(a) {
          return !a || a instanceof Hi ? a : new Hi(a);
        };
        var oi = function(a, c) {
          if (isNaN(a) || isNaN(c)) throw new Error("Invalid LngLat object: (" + a + ", " + c + ")");
          if (this.lng = +a, this.lat = +c, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
        };
        oi.prototype.wrap = function() {
          return new oi(j(this.lng, -180, 180), this.lat);
        }, oi.prototype.toArray = function() {
          return [this.lng, this.lat];
        }, oi.prototype.toString = function() {
          return "LngLat(" + this.lng + ", " + this.lat + ")";
        }, oi.prototype.distanceTo = function(a) {
          var c = Math.PI / 180, p = this.lat * c, x = a.lat * c, S = Math.sin(p) * Math.sin(x) + Math.cos(p) * Math.cos(x) * Math.cos((a.lng - this.lng) * c);
          return 63710088e-1 * Math.acos(Math.min(S, 1));
        }, oi.prototype.toBounds = function(a) {
          a === void 0 && (a = 0);
          var c = 360 * a / 40075017, p = c / Math.cos(Math.PI / 180 * this.lat);
          return new Hi(new oi(this.lng - p, this.lat - c), new oi(this.lng + p, this.lat + c));
        }, oi.convert = function(a) {
          if (a instanceof oi) return a;
          if (Array.isArray(a) && (a.length === 2 || a.length === 3)) return new oi(Number(a[0]), Number(a[1]));
          if (!Array.isArray(a) && typeof a == "object" && a !== null) return new oi(Number("lng" in a ? a.lng : a.lon), Number(a.lat));
          throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
        };
        var P3 = 2 * Math.PI * 63710088e-1;
        function M3(a) {
          return P3 * Math.cos(a * Math.PI / 180);
        }
        function R3(a) {
          return (180 + a) / 360;
        }
        function B3(a) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + a * Math.PI / 360))) / 360;
        }
        function O3(a, c) {
          return a / M3(c);
        }
        function Yy(a) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * a) * Math.PI / 180)) - 90;
        }
        var Pf = function(a, c, p) {
          p === void 0 && (p = 0), this.x = +a, this.y = +c, this.z = +p;
        };
        Pf.fromLngLat = function(a, c) {
          c === void 0 && (c = 0);
          var p = oi.convert(a);
          return new Pf(R3(p.lng), B3(p.lat), O3(c, p.lat));
        }, Pf.prototype.toLngLat = function() {
          return new oi(360 * this.x - 180, Yy(this.y));
        }, Pf.prototype.toAltitude = function() {
          return this.z * M3(Yy(this.y));
        }, Pf.prototype.meterInMercatorCoordinateUnits = function() {
          return 1 / P3 * (a = Yy(this.y), 1 / Math.cos(a * Math.PI / 180));
          var a;
        };
        var Mf = function(a, c, p) {
          this.z = a, this.x = c, this.y = p, this.key = rA(0, a, a, c, p);
        };
        Mf.prototype.equals = function(a) {
          return this.z === a.z && this.x === a.x && this.y === a.y;
        }, Mf.prototype.url = function(a, c) {
          var p, x, S, M, O, N = (x = this.y, S = this.z, M = I3(256 * (p = this.x), 256 * (x = Math.pow(2, S) - x - 1), S), O = I3(256 * (p + 1), 256 * (x + 1), S), M[0] + "," + M[1] + "," + O[0] + "," + O[1]), G = (function(Z, te, se) {
            for (var he, xe = "", Ve = Z; Ve > 0; Ve--) xe += (te & (he = 1 << Ve - 1) ? 1 : 0) + (se & he ? 2 : 0);
            return xe;
          })(this.z, this.x, this.y);
          return a[(this.x + this.y) % a.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace("{z}", String(this.z)).replace("{x}", String(this.x)).replace("{y}", String(c === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", G).replace("{bbox-epsg-3857}", N);
        }, Mf.prototype.getTilePoint = function(a) {
          var c = Math.pow(2, this.z);
          return new y(8192 * (a.x * c - this.x), 8192 * (a.y * c - this.y));
        }, Mf.prototype.toString = function() {
          return this.z + "/" + this.x + "/" + this.y;
        };
        var D3 = function(a, c) {
          this.wrap = a, this.canonical = c, this.key = rA(a, c.z, c.z, c.x, c.y);
        }, Gi = function(a, c, p, x, S) {
          this.overscaledZ = a, this.wrap = c, this.canonical = new Mf(p, +x, +S), this.key = rA(c, a, p, x, S);
        };
        function rA(a, c, p, x, S) {
          (a *= 2) < 0 && (a = -1 * a - 1);
          var M = 1 << p;
          return (M * M * a + M * S + x).toString(36) + p.toString(36) + c.toString(36);
        }
        Gi.prototype.equals = function(a) {
          return this.overscaledZ === a.overscaledZ && this.wrap === a.wrap && this.canonical.equals(a.canonical);
        }, Gi.prototype.scaledTo = function(a) {
          var c = this.canonical.z - a;
          return a > this.canonical.z ? new Gi(a, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Gi(a, this.wrap, a, this.canonical.x >> c, this.canonical.y >> c);
        }, Gi.prototype.calculateScaledKey = function(a, c) {
          var p = this.canonical.z - a;
          return a > this.canonical.z ? rA(this.wrap * +c, a, this.canonical.z, this.canonical.x, this.canonical.y) : rA(this.wrap * +c, a, a, this.canonical.x >> p, this.canonical.y >> p);
        }, Gi.prototype.isChildOf = function(a) {
          if (a.wrap !== this.wrap) return !1;
          var c = this.canonical.z - a.canonical.z;
          return a.overscaledZ === 0 || a.overscaledZ < this.overscaledZ && a.canonical.x === this.canonical.x >> c && a.canonical.y === this.canonical.y >> c;
        }, Gi.prototype.children = function(a) {
          if (this.overscaledZ >= a) return [new Gi(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
          var c = this.canonical.z + 1, p = 2 * this.canonical.x, x = 2 * this.canonical.y;
          return [new Gi(c, this.wrap, c, p, x), new Gi(c, this.wrap, c, p + 1, x), new Gi(c, this.wrap, c, p, x + 1), new Gi(c, this.wrap, c, p + 1, x + 1)];
        }, Gi.prototype.isLessThan = function(a) {
          return this.wrap < a.wrap || !(this.wrap > a.wrap) && (this.overscaledZ < a.overscaledZ || !(this.overscaledZ > a.overscaledZ) && (this.canonical.x < a.canonical.x || !(this.canonical.x > a.canonical.x) && this.canonical.y < a.canonical.y));
        }, Gi.prototype.wrapped = function() {
          return new Gi(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
        }, Gi.prototype.unwrapTo = function(a) {
          return new Gi(this.overscaledZ, a, this.canonical.z, this.canonical.x, this.canonical.y);
        }, Gi.prototype.overscaleFactor = function() {
          return Math.pow(2, this.overscaledZ - this.canonical.z);
        }, Gi.prototype.toUnwrapped = function() {
          return new D3(this.wrap, this.canonical);
        }, Gi.prototype.toString = function() {
          return this.overscaledZ + "/" + this.canonical.x + "/" + this.canonical.y;
        }, Gi.prototype.getTilePoint = function(a) {
          return this.canonical.getTilePoint(new Pf(a.x - this.wrap, a.y));
        }, ur("CanonicalTileID", Mf), ur("OverscaledTileID", Gi, { omit: ["posMatrix"] });
        var Oc = function(a, c, p) {
          if (this.uid = a, c.height !== c.width) throw new RangeError("DEM tiles must be square");
          if (p && p !== "mapbox" && p !== "terrarium") return re('"' + p + '" is not a valid encoding type. Valid types include "mapbox" and "terrarium".');
          this.stride = c.height;
          var x = this.dim = c.height - 2;
          this.data = new Uint32Array(c.data.buffer), this.encoding = p || "mapbox";
          for (var S = 0; S < x; S++) this.data[this._idx(-1, S)] = this.data[this._idx(0, S)], this.data[this._idx(x, S)] = this.data[this._idx(x - 1, S)], this.data[this._idx(S, -1)] = this.data[this._idx(S, 0)], this.data[this._idx(S, x)] = this.data[this._idx(S, x - 1)];
          this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(x, -1)] = this.data[this._idx(x - 1, 0)], this.data[this._idx(-1, x)] = this.data[this._idx(0, x - 1)], this.data[this._idx(x, x)] = this.data[this._idx(x - 1, x - 1)];
        };
        Oc.prototype.get = function(a, c) {
          var p = new Uint8Array(this.data.buffer), x = 4 * this._idx(a, c);
          return (this.encoding === "terrarium" ? this._unpackTerrarium : this._unpackMapbox)(p[x], p[x + 1], p[x + 2]);
        }, Oc.prototype.getUnpackVector = function() {
          return this.encoding === "terrarium" ? [256, 1, 1 / 256, 32768] : [6553.6, 25.6, 0.1, 1e4];
        }, Oc.prototype._idx = function(a, c) {
          if (a < -1 || a >= this.dim + 1 || c < -1 || c >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
          return (c + 1) * this.stride + (a + 1);
        }, Oc.prototype._unpackMapbox = function(a, c, p) {
          return (256 * a * 256 + 256 * c + p) / 10 - 1e4;
        }, Oc.prototype._unpackTerrarium = function(a, c, p) {
          return 256 * a + c + p / 256 - 32768;
        }, Oc.prototype.getPixels = function() {
          return new uo({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
        }, Oc.prototype.backfillBorder = function(a, c, p) {
          if (this.dim !== a.dim) throw new Error("dem dimension mismatch");
          var x = c * this.dim, S = c * this.dim + this.dim, M = p * this.dim, O = p * this.dim + this.dim;
          switch (c) {
            case -1:
              x = S - 1;
              break;
            case 1:
              S = x + 1;
          }
          switch (p) {
            case -1:
              M = O - 1;
              break;
            case 1:
              O = M + 1;
          }
          for (var N = -c * this.dim, G = -p * this.dim, Z = M; Z < O; Z++) for (var te = x; te < S; te++) this.data[this._idx(te, Z)] = a.data[this._idx(te + N, Z + G)];
        }, ur("DEMData", Oc);
        var X0 = function(a) {
          this._stringToNumber = {}, this._numberToString = [];
          for (var c = 0; c < a.length; c++) {
            var p = a[c];
            this._stringToNumber[p] = c, this._numberToString[c] = p;
          }
        };
        X0.prototype.encode = function(a) {
          return this._stringToNumber[a];
        }, X0.prototype.decode = function(a) {
          return this._numberToString[a];
        };
        var Z0 = function(a, c, p, x, S) {
          this.type = "Feature", this._vectorTileFeature = a, a._z = c, a._x = p, a._y = x, this.properties = a.properties, this.id = S;
        }, Ky = { geometry: { configurable: !0 } };
        Ky.geometry.get = function() {
          return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
        }, Ky.geometry.set = function(a) {
          this._geometry = a;
        }, Z0.prototype.toJSON = function() {
          var a = { geometry: this.geometry };
          for (var c in this) c !== "_geometry" && c !== "_vectorTileFeature" && (a[c] = this[c]);
          return a;
        }, Object.defineProperties(Z0.prototype, Ky);
        var rd = function() {
          this.state = {}, this.stateChanges = {}, this.deletedStates = {};
        };
        rd.prototype.updateState = function(a, c, p) {
          var x = String(c);
          if (this.stateChanges[a] = this.stateChanges[a] || {}, this.stateChanges[a][x] = this.stateChanges[a][x] || {}, K(this.stateChanges[a][x], p), this.deletedStates[a] === null) for (var S in this.deletedStates[a] = {}, this.state[a]) S !== x && (this.deletedStates[a][S] = null);
          else if (this.deletedStates[a] && this.deletedStates[a][x] === null) for (var M in this.deletedStates[a][x] = {}, this.state[a][x]) p[M] || (this.deletedStates[a][x][M] = null);
          else for (var O in p) this.deletedStates[a] && this.deletedStates[a][x] && this.deletedStates[a][x][O] === null && delete this.deletedStates[a][x][O];
        }, rd.prototype.removeFeatureState = function(a, c, p) {
          if (this.deletedStates[a] !== null) {
            var x = String(c);
            if (this.deletedStates[a] = this.deletedStates[a] || {}, p && c !== void 0) this.deletedStates[a][x] !== null && (this.deletedStates[a][x] = this.deletedStates[a][x] || {}, this.deletedStates[a][x][p] = null);
            else if (c !== void 0) if (this.stateChanges[a] && this.stateChanges[a][x]) for (p in this.deletedStates[a][x] = {}, this.stateChanges[a][x]) this.deletedStates[a][x][p] = null;
            else this.deletedStates[a][x] = null;
            else this.deletedStates[a] = null;
          }
        }, rd.prototype.getState = function(a, c) {
          var p = String(c), x = K({}, (this.state[a] || {})[p], (this.stateChanges[a] || {})[p]);
          if (this.deletedStates[a] === null) return {};
          if (this.deletedStates[a]) {
            var S = this.deletedStates[a][c];
            if (S === null) return {};
            for (var M in S) delete x[M];
          }
          return x;
        }, rd.prototype.initializeTileState = function(a, c) {
          a.setFeatureState(this.state, c);
        }, rd.prototype.coalesceChanges = function(a, c) {
          var p = {};
          for (var x in this.stateChanges) {
            this.state[x] = this.state[x] || {};
            var S = {};
            for (var M in this.stateChanges[x]) this.state[x][M] || (this.state[x][M] = {}), K(this.state[x][M], this.stateChanges[x][M]), S[M] = this.state[x][M];
            p[x] = S;
          }
          for (var O in this.deletedStates) {
            this.state[O] = this.state[O] || {};
            var N = {};
            if (this.deletedStates[O] === null) for (var G in this.state[O]) N[G] = {}, this.state[O][G] = {};
            else for (var Z in this.deletedStates[O]) {
              if (this.deletedStates[O][Z] === null) this.state[O][Z] = {};
              else for (var te = 0, se = Object.keys(this.deletedStates[O][Z]); te < se.length; te += 1) delete this.state[O][Z][se[te]];
              N[Z] = this.state[O][Z];
            }
            p[O] = p[O] || {}, K(p[O], N);
          }
          if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(p).length !== 0) for (var he in a) a[he].setFeatureState(p, c);
        };
        var Dc = function(a, c) {
          this.tileID = a, this.x = a.canonical.x, this.y = a.canonical.y, this.z = a.canonical.z, this.grid = new ao(8192, 16, 0), this.grid3D = new ao(8192, 16, 0), this.featureIndexArray = new oe(), this.promoteId = c;
        };
        function L3(a, c, p, x, S) {
          return fe(a, (function(M, O) {
            var N = c instanceof Cc ? c.get(O) : null;
            return N && N.evaluate ? N.evaluate(p, x, S) : N;
          }));
        }
        function k3(a) {
          for (var c = 1 / 0, p = 1 / 0, x = -1 / 0, S = -1 / 0, M = 0, O = a; M < O.length; M += 1) {
            var N = O[M];
            c = Math.min(c, N.x), p = Math.min(p, N.y), x = Math.max(x, N.x), S = Math.max(S, N.y);
          }
          return { minX: c, minY: p, maxX: x, maxY: S };
        }
        function dN(a, c) {
          return c - a;
        }
        Dc.prototype.insert = function(a, c, p, x, S, M) {
          var O = this.featureIndexArray.length;
          this.featureIndexArray.emplaceBack(p, x, S);
          for (var N = M ? this.grid3D : this.grid, G = 0; G < c.length; G++) {
            for (var Z = c[G], te = [1 / 0, 1 / 0, -1 / 0, -1 / 0], se = 0; se < Z.length; se++) {
              var he = Z[se];
              te[0] = Math.min(te[0], he.x), te[1] = Math.min(te[1], he.y), te[2] = Math.max(te[2], he.x), te[3] = Math.max(te[3], he.y);
            }
            te[0] < 8192 && te[1] < 8192 && te[2] >= 0 && te[3] >= 0 && N.insert(O, te[0], te[1], te[2], te[3]);
          }
        }, Dc.prototype.loadVTLayers = function() {
          return this.vtLayers || (this.vtLayers = new $h.VectorTile(new F0(this.rawTileData)).layers, this.sourceLayerCoder = new X0(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
        }, Dc.prototype.query = function(a, c, p, x) {
          var S = this;
          this.loadVTLayers();
          for (var M = a.params || {}, O = 8192 / a.tileSize / a.scale, N = vs(M.filter), G = a.queryGeometry, Z = a.queryPadding * O, te = k3(G), se = this.grid.query(te.minX - Z, te.minY - Z, te.maxX + Z, te.maxY + Z), he = k3(a.cameraQueryGeometry), xe = this.grid3D.query(he.minX - Z, he.minY - Z, he.maxX + Z, he.maxY + Z, (function(xt, Tt, Nt, Kt) {
            return (function(rr, Ir, lr, Dr, cr) {
              for (var an = 0, jr = rr; an < jr.length; an += 1) {
                var mr = jr[an];
                if (Ir <= mr.x && lr <= mr.y && Dr >= mr.x && cr >= mr.y) return !0;
              }
              var yn = [new y(Ir, lr), new y(Ir, cr), new y(Dr, cr), new y(Dr, lr)];
              if (rr.length > 2) {
                for (var en = 0, Cn = yn; en < Cn.length; en += 1) if (Ca(rr, Cn[en])) return !0;
              }
              for (var Lr = 0; Lr < rr.length - 1; Lr++) if (Ef(rr[Lr], rr[Lr + 1], yn)) return !0;
              return !1;
            })(a.cameraQueryGeometry, xt - Z, Tt - Z, Nt + Z, Kt + Z);
          })), Ve = 0, je = xe; Ve < je.length; Ve += 1) se.push(je[Ve]);
          se.sort(dN);
          for (var Qe, Ye = {}, it = function(xt) {
            var Tt = se[xt];
            if (Tt !== Qe) {
              Qe = Tt;
              var Nt = S.featureIndexArray.get(Tt), Kt = null;
              S.loadMatchingFeature(Ye, Nt.bucketIndex, Nt.sourceLayerIndex, Nt.featureIndex, N, M.layers, M.availableImages, c, p, x, (function(rr, Ir, lr) {
                return Kt || (Kt = ar(rr)), Ir.queryIntersectsFeature(G, rr, lr, Kt, S.z, a.transform, O, a.pixelPosMatrix);
              }));
            }
          }, pt = 0; pt < se.length; pt++) it(pt);
          return Ye;
        }, Dc.prototype.loadMatchingFeature = function(a, c, p, x, S, M, O, N, G, Z, te) {
          var se = this.bucketLayerIDs[c];
          if (!M || (function(rr, Ir) {
            for (var lr = 0; lr < rr.length; lr++) if (Ir.indexOf(rr[lr]) >= 0) return !0;
            return !1;
          })(M, se)) {
            var he = this.sourceLayerCoder.decode(p), xe = this.vtLayers[he].feature(x);
            if (S.needGeometry) {
              var Ve = jt(xe, !0);
              if (!S.filter(new cn(this.tileID.overscaledZ), Ve, this.tileID.canonical)) return;
            } else if (!S.filter(new cn(this.tileID.overscaledZ), xe)) return;
            for (var je = this.getId(xe, he), Qe = 0; Qe < se.length; Qe++) {
              var Ye = se[Qe];
              if (!(M && M.indexOf(Ye) < 0)) {
                var it = N[Ye];
                if (it) {
                  var pt = {};
                  je !== void 0 && Z && (pt = Z.getState(it.sourceLayer || "_geojsonTileLayer", je));
                  var xt = K({}, G[Ye]);
                  xt.paint = L3(xt.paint, it.paint, xe, pt, O), xt.layout = L3(xt.layout, it.layout, xe, pt, O);
                  var Tt = !te || te(xe, it, pt);
                  if (Tt) {
                    var Nt = new Z0(xe, this.z, this.x, this.y, je);
                    Nt.layer = xt;
                    var Kt = a[Ye];
                    Kt === void 0 && (Kt = a[Ye] = []), Kt.push({ featureIndex: x, feature: Nt, intersectionZ: Tt });
                  }
                }
              }
            }
          }
        }, Dc.prototype.lookupSymbolFeatures = function(a, c, p, x, S, M, O, N) {
          var G = {};
          this.loadVTLayers();
          for (var Z = vs(S), te = 0, se = a; te < se.length; te += 1) this.loadMatchingFeature(G, p, x, se[te], Z, M, O, N, c);
          return G;
        }, Dc.prototype.hasLayer = function(a) {
          for (var c = 0, p = this.bucketLayerIDs; c < p.length; c += 1) for (var x = 0, S = p[c]; x < S.length; x += 1) if (a === S[x]) return !0;
          return !1;
        }, Dc.prototype.getId = function(a, c) {
          var p = a.id;
          return this.promoteId && typeof (p = a.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[c]]) == "boolean" && (p = Number(p)), p;
        }, ur("FeatureIndex", Dc, { omit: ["rawTileData", "sourceLayerCoder"] });
        var os = function(a, c) {
          this.tileID = a, this.uid = de(), this.uses = 0, this.tileSize = c, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.expiredRequestCount = 0, this.state = "loading";
        };
        os.prototype.registerFadeDuration = function(a) {
          var c = a + this.timeAdded;
          c < tr.now() || this.fadeEndTime && c < this.fadeEndTime || (this.fadeEndTime = c);
        }, os.prototype.wasRequested = function() {
          return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
        }, os.prototype.loadVectorData = function(a, c, p) {
          if (this.hasData() && this.unloadVectorData(), this.state = "loaded", a) {
            for (var x in a.featureIndex && (this.latestFeatureIndex = a.featureIndex, a.rawTileData ? (this.latestRawTileData = a.rawTileData, this.latestFeatureIndex.rawTileData = a.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = a.collisionBoxArray, this.buckets = (function(Z, te) {
              var se = {};
              if (!te) return se;
              for (var he = function() {
                var je = Ve[xe], Qe = je.layerIds.map((function(pt) {
                  return te.getLayer(pt);
                })).filter(Boolean);
                if (Qe.length !== 0) {
                  je.layers = Qe, je.stateDependentLayerIds && (je.stateDependentLayers = je.stateDependentLayerIds.map((function(pt) {
                    return Qe.filter((function(xt) {
                      return xt.id === pt;
                    }))[0];
                  })));
                  for (var Ye = 0, it = Qe; Ye < it.length; Ye += 1) se[it[Ye].id] = je;
                }
              }, xe = 0, Ve = Z; xe < Ve.length; xe += 1) he();
              return se;
            })(a.buckets, c.style), this.hasSymbolBuckets = !1, this.buckets) {
              var S = this.buckets[x];
              if (S instanceof Nn) {
                if (this.hasSymbolBuckets = !0, !p) break;
                S.justReloaded = !0;
              }
            }
            if (this.hasRTLText = !1, this.hasSymbolBuckets) for (var M in this.buckets) {
              var O = this.buckets[M];
              if (O instanceof Nn && O.hasRTLText) {
                this.hasRTLText = !0, is.isLoading() || is.isLoaded() || vf() !== "deferred" || Eo();
                break;
              }
            }
            for (var N in this.queryPadding = 0, this.buckets) {
              var G = this.buckets[N];
              this.queryPadding = Math.max(this.queryPadding, c.style.getLayer(N).queryRadius(G));
            }
            a.imageAtlas && (this.imageAtlas = a.imageAtlas), a.glyphAtlasImage && (this.glyphAtlasImage = a.glyphAtlasImage);
          } else this.collisionBoxArray = new v();
        }, os.prototype.unloadVectorData = function() {
          for (var a in this.buckets) this.buckets[a].destroy();
          this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
        }, os.prototype.getBucket = function(a) {
          return this.buckets[a.id];
        }, os.prototype.upload = function(a) {
          for (var c in this.buckets) {
            var p = this.buckets[c];
            p.uploadPending() && p.upload(a);
          }
          var x = a.gl;
          this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new If(a, this.imageAtlas.image, x.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new If(a, this.glyphAtlasImage, x.ALPHA), this.glyphAtlasImage = null);
        }, os.prototype.prepare = function(a) {
          this.imageAtlas && this.imageAtlas.patchUpdatedImages(a, this.imageAtlasTexture);
        }, os.prototype.queryRenderedFeatures = function(a, c, p, x, S, M, O, N, G, Z) {
          return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: x, cameraQueryGeometry: S, scale: M, tileSize: this.tileSize, pixelPosMatrix: Z, transform: N, params: O, queryPadding: this.queryPadding * G }, a, c, p) : {};
        }, os.prototype.querySourceFeatures = function(a, c) {
          var p = this.latestFeatureIndex;
          if (p && p.rawTileData) {
            var x = p.loadVTLayers(), S = c ? c.sourceLayer : "", M = x._geojsonTileLayer || x[S];
            if (M) for (var O = vs(c && c.filter), N = this.tileID.canonical, G = N.z, Z = N.x, te = N.y, se = { z: G, x: Z, y: te }, he = 0; he < M.length; he++) {
              var xe = M.feature(he);
              if (O.needGeometry) {
                var Ve = jt(xe, !0);
                if (!O.filter(new cn(this.tileID.overscaledZ), Ve, this.tileID.canonical)) continue;
              } else if (!O.filter(new cn(this.tileID.overscaledZ), xe)) continue;
              var je = p.getId(xe, S), Qe = new Z0(xe, G, Z, te, je);
              Qe.tile = se, a.push(Qe);
            }
          }
        }, os.prototype.hasData = function() {
          return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
        }, os.prototype.patternsLoaded = function() {
          return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
        }, os.prototype.setExpiryData = function(a) {
          var c = this.expirationTime;
          if (a.cacheControl) {
            var p = Ue(a.cacheControl);
            p["max-age"] && (this.expirationTime = Date.now() + 1e3 * p["max-age"]);
          } else a.expires && (this.expirationTime = new Date(a.expires).getTime());
          if (this.expirationTime) {
            var x = Date.now(), S = !1;
            if (this.expirationTime > x) S = !1;
            else if (c) if (this.expirationTime < c) S = !0;
            else {
              var M = this.expirationTime - c;
              M ? this.expirationTime = x + Math.max(M, 3e4) : S = !0;
            }
            else S = !0;
            S ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
          }
        }, os.prototype.getExpiryTimeout = function() {
          if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
        }, os.prototype.setFeatureState = function(a, c) {
          if (this.latestFeatureIndex && this.latestFeatureIndex.rawTileData && Object.keys(a).length !== 0) {
            var p = this.latestFeatureIndex.loadVTLayers();
            for (var x in this.buckets) if (c.style.hasLayer(x)) {
              var S = this.buckets[x], M = S.layers[0].sourceLayer || "_geojsonTileLayer", O = p[M], N = a[M];
              if (O && N && Object.keys(N).length !== 0) {
                S.update(N, O, this.imageAtlas && this.imageAtlas.patternPositions || {});
                var G = c && c.style && c.style.getLayer(x);
                G && (this.queryPadding = Math.max(this.queryPadding, G.queryRadius(S)));
              }
            }
          }
        }, os.prototype.holdingForFade = function() {
          return this.symbolFadeHoldUntil !== void 0;
        }, os.prototype.symbolFadeFinished = function() {
          return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < tr.now();
        }, os.prototype.clearFadeHold = function() {
          this.symbolFadeHoldUntil = void 0;
        }, os.prototype.setHoldDuration = function(a) {
          this.symbolFadeHoldUntil = tr.now() + a;
        }, os.prototype.setDependencies = function(a, c) {
          for (var p = {}, x = 0, S = c; x < S.length; x += 1) p[S[x]] = !0;
          this.dependencies[a] = p;
        }, os.prototype.hasDependency = function(a, c) {
          for (var p = 0, x = a; p < x.length; p += 1) {
            var S = this.dependencies[x[p]];
            if (S) {
              for (var M = 0, O = c; M < O.length; M += 1) if (S[O[M]]) return !0;
            }
          }
          return !1;
        };
        var Mu = P.performance, F3 = function(a) {
          this._marks = { start: [a.url, "start"].join("#"), end: [a.url, "end"].join("#"), measure: a.url.toString() }, Mu.mark(this._marks.start);
        };
        F3.prototype.finish = function() {
          Mu.mark(this._marks.end);
          var a = Mu.getEntriesByName(this._marks.measure);
          return a.length === 0 && (Mu.measure(this._marks.measure, this._marks.start, this._marks.end), a = Mu.getEntriesByName(this._marks.measure), Mu.clearMarks(this._marks.start), Mu.clearMarks(this._marks.end), Mu.clearMeasures(this._marks.measure)), a;
        }, o.Actor = td, o.AlphaImage = Sf, o.CanonicalTileID = Mf, o.CollisionBoxArray = v, o.Color = sn, o.DEMData = Oc, o.DataConstantProperty = Mr, o.DictionaryCoder = X0, o.EXTENT = 8192, o.ErrorEvent = pe, o.EvaluationParameters = cn, o.Event = Ne, o.Evented = Te, o.FeatureIndex = Dc, o.FillBucket = el, o.FillExtrusionBucket = tl, o.ImageAtlas = eA, o.ImagePosition = U0, o.LineBucket = Qs, o.LngLat = oi, o.LngLatBounds = Hi, o.MercatorCoordinate = Pf, o.ONE_EM = 24, o.OverscaledTileID = Gi, o.Point = y, o.Point$1 = y, o.Properties = Xi, o.Protobuf = F0, o.RGBAImage = uo, o.RequestManager = xr, o.RequestPerformance = F3, o.ResourceType = Xt, o.SegmentVector = Se, o.SourceFeatureState = rd, o.StructArrayLayout1ui2 = Pc, o.StructArrayLayout2f1f2i16 = Qa, o.StructArrayLayout2i4 = Io, o.StructArrayLayout3ui6 = xs, o.StructArrayLayout4i8 = Ns, o.SymbolBucket = Nn, o.Texture = If, o.Tile = os, o.Transitionable = Li, o.Uniform1f = z, o.Uniform1i = F, o.Uniform2f = W, o.Uniform3f = ue, o.Uniform4f = Ie, o.UniformColor = Re, o.UniformMatrix4f = Ze, o.UnwrappedTileID = D3, o.ValidationError = ge, o.WritingMode = Go, o.ZoomHistory = _f, o.add = function(a, c, p) {
          return a[0] = c[0] + p[0], a[1] = c[1] + p[1], a[2] = c[2] + p[2], a;
        }, o.addDynamicAttributes = qy, o.asyncAll = function(a, c, p) {
          if (!a.length) return p(null, []);
          var x = a.length, S = new Array(a.length), M = null;
          a.forEach((function(O, N) {
            c(O, (function(G, Z) {
              G && (M = G), S[N] = Z, --x == 0 && p(M, S);
            }));
          }));
        }, o.bezier = U, o.bindAll = De, o.browser = tr, o.cacheEntryPossiblyAdded = function(a) {
          ++Ft > Gt && (a.getActor().send("enforceCacheSizeLimit", Le), Ft = 0);
        }, o.clamp = q, o.clearTileCache = function(a) {
          var c = P.caches.delete("mapbox-tiles");
          a && c.catch(a).then((function() {
            return a();
          }));
        }, o.clipLine = _3, o.clone = function(a) {
          var c = new Mn(16);
          return c[0] = a[0], c[1] = a[1], c[2] = a[2], c[3] = a[3], c[4] = a[4], c[5] = a[5], c[6] = a[6], c[7] = a[7], c[8] = a[8], c[9] = a[9], c[10] = a[10], c[11] = a[11], c[12] = a[12], c[13] = a[13], c[14] = a[14], c[15] = a[15], c;
        }, o.clone$1 = me, o.clone$2 = function(a) {
          var c = new Mn(3);
          return c[0] = a[0], c[1] = a[1], c[2] = a[2], c;
        }, o.collisionCircleLayout = O8, o.config = Wt, o.create = function() {
          var a = new Mn(16);
          return Mn != Float32Array && (a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0), a[0] = 1, a[5] = 1, a[10] = 1, a[15] = 1, a;
        }, o.create$1 = function() {
          var a = new Mn(9);
          return Mn != Float32Array && (a[1] = 0, a[2] = 0, a[3] = 0, a[5] = 0, a[6] = 0, a[7] = 0), a[0] = 1, a[4] = 1, a[8] = 1, a;
        }, o.create$2 = function() {
          var a = new Mn(4);
          return Mn != Float32Array && (a[1] = 0, a[2] = 0), a[0] = 1, a[3] = 1, a;
        }, o.createCommonjsModule = l, o.createExpression = gu, o.createLayout = zi, o.createStyleLayer = function(a) {
          return a.type === "custom" ? new fN(a) : new hN[a.type](a);
        }, o.cross = function(a, c, p) {
          var x = c[0], S = c[1], M = c[2], O = p[0], N = p[1], G = p[2];
          return a[0] = S * G - M * N, a[1] = M * O - x * G, a[2] = x * N - S * O, a;
        }, o.deepEqual = function a(c, p) {
          if (Array.isArray(c)) {
            if (!Array.isArray(p) || c.length !== p.length) return !1;
            for (var x = 0; x < c.length; x++) if (!a(c[x], p[x])) return !1;
            return !0;
          }
          if (typeof c == "object" && c !== null && p !== null) {
            if (typeof p != "object" || Object.keys(c).length !== Object.keys(p).length) return !1;
            for (var S in c) if (!a(c[S], p[S])) return !1;
            return !0;
          }
          return c === p;
        }, o.dot = function(a, c) {
          return a[0] * c[0] + a[1] * c[1] + a[2] * c[2];
        }, o.dot$1 = function(a, c) {
          return a[0] * c[0] + a[1] * c[1] + a[2] * c[2] + a[3] * c[3];
        }, o.ease = V, o.emitValidationErrors = Tc, o.endsWith = Ge, o.enforceCacheSizeLimit = function(a) {
          Jt(), Rn && Rn.then((function(c) {
            c.keys().then((function(p) {
              for (var x = 0; x < p.length - a; x++) c.delete(p[x]);
            }));
          }));
        }, o.evaluateSizeForFeature = h3, o.evaluateSizeForZoom = d3, o.evaluateVariableOffset = b3, o.evented = wu, o.extend = K, o.featureFilter = vs, o.filterObject = ve, o.fromRotation = function(a, c) {
          var p = Math.sin(c), x = Math.cos(c);
          return a[0] = x, a[1] = p, a[2] = 0, a[3] = -p, a[4] = x, a[5] = 0, a[6] = 0, a[7] = 0, a[8] = 1, a;
        }, o.getAnchorAlignment = Hy, o.getAnchorJustification = $y, o.getArrayBuffer = tt, o.getImage = ie, o.getJSON = function(a, c) {
          return Pe(K(a, { type: "json" }), c);
        }, o.getRTLTextPluginStatus = vf, o.getReferrer = $, o.getVideo = function(a, c) {
          var p, x, S = P.document.createElement("video");
          S.muted = !0, S.onloadstart = function() {
            c(null, S);
          };
          for (var M = 0; M < a.length; M++) {
            var O = P.document.createElement("source");
            p = a[M], x = void 0, (x = P.document.createElement("a")).href = p, (x.protocol !== P.document.location.protocol || x.host !== P.document.location.host) && (S.crossOrigin = "Anonymous"), O.src = a[M], S.appendChild(O);
          }
          return { cancel: function() {
          } };
        }, o.identity = Ro, o.invert = function(a, c) {
          var p = c[0], x = c[1], S = c[2], M = c[3], O = c[4], N = c[5], G = c[6], Z = c[7], te = c[8], se = c[9], he = c[10], xe = c[11], Ve = c[12], je = c[13], Qe = c[14], Ye = c[15], it = p * N - x * O, pt = p * G - S * O, xt = p * Z - M * O, Tt = x * G - S * N, Nt = x * Z - M * N, Kt = S * Z - M * G, rr = te * je - se * Ve, Ir = te * Qe - he * Ve, lr = te * Ye - xe * Ve, Dr = se * Qe - he * je, cr = se * Ye - xe * je, an = he * Ye - xe * Qe, jr = it * an - pt * cr + xt * Dr + Tt * lr - Nt * Ir + Kt * rr;
          return jr ? (a[0] = (N * an - G * cr + Z * Dr) * (jr = 1 / jr), a[1] = (S * cr - x * an - M * Dr) * jr, a[2] = (je * Kt - Qe * Nt + Ye * Tt) * jr, a[3] = (he * Nt - se * Kt - xe * Tt) * jr, a[4] = (G * lr - O * an - Z * Ir) * jr, a[5] = (p * an - S * lr + M * Ir) * jr, a[6] = (Qe * xt - Ve * Kt - Ye * pt) * jr, a[7] = (te * Kt - he * xt + xe * pt) * jr, a[8] = (O * cr - N * lr + Z * rr) * jr, a[9] = (x * lr - p * cr - M * rr) * jr, a[10] = (Ve * Nt - je * xt + Ye * it) * jr, a[11] = (se * xt - te * Nt - xe * it) * jr, a[12] = (N * Ir - O * Dr - G * rr) * jr, a[13] = (p * Dr - x * Ir + S * rr) * jr, a[14] = (je * pt - Ve * Tt - Qe * it) * jr, a[15] = (te * Tt - se * pt + he * it) * jr, a) : null;
        }, o.isChar = nr, o.isMapboxURL = wr, o.keysDifference = function(a, c) {
          var p = [];
          for (var x in a) x in c || p.push(x);
          return p;
        }, o.makeRequest = Pe, o.mapObject = fe, o.mercatorXfromLng = R3, o.mercatorYfromLat = B3, o.mercatorZfromAltitude = O3, o.mul = Ry, o.multiply = Ks, o.mvt = $h, o.nextPowerOfTwo = function(a) {
          return a <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(a) / Math.LN2));
        }, o.normalize = function(a, c) {
          var p = c[0], x = c[1], S = c[2], M = p * p + x * x + S * S;
          return M > 0 && (M = 1 / Math.sqrt(M)), a[0] = c[0] * M, a[1] = c[1] * M, a[2] = c[2] * M, a;
        }, o.number = gi, o.offscreenCanvasSupported = _e, o.ortho = function(a, c, p, x, S, M, O) {
          var N = 1 / (c - p), G = 1 / (x - S), Z = 1 / (M - O);
          return a[0] = -2 * N, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = -2 * G, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = 2 * Z, a[11] = 0, a[12] = (c + p) * N, a[13] = (S + x) * G, a[14] = (O + M) * Z, a[15] = 1, a;
        }, o.parseGlyphPBF = function(a) {
          return new F0(a).readFields(G8, []);
        }, o.pbf = F0, o.performSymbolLayout = function(a, c, p, x, S, M, O) {
          a.createArrays(), a.tilePixelRatio = 8192 / (512 * a.overscaling), a.compareText = {}, a.iconsNeedLinear = !1;
          var N = a.layers[0].layout, G = a.layers[0]._unevaluatedLayout._values, Z = {};
          if (a.textSizeData.kind === "composite") {
            var te = a.textSizeData, se = te.maxZoom;
            Z.compositeTextSizes = [G["text-size"].possiblyEvaluate(new cn(te.minZoom), O), G["text-size"].possiblyEvaluate(new cn(se), O)];
          }
          if (a.iconSizeData.kind === "composite") {
            var he = a.iconSizeData, xe = he.maxZoom;
            Z.compositeIconSizes = [G["icon-size"].possiblyEvaluate(new cn(he.minZoom), O), G["icon-size"].possiblyEvaluate(new cn(xe), O)];
          }
          Z.layoutTextSize = G["text-size"].possiblyEvaluate(new cn(a.zoom + 1), O), Z.layoutIconSize = G["icon-size"].possiblyEvaluate(new cn(a.zoom + 1), O), Z.textMaxSize = G["text-size"].possiblyEvaluate(new cn(18));
          for (var Ve = 24 * N.get("text-line-height"), je = N.get("text-rotation-alignment") === "map" && N.get("symbol-placement") !== "point", Qe = N.get("text-keep-upright"), Ye = N.get("text-size"), it = function() {
            var Tt = xt[pt], Nt = N.get("text-font").evaluate(Tt, {}, O).join(","), Kt = Ye.evaluate(Tt, {}, O), rr = Z.layoutTextSize.evaluate(Tt, {}, O), Ir = Z.layoutIconSize.evaluate(Tt, {}, O), lr = { horizontal: {}, vertical: void 0 }, Dr = Tt.text, cr = [0, 0];
            if (Dr) {
              var an = Dr.toString(), jr = 24 * N.get("text-letter-spacing").evaluate(Tt, {}, O), mr = (function(bn) {
                for (var Vn = 0, Ln = bn; Vn < Ln.length; Vn += 1) if (Sn = Ln[Vn].charCodeAt(0), nr.Arabic(Sn) || nr["Arabic Supplement"](Sn) || nr["Arabic Extended-A"](Sn) || nr["Arabic Presentation Forms-A"](Sn) || nr["Arabic Presentation Forms-B"](Sn)) return !1;
                var Sn;
                return !0;
              })(an) ? jr : 0, yn = N.get("text-anchor").evaluate(Tt, {}, O), en = N.get("text-variable-anchor");
              if (!en) {
                var Cn = N.get("text-radial-offset").evaluate(Tt, {}, O);
                cr = Cn ? b3(yn, [24 * Cn, Wy]) : N.get("text-offset").evaluate(Tt, {}, O).map((function(bn) {
                  return 24 * bn;
                }));
              }
              var Lr = je ? "center" : N.get("text-justify").evaluate(Tt, {}, O), In = N.get("symbol-placement"), ai = In === "point" ? 24 * N.get("text-max-width").evaluate(Tt, {}, O) : 0, Ti = function() {
                a.allowVerticalPlacement && wo(an) && (lr.vertical = z0(Dr, c, p, S, Nt, ai, Ve, yn, "left", mr, cr, Go.vertical, !0, In, rr, Kt));
              };
              if (!je && en) {
                for (var mi = Lr === "auto" ? en.map((function(bn) {
                  return $y(bn);
                })) : [Lr], li = !1, Ei = 0; Ei < mi.length; Ei++) {
                  var Yi = mi[Ei];
                  if (!lr.horizontal[Yi]) if (li) lr.horizontal[Yi] = lr.horizontal[0];
                  else {
                    var Ki = z0(Dr, c, p, S, Nt, ai, Ve, "center", Yi, mr, cr, Go.horizontal, !1, In, rr, Kt);
                    Ki && (lr.horizontal[Yi] = Ki, li = Ki.positionedLines.length === 1);
                  }
                }
                Ti();
              } else {
                Lr === "auto" && (Lr = $y(yn));
                var Vs = z0(Dr, c, p, S, Nt, ai, Ve, yn, Lr, mr, cr, Go.horizontal, !1, In, rr, Kt);
                Vs && (lr.horizontal[Lr] = Vs), Ti(), wo(an) && je && Qe && (lr.vertical = z0(Dr, c, p, S, Nt, ai, Ve, yn, Lr, mr, cr, Go.vertical, !1, In, rr, Kt));
              }
            }
            var as = void 0, js = !1;
            if (Tt.icon && Tt.icon.name) {
              var Pi = x[Tt.icon.name];
              Pi && (as = (function(bn, Vn, Ln) {
                var Sn = Hy(Ln), Js = Vn[0] - bn.displaySize[0] * Sn.horizontalAlign, ws = Vn[1] - bn.displaySize[1] * Sn.verticalAlign;
                return { image: bn, top: ws, bottom: ws + bn.displaySize[1], left: Js, right: Js + bn.displaySize[0] };
              })(S[Tt.icon.name], N.get("icon-offset").evaluate(Tt, {}, O), N.get("icon-anchor").evaluate(Tt, {}, O)), js = Pi.sdf, a.sdfIcons === void 0 ? a.sdfIcons = Pi.sdf : a.sdfIcons !== Pi.sdf && re("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (Pi.pixelRatio !== a.pixelRatio || N.get("icon-rotate").constantOr(1) !== 0) && (a.iconsNeedLinear = !0));
            }
            var ls = w3(lr.horizontal) || lr.vertical;
            a.iconsInText = !!ls && ls.iconsInText, (ls || as) && (function(bn, Vn, Ln, Sn, Js, ws, ti, ki, Ts, Pn, Hl) {
              var Wo = ws.textMaxSize.evaluate(Vn, {});
              Wo === void 0 && (Wo = ti);
              var Gl, Mi = bn.layers[0].layout, Wl = Mi.get("icon-offset").evaluate(Vn, {}, Hl), Ia = w3(Ln.horizontal), nd = ti / 24, Rf = bn.tilePixelRatio * nd, id = bn.tilePixelRatio * Wo / 24, Lc = bn.tilePixelRatio * ki, sd = bn.tilePixelRatio * Mi.get("symbol-spacing"), Y0 = Mi.get("text-padding") * bn.tilePixelRatio, od = Mi.get("icon-padding") * bn.tilePixelRatio, nA = Mi.get("text-max-angle") / 180 * Math.PI, K0 = Mi.get("text-rotation-alignment") === "map" && Mi.get("symbol-placement") !== "point", Q0 = Mi.get("icon-rotation-alignment") === "map" && Mi.get("symbol-placement") !== "point", kc = Mi.get("symbol-placement"), iA = sd / 2, ad = Mi.get("icon-text-fit");
              Sn && ad !== "none" && (bn.allowVerticalPlacement && Ln.vertical && (Gl = f3(Sn, Ln.vertical, ad, Mi.get("icon-text-fit-padding"), Wl, nd)), Ia && (Sn = f3(Sn, Ia, ad, Mi.get("icon-text-fit-padding"), Wl, nd)));
              var Ru = function(pN, hA) {
                hA.x < 0 || hA.x >= 8192 || hA.y < 0 || hA.y >= 8192 || (function(Ri, rl, AN, Bu, tv, z3, ig, $l, sg, dA, og, ag, rv, V3, pA, j3, H3, G3, W3, $3, $o, lg, q3, ql, gN) {
                  var X3, Of, hd, dd, pd, Ad = Ri.addToLineVertexArray(rl, AN), Z3 = 0, Y3 = 0, K3 = 0, Q3 = 0, nv = -1, iv = -1, Fc = {}, J3 = f(""), sv = 0, ov = 0;
                  if ($l._unevaluatedLayout.getValue("text-radial-offset") === void 0 ? (sv = (X3 = $l.layout.get("text-offset").evaluate($o, {}, ql).map((function(gA) {
                    return 24 * gA;
                  })))[0], ov = X3[1]) : (sv = 24 * $l.layout.get("text-radial-offset").evaluate($o, {}, ql), ov = Wy), Ri.allowVerticalPlacement && Bu.vertical) {
                    var eE = $l.layout.get("text-rotate").evaluate($o, {}, ql) + 90;
                    dd = new W0(sg, rl, dA, og, ag, Bu.vertical, rv, V3, pA, eE), ig && (pd = new W0(sg, rl, dA, og, ag, ig, H3, G3, pA, eE));
                  }
                  if (tv) {
                    var av = $l.layout.get("icon-rotate").evaluate($o, {}), tE = $l.layout.get("icon-text-fit") !== "none", rE = y3(tv, av, q3, tE), lv = ig ? y3(ig, av, q3, tE) : void 0;
                    hd = new W0(sg, rl, dA, og, ag, tv, H3, G3, !1, av), Z3 = 4 * rE.length;
                    var nE = Ri.iconSizeData, AA = null;
                    nE.kind === "source" ? (AA = [128 * $l.layout.get("icon-size").evaluate($o, {})])[0] > 32640 && re(Ri.layerIds[0] + ': Value for "icon-size" is >= 255. Reduce your "icon-size".') : nE.kind === "composite" && ((AA = [128 * lg.compositeIconSizes[0].evaluate($o, {}, ql), 128 * lg.compositeIconSizes[1].evaluate($o, {}, ql)])[0] > 32640 || AA[1] > 32640) && re(Ri.layerIds[0] + ': Value for "icon-size" is >= 255. Reduce your "icon-size".'), Ri.addSymbols(Ri.icon, rE, AA, $3, W3, $o, !1, rl, Ad.lineStartIndex, Ad.lineLength, -1, ql), nv = Ri.icon.placedSymbolArray.length - 1, lv && (Y3 = 4 * lv.length, Ri.addSymbols(Ri.icon, lv, AA, $3, W3, $o, Go.vertical, rl, Ad.lineStartIndex, Ad.lineLength, -1, ql), iv = Ri.icon.placedSymbolArray.length - 1);
                  }
                  for (var iE in Bu.horizontal) {
                    var cg = Bu.horizontal[iE];
                    if (!Of) {
                      J3 = f(cg.text);
                      var mN = $l.layout.get("text-rotate").evaluate($o, {}, ql);
                      Of = new W0(sg, rl, dA, og, ag, cg, rv, V3, pA, mN);
                    }
                    var sE = cg.positionedLines.length === 1;
                    if (K3 += x3(Ri, rl, cg, z3, $l, pA, $o, j3, Ad, Bu.vertical ? Go.horizontal : Go.horizontalOnly, sE ? Object.keys(Bu.horizontal) : [iE], Fc, nv, lg, ql), sE) break;
                  }
                  Bu.vertical && (Q3 += x3(Ri, rl, Bu.vertical, z3, $l, pA, $o, j3, Ad, Go.vertical, ["vertical"], Fc, iv, lg, ql));
                  var _N = Of ? Of.boxStartIndex : Ri.collisionBoxArray.length, yN = Of ? Of.boxEndIndex : Ri.collisionBoxArray.length, vN = dd ? dd.boxStartIndex : Ri.collisionBoxArray.length, bN = dd ? dd.boxEndIndex : Ri.collisionBoxArray.length, xN = hd ? hd.boxStartIndex : Ri.collisionBoxArray.length, wN = hd ? hd.boxEndIndex : Ri.collisionBoxArray.length, TN = pd ? pd.boxStartIndex : Ri.collisionBoxArray.length, EN = pd ? pd.boxEndIndex : Ri.collisionBoxArray.length, Xl = -1, ug = function(gA, aE) {
                    return gA && gA.circleDiameter ? Math.max(gA.circleDiameter, aE) : aE;
                  };
                  Xl = ug(Of, Xl), Xl = ug(dd, Xl), Xl = ug(hd, Xl);
                  var oE = (Xl = ug(pd, Xl)) > -1 ? 1 : 0;
                  oE && (Xl *= gN / 24), Ri.glyphOffsetArray.length >= Nn.MAX_GLYPHS && re("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), $o.sortKey !== void 0 && Ri.addToSortKeyRanges(Ri.symbolInstances.length, $o.sortKey), Ri.symbolInstances.emplaceBack(rl.x, rl.y, Fc.right >= 0 ? Fc.right : -1, Fc.center >= 0 ? Fc.center : -1, Fc.left >= 0 ? Fc.left : -1, Fc.vertical || -1, nv, iv, J3, _N, yN, vN, bN, xN, wN, TN, EN, dA, K3, Q3, Z3, Y3, oE, 0, rv, sv, ov, Xl);
                })(bn, hA, pN, Ln, Sn, Js, Gl, bn.layers[0], bn.collisionBoxArray, Vn.index, Vn.sourceLayerIndex, bn.index, Rf, Y0, K0, Ts, Lc, od, Q0, Wl, Vn, ws, Pn, Hl, ti);
              };
              if (kc === "line") for (var ld = 0, J0 = _3(Vn.geometry, 0, 0, 8192, 8192); ld < J0.length; ld += 1) for (var eg = J0[ld], sA = 0, oA = K8(eg, sd, nA, Ln.vertical || Ia, Sn, 24, id, bn.overscaling, 8192); sA < oA.length; sA += 1) {
                var tg = oA[sA];
                Ia && tN(bn, Ia.text, iA, tg) || Ru(eg, tg);
              }
              else if (kc === "line-center") for (var aA = 0, lA = Vn.geometry; aA < lA.length; aA += 1) {
                var cA = lA[aA];
                if (cA.length > 1) {
                  var rg = Y8(cA, nA, Ln.vertical || Ia, Sn, 24, id);
                  rg && Ru(cA, rg);
                }
              }
              else if (Vn.type === "Polygon") for (var cd = 0, ng = Ny(Vn.geometry, 0); cd < ng.length; cd += 1) {
                var ud = ng[cd], uA = J8(ud, 16);
                Ru(ud[0], new Yh(uA.x, uA.y, 0));
              }
              else if (Vn.type === "LineString") for (var Bf = 0, fA = Vn.geometry; Bf < fA.length; Bf += 1) {
                var fd = fA[Bf];
                Ru(fd, new Yh(fd[0].x, fd[0].y, 0));
              }
              else if (Vn.type === "Point") for (var Qy = 0, N3 = Vn.geometry; Qy < N3.length; Qy += 1) for (var Jy = 0, U3 = N3[Qy]; Jy < U3.length; Jy += 1) {
                var ev = U3[Jy];
                Ru([ev], new Yh(ev.x, ev.y, 0));
              }
            })(a, Tt, lr, as, x, Z, rr, Ir, cr, js, O);
          }, pt = 0, xt = a.features; pt < xt.length; pt += 1) it();
          M && a.generateCollisionDebugBuffers();
        }, o.perspective = function(a, c, p, x, S) {
          var M, O = 1 / Math.tan(c / 2);
          return a[0] = O / p, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = O, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[11] = -1, a[12] = 0, a[13] = 0, a[15] = 0, S != null && S !== 1 / 0 ? (a[10] = (S + x) * (M = 1 / (x - S)), a[14] = 2 * S * x * M) : (a[10] = -1, a[14] = -2 * x), a;
        }, o.pick = function(a, c) {
          for (var p = {}, x = 0; x < c.length; x++) {
            var S = c[x];
            S in a && (p[S] = a[S]);
          }
          return p;
        }, o.plugin = is, o.polygonIntersectsPolygon = Zr, o.postMapLoadEvent = pi, o.postTurnstileEvent = Nr, o.potpack = a3, o.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], o.register = ur, o.registerForPluginStateChange = function(a) {
          return a({ pluginStatus: Si, pluginURL: To }), wu.on("pluginStateChange", a), a;
        }, o.renderColorRamp = jT, o.rotate = function(a, c, p) {
          var x = c[0], S = c[1], M = c[2], O = c[3], N = Math.sin(p), G = Math.cos(p);
          return a[0] = x * G + M * N, a[1] = S * G + O * N, a[2] = x * -N + M * G, a[3] = S * -N + O * G, a;
        }, o.rotateX = function(a, c, p) {
          var x = Math.sin(p), S = Math.cos(p), M = c[4], O = c[5], N = c[6], G = c[7], Z = c[8], te = c[9], se = c[10], he = c[11];
          return c !== a && (a[0] = c[0], a[1] = c[1], a[2] = c[2], a[3] = c[3], a[12] = c[12], a[13] = c[13], a[14] = c[14], a[15] = c[15]), a[4] = M * S + Z * x, a[5] = O * S + te * x, a[6] = N * S + se * x, a[7] = G * S + he * x, a[8] = Z * S - M * x, a[9] = te * S - O * x, a[10] = se * S - N * x, a[11] = he * S - G * x, a;
        }, o.rotateZ = function(a, c, p) {
          var x = Math.sin(p), S = Math.cos(p), M = c[0], O = c[1], N = c[2], G = c[3], Z = c[4], te = c[5], se = c[6], he = c[7];
          return c !== a && (a[8] = c[8], a[9] = c[9], a[10] = c[10], a[11] = c[11], a[12] = c[12], a[13] = c[13], a[14] = c[14], a[15] = c[15]), a[0] = M * S + Z * x, a[1] = O * S + te * x, a[2] = N * S + se * x, a[3] = G * S + he * x, a[4] = Z * S - M * x, a[5] = te * S - O * x, a[6] = se * S - N * x, a[7] = he * S - G * x, a;
        }, o.scale = function(a, c, p) {
          var x = p[0], S = p[1], M = p[2];
          return a[0] = c[0] * x, a[1] = c[1] * x, a[2] = c[2] * x, a[3] = c[3] * x, a[4] = c[4] * S, a[5] = c[5] * S, a[6] = c[6] * S, a[7] = c[7] * S, a[8] = c[8] * M, a[9] = c[9] * M, a[10] = c[10] * M, a[11] = c[11] * M, a[12] = c[12], a[13] = c[13], a[14] = c[14], a[15] = c[15], a;
        }, o.scale$1 = function(a, c, p) {
          return a[0] = c[0] * p, a[1] = c[1] * p, a[2] = c[2] * p, a[3] = c[3] * p, a;
        }, o.scale$2 = function(a, c, p) {
          return a[0] = c[0] * p, a[1] = c[1] * p, a[2] = c[2] * p, a;
        }, o.setCacheLimits = function(a, c) {
          Le = a, Gt = c;
        }, o.setRTLTextPlugin = function(a, c, p) {
          if (p === void 0 && (p = !1), Si === "deferred" || Si === "loading" || Si === "loaded") throw new Error("setRTLTextPlugin cannot be called multiple times.");
          To = tr.resolveURL(a), Si = "deferred", xu = c, Ta(), p || Eo();
        }, o.sphericalToCartesian = function(a) {
          var c = a[0], p = a[1], x = a[2];
          return p += 90, p *= Math.PI / 180, x *= Math.PI / 180, { x: c * Math.cos(p) * Math.sin(x), y: c * Math.sin(p) * Math.sin(x), z: c * Math.cos(x) };
        }, o.sqrLen = function(a) {
          var c = a[0], p = a[1];
          return c * c + p * p;
        }, o.styleSpec = le, o.sub = function(a, c, p) {
          return a[0] = c[0] - p[0], a[1] = c[1] - p[1], a[2] = c[2] - p[2], a;
        }, o.symbolSize = Z8, o.transformMat3 = function(a, c, p) {
          var x = c[0], S = c[1], M = c[2];
          return a[0] = x * p[0] + S * p[3] + M * p[6], a[1] = x * p[1] + S * p[4] + M * p[7], a[2] = x * p[2] + S * p[5] + M * p[8], a;
        }, o.transformMat4 = jh, o.translate = function(a, c, p) {
          var x, S, M, O, N, G, Z, te, se, he, xe, Ve, je = p[0], Qe = p[1], Ye = p[2];
          return c === a ? (a[12] = c[0] * je + c[4] * Qe + c[8] * Ye + c[12], a[13] = c[1] * je + c[5] * Qe + c[9] * Ye + c[13], a[14] = c[2] * je + c[6] * Qe + c[10] * Ye + c[14], a[15] = c[3] * je + c[7] * Qe + c[11] * Ye + c[15]) : (S = c[1], M = c[2], O = c[3], N = c[4], G = c[5], Z = c[6], te = c[7], se = c[8], he = c[9], xe = c[10], Ve = c[11], a[0] = x = c[0], a[1] = S, a[2] = M, a[3] = O, a[4] = N, a[5] = G, a[6] = Z, a[7] = te, a[8] = se, a[9] = he, a[10] = xe, a[11] = Ve, a[12] = x * je + N * Qe + se * Ye + c[12], a[13] = S * je + G * Qe + he * Ye + c[13], a[14] = M * je + Z * Qe + xe * Ye + c[14], a[15] = O * je + te * Qe + Ve * Ye + c[15]), a;
        }, o.triggerPluginCompletionEvent = zh, o.uniqueId = de, o.validateCustomStyleLayer = function(a) {
          var c = [], p = a.id;
          return p === void 0 && c.push({ message: "layers." + p + ': missing required property "id"' }), a.render === void 0 && c.push({ message: "layers." + p + ': missing required method "render"' }), a.renderingMode && a.renderingMode !== "2d" && a.renderingMode !== "3d" && c.push({ message: "layers." + p + ': property "renderingMode" must be either "2d" or "3d"' }), c;
        }, o.validateLight = Nh, o.validateStyle = xc, o.values = function(a) {
          var c = [];
          for (var p in a) c.push(a[p]);
          return c;
        }, o.vectorTile = $h, o.version = "1.13.3", o.warnOnce = re, o.webpSupported = yr, o.window = P, o.wrap = j;
      })), s(["./shared"], (function(o) {
        function l(Q) {
          var ie = typeof Q;
          if (ie === "number" || ie === "boolean" || ie === "string" || Q == null) return JSON.stringify(Q);
          if (Array.isArray(Q)) {
            for (var ce = "[", we = 0, Ne = Q; we < Ne.length; we += 1) ce += l(Ne[we]) + ",";
            return ce + "]";
          }
          for (var pe = Object.keys(Q).sort(), Te = "{", le = 0; le < pe.length; le++) Te += JSON.stringify(pe[le]) + ":" + l(Q[pe[le]]) + ",";
          return Te + "}";
        }
        function u(Q) {
          for (var ie = "", ce = 0, we = o.refProperties; ce < we.length; ce += 1) ie += "/" + l(Q[we[ce]]);
          return ie;
        }
        var m = function(Q) {
          this.keyCache = {}, Q && this.replace(Q);
        };
        m.prototype.replace = function(Q) {
          this._layerConfigs = {}, this._layers = {}, this.update(Q, []);
        }, m.prototype.update = function(Q, ie) {
          for (var ce = this, we = 0, Ne = Q; we < Ne.length; we += 1) {
            var pe = Ne[we];
            this._layerConfigs[pe.id] = pe;
            var Te = this._layers[pe.id] = o.createStyleLayer(pe);
            Te._featureFilter = o.featureFilter(Te.filter), this.keyCache[pe.id] && delete this.keyCache[pe.id];
          }
          for (var le = 0, ge = ie; le < ge.length; le += 1) {
            var d = ge[le];
            delete this.keyCache[d], delete this._layerConfigs[d], delete this._layers[d];
          }
          this.familiesBySource = {};
          for (var ee = 0, It = (function(Lt, Yt) {
            for (var Hr = {}, ir = 0; ir < Lt.length; ir++) {
              var nn = Yt && Yt[Lt[ir].id] || u(Lt[ir]);
              Yt && (Yt[Lt[ir].id] = nn);
              var un = Hr[nn];
              un || (un = Hr[nn] = []), un.push(Lt[ir]);
            }
            var Yr = [];
            for (var Qr in Hr) Yr.push(Hr[Qr]);
            return Yr;
          })(o.values(this._layerConfigs), this.keyCache); ee < It.length; ee += 1) {
            var nt = It[ee].map((function(Lt) {
              return ce._layers[Lt.id];
            })), Mt = nt[0];
            if (Mt.visibility !== "none") {
              var kt = Mt.source || "", zt = this.familiesBySource[kt];
              zt || (zt = this.familiesBySource[kt] = {});
              var _t = Mt.sourceLayer || "_geojsonTileLayer", Vt = zt[_t];
              Vt || (Vt = zt[_t] = []), Vt.push(nt);
            }
          }
        };
        var y = function(Q) {
          var ie = {}, ce = [];
          for (var we in Q) {
            var Ne = Q[we], pe = ie[we] = {};
            for (var Te in Ne) {
              var le = Ne[+Te];
              if (le && le.bitmap.width !== 0 && le.bitmap.height !== 0) {
                var ge = { x: 0, y: 0, w: le.bitmap.width + 2, h: le.bitmap.height + 2 };
                ce.push(ge), pe[Te] = { rect: ge, metrics: le.metrics };
              }
            }
          }
          var d = o.potpack(ce), ee = new o.AlphaImage({ width: d.w || 1, height: d.h || 1 });
          for (var It in Q) {
            var nt = Q[It];
            for (var Mt in nt) {
              var kt = nt[+Mt];
              if (kt && kt.bitmap.width !== 0 && kt.bitmap.height !== 0) {
                var zt = ie[It][Mt].rect;
                o.AlphaImage.copy(kt.bitmap, ee, { x: 0, y: 0 }, { x: zt.x + 1, y: zt.y + 1 }, kt.bitmap);
              }
            }
          }
          this.image = ee, this.positions = ie;
        };
        o.register("GlyphAtlas", y);
        var E = function(Q) {
          this.tileID = new o.OverscaledTileID(Q.tileID.overscaledZ, Q.tileID.wrap, Q.tileID.canonical.z, Q.tileID.canonical.x, Q.tileID.canonical.y), this.uid = Q.uid, this.zoom = Q.zoom, this.pixelRatio = Q.pixelRatio, this.tileSize = Q.tileSize, this.source = Q.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = Q.showCollisionBoxes, this.collectResourceTiming = !!Q.collectResourceTiming, this.returnDependencies = !!Q.returnDependencies, this.promoteId = Q.promoteId;
        };
        function P(Q, ie, ce) {
          for (var we = new o.EvaluationParameters(ie), Ne = 0, pe = Q; Ne < pe.length; Ne += 1) pe[Ne].recalculate(we, ce);
        }
        function L(Q, ie) {
          var ce = o.getArrayBuffer(Q.request, (function(we, Ne, pe, Te) {
            we ? ie(we) : Ne && ie(null, { vectorTile: new o.vectorTile.VectorTile(new o.pbf(Ne)), rawData: Ne, cacheControl: pe, expires: Te });
          }));
          return function() {
            ce.cancel(), ie();
          };
        }
        E.prototype.parse = function(Q, ie, ce, we, Ne) {
          var pe = this;
          this.status = "parsing", this.data = Q, this.collisionBoxArray = new o.CollisionBoxArray();
          var Te = new o.DictionaryCoder(Object.keys(Q.layers).sort()), le = new o.FeatureIndex(this.tileID, this.promoteId);
          le.bucketLayerIDs = [];
          var ge, d, ee, It, nt = {}, Mt = { featureIndex: le, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: ce }, kt = ie.familiesBySource[this.source];
          for (var zt in kt) {
            var _t = Q.layers[zt];
            if (_t) {
              _t.version === 1 && o.warnOnce('Vector tile source "' + this.source + '" layer "' + zt + '" does not use vector tile spec v2 and therefore may have some rendering errors.');
              for (var Vt = Te.encode(zt), Lt = [], Yt = 0; Yt < _t.length; Yt++) {
                var Hr = _t.feature(Yt), ir = le.getId(Hr, zt);
                Lt.push({ feature: Hr, id: ir, index: Yt, sourceLayerIndex: Vt });
              }
              for (var nn = 0, un = kt[zt]; nn < un.length; nn += 1) {
                var Yr = un[nn], Qr = Yr[0];
                Qr.minzoom && this.zoom < Math.floor(Qr.minzoom) || Qr.maxzoom && this.zoom >= Qr.maxzoom || Qr.visibility !== "none" && (P(Yr, this.zoom, ce), (nt[Qr.id] = Qr.createBucket({ index: le.bucketLayerIDs.length, layers: Yr, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: Vt, sourceID: this.source })).populate(Lt, Mt, this.tileID.canonical), le.bucketLayerIDs.push(Yr.map((function(ye) {
                  return ye.id;
                }))));
              }
            }
          }
          var $r = o.mapObject(Mt.glyphDependencies, (function(ye) {
            return Object.keys(ye).map(Number);
          }));
          Object.keys($r).length ? we.send("getGlyphs", { uid: this.uid, stacks: $r }, (function(ye, er) {
            ge || (ge = ye, d = er, hr.call(pe));
          })) : d = {};
          var Ai = Object.keys(Mt.iconDependencies);
          Ai.length ? we.send("getImages", { icons: Ai, source: this.source, tileID: this.tileID, type: "icons" }, (function(ye, er) {
            ge || (ge = ye, ee = er, hr.call(pe));
          })) : ee = {};
          var Kr = Object.keys(Mt.patternDependencies);
          function hr() {
            if (ge) return Ne(ge);
            if (d && ee && It) {
              var ye = new y(d), er = new o.ImageAtlas(ee, It);
              for (var sn in nt) {
                var Wi = nt[sn];
                Wi instanceof o.SymbolBucket ? (P(Wi.layers, this.zoom, ce), o.performSymbolLayout(Wi, d, ye.positions, ee, er.iconPositions, this.showCollisionBoxes, this.tileID.canonical)) : Wi.hasPattern && (Wi instanceof o.LineBucket || Wi instanceof o.FillBucket || Wi instanceof o.FillExtrusionBucket) && (P(Wi.layers, this.zoom, ce), Wi.addFeatures(Mt, this.tileID.canonical, er.patternPositions));
              }
              this.status = "done", Ne(null, { buckets: o.values(nt).filter((function(ma) {
                return !ma.isEmpty();
              })), featureIndex: le, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: ye.image, imageAtlas: er, glyphMap: this.returnDependencies ? d : null, iconMap: this.returnDependencies ? ee : null, glyphPositions: this.returnDependencies ? ye.positions : null });
            }
          }
          Kr.length ? we.send("getImages", { icons: Kr, source: this.source, tileID: this.tileID, type: "patterns" }, (function(ye, er) {
            ge || (ge = ye, It = er, hr.call(pe));
          })) : It = {}, hr.call(this);
        };
        var U = function(Q, ie, ce, we) {
          this.actor = Q, this.layerIndex = ie, this.availableImages = ce, this.loadVectorData = we || L, this.loading = {}, this.loaded = {};
        };
        U.prototype.loadTile = function(Q, ie) {
          var ce = this, we = Q.uid;
          this.loading || (this.loading = {});
          var Ne = !!(Q && Q.request && Q.request.collectResourceTiming) && new o.RequestPerformance(Q.request), pe = this.loading[we] = new E(Q);
          pe.abort = this.loadVectorData(Q, (function(Te, le) {
            if (delete ce.loading[we], Te || !le) return pe.status = "done", ce.loaded[we] = pe, ie(Te);
            var ge = le.rawData, d = {};
            le.expires && (d.expires = le.expires), le.cacheControl && (d.cacheControl = le.cacheControl);
            var ee = {};
            if (Ne) {
              var It = Ne.finish();
              It && (ee.resourceTiming = JSON.parse(JSON.stringify(It)));
            }
            pe.vectorTile = le.vectorTile, pe.parse(le.vectorTile, ce.layerIndex, ce.availableImages, ce.actor, (function(nt, Mt) {
              if (nt || !Mt) return ie(nt);
              ie(null, o.extend({ rawTileData: ge.slice(0) }, Mt, d, ee));
            })), ce.loaded = ce.loaded || {}, ce.loaded[we] = pe;
          }));
        }, U.prototype.reloadTile = function(Q, ie) {
          var ce = this, we = this.loaded, Ne = Q.uid, pe = this;
          if (we && we[Ne]) {
            var Te = we[Ne];
            Te.showCollisionBoxes = Q.showCollisionBoxes;
            var le = function(ge, d) {
              var ee = Te.reloadCallback;
              ee && (delete Te.reloadCallback, Te.parse(Te.vectorTile, pe.layerIndex, ce.availableImages, pe.actor, ee)), ie(ge, d);
            };
            Te.status === "parsing" ? Te.reloadCallback = le : Te.status === "done" && (Te.vectorTile ? Te.parse(Te.vectorTile, this.layerIndex, this.availableImages, this.actor, le) : le());
          }
        }, U.prototype.abortTile = function(Q, ie) {
          var ce = this.loading, we = Q.uid;
          ce && ce[we] && ce[we].abort && (ce[we].abort(), delete ce[we]), ie();
        }, U.prototype.removeTile = function(Q, ie) {
          var ce = this.loaded, we = Q.uid;
          ce && ce[we] && delete ce[we], ie();
        };
        var V = o.window.ImageBitmap, q = function() {
          this.loaded = {};
        };
        function j(Q, ie) {
          if (Q.length !== 0) {
            K(Q[0], ie);
            for (var ce = 1; ce < Q.length; ce++) K(Q[ce], !ie);
          }
        }
        function K(Q, ie) {
          for (var ce = 0, we = 0, Ne = 0, pe = Q.length, Te = pe - 1; Ne < pe; Te = Ne++) {
            var le = (Q[Ne][0] - Q[Te][0]) * (Q[Te][1] + Q[Ne][1]), ge = ce + le;
            we += Math.abs(ce) >= Math.abs(le) ? ce - ge + le : le - ge + ce, ce = ge;
          }
          ce + we >= 0 != !!ie && Q.reverse();
        }
        q.prototype.loadTile = function(Q, ie) {
          var ce = Q.uid, we = Q.encoding, Ne = Q.rawImageData, pe = V && Ne instanceof V ? this.getImageData(Ne) : Ne, Te = new o.DEMData(ce, pe, we);
          this.loaded = this.loaded || {}, this.loaded[ce] = Te, ie(null, Te);
        }, q.prototype.getImageData = function(Q) {
          this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(Q.width, Q.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d")), this.offscreenCanvas.width = Q.width, this.offscreenCanvas.height = Q.height, this.offscreenCanvasContext.drawImage(Q, 0, 0, Q.width, Q.height);
          var ie = this.offscreenCanvasContext.getImageData(-1, -1, Q.width + 2, Q.height + 2);
          return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), new o.RGBAImage({ width: ie.width, height: ie.height }, ie.data);
        }, q.prototype.removeTile = function(Q) {
          var ie = this.loaded, ce = Q.uid;
          ie && ie[ce] && delete ie[ce];
        };
        var Y = o.vectorTile.VectorTileFeature.prototype.toGeoJSON, de = function(Q) {
          this._feature = Q, this.extent = o.EXTENT, this.type = Q.type, this.properties = Q.tags, "id" in Q && !isNaN(Q.id) && (this.id = parseInt(Q.id, 10));
        };
        de.prototype.loadGeometry = function() {
          if (this._feature.type === 1) {
            for (var Q = [], ie = 0, ce = this._feature.geometry; ie < ce.length; ie += 1) {
              var we = ce[ie];
              Q.push([new o.Point$1(we[0], we[1])]);
            }
            return Q;
          }
          for (var Ne = [], pe = 0, Te = this._feature.geometry; pe < Te.length; pe += 1) {
            for (var le = [], ge = 0, d = Te[pe]; ge < d.length; ge += 1) {
              var ee = d[ge];
              le.push(new o.Point$1(ee[0], ee[1]));
            }
            Ne.push(le);
          }
          return Ne;
        }, de.prototype.toGeoJSON = function(Q, ie, ce) {
          return Y.call(this, Q, ie, ce);
        };
        var ne = function(Q) {
          this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = o.EXTENT, this.length = Q.length, this._features = Q;
        };
        ne.prototype.feature = function(Q) {
          return new de(this._features[Q]);
        };
        var ae = o.vectorTile.VectorTileFeature, De = Ge;
        function Ge(Q, ie) {
          this.options = ie || {}, this.features = Q, this.length = Q.length;
        }
        function fe(Q, ie) {
          this.id = typeof Q.id == "number" ? Q.id : void 0, this.type = Q.type, this.rawGeometry = Q.type === 1 ? [Q.geometry] : Q.geometry, this.properties = Q.tags, this.extent = ie || 4096;
        }
        Ge.prototype.feature = function(Q) {
          return new fe(this.features[Q], this.options.extent);
        }, fe.prototype.loadGeometry = function() {
          var Q = this.rawGeometry;
          this.geometry = [];
          for (var ie = 0; ie < Q.length; ie++) {
            for (var ce = Q[ie], we = [], Ne = 0; Ne < ce.length; Ne++) we.push(new o.Point$1(ce[Ne][0], ce[Ne][1]));
            this.geometry.push(we);
          }
          return this.geometry;
        }, fe.prototype.bbox = function() {
          this.geometry || this.loadGeometry();
          for (var Q = this.geometry, ie = 1 / 0, ce = -1 / 0, we = 1 / 0, Ne = -1 / 0, pe = 0; pe < Q.length; pe++) for (var Te = Q[pe], le = 0; le < Te.length; le++) {
            var ge = Te[le];
            ie = Math.min(ie, ge.x), ce = Math.max(ce, ge.x), we = Math.min(we, ge.y), Ne = Math.max(Ne, ge.y);
          }
          return [ie, we, ce, Ne];
        }, fe.prototype.toGeoJSON = ae.prototype.toGeoJSON;
        var ve = X, me = De;
        function X(Q) {
          var ie = new o.pbf();
          return (function(ce, we) {
            for (var Ne in ce.layers) we.writeMessage(3, re, ce.layers[Ne]);
          })(Q, ie), ie.finish();
        }
        function re(Q, ie) {
          var ce;
          ie.writeVarintField(15, Q.version || 1), ie.writeStringField(1, Q.name || ""), ie.writeVarintField(5, Q.extent || 4096);
          var we = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (ce = 0; ce < Q.length; ce++) we.feature = Q.feature(ce), ie.writeMessage(2, Me, we);
          var Ne = we.keys;
          for (ce = 0; ce < Ne.length; ce++) ie.writeStringField(3, Ne[ce]);
          var pe = we.values;
          for (ce = 0; ce < pe.length; ce++) ie.writeMessage(4, lt, pe[ce]);
        }
        function Me(Q, ie) {
          var ce = Q.feature;
          ce.id !== void 0 && ie.writeVarintField(1, ce.id), ie.writeMessage(2, ot, Q), ie.writeVarintField(3, ce.type), ie.writeMessage(4, Xe, ce);
        }
        function ot(Q, ie) {
          var ce = Q.feature, we = Q.keys, Ne = Q.values, pe = Q.keycache, Te = Q.valuecache;
          for (var le in ce.properties) {
            var ge = pe[le];
            ge === void 0 && (we.push(le), pe[le] = ge = we.length - 1), ie.writeVarint(ge);
            var d = ce.properties[le], ee = typeof d;
            ee !== "string" && ee !== "boolean" && ee !== "number" && (d = JSON.stringify(d));
            var It = ee + ":" + d, nt = Te[It];
            nt === void 0 && (Ne.push(d), Te[It] = nt = Ne.length - 1), ie.writeVarint(nt);
          }
        }
        function be(Q, ie) {
          return (ie << 3) + (7 & Q);
        }
        function Ue(Q) {
          return Q << 1 ^ Q >> 31;
        }
        function Xe(Q, ie) {
          for (var ce = Q.loadGeometry(), we = Q.type, Ne = 0, pe = 0, Te = ce.length, le = 0; le < Te; le++) {
            var ge = ce[le], d = 1;
            we === 1 && (d = ge.length), ie.writeVarint(be(1, d));
            for (var ee = we === 3 ? ge.length - 1 : ge.length, It = 0; It < ee; It++) {
              It === 1 && we !== 1 && ie.writeVarint(be(2, ee - 1));
              var nt = ge[It].x - Ne, Mt = ge[It].y - pe;
              ie.writeVarint(Ue(nt)), ie.writeVarint(Ue(Mt)), Ne += nt, pe += Mt;
            }
            we === 3 && ie.writeVarint(be(7, 1));
          }
        }
        function lt(Q, ie) {
          var ce = typeof Q;
          ce === "string" ? ie.writeStringField(1, Q) : ce === "boolean" ? ie.writeBooleanField(7, Q) : ce === "number" && (Q % 1 != 0 ? ie.writeDoubleField(3, Q) : Q < 0 ? ie.writeSVarintField(6, Q) : ie.writeVarintField(5, Q));
        }
        function at(Q, ie, ce, we) {
          ct(Q, ce, we), ct(ie, 2 * ce, 2 * we), ct(ie, 2 * ce + 1, 2 * we + 1);
        }
        function ct(Q, ie, ce) {
          var we = Q[ie];
          Q[ie] = Q[ce], Q[ce] = we;
        }
        function gt(Q, ie, ce, we) {
          var Ne = Q - ce, pe = ie - we;
          return Ne * Ne + pe * pe;
        }
        ve.fromVectorTileJs = X, ve.fromGeojsonVt = function(Q, ie) {
          ie = ie || {};
          var ce = {};
          for (var we in Q) ce[we] = new De(Q[we].features, ie), ce[we].name = we, ce[we].version = ie.version, ce[we].extent = ie.extent;
          return X({ layers: ce });
        }, ve.GeoJSONWrapper = me;
        var St = function(Q) {
          return Q[0];
        }, Ot = function(Q) {
          return Q[1];
        }, dt = function(Q, ie, ce, we, Ne) {
          ie === void 0 && (ie = St), ce === void 0 && (ce = Ot), we === void 0 && (we = 64), Ne === void 0 && (Ne = Float64Array), this.nodeSize = we, this.points = Q;
          for (var pe = Q.length < 65536 ? Uint16Array : Uint32Array, Te = this.ids = new pe(Q.length), le = this.coords = new Ne(2 * Q.length), ge = 0; ge < Q.length; ge++) Te[ge] = ge, le[2 * ge] = ie(Q[ge]), le[2 * ge + 1] = ce(Q[ge]);
          (function d(ee, It, nt, Mt, kt, zt) {
            if (!(kt - Mt <= nt)) {
              var _t = Mt + kt >> 1;
              (function Vt(Lt, Yt, Hr, ir, nn, un) {
                for (; nn > ir; ) {
                  if (nn - ir > 600) {
                    var Yr = nn - ir + 1, Qr = Hr - ir + 1, $r = Math.log(Yr), Ai = 0.5 * Math.exp(2 * $r / 3), Kr = 0.5 * Math.sqrt($r * Ai * (Yr - Ai) / Yr) * (Qr - Yr / 2 < 0 ? -1 : 1);
                    Vt(Lt, Yt, Hr, Math.max(ir, Math.floor(Hr - Qr * Ai / Yr + Kr)), Math.min(nn, Math.floor(Hr + (Yr - Qr) * Ai / Yr + Kr)), un);
                  }
                  var hr = Yt[2 * Hr + un], ye = ir, er = nn;
                  for (at(Lt, Yt, ir, Hr), Yt[2 * nn + un] > hr && at(Lt, Yt, ir, nn); ye < er; ) {
                    for (at(Lt, Yt, ye, er), ye++, er--; Yt[2 * ye + un] < hr; ) ye++;
                    for (; Yt[2 * er + un] > hr; ) er--;
                  }
                  Yt[2 * ir + un] === hr ? at(Lt, Yt, ir, er) : at(Lt, Yt, ++er, nn), er <= Hr && (ir = er + 1), Hr <= er && (nn = er - 1);
                }
              })(ee, It, _t, Mt, kt, zt % 2), d(ee, It, nt, Mt, _t - 1, zt + 1), d(ee, It, nt, _t + 1, kt, zt + 1);
            }
          })(Te, le, we, 0, Te.length - 1, 0);
        };
        dt.prototype.range = function(Q, ie, ce, we) {
          return (function(Ne, pe, Te, le, ge, d, ee) {
            for (var It, nt, Mt = [0, Ne.length - 1, 0], kt = []; Mt.length; ) {
              var zt = Mt.pop(), _t = Mt.pop(), Vt = Mt.pop();
              if (_t - Vt <= ee) for (var Lt = Vt; Lt <= _t; Lt++) nt = pe[2 * Lt + 1], (It = pe[2 * Lt]) >= Te && It <= ge && nt >= le && nt <= d && kt.push(Ne[Lt]);
              else {
                var Yt = Math.floor((Vt + _t) / 2);
                nt = pe[2 * Yt + 1], (It = pe[2 * Yt]) >= Te && It <= ge && nt >= le && nt <= d && kt.push(Ne[Yt]);
                var Hr = (zt + 1) % 2;
                (zt === 0 ? Te <= It : le <= nt) && (Mt.push(Vt), Mt.push(Yt - 1), Mt.push(Hr)), (zt === 0 ? ge >= It : d >= nt) && (Mt.push(Yt + 1), Mt.push(_t), Mt.push(Hr));
              }
            }
            return kt;
          })(this.ids, this.coords, Q, ie, ce, we, this.nodeSize);
        }, dt.prototype.within = function(Q, ie, ce) {
          return (function(we, Ne, pe, Te, le, ge) {
            for (var d = [0, we.length - 1, 0], ee = [], It = le * le; d.length; ) {
              var nt = d.pop(), Mt = d.pop(), kt = d.pop();
              if (Mt - kt <= ge) for (var zt = kt; zt <= Mt; zt++) gt(Ne[2 * zt], Ne[2 * zt + 1], pe, Te) <= It && ee.push(we[zt]);
              else {
                var _t = Math.floor((kt + Mt) / 2), Vt = Ne[2 * _t], Lt = Ne[2 * _t + 1];
                gt(Vt, Lt, pe, Te) <= It && ee.push(we[_t]);
                var Yt = (nt + 1) % 2;
                (nt === 0 ? pe - le <= Vt : Te - le <= Lt) && (d.push(kt), d.push(_t - 1), d.push(Yt)), (nt === 0 ? pe + le >= Vt : Te + le >= Lt) && (d.push(_t + 1), d.push(Mt), d.push(Yt));
              }
            }
            return ee;
          })(this.ids, this.coords, Q, ie, ce, this.nodeSize);
        };
        var _r = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: function(Q) {
          return Q;
        } }, sr = function(Q) {
          this.options = $n(Object.create(_r), Q), this.trees = new Array(this.options.maxZoom + 1);
        };
        function tr(Q, ie, ce, we, Ne) {
          return { x: Q, y: ie, zoom: 1 / 0, id: ce, parentId: -1, numPoints: we, properties: Ne };
        }
        function Wt(Q, ie) {
          var ce = Q.geometry.coordinates, we = ce[1];
          return { x: Fr(ce[0]), y: Pr(we), zoom: 1 / 0, index: ie, parentId: -1 };
        }
        function yr(Q) {
          return { type: "Feature", id: Q.id, properties: An(Q), geometry: { type: "Point", coordinates: [(we = Q.x, 360 * (we - 0.5)), (ie = Q.y, ce = (180 - 360 * ie) * Math.PI / 180, 360 * Math.atan(Math.exp(ce)) / Math.PI - 90)] } };
          var ie, ce, we;
        }
        function An(Q) {
          var ie = Q.numPoints, ce = ie >= 1e4 ? Math.round(ie / 1e3) + "k" : ie >= 1e3 ? Math.round(ie / 100) / 10 + "k" : ie;
          return $n($n({}, Q.properties), { cluster: !0, cluster_id: Q.id, point_count: ie, point_count_abbreviated: ce });
        }
        function Fr(Q) {
          return Q / 360 + 0.5;
        }
        function Pr(Q) {
          var ie = Math.sin(Q * Math.PI / 180), ce = 0.5 - 0.25 * Math.log((1 + ie) / (1 - ie)) / Math.PI;
          return ce < 0 ? 0 : ce > 1 ? 1 : ce;
        }
        function $n(Q, ie) {
          for (var ce in ie) Q[ce] = ie[ce];
          return Q;
        }
        function xr(Q) {
          return Q.x;
        }
        function wr(Q) {
          return Q.y;
        }
        function gn(Q, ie, ce, we, Ne, pe) {
          var Te = Ne - ce, le = pe - we;
          if (Te !== 0 || le !== 0) {
            var ge = ((Q - ce) * Te + (ie - we) * le) / (Te * Te + le * le);
            ge > 1 ? (ce = Ne, we = pe) : ge > 0 && (ce += Te * ge, we += le * ge);
          }
          return (Te = Q - ce) * Te + (le = ie - we) * le;
        }
        function zr(Q, ie, ce, we) {
          var Ne = { id: Q === void 0 ? null : Q, type: ie, geometry: ce, tags: we, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          return (function(pe) {
            var Te = pe.geometry, le = pe.type;
            if (le === "Point" || le === "MultiPoint" || le === "LineString") ci(pe, Te);
            else if (le === "Polygon" || le === "MultiLineString") for (var ge = 0; ge < Te.length; ge++) ci(pe, Te[ge]);
            else if (le === "MultiPolygon") for (ge = 0; ge < Te.length; ge++) for (var d = 0; d < Te[ge].length; d++) ci(pe, Te[ge][d]);
          })(Ne), Ne;
        }
        function ci(Q, ie) {
          for (var ce = 0; ce < ie.length; ce += 3) Q.minX = Math.min(Q.minX, ie[ce]), Q.minY = Math.min(Q.minY, ie[ce + 1]), Q.maxX = Math.max(Q.maxX, ie[ce]), Q.maxY = Math.max(Q.maxY, ie[ce + 1]);
        }
        function Jn(Q, ie, ce, we) {
          if (ie.geometry) {
            var Ne = ie.geometry.coordinates, pe = ie.geometry.type, Te = Math.pow(ce.tolerance / ((1 << ce.maxZoom) * ce.extent), 2), le = [], ge = ie.id;
            if (ce.promoteId ? ge = ie.properties[ce.promoteId] : ce.generateId && (ge = we || 0), pe === "Point") wn(Ne, le);
            else if (pe === "MultiPoint") for (var d = 0; d < Ne.length; d++) wn(Ne[d], le);
            else if (pe === "LineString") ii(Ne, le, Te, !1);
            else if (pe === "MultiLineString") {
              if (ce.lineMetrics) {
                for (d = 0; d < Ne.length; d++) ii(Ne[d], le = [], Te, !1), Q.push(zr(ge, "LineString", le, ie.properties));
                return;
              }
              qn(Ne, le, Te, !1);
            } else if (pe === "Polygon") qn(Ne, le, Te, !0);
            else {
              if (pe !== "MultiPolygon") {
                if (pe === "GeometryCollection") {
                  for (d = 0; d < ie.geometry.geometries.length; d++) Jn(Q, { id: ge, geometry: ie.geometry.geometries[d], properties: ie.properties }, ce, we);
                  return;
                }
                throw new Error("Input data is not a valid GeoJSON object.");
              }
              for (d = 0; d < Ne.length; d++) {
                var ee = [];
                qn(Ne[d], ee, Te, !0), le.push(ee);
              }
            }
            Q.push(zr(ge, pe, le, ie.properties));
          }
        }
        function wn(Q, ie) {
          ie.push(Rn(Q[0])), ie.push(ei(Q[1])), ie.push(0);
        }
        function ii(Q, ie, ce, we) {
          for (var Ne, pe, Te = 0, le = 0; le < Q.length; le++) {
            var ge = Rn(Q[le][0]), d = ei(Q[le][1]);
            ie.push(ge), ie.push(d), ie.push(0), le > 0 && (Te += we ? (Ne * d - ge * pe) / 2 : Math.sqrt(Math.pow(ge - Ne, 2) + Math.pow(d - pe, 2))), Ne = ge, pe = d;
          }
          var ee = ie.length - 3;
          ie[2] = 1, (function It(nt, Mt, kt, zt) {
            for (var _t, Vt = zt, Lt = kt - Mt >> 1, Yt = kt - Mt, Hr = nt[Mt], ir = nt[Mt + 1], nn = nt[kt], un = nt[kt + 1], Yr = Mt + 3; Yr < kt; Yr += 3) {
              var Qr = gn(nt[Yr], nt[Yr + 1], Hr, ir, nn, un);
              if (Qr > Vt) _t = Yr, Vt = Qr;
              else if (Qr === Vt) {
                var $r = Math.abs(Yr - Lt);
                $r < Yt && (_t = Yr, Yt = $r);
              }
            }
            Vt > zt && (_t - Mt > 3 && It(nt, Mt, _t, zt), nt[_t + 2] = Vt, kt - _t > 3 && It(nt, _t, kt, zt));
          })(ie, 0, ee, ce), ie[ee + 2] = 1, ie.size = Math.abs(Te), ie.start = 0, ie.end = ie.size;
        }
        function qn(Q, ie, ce, we) {
          for (var Ne = 0; Ne < Q.length; Ne++) {
            var pe = [];
            ii(Q[Ne], pe, ce, we), ie.push(pe);
          }
        }
        function Rn(Q) {
          return Q / 360 + 0.5;
        }
        function ei(Q) {
          var ie = Math.sin(Q * Math.PI / 180), ce = 0.5 - 0.25 * Math.log((1 + ie) / (1 - ie)) / Math.PI;
          return ce < 0 ? 0 : ce > 1 ? 1 : ce;
        }
        function Zt(Q, ie, ce, we, Ne, pe, Te, le) {
          if (we /= ie, pe >= (ce /= ie) && Te < we) return Q;
          if (Te < ce || pe >= we) return null;
          for (var ge = [], d = 0; d < Q.length; d++) {
            var ee = Q[d], It = ee.geometry, nt = ee.type, Mt = Ne === 0 ? ee.minX : ee.minY, kt = Ne === 0 ? ee.maxX : ee.maxY;
            if (Mt >= ce && kt < we) ge.push(ee);
            else if (!(kt < ce || Mt >= we)) {
              var zt = [];
              if (nt === "Point" || nt === "MultiPoint") br(It, zt, ce, we, Ne);
              else if (nt === "LineString") Nr(It, zt, ce, we, Ne, !1, le.lineMetrics);
              else if (nt === "MultiLineString") pi(It, zt, ce, we, Ne, !1);
              else if (nt === "Polygon") pi(It, zt, ce, we, Ne, !0);
              else if (nt === "MultiPolygon") for (var _t = 0; _t < It.length; _t++) {
                var Vt = [];
                pi(It[_t], Vt, ce, we, Ne, !0), Vt.length && zt.push(Vt);
              }
              if (zt.length) {
                if (le.lineMetrics && nt === "LineString") {
                  for (_t = 0; _t < zt.length; _t++) ge.push(zr(ee.id, nt, zt[_t], ee.tags));
                  continue;
                }
                nt !== "LineString" && nt !== "MultiLineString" || (zt.length === 1 ? (nt = "LineString", zt = zt[0]) : nt = "MultiLineString"), nt !== "Point" && nt !== "MultiPoint" || (nt = zt.length === 3 ? "Point" : "MultiPoint"), ge.push(zr(ee.id, nt, zt, ee.tags));
              }
            }
          }
          return ge.length ? ge : null;
        }
        function br(Q, ie, ce, we, Ne) {
          for (var pe = 0; pe < Q.length; pe += 3) {
            var Te = Q[pe + Ne];
            Te >= ce && Te <= we && (ie.push(Q[pe]), ie.push(Q[pe + 1]), ie.push(Q[pe + 2]));
          }
        }
        function Nr(Q, ie, ce, we, Ne, pe, Te) {
          for (var le, ge, d = on(Q), ee = Ne === 0 ? Gt : Jt, It = Q.start, nt = 0; nt < Q.length - 3; nt += 3) {
            var Mt = Q[nt], kt = Q[nt + 1], zt = Q[nt + 2], _t = Q[nt + 3], Vt = Q[nt + 4], Lt = Ne === 0 ? Mt : kt, Yt = Ne === 0 ? _t : Vt, Hr = !1;
            Te && (le = Math.sqrt(Math.pow(Mt - _t, 2) + Math.pow(kt - Vt, 2))), Lt < ce ? Yt > ce && (ge = ee(d, Mt, kt, _t, Vt, ce), Te && (d.start = It + le * ge)) : Lt > we ? Yt < we && (ge = ee(d, Mt, kt, _t, Vt, we), Te && (d.start = It + le * ge)) : Le(d, Mt, kt, zt), Yt < ce && Lt >= ce && (ge = ee(d, Mt, kt, _t, Vt, ce), Hr = !0), Yt > we && Lt <= we && (ge = ee(d, Mt, kt, _t, Vt, we), Hr = !0), !pe && Hr && (Te && (d.end = It + le * ge), ie.push(d), d = on(Q)), Te && (It += le);
          }
          var ir = Q.length - 3;
          Mt = Q[ir], kt = Q[ir + 1], zt = Q[ir + 2], (Lt = Ne === 0 ? Mt : kt) >= ce && Lt <= we && Le(d, Mt, kt, zt), ir = d.length - 3, pe && ir >= 3 && (d[ir] !== d[0] || d[ir + 1] !== d[1]) && Le(d, d[0], d[1], d[2]), d.length && ie.push(d);
        }
        function on(Q) {
          var ie = [];
          return ie.size = Q.size, ie.start = Q.start, ie.end = Q.end, ie;
        }
        function pi(Q, ie, ce, we, Ne, pe) {
          for (var Te = 0; Te < Q.length; Te++) Nr(Q[Te], ie, ce, we, Ne, pe, !1);
        }
        function Le(Q, ie, ce, we) {
          Q.push(ie), Q.push(ce), Q.push(we);
        }
        function Gt(Q, ie, ce, we, Ne, pe) {
          var Te = (pe - ie) / (we - ie);
          return Q.push(pe), Q.push(ce + (Ne - ce) * Te), Q.push(1), Te;
        }
        function Jt(Q, ie, ce, we, Ne, pe) {
          var Te = (pe - ce) / (Ne - ce);
          return Q.push(ie + (we - ie) * Te), Q.push(pe), Q.push(1), Te;
        }
        function pr(Q, ie) {
          for (var ce = [], we = 0; we < Q.length; we++) {
            var Ne, pe = Q[we], Te = pe.type;
            if (Te === "Point" || Te === "MultiPoint" || Te === "LineString") Ne = st(pe.geometry, ie);
            else if (Te === "MultiLineString" || Te === "Polygon") {
              Ne = [];
              for (var le = 0; le < pe.geometry.length; le++) Ne.push(st(pe.geometry[le], ie));
            } else if (Te === "MultiPolygon") for (Ne = [], le = 0; le < pe.geometry.length; le++) {
              for (var ge = [], d = 0; d < pe.geometry[le].length; d++) ge.push(st(pe.geometry[le][d], ie));
              Ne.push(ge);
            }
            ce.push(zr(pe.id, Te, Ne, pe.tags));
          }
          return ce;
        }
        function st(Q, ie) {
          var ce = [];
          ce.size = Q.size, Q.start !== void 0 && (ce.start = Q.start, ce.end = Q.end);
          for (var we = 0; we < Q.length; we += 3) ce.push(Q[we] + ie, Q[we + 1], Q[we + 2]);
          return ce;
        }
        function Ft(Q, ie) {
          if (Q.transformed) return Q;
          var ce, we, Ne, pe = 1 << Q.z, Te = Q.x, le = Q.y;
          for (ce = 0; ce < Q.features.length; ce++) {
            var ge = Q.features[ce], d = ge.geometry, ee = ge.type;
            if (ge.geometry = [], ee === 1) for (we = 0; we < d.length; we += 2) ge.geometry.push(_e(d[we], d[we + 1], ie, pe, Te, le));
            else for (we = 0; we < d.length; we++) {
              var It = [];
              for (Ne = 0; Ne < d[we].length; Ne += 2) It.push(_e(d[we][Ne], d[we][Ne + 1], ie, pe, Te, le));
              ge.geometry.push(It);
            }
          }
          return Q.transformed = !0, Q;
        }
        function _e(Q, ie, ce, we, Ne, pe) {
          return [Math.round(ce * (Q * we - Ne)), Math.round(ce * (ie * we - pe))];
        }
        function Xt(Q, ie, ce, we, Ne) {
          for (var pe = ie === Ne.maxZoom ? 0 : Ne.tolerance / ((1 << ie) * Ne.extent), Te = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: ce, y: we, z: ie, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 }, le = 0; le < Q.length; le++) {
            Te.numFeatures++, Ct(Te, Q[le], pe, Ne);
            var ge = Q[le].minX, d = Q[le].minY, ee = Q[le].maxX, It = Q[le].maxY;
            ge < Te.minX && (Te.minX = ge), d < Te.minY && (Te.minY = d), ee > Te.maxX && (Te.maxX = ee), It > Te.maxY && (Te.maxY = It);
          }
          return Te;
        }
        function Ct(Q, ie, ce, we) {
          var Ne = ie.geometry, pe = ie.type, Te = [];
          if (pe === "Point" || pe === "MultiPoint") for (var le = 0; le < Ne.length; le += 3) Te.push(Ne[le]), Te.push(Ne[le + 1]), Q.numPoints++, Q.numSimplified++;
          else if (pe === "LineString") $(Te, Ne, Q, ce, !1, !1);
          else if (pe === "MultiLineString" || pe === "Polygon") for (le = 0; le < Ne.length; le++) $(Te, Ne[le], Q, ce, pe === "Polygon", le === 0);
          else if (pe === "MultiPolygon") for (var ge = 0; ge < Ne.length; ge++) {
            var d = Ne[ge];
            for (le = 0; le < d.length; le++) $(Te, d[le], Q, ce, !0, le === 0);
          }
          if (Te.length) {
            var ee = ie.tags || null;
            if (pe === "LineString" && we.lineMetrics) {
              for (var It in ee = {}, ie.tags) ee[It] = ie.tags[It];
              ee.mapbox_clip_start = Ne.start / Ne.size, ee.mapbox_clip_end = Ne.end / Ne.size;
            }
            var nt = { geometry: Te, type: pe === "Polygon" || pe === "MultiPolygon" ? 3 : pe === "LineString" || pe === "MultiLineString" ? 2 : 1, tags: ee };
            ie.id !== null && (nt.id = ie.id), Q.features.push(nt);
          }
        }
        function $(Q, ie, ce, we, Ne, pe) {
          var Te = we * we;
          if (we > 0 && ie.size < (Ne ? Te : we)) ce.numPoints += ie.length / 3;
          else {
            for (var le = [], ge = 0; ge < ie.length; ge += 3) (we === 0 || ie[ge + 2] > Te) && (ce.numSimplified++, le.push(ie[ge]), le.push(ie[ge + 1])), ce.numPoints++;
            Ne && (function(d, ee) {
              for (var It = 0, nt = 0, Mt = d.length, kt = Mt - 2; nt < Mt; kt = nt, nt += 2) It += (d[nt] - d[kt]) * (d[nt + 1] + d[kt + 1]);
              if (It > 0 === ee) for (nt = 0, Mt = d.length; nt < Mt / 2; nt += 2) {
                var zt = d[nt], _t = d[nt + 1];
                d[nt] = d[Mt - 2 - nt], d[nt + 1] = d[Mt - 1 - nt], d[Mt - 2 - nt] = zt, d[Mt - 1 - nt] = _t;
              }
            })(le, pe), Q.push(le);
          }
        }
        function Et(Q, ie) {
          var ce = (ie = this.options = (function(Ne, pe) {
            for (var Te in pe) Ne[Te] = pe[Te];
            return Ne;
          })(Object.create(this.options), ie)).debug;
          if (ce && console.time("preprocess data"), ie.maxZoom < 0 || ie.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
          if (ie.promoteId && ie.generateId) throw new Error("promoteId and generateId cannot be used together.");
          var we = (function(Ne, pe) {
            var Te = [];
            if (Ne.type === "FeatureCollection") for (var le = 0; le < Ne.features.length; le++) Jn(Te, Ne.features[le], pe, le);
            else Jn(Te, Ne.type === "Feature" ? Ne : { geometry: Ne }, pe);
            return Te;
          })(Q, ie);
          this.tiles = {}, this.tileCoords = [], ce && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", ie.indexMaxZoom, ie.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), (we = (function(Ne, pe) {
            var Te = pe.buffer / pe.extent, le = Ne, ge = Zt(Ne, 1, -1 - Te, Te, 0, -1, 2, pe), d = Zt(Ne, 1, 1 - Te, 2 + Te, 0, -1, 2, pe);
            return (ge || d) && (le = Zt(Ne, 1, -Te, 1 + Te, 0, -1, 2, pe) || [], ge && (le = pr(ge, 1).concat(le)), d && (le = le.concat(pr(d, -1)))), le;
          })(we, ie)).length && this.splitTile(we, 0, 0, 0), ce && (we.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }
        function Rt(Q, ie, ce) {
          return 32 * ((1 << Q) * ce + ie) + Q;
        }
        function Pe(Q, ie) {
          var ce = Q.tileID.canonical;
          if (!this._geoJSONIndex) return ie(null, null);
          var we = this._geoJSONIndex.getTile(ce.z, ce.x, ce.y);
          if (!we) return ie(null, null);
          var Ne = new ne(we.features), pe = ve(Ne);
          pe.byteOffset === 0 && pe.byteLength === pe.buffer.byteLength || (pe = new Uint8Array(pe)), ie(null, { vectorTile: Ne, rawData: pe.buffer });
        }
        sr.prototype.load = function(Q) {
          var ie = this.options, ce = ie.log, we = ie.minZoom, Ne = ie.maxZoom, pe = ie.nodeSize;
          ce && console.time("total time");
          var Te = "prepare " + Q.length + " points";
          ce && console.time(Te), this.points = Q;
          for (var le = [], ge = 0; ge < Q.length; ge++) Q[ge].geometry && le.push(Wt(Q[ge], ge));
          this.trees[Ne + 1] = new dt(le, xr, wr, pe, Float32Array), ce && console.timeEnd(Te);
          for (var d = Ne; d >= we; d--) {
            var ee = +Date.now();
            le = this._cluster(le, d), this.trees[d] = new dt(le, xr, wr, pe, Float32Array), ce && console.log("z%d: %d clusters in %dms", d, le.length, +Date.now() - ee);
          }
          return ce && console.timeEnd("total time"), this;
        }, sr.prototype.getClusters = function(Q, ie) {
          var ce = ((Q[0] + 180) % 360 + 360) % 360 - 180, we = Math.max(-90, Math.min(90, Q[1])), Ne = Q[2] === 180 ? 180 : ((Q[2] + 180) % 360 + 360) % 360 - 180, pe = Math.max(-90, Math.min(90, Q[3]));
          if (Q[2] - Q[0] >= 360) ce = -180, Ne = 180;
          else if (ce > Ne) {
            var Te = this.getClusters([ce, we, 180, pe], ie), le = this.getClusters([-180, we, Ne, pe], ie);
            return Te.concat(le);
          }
          for (var ge = this.trees[this._limitZoom(ie)], d = [], ee = 0, It = ge.range(Fr(ce), Pr(pe), Fr(Ne), Pr(we)); ee < It.length; ee += 1) {
            var nt = ge.points[It[ee]];
            d.push(nt.numPoints ? yr(nt) : this.points[nt.index]);
          }
          return d;
        }, sr.prototype.getChildren = function(Q) {
          var ie = this._getOriginId(Q), ce = this._getOriginZoom(Q), we = "No cluster with the specified id.", Ne = this.trees[ce];
          if (!Ne) throw new Error(we);
          var pe = Ne.points[ie];
          if (!pe) throw new Error(we);
          for (var Te = this.options.radius / (this.options.extent * Math.pow(2, ce - 1)), le = [], ge = 0, d = Ne.within(pe.x, pe.y, Te); ge < d.length; ge += 1) {
            var ee = Ne.points[d[ge]];
            ee.parentId === Q && le.push(ee.numPoints ? yr(ee) : this.points[ee.index]);
          }
          if (le.length === 0) throw new Error(we);
          return le;
        }, sr.prototype.getLeaves = function(Q, ie, ce) {
          var we = [];
          return this._appendLeaves(we, Q, ie = ie || 10, ce = ce || 0, 0), we;
        }, sr.prototype.getTile = function(Q, ie, ce) {
          var we = this.trees[this._limitZoom(Q)], Ne = Math.pow(2, Q), pe = this.options, Te = pe.radius / pe.extent, le = (ce - Te) / Ne, ge = (ce + 1 + Te) / Ne, d = { features: [] };
          return this._addTileFeatures(we.range((ie - Te) / Ne, le, (ie + 1 + Te) / Ne, ge), we.points, ie, ce, Ne, d), ie === 0 && this._addTileFeatures(we.range(1 - Te / Ne, le, 1, ge), we.points, Ne, ce, Ne, d), ie === Ne - 1 && this._addTileFeatures(we.range(0, le, Te / Ne, ge), we.points, -1, ce, Ne, d), d.features.length ? d : null;
        }, sr.prototype.getClusterExpansionZoom = function(Q) {
          for (var ie = this._getOriginZoom(Q) - 1; ie <= this.options.maxZoom; ) {
            var ce = this.getChildren(Q);
            if (ie++, ce.length !== 1) break;
            Q = ce[0].properties.cluster_id;
          }
          return ie;
        }, sr.prototype._appendLeaves = function(Q, ie, ce, we, Ne) {
          for (var pe = 0, Te = this.getChildren(ie); pe < Te.length; pe += 1) {
            var le = Te[pe], ge = le.properties;
            if (ge && ge.cluster ? Ne + ge.point_count <= we ? Ne += ge.point_count : Ne = this._appendLeaves(Q, ge.cluster_id, ce, we, Ne) : Ne < we ? Ne++ : Q.push(le), Q.length === ce) break;
          }
          return Ne;
        }, sr.prototype._addTileFeatures = function(Q, ie, ce, we, Ne, pe) {
          for (var Te = 0, le = Q; Te < le.length; Te += 1) {
            var ge = ie[le[Te]], d = ge.numPoints, ee = { type: 1, geometry: [[Math.round(this.options.extent * (ge.x * Ne - ce)), Math.round(this.options.extent * (ge.y * Ne - we))]], tags: d ? An(ge) : this.points[ge.index].properties }, It = void 0;
            d ? It = ge.id : this.options.generateId ? It = ge.index : this.points[ge.index].id && (It = this.points[ge.index].id), It !== void 0 && (ee.id = It), pe.features.push(ee);
          }
        }, sr.prototype._limitZoom = function(Q) {
          return Math.max(this.options.minZoom, Math.min(+Q, this.options.maxZoom + 1));
        }, sr.prototype._cluster = function(Q, ie) {
          for (var ce = [], we = this.options, Ne = we.reduce, pe = we.minPoints, Te = we.radius / (we.extent * Math.pow(2, ie)), le = 0; le < Q.length; le++) {
            var ge = Q[le];
            if (!(ge.zoom <= ie)) {
              ge.zoom = ie;
              for (var d = this.trees[ie + 1], ee = d.within(ge.x, ge.y, Te), It = ge.numPoints || 1, nt = It, Mt = 0, kt = ee; Mt < kt.length; Mt += 1) {
                var zt = d.points[kt[Mt]];
                zt.zoom > ie && (nt += zt.numPoints || 1);
              }
              if (nt >= pe) {
                for (var _t = ge.x * It, Vt = ge.y * It, Lt = Ne && It > 1 ? this._map(ge, !0) : null, Yt = (le << 5) + (ie + 1) + this.points.length, Hr = 0, ir = ee; Hr < ir.length; Hr += 1) {
                  var nn = d.points[ir[Hr]];
                  if (!(nn.zoom <= ie)) {
                    nn.zoom = ie;
                    var un = nn.numPoints || 1;
                    _t += nn.x * un, Vt += nn.y * un, nn.parentId = Yt, Ne && (Lt || (Lt = this._map(ge, !0)), Ne(Lt, this._map(nn)));
                  }
                }
                ge.parentId = Yt, ce.push(tr(_t / nt, Vt / nt, Yt, nt, Lt));
              } else if (ce.push(ge), nt > 1) for (var Yr = 0, Qr = ee; Yr < Qr.length; Yr += 1) {
                var $r = d.points[Qr[Yr]];
                $r.zoom <= ie || ($r.zoom = ie, ce.push($r));
              }
            }
          }
          return ce;
        }, sr.prototype._getOriginId = function(Q) {
          return Q - this.points.length >> 5;
        }, sr.prototype._getOriginZoom = function(Q) {
          return (Q - this.points.length) % 32;
        }, sr.prototype._map = function(Q, ie) {
          if (Q.numPoints) return ie ? $n({}, Q.properties) : Q.properties;
          var ce = this.points[Q.index].properties, we = this.options.map(ce);
          return ie && we === ce ? $n({}, we) : we;
        }, Et.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 }, Et.prototype.splitTile = function(Q, ie, ce, we, Ne, pe, Te) {
          for (var le = [Q, ie, ce, we], ge = this.options, d = ge.debug; le.length; ) {
            we = le.pop(), ce = le.pop(), ie = le.pop(), Q = le.pop();
            var ee = 1 << ie, It = Rt(ie, ce, we), nt = this.tiles[It];
            if (!nt && (d > 1 && console.time("creation"), nt = this.tiles[It] = Xt(Q, ie, ce, we, ge), this.tileCoords.push({ z: ie, x: ce, y: we }), d)) {
              d > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", ie, ce, we, nt.numFeatures, nt.numPoints, nt.numSimplified), console.timeEnd("creation"));
              var Mt = "z" + ie;
              this.stats[Mt] = (this.stats[Mt] || 0) + 1, this.total++;
            }
            if (nt.source = Q, Ne) {
              if (ie === ge.maxZoom || ie === Ne) continue;
              var kt = 1 << Ne - ie;
              if (ce !== Math.floor(pe / kt) || we !== Math.floor(Te / kt)) continue;
            } else if (ie === ge.indexMaxZoom || nt.numPoints <= ge.indexMaxPoints) continue;
            if (nt.source = null, Q.length !== 0) {
              d > 1 && console.time("clipping");
              var zt, _t, Vt, Lt, Yt, Hr, ir = 0.5 * ge.buffer / ge.extent, nn = 0.5 - ir, un = 0.5 + ir, Yr = 1 + ir;
              zt = _t = Vt = Lt = null, Yt = Zt(Q, ee, ce - ir, ce + un, 0, nt.minX, nt.maxX, ge), Hr = Zt(Q, ee, ce + nn, ce + Yr, 0, nt.minX, nt.maxX, ge), Q = null, Yt && (zt = Zt(Yt, ee, we - ir, we + un, 1, nt.minY, nt.maxY, ge), _t = Zt(Yt, ee, we + nn, we + Yr, 1, nt.minY, nt.maxY, ge), Yt = null), Hr && (Vt = Zt(Hr, ee, we - ir, we + un, 1, nt.minY, nt.maxY, ge), Lt = Zt(Hr, ee, we + nn, we + Yr, 1, nt.minY, nt.maxY, ge), Hr = null), d > 1 && console.timeEnd("clipping"), le.push(zt || [], ie + 1, 2 * ce, 2 * we), le.push(_t || [], ie + 1, 2 * ce, 2 * we + 1), le.push(Vt || [], ie + 1, 2 * ce + 1, 2 * we), le.push(Lt || [], ie + 1, 2 * ce + 1, 2 * we + 1);
            }
          }
        }, Et.prototype.getTile = function(Q, ie, ce) {
          var we = this.options, Ne = we.extent, pe = we.debug;
          if (Q < 0 || Q > 24) return null;
          var Te = 1 << Q, le = Rt(Q, ie = (ie % Te + Te) % Te, ce);
          if (this.tiles[le]) return Ft(this.tiles[le], Ne);
          pe > 1 && console.log("drilling down to z%d-%d-%d", Q, ie, ce);
          for (var ge, d = Q, ee = ie, It = ce; !ge && d > 0; ) d--, ee = Math.floor(ee / 2), It = Math.floor(It / 2), ge = this.tiles[Rt(d, ee, It)];
          return ge && ge.source ? (pe > 1 && console.log("found parent tile z%d-%d-%d", d, ee, It), pe > 1 && console.time("drilling down"), this.splitTile(ge.source, d, ee, It, Q, ie, ce), pe > 1 && console.timeEnd("drilling down"), this.tiles[le] ? Ft(this.tiles[le], Ne) : null) : null;
        };
        var tt = (function(Q) {
          function ie(ce, we, Ne, pe) {
            Q.call(this, ce, we, Ne, Pe), pe && (this.loadGeoJSON = pe);
          }
          return Q && (ie.__proto__ = Q), (ie.prototype = Object.create(Q && Q.prototype)).constructor = ie, ie.prototype.loadData = function(ce, we) {
            this._pendingCallback && this._pendingCallback(null, { abandoned: !0 }), this._pendingCallback = we, this._pendingLoadDataParams = ce, this._state && this._state !== "Idle" ? this._state = "NeedsLoadData" : (this._state = "Coalescing", this._loadData());
          }, ie.prototype._loadData = function() {
            var ce = this;
            if (this._pendingCallback && this._pendingLoadDataParams) {
              var we = this._pendingCallback, Ne = this._pendingLoadDataParams;
              delete this._pendingCallback, delete this._pendingLoadDataParams;
              var pe = !!(Ne && Ne.request && Ne.request.collectResourceTiming) && new o.RequestPerformance(Ne.request);
              this.loadGeoJSON(Ne, (function(Te, le) {
                if (Te || !le) return we(Te);
                if (typeof le != "object") return we(new Error("Input data given to '" + Ne.source + "' is not a valid GeoJSON object."));
                (function nt(Mt, kt) {
                  var zt, _t = Mt && Mt.type;
                  if (_t === "FeatureCollection") for (zt = 0; zt < Mt.features.length; zt++) nt(Mt.features[zt], kt);
                  else if (_t === "GeometryCollection") for (zt = 0; zt < Mt.geometries.length; zt++) nt(Mt.geometries[zt], kt);
                  else if (_t === "Feature") nt(Mt.geometry, kt);
                  else if (_t === "Polygon") j(Mt.coordinates, kt);
                  else if (_t === "MultiPolygon") for (zt = 0; zt < Mt.coordinates.length; zt++) j(Mt.coordinates[zt], kt);
                  return Mt;
                })(le, !0);
                try {
                  if (Ne.filter) {
                    var ge = o.createExpression(Ne.filter, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 });
                    if (ge.result === "error") throw new Error(ge.value.map((function(nt) {
                      return nt.key + ": " + nt.message;
                    })).join(", "));
                    var d = le.features.filter((function(nt) {
                      return ge.value.evaluate({ zoom: 0 }, nt);
                    }));
                    le = { type: "FeatureCollection", features: d };
                  }
                  ce._geoJSONIndex = Ne.cluster ? new sr((function(nt) {
                    var Mt = nt.superclusterOptions, kt = nt.clusterProperties;
                    if (!kt || !Mt) return Mt;
                    for (var zt = {}, _t = {}, Vt = { accumulated: null, zoom: 0 }, Lt = { properties: null }, Yt = Object.keys(kt), Hr = 0, ir = Yt; Hr < ir.length; Hr += 1) {
                      var nn = ir[Hr], un = kt[nn], Yr = un[0], Qr = o.createExpression(un[1]), $r = o.createExpression(typeof Yr == "string" ? [Yr, ["accumulated"], ["get", nn]] : Yr);
                      zt[nn] = Qr.value, _t[nn] = $r.value;
                    }
                    return Mt.map = function(Ai) {
                      Lt.properties = Ai;
                      for (var Kr = {}, hr = 0, ye = Yt; hr < ye.length; hr += 1) {
                        var er = ye[hr];
                        Kr[er] = zt[er].evaluate(Vt, Lt);
                      }
                      return Kr;
                    }, Mt.reduce = function(Ai, Kr) {
                      Lt.properties = Kr;
                      for (var hr = 0, ye = Yt; hr < ye.length; hr += 1) {
                        var er = ye[hr];
                        Vt.accumulated = Ai[er], Ai[er] = _t[er].evaluate(Vt, Lt);
                      }
                    }, Mt;
                  })(Ne)).load(le.features) : (function(nt, Mt) {
                    return new Et(nt, Mt);
                  })(le, Ne.geojsonVtOptions);
                } catch (nt) {
                  return we(nt);
                }
                ce.loaded = {};
                var ee = {};
                if (pe) {
                  var It = pe.finish();
                  It && (ee.resourceTiming = {}, ee.resourceTiming[Ne.source] = JSON.parse(JSON.stringify(It)));
                }
                we(null, ee);
              }));
            }
          }, ie.prototype.coalesce = function() {
            this._state === "Coalescing" ? this._state = "Idle" : this._state === "NeedsLoadData" && (this._state = "Coalescing", this._loadData());
          }, ie.prototype.reloadTile = function(ce, we) {
            var Ne = this.loaded;
            return Ne && Ne[ce.uid] ? Q.prototype.reloadTile.call(this, ce, we) : this.loadTile(ce, we);
          }, ie.prototype.loadGeoJSON = function(ce, we) {
            if (ce.request) o.getJSON(ce.request, we);
            else {
              if (typeof ce.data != "string") return we(new Error("Input data given to '" + ce.source + "' is not a valid GeoJSON object."));
              try {
                return we(null, JSON.parse(ce.data));
              } catch {
                return we(new Error("Input data given to '" + ce.source + "' is not a valid GeoJSON object."));
              }
            }
          }, ie.prototype.removeSource = function(ce, we) {
            this._pendingCallback && this._pendingCallback(null, { abandoned: !0 }), we();
          }, ie.prototype.getClusterExpansionZoom = function(ce, we) {
            try {
              we(null, this._geoJSONIndex.getClusterExpansionZoom(ce.clusterId));
            } catch (Ne) {
              we(Ne);
            }
          }, ie.prototype.getClusterChildren = function(ce, we) {
            try {
              we(null, this._geoJSONIndex.getChildren(ce.clusterId));
            } catch (Ne) {
              we(Ne);
            }
          }, ie.prototype.getClusterLeaves = function(ce, we) {
            try {
              we(null, this._geoJSONIndex.getLeaves(ce.clusterId, ce.limit, ce.offset));
            } catch (Ne) {
              we(Ne);
            }
          }, ie;
        })(U), At = function(Q) {
          var ie = this;
          this.self = Q, this.actor = new o.Actor(Q, this), this.layerIndexes = {}, this.availableImages = {}, this.workerSourceTypes = { vector: U, geojson: tt }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = function(ce, we) {
            if (ie.workerSourceTypes[ce]) throw new Error('Worker source with name "' + ce + '" already registered.');
            ie.workerSourceTypes[ce] = we;
          }, this.self.registerRTLTextPlugin = function(ce) {
            if (o.plugin.isParsed()) throw new Error("RTL text plugin already registered.");
            o.plugin.applyArabicShaping = ce.applyArabicShaping, o.plugin.processBidirectionalText = ce.processBidirectionalText, o.plugin.processStyledBidirectionalText = ce.processStyledBidirectionalText;
          };
        };
        return At.prototype.setReferrer = function(Q, ie) {
          this.referrer = ie;
        }, At.prototype.setImages = function(Q, ie, ce) {
          for (var we in this.availableImages[Q] = ie, this.workerSources[Q]) {
            var Ne = this.workerSources[Q][we];
            for (var pe in Ne) Ne[pe].availableImages = ie;
          }
          ce();
        }, At.prototype.setLayers = function(Q, ie, ce) {
          this.getLayerIndex(Q).replace(ie), ce();
        }, At.prototype.updateLayers = function(Q, ie, ce) {
          this.getLayerIndex(Q).update(ie.layers, ie.removedIds), ce();
        }, At.prototype.loadTile = function(Q, ie, ce) {
          this.getWorkerSource(Q, ie.type, ie.source).loadTile(ie, ce);
        }, At.prototype.loadDEMTile = function(Q, ie, ce) {
          this.getDEMWorkerSource(Q, ie.source).loadTile(ie, ce);
        }, At.prototype.reloadTile = function(Q, ie, ce) {
          this.getWorkerSource(Q, ie.type, ie.source).reloadTile(ie, ce);
        }, At.prototype.abortTile = function(Q, ie, ce) {
          this.getWorkerSource(Q, ie.type, ie.source).abortTile(ie, ce);
        }, At.prototype.removeTile = function(Q, ie, ce) {
          this.getWorkerSource(Q, ie.type, ie.source).removeTile(ie, ce);
        }, At.prototype.removeDEMTile = function(Q, ie) {
          this.getDEMWorkerSource(Q, ie.source).removeTile(ie);
        }, At.prototype.removeSource = function(Q, ie, ce) {
          if (this.workerSources[Q] && this.workerSources[Q][ie.type] && this.workerSources[Q][ie.type][ie.source]) {
            var we = this.workerSources[Q][ie.type][ie.source];
            delete this.workerSources[Q][ie.type][ie.source], we.removeSource !== void 0 ? we.removeSource(ie, ce) : ce();
          }
        }, At.prototype.loadWorkerSource = function(Q, ie, ce) {
          try {
            this.self.importScripts(ie.url), ce();
          } catch (we) {
            ce(we.toString());
          }
        }, At.prototype.syncRTLPluginState = function(Q, ie, ce) {
          try {
            o.plugin.setState(ie);
            var we = o.plugin.getPluginURL();
            if (o.plugin.isLoaded() && !o.plugin.isParsed() && we != null) {
              this.self.importScripts(we);
              var Ne = o.plugin.isParsed();
              ce(Ne ? void 0 : new Error("RTL Text Plugin failed to import scripts from " + we), Ne);
            }
          } catch (pe) {
            ce(pe.toString());
          }
        }, At.prototype.getAvailableImages = function(Q) {
          var ie = this.availableImages[Q];
          return ie || (ie = []), ie;
        }, At.prototype.getLayerIndex = function(Q) {
          var ie = this.layerIndexes[Q];
          return ie || (ie = this.layerIndexes[Q] = new m()), ie;
        }, At.prototype.getWorkerSource = function(Q, ie, ce) {
          var we = this;
          return this.workerSources[Q] || (this.workerSources[Q] = {}), this.workerSources[Q][ie] || (this.workerSources[Q][ie] = {}), this.workerSources[Q][ie][ce] || (this.workerSources[Q][ie][ce] = new this.workerSourceTypes[ie]({ send: function(Ne, pe, Te) {
            we.actor.send(Ne, pe, Te, Q);
          } }, this.getLayerIndex(Q), this.getAvailableImages(Q))), this.workerSources[Q][ie][ce];
        }, At.prototype.getDEMWorkerSource = function(Q, ie) {
          return this.demWorkerSources[Q] || (this.demWorkerSources[Q] = {}), this.demWorkerSources[Q][ie] || (this.demWorkerSources[Q][ie] = new q()), this.demWorkerSources[Q][ie];
        }, At.prototype.enforceCacheSizeLimit = function(Q, ie) {
          o.enforceCacheSizeLimit(ie);
        }, typeof WorkerGlobalScope < "u" && typeof self < "u" && self instanceof WorkerGlobalScope && (self.worker = new At(self)), At;
      })), s(["./shared"], (function(o) {
        var l = o.createCommonjsModule((function(g) {
          function v(R) {
            return !_(R);
          }
          function _(R) {
            return typeof window > "u" || typeof document > "u" ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? (function() {
              if (!("Worker" in window && "Blob" in window && "URL" in window)) return !1;
              var k, H, J = new Blob([""], { type: "text/javascript" }), oe = URL.createObjectURL(J);
              try {
                H = new Worker(oe), k = !0;
              } catch {
                k = !1;
              }
              return H && H.terminate(), URL.revokeObjectURL(oe), k;
            })() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? (function() {
              var k = document.createElement("canvas");
              k.width = k.height = 1;
              var H = k.getContext("2d");
              if (!H) return !1;
              var J = H.getImageData(0, 0, 1, 1);
              return J && J.width === k.width;
            })() ? (w[D = R && R.failIfMajorPerformanceCaveat] === void 0 && (w[D] = (function(k) {
              var H = (function(oe) {
                var Ce = document.createElement("canvas"), Se = Object.create(v.webGLContextAttributes);
                return Se.failIfMajorPerformanceCaveat = oe, Ce.probablySupportsContext ? Ce.probablySupportsContext("webgl", Se) || Ce.probablySupportsContext("experimental-webgl", Se) : Ce.supportsContext ? Ce.supportsContext("webgl", Se) || Ce.supportsContext("experimental-webgl", Se) : Ce.getContext("webgl", Se) || Ce.getContext("experimental-webgl", Se);
              })(k);
              if (!H) return !1;
              var J = H.createShader(H.VERTEX_SHADER);
              return !(!J || H.isContextLost()) && (H.shaderSource(J, "void main() {}"), H.compileShader(J), H.getShaderParameter(J, H.COMPILE_STATUS) === !0);
            })(D)), w[D] ? void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";
            var D;
          }
          g.exports ? g.exports = v : window && (window.mapboxgl = window.mapboxgl || {}, window.mapboxgl.supported = v, window.mapboxgl.notSupportedReason = _);
          var w = {};
          v.webGLContextAttributes = { antialias: !1, alpha: !0, stencil: !0, depth: !0 };
        })), u = { create: function(g, v, _) {
          var w = o.window.document.createElement(g);
          return v !== void 0 && (w.className = v), _ && _.appendChild(w), w;
        }, createNS: function(g, v) {
          return o.window.document.createElementNS(g, v);
        } }, m = o.window.document && o.window.document.documentElement.style;
        function y(g) {
          if (!m) return g[0];
          for (var v = 0; v < g.length; v++) if (g[v] in m) return g[v];
          return g[0];
        }
        var E, P = y(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]);
        u.disableDrag = function() {
          m && P && (E = m[P], m[P] = "none");
        }, u.enableDrag = function() {
          m && P && (m[P] = E);
        };
        var L = y(["transform", "WebkitTransform"]);
        u.setTransform = function(g, v) {
          g.style[L] = v;
        };
        var U = !1;
        try {
          var V = Object.defineProperty({}, "passive", { get: function() {
            U = !0;
          } });
          o.window.addEventListener("test", V, V), o.window.removeEventListener("test", V, V);
        } catch {
          U = !1;
        }
        u.addEventListener = function(g, v, _, w) {
          w === void 0 && (w = {}), g.addEventListener(v, _, "passive" in w && U ? w : w.capture);
        }, u.removeEventListener = function(g, v, _, w) {
          w === void 0 && (w = {}), g.removeEventListener(v, _, "passive" in w && U ? w : w.capture);
        };
        var q = function(g) {
          g.preventDefault(), g.stopPropagation(), o.window.removeEventListener("click", q, !0);
        };
        function j(g) {
          var v = g.userImage;
          return !!(v && v.render && v.render()) && (g.data.replace(new Uint8Array(v.data.buffer)), !0);
        }
        u.suppressClick = function() {
          o.window.addEventListener("click", q, !0), o.window.setTimeout((function() {
            o.window.removeEventListener("click", q, !0);
          }), 0);
        }, u.mousePos = function(g, v) {
          var _ = g.getBoundingClientRect();
          return new o.Point(v.clientX - _.left - g.clientLeft, v.clientY - _.top - g.clientTop);
        }, u.touchPos = function(g, v) {
          for (var _ = g.getBoundingClientRect(), w = [], R = 0; R < v.length; R++) w.push(new o.Point(v[R].clientX - _.left - g.clientLeft, v[R].clientY - _.top - g.clientTop));
          return w;
        }, u.mouseButton = function(g) {
          return o.window.InstallTrigger !== void 0 && g.button === 2 && g.ctrlKey && o.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : g.button;
        }, u.remove = function(g) {
          g.parentNode && g.parentNode.removeChild(g);
        };
        var K = (function(g) {
          function v() {
            g.call(this), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new o.RGBAImage({ width: 1, height: 1 }), this.dirty = !0;
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.isLoaded = function() {
            return this.loaded;
          }, v.prototype.setLoaded = function(_) {
            if (this.loaded !== _ && (this.loaded = _, _)) {
              for (var w = 0, R = this.requestors; w < R.length; w += 1) {
                var D = R[w];
                this._notify(D.ids, D.callback);
              }
              this.requestors = [];
            }
          }, v.prototype.getImage = function(_) {
            return this.images[_];
          }, v.prototype.addImage = function(_, w) {
            this._validate(_, w) && (this.images[_] = w);
          }, v.prototype._validate = function(_, w) {
            var R = !0;
            return this._validateStretch(w.stretchX, w.data && w.data.width) || (this.fire(new o.ErrorEvent(new Error('Image "' + _ + '" has invalid "stretchX" value'))), R = !1), this._validateStretch(w.stretchY, w.data && w.data.height) || (this.fire(new o.ErrorEvent(new Error('Image "' + _ + '" has invalid "stretchY" value'))), R = !1), this._validateContent(w.content, w) || (this.fire(new o.ErrorEvent(new Error('Image "' + _ + '" has invalid "content" value'))), R = !1), R;
          }, v.prototype._validateStretch = function(_, w) {
            if (!_) return !0;
            for (var R = 0, D = 0, k = _; D < k.length; D += 1) {
              var H = k[D];
              if (H[0] < R || H[1] < H[0] || w < H[1]) return !1;
              R = H[1];
            }
            return !0;
          }, v.prototype._validateContent = function(_, w) {
            return !(_ && (_.length !== 4 || _[0] < 0 || w.data.width < _[0] || _[1] < 0 || w.data.height < _[1] || _[2] < 0 || w.data.width < _[2] || _[3] < 0 || w.data.height < _[3] || _[2] < _[0] || _[3] < _[1]));
          }, v.prototype.updateImage = function(_, w) {
            w.version = this.images[_].version + 1, this.images[_] = w, this.updatedImages[_] = !0;
          }, v.prototype.removeImage = function(_) {
            var w = this.images[_];
            delete this.images[_], delete this.patterns[_], w.userImage && w.userImage.onRemove && w.userImage.onRemove();
          }, v.prototype.listImages = function() {
            return Object.keys(this.images);
          }, v.prototype.getImages = function(_, w) {
            var R = !0;
            if (!this.isLoaded()) for (var D = 0, k = _; D < k.length; D += 1) this.images[k[D]] || (R = !1);
            this.isLoaded() || R ? this._notify(_, w) : this.requestors.push({ ids: _, callback: w });
          }, v.prototype._notify = function(_, w) {
            for (var R = {}, D = 0, k = _; D < k.length; D += 1) {
              var H = k[D];
              this.images[H] || this.fire(new o.Event("styleimagemissing", { id: H }));
              var J = this.images[H];
              J ? R[H] = { data: J.data.clone(), pixelRatio: J.pixelRatio, sdf: J.sdf, version: J.version, stretchX: J.stretchX, stretchY: J.stretchY, content: J.content, hasRenderCallback: !!(J.userImage && J.userImage.render) } : o.warnOnce('Image "' + H + '" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.');
            }
            w(null, R);
          }, v.prototype.getPixelSize = function() {
            var _ = this.atlasImage;
            return { width: _.width, height: _.height };
          }, v.prototype.getPattern = function(_) {
            var w = this.patterns[_], R = this.getImage(_);
            if (!R) return null;
            if (w && w.position.version === R.version) return w.position;
            if (w) w.position.version = R.version;
            else {
              var D = { w: R.data.width + 2, h: R.data.height + 2, x: 0, y: 0 }, k = new o.ImagePosition(D, R);
              this.patterns[_] = { bin: D, position: k };
            }
            return this._updatePatternAtlas(), this.patterns[_].position;
          }, v.prototype.bind = function(_) {
            var w = _.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new o.Texture(_, this.atlasImage, w.RGBA), this.atlasTexture.bind(w.LINEAR, w.CLAMP_TO_EDGE);
          }, v.prototype._updatePatternAtlas = function() {
            var _ = [];
            for (var w in this.patterns) _.push(this.patterns[w].bin);
            var R = o.potpack(_), D = R.w, k = R.h, H = this.atlasImage;
            for (var J in H.resize({ width: D || 1, height: k || 1 }), this.patterns) {
              var oe = this.patterns[J].bin, Ce = oe.x + 1, Se = oe.y + 1, Oe = this.images[J].data, He = Oe.width, ze = Oe.height;
              o.RGBAImage.copy(Oe, H, { x: 0, y: 0 }, { x: Ce, y: Se }, { width: He, height: ze }), o.RGBAImage.copy(Oe, H, { x: 0, y: ze - 1 }, { x: Ce, y: Se - 1 }, { width: He, height: 1 }), o.RGBAImage.copy(Oe, H, { x: 0, y: 0 }, { x: Ce, y: Se + ze }, { width: He, height: 1 }), o.RGBAImage.copy(Oe, H, { x: He - 1, y: 0 }, { x: Ce - 1, y: Se }, { width: 1, height: ze }), o.RGBAImage.copy(Oe, H, { x: 0, y: 0 }, { x: Ce + He, y: Se }, { width: 1, height: ze });
            }
            this.dirty = !0;
          }, v.prototype.beginFrame = function() {
            this.callbackDispatchedThisFrame = {};
          }, v.prototype.dispatchRenderCallbacks = function(_) {
            for (var w = 0, R = _; w < R.length; w += 1) {
              var D = R[w];
              if (!this.callbackDispatchedThisFrame[D]) {
                this.callbackDispatchedThisFrame[D] = !0;
                var k = this.images[D];
                j(k) && this.updateImage(D, k);
              }
            }
          }, v;
        })(o.Evented), Y = ae, de = ae, ne = 1e20;
        function ae(g, v, _, w, R, D) {
          this.fontSize = g || 24, this.buffer = v === void 0 ? 3 : v, this.cutoff = w || 0.25, this.fontFamily = R || "sans-serif", this.fontWeight = D || "normal", this.radius = _ || 8;
          var k = this.size = this.fontSize + 2 * this.buffer;
          this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = k, this.ctx = this.canvas.getContext("2d"), this.ctx.font = this.fontWeight + " " + this.fontSize + "px " + this.fontFamily, this.ctx.textBaseline = "middle", this.ctx.fillStyle = "black", this.gridOuter = new Float64Array(k * k), this.gridInner = new Float64Array(k * k), this.f = new Float64Array(k), this.d = new Float64Array(k), this.z = new Float64Array(k + 1), this.v = new Int16Array(k), this.middle = Math.round(k / 2 * (navigator.userAgent.indexOf("Gecko/") >= 0 ? 1.2 : 1));
        }
        function De(g, v, _, w, R, D, k) {
          for (var H = 0; H < v; H++) {
            for (var J = 0; J < _; J++) w[J] = g[J * v + H];
            for (Ge(w, R, D, k, _), J = 0; J < _; J++) g[J * v + H] = R[J];
          }
          for (J = 0; J < _; J++) {
            for (H = 0; H < v; H++) w[H] = g[J * v + H];
            for (Ge(w, R, D, k, v), H = 0; H < v; H++) g[J * v + H] = Math.sqrt(R[H]);
          }
        }
        function Ge(g, v, _, w, R) {
          _[0] = 0, w[0] = -ne, w[1] = +ne;
          for (var D = 1, k = 0; D < R; D++) {
            for (var H = (g[D] + D * D - (g[_[k]] + _[k] * _[k])) / (2 * D - 2 * _[k]); H <= w[k]; ) k--, H = (g[D] + D * D - (g[_[k]] + _[k] * _[k])) / (2 * D - 2 * _[k]);
            _[++k] = D, w[k] = H, w[k + 1] = +ne;
          }
          for (D = 0, k = 0; D < R; D++) {
            for (; w[k + 1] < D; ) k++;
            v[D] = (D - _[k]) * (D - _[k]) + g[_[k]];
          }
        }
        ae.prototype.draw = function(g) {
          this.ctx.clearRect(0, 0, this.size, this.size), this.ctx.fillText(g, this.buffer, this.middle);
          for (var v = this.ctx.getImageData(0, 0, this.size, this.size), _ = new Uint8ClampedArray(this.size * this.size), w = 0; w < this.size * this.size; w++) {
            var R = v.data[4 * w + 3] / 255;
            this.gridOuter[w] = R === 1 ? 0 : R === 0 ? ne : Math.pow(Math.max(0, 0.5 - R), 2), this.gridInner[w] = R === 1 ? ne : R === 0 ? 0 : Math.pow(Math.max(0, R - 0.5), 2);
          }
          for (De(this.gridOuter, this.size, this.size, this.f, this.d, this.v, this.z), De(this.gridInner, this.size, this.size, this.f, this.d, this.v, this.z), w = 0; w < this.size * this.size; w++) _[w] = Math.max(0, Math.min(255, Math.round(255 - 255 * ((this.gridOuter[w] - this.gridInner[w]) / this.radius + this.cutoff))));
          return _;
        }, Y.default = de;
        var fe = function(g, v) {
          this.requestManager = g, this.localIdeographFontFamily = v, this.entries = {};
        };
        fe.prototype.setURL = function(g) {
          this.url = g;
        }, fe.prototype.getGlyphs = function(g, v) {
          var _ = this, w = [];
          for (var R in g) for (var D = 0, k = g[R]; D < k.length; D += 1) w.push({ stack: R, id: k[D] });
          o.asyncAll(w, (function(H, J) {
            var oe = H.stack, Ce = H.id, Se = _.entries[oe];
            Se || (Se = _.entries[oe] = { glyphs: {}, requests: {}, ranges: {} });
            var Oe = Se.glyphs[Ce];
            if (Oe === void 0) {
              if (Oe = _._tinySDF(Se, oe, Ce)) return Se.glyphs[Ce] = Oe, void J(null, { stack: oe, id: Ce, glyph: Oe });
              var He = Math.floor(Ce / 256);
              if (256 * He > 65535) J(new Error("glyphs > 65535 not supported"));
              else if (Se.ranges[He]) J(null, { stack: oe, id: Ce, glyph: Oe });
              else {
                var ze = Se.requests[He];
                ze || (ze = Se.requests[He] = [], fe.loadGlyphRange(oe, He, _.url, _.requestManager, (function(h, f) {
                  if (f) {
                    for (var A in f) _._doesCharSupportLocalGlyph(+A) || (Se.glyphs[+A] = f[+A]);
                    Se.ranges[He] = !0;
                  }
                  for (var b = 0, T = ze; b < T.length; b += 1) (0, T[b])(h, f);
                  delete Se.requests[He];
                }))), ze.push((function(h, f) {
                  h ? J(h) : f && J(null, { stack: oe, id: Ce, glyph: f[Ce] || null });
                }));
              }
            } else J(null, { stack: oe, id: Ce, glyph: Oe });
          }), (function(H, J) {
            if (H) v(H);
            else if (J) {
              for (var oe = {}, Ce = 0, Se = J; Ce < Se.length; Ce += 1) {
                var Oe = Se[Ce], He = Oe.stack, ze = Oe.id, h = Oe.glyph;
                (oe[He] || (oe[He] = {}))[ze] = h && { id: h.id, bitmap: h.bitmap.clone(), metrics: h.metrics };
              }
              v(null, oe);
            }
          }));
        }, fe.prototype._doesCharSupportLocalGlyph = function(g) {
          return !!this.localIdeographFontFamily && (o.isChar["CJK Unified Ideographs"](g) || o.isChar["Hangul Syllables"](g) || o.isChar.Hiragana(g) || o.isChar.Katakana(g));
        }, fe.prototype._tinySDF = function(g, v, _) {
          var w = this.localIdeographFontFamily;
          if (w && this._doesCharSupportLocalGlyph(_)) {
            var R = g.tinySDF;
            if (!R) {
              var D = "400";
              /bold/i.test(v) ? D = "900" : /medium/i.test(v) ? D = "500" : /light/i.test(v) && (D = "200"), R = g.tinySDF = new fe.TinySDF(24, 3, 8, 0.25, w, D);
            }
            return { id: _, bitmap: new o.AlphaImage({ width: 30, height: 30 }, R.draw(String.fromCharCode(_))), metrics: { width: 24, height: 24, left: 0, top: -8, advance: 24 } };
          }
        }, fe.loadGlyphRange = function(g, v, _, w, R) {
          var D = 256 * v, k = D + 255, H = w.transformRequest(w.normalizeGlyphsURL(_).replace("{fontstack}", g).replace("{range}", D + "-" + k), o.ResourceType.Glyphs);
          o.getArrayBuffer(H, (function(J, oe) {
            if (J) R(J);
            else if (oe) {
              for (var Ce = {}, Se = 0, Oe = o.parseGlyphPBF(oe); Se < Oe.length; Se += 1) {
                var He = Oe[Se];
                Ce[He.id] = He;
              }
              R(null, Ce);
            }
          }));
        }, fe.TinySDF = Y;
        var ve = function() {
          this.specification = o.styleSpec.light.position;
        };
        ve.prototype.possiblyEvaluate = function(g, v) {
          return o.sphericalToCartesian(g.expression.evaluate(v));
        }, ve.prototype.interpolate = function(g, v, _) {
          return { x: o.number(g.x, v.x, _), y: o.number(g.y, v.y, _), z: o.number(g.z, v.z, _) };
        };
        var me = new o.Properties({ anchor: new o.DataConstantProperty(o.styleSpec.light.anchor), position: new ve(), color: new o.DataConstantProperty(o.styleSpec.light.color), intensity: new o.DataConstantProperty(o.styleSpec.light.intensity) }), X = (function(g) {
          function v(_) {
            g.call(this), this._transitionable = new o.Transitionable(me), this.setLight(_), this._transitioning = this._transitionable.untransitioned();
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.getLight = function() {
            return this._transitionable.serialize();
          }, v.prototype.setLight = function(_, w) {
            if (w === void 0 && (w = {}), !this._validate(o.validateLight, _, w)) for (var R in _) {
              var D = _[R];
              o.endsWith(R, "-transition") ? this._transitionable.setTransition(R.slice(0, -11), D) : this._transitionable.setValue(R, D);
            }
          }, v.prototype.updateTransitions = function(_) {
            this._transitioning = this._transitionable.transitioned(_, this._transitioning);
          }, v.prototype.hasTransition = function() {
            return this._transitioning.hasTransition();
          }, v.prototype.recalculate = function(_) {
            this.properties = this._transitioning.possiblyEvaluate(_);
          }, v.prototype._validate = function(_, w, R) {
            return (!R || R.validate !== !1) && o.emitValidationErrors(this, _.call(o.validateStyle, o.extend({ value: w, style: { glyphs: !0, sprite: !0 }, styleSpec: o.styleSpec })));
          }, v;
        })(o.Evented), re = function(g, v) {
          this.width = g, this.height = v, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
        };
        re.prototype.getDash = function(g, v) {
          var _ = g.join(",") + String(v);
          return this.dashEntry[_] || (this.dashEntry[_] = this.addDash(g, v)), this.dashEntry[_];
        }, re.prototype.getDashRanges = function(g, v, _) {
          var w = [], R = g.length % 2 == 1 ? -g[g.length - 1] * _ : 0, D = g[0] * _, k = !0;
          w.push({ left: R, right: D, isDash: k, zeroLength: g[0] === 0 });
          for (var H = g[0], J = 1; J < g.length; J++) {
            var oe = g[J];
            w.push({ left: R = H * _, right: D = (H += oe) * _, isDash: k = !k, zeroLength: oe === 0 });
          }
          return w;
        }, re.prototype.addRoundDash = function(g, v, _) {
          for (var w = v / 2, R = -_; R <= _; R++) for (var D = this.width * (this.nextRow + _ + R), k = 0, H = g[k], J = 0; J < this.width; J++) {
            J / H.right > 1 && (H = g[++k]);
            var oe = Math.abs(J - H.left), Ce = Math.abs(J - H.right), Se = Math.min(oe, Ce), Oe = void 0, He = R / _ * (w + 1);
            if (H.isDash) {
              var ze = w - Math.abs(He);
              Oe = Math.sqrt(Se * Se + ze * ze);
            } else Oe = w - Math.sqrt(Se * Se + He * He);
            this.data[D + J] = Math.max(0, Math.min(255, Oe + 128));
          }
        }, re.prototype.addRegularDash = function(g) {
          for (var v = g.length - 1; v >= 0; --v) {
            var _ = g[v], w = g[v + 1];
            _.zeroLength ? g.splice(v, 1) : w && w.isDash === _.isDash && (w.left = _.left, g.splice(v, 1));
          }
          var R = g[0], D = g[g.length - 1];
          R.isDash === D.isDash && (R.left = D.left - this.width, D.right = R.right + this.width);
          for (var k = this.width * this.nextRow, H = 0, J = g[H], oe = 0; oe < this.width; oe++) {
            oe / J.right > 1 && (J = g[++H]);
            var Ce = Math.abs(oe - J.left), Se = Math.abs(oe - J.right), Oe = Math.min(Ce, Se);
            this.data[k + oe] = Math.max(0, Math.min(255, (J.isDash ? Oe : -Oe) + 128));
          }
        }, re.prototype.addDash = function(g, v) {
          var _ = v ? 7 : 0, w = 2 * _ + 1;
          if (this.nextRow + w > this.height) return o.warnOnce("LineAtlas out of space"), null;
          for (var R = 0, D = 0; D < g.length; D++) R += g[D];
          if (R !== 0) {
            var k = this.width / R, H = this.getDashRanges(g, this.width, k);
            v ? this.addRoundDash(H, k, _) : this.addRegularDash(H);
          }
          var J = { y: (this.nextRow + _ + 0.5) / this.height, height: 2 * _ / this.height, width: R };
          return this.nextRow += w, this.dirty = !0, J;
        }, re.prototype.bind = function(g) {
          var v = g.gl;
          this.texture ? (v.bindTexture(v.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, v.texSubImage2D(v.TEXTURE_2D, 0, 0, 0, this.width, this.height, v.ALPHA, v.UNSIGNED_BYTE, this.data))) : (this.texture = v.createTexture(), v.bindTexture(v.TEXTURE_2D, this.texture), v.texParameteri(v.TEXTURE_2D, v.TEXTURE_WRAP_S, v.REPEAT), v.texParameteri(v.TEXTURE_2D, v.TEXTURE_WRAP_T, v.REPEAT), v.texParameteri(v.TEXTURE_2D, v.TEXTURE_MIN_FILTER, v.LINEAR), v.texParameteri(v.TEXTURE_2D, v.TEXTURE_MAG_FILTER, v.LINEAR), v.texImage2D(v.TEXTURE_2D, 0, v.ALPHA, this.width, this.height, 0, v.ALPHA, v.UNSIGNED_BYTE, this.data));
        };
        var Me = function g(v, _) {
          this.workerPool = v, this.actors = [], this.currentActor = 0, this.id = o.uniqueId();
          for (var w = this.workerPool.acquire(this.id), R = 0; R < w.length; R++) {
            var D = new g.Actor(w[R], _, this.id);
            D.name = "Worker " + R, this.actors.push(D);
          }
        };
        function ot(g, v, _) {
          var w = function(R, D) {
            if (R) return _(R);
            if (D) {
              var k = o.pick(o.extend(D, g), ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]);
              D.vector_layers && (k.vectorLayers = D.vector_layers, k.vectorLayerIds = k.vectorLayers.map((function(H) {
                return H.id;
              }))), k.tiles = v.canonicalizeTileset(k, g.url), _(null, k);
            }
          };
          return g.url ? o.getJSON(v.transformRequest(v.normalizeSourceURL(g.url), o.ResourceType.Source), w) : o.browser.frame((function() {
            return w(null, g);
          }));
        }
        Me.prototype.broadcast = function(g, v, _) {
          o.asyncAll(this.actors, (function(w, R) {
            w.send(g, v, R);
          }), _ = _ || function() {
          });
        }, Me.prototype.getActor = function() {
          return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
        }, Me.prototype.remove = function() {
          this.actors.forEach((function(g) {
            g.remove();
          })), this.actors = [], this.workerPool.release(this.id);
        }, Me.Actor = o.Actor;
        var be = function(g, v, _) {
          this.bounds = o.LngLatBounds.convert(this.validateBounds(g)), this.minzoom = v || 0, this.maxzoom = _ || 24;
        };
        be.prototype.validateBounds = function(g) {
          return Array.isArray(g) && g.length === 4 ? [Math.max(-180, g[0]), Math.max(-90, g[1]), Math.min(180, g[2]), Math.min(90, g[3])] : [-180, -90, 180, 90];
        }, be.prototype.contains = function(g) {
          var v = Math.pow(2, g.z), _ = Math.floor(o.mercatorXfromLng(this.bounds.getWest()) * v), w = Math.floor(o.mercatorYfromLat(this.bounds.getNorth()) * v), R = Math.ceil(o.mercatorXfromLng(this.bounds.getEast()) * v), D = Math.ceil(o.mercatorYfromLat(this.bounds.getSouth()) * v);
          return g.x >= _ && g.x < R && g.y >= w && g.y < D;
        };
        var Ue = (function(g) {
          function v(_, w, R, D) {
            if (g.call(this), this.id = _, this.dispatcher = R, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, o.extend(this, o.pick(w, ["url", "scheme", "tileSize", "promoteId"])), this._options = o.extend({ type: "vector" }, w), this._collectResourceTiming = w.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(D);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.load = function() {
            var _ = this;
            this._loaded = !1, this.fire(new o.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = ot(this._options, this.map._requestManager, (function(w, R) {
              _._tileJSONRequest = null, _._loaded = !0, w ? _.fire(new o.ErrorEvent(w)) : R && (o.extend(_, R), R.bounds && (_.tileBounds = new be(R.bounds, _.minzoom, _.maxzoom)), o.postTurnstileEvent(R.tiles, _.map._requestManager._customAccessToken), o.postMapLoadEvent(R.tiles, _.map._getMapId(), _.map._requestManager._skuToken, _.map._requestManager._customAccessToken), _.fire(new o.Event("data", { dataType: "source", sourceDataType: "metadata" })), _.fire(new o.Event("data", { dataType: "source", sourceDataType: "content" })));
            }));
          }, v.prototype.loaded = function() {
            return this._loaded;
          }, v.prototype.hasTile = function(_) {
            return !this.tileBounds || this.tileBounds.contains(_.canonical);
          }, v.prototype.onAdd = function(_) {
            this.map = _, this.load();
          }, v.prototype.setSourceProperty = function(_) {
            this._tileJSONRequest && this._tileJSONRequest.cancel(), _(), this.map.style.sourceCaches[this.id].clearTiles(), this.load();
          }, v.prototype.setTiles = function(_) {
            var w = this;
            return this.setSourceProperty((function() {
              w._options.tiles = _;
            })), this;
          }, v.prototype.setUrl = function(_) {
            var w = this;
            return this.setSourceProperty((function() {
              w.url = _, w._options.url = _;
            })), this;
          }, v.prototype.onRemove = function() {
            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
          }, v.prototype.serialize = function() {
            return o.extend({}, this._options);
          }, v.prototype.loadTile = function(_, w) {
            var R = this.map._requestManager.normalizeTileURL(_.tileID.canonical.url(this.tiles, this.scheme)), D = { request: this.map._requestManager.transformRequest(R, o.ResourceType.Tile), uid: _.uid, tileID: _.tileID, zoom: _.tileID.overscaledZ, tileSize: this.tileSize * _.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: o.browser.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
            function k(H, J) {
              return delete _.request, _.aborted ? w(null) : H && H.status !== 404 ? w(H) : (J && J.resourceTiming && (_.resourceTiming = J.resourceTiming), this.map._refreshExpiredTiles && J && _.setExpiryData(J), _.loadVectorData(J, this.map.painter), o.cacheEntryPossiblyAdded(this.dispatcher), w(null), void (_.reloadCallback && (this.loadTile(_, _.reloadCallback), _.reloadCallback = null)));
            }
            D.request.collectResourceTiming = this._collectResourceTiming, _.actor && _.state !== "expired" ? _.state === "loading" ? _.reloadCallback = w : _.request = _.actor.send("reloadTile", D, k.bind(this)) : (_.actor = this.dispatcher.getActor(), _.request = _.actor.send("loadTile", D, k.bind(this)));
          }, v.prototype.abortTile = function(_) {
            _.request && (_.request.cancel(), delete _.request), _.actor && _.actor.send("abortTile", { uid: _.uid, type: this.type, source: this.id }, void 0);
          }, v.prototype.unloadTile = function(_) {
            _.unloadVectorData(), _.actor && _.actor.send("removeTile", { uid: _.uid, type: this.type, source: this.id }, void 0);
          }, v.prototype.hasTransition = function() {
            return !1;
          }, v;
        })(o.Evented), Xe = (function(g) {
          function v(_, w, R, D) {
            g.call(this), this.id = _, this.dispatcher = R, this.setEventedParent(D), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = o.extend({ type: "raster" }, w), o.extend(this, o.pick(w, ["url", "scheme", "tileSize"]));
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.load = function() {
            var _ = this;
            this._loaded = !1, this.fire(new o.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = ot(this._options, this.map._requestManager, (function(w, R) {
              _._tileJSONRequest = null, _._loaded = !0, w ? _.fire(new o.ErrorEvent(w)) : R && (o.extend(_, R), R.bounds && (_.tileBounds = new be(R.bounds, _.minzoom, _.maxzoom)), o.postTurnstileEvent(R.tiles), o.postMapLoadEvent(R.tiles, _.map._getMapId(), _.map._requestManager._skuToken), _.fire(new o.Event("data", { dataType: "source", sourceDataType: "metadata" })), _.fire(new o.Event("data", { dataType: "source", sourceDataType: "content" })));
            }));
          }, v.prototype.loaded = function() {
            return this._loaded;
          }, v.prototype.onAdd = function(_) {
            this.map = _, this.load();
          }, v.prototype.onRemove = function() {
            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
          }, v.prototype.serialize = function() {
            return o.extend({}, this._options);
          }, v.prototype.hasTile = function(_) {
            return !this.tileBounds || this.tileBounds.contains(_.canonical);
          }, v.prototype.loadTile = function(_, w) {
            var R = this, D = this.map._requestManager.normalizeTileURL(_.tileID.canonical.url(this.tiles, this.scheme), this.tileSize);
            _.request = o.getImage(this.map._requestManager.transformRequest(D, o.ResourceType.Tile), (function(k, H) {
              if (delete _.request, _.aborted) _.state = "unloaded", w(null);
              else if (k) _.state = "errored", w(k);
              else if (H) {
                R.map._refreshExpiredTiles && _.setExpiryData(H), delete H.cacheControl, delete H.expires;
                var J = R.map.painter.context, oe = J.gl;
                _.texture = R.map.painter.getTileTexture(H.width), _.texture ? _.texture.update(H, { useMipmap: !0 }) : (_.texture = new o.Texture(J, H, oe.RGBA, { useMipmap: !0 }), _.texture.bind(oe.LINEAR, oe.CLAMP_TO_EDGE, oe.LINEAR_MIPMAP_NEAREST), J.extTextureFilterAnisotropic && oe.texParameterf(oe.TEXTURE_2D, J.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, J.extTextureFilterAnisotropicMax)), _.state = "loaded", o.cacheEntryPossiblyAdded(R.dispatcher), w(null);
              }
            }));
          }, v.prototype.abortTile = function(_, w) {
            _.request && (_.request.cancel(), delete _.request), w();
          }, v.prototype.unloadTile = function(_, w) {
            _.texture && this.map.painter.saveTileTexture(_.texture), w();
          }, v.prototype.hasTransition = function() {
            return !1;
          }, v;
        })(o.Evented), lt = (function(g) {
          function v(_, w, R, D) {
            g.call(this, _, w, R, D), this.type = "raster-dem", this.maxzoom = 22, this._options = o.extend({ type: "raster-dem" }, w), this.encoding = w.encoding || "mapbox";
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.serialize = function() {
            return { type: "raster-dem", url: this.url, tileSize: this.tileSize, tiles: this.tiles, bounds: this.bounds, encoding: this.encoding };
          }, v.prototype.loadTile = function(_, w) {
            var R = this.map._requestManager.normalizeTileURL(_.tileID.canonical.url(this.tiles, this.scheme), this.tileSize);
            function D(k, H) {
              k && (_.state = "errored", w(k)), H && (_.dem = H, _.needsHillshadePrepare = !0, _.state = "loaded", w(null));
            }
            _.request = o.getImage(this.map._requestManager.transformRequest(R, o.ResourceType.Tile), (function(k, H) {
              if (delete _.request, _.aborted) _.state = "unloaded", w(null);
              else if (k) _.state = "errored", w(k);
              else if (H) {
                this.map._refreshExpiredTiles && _.setExpiryData(H), delete H.cacheControl, delete H.expires;
                var J = o.window.ImageBitmap && H instanceof o.window.ImageBitmap && o.offscreenCanvasSupported() ? H : o.browser.getImageData(H, 1), oe = { uid: _.uid, coord: _.tileID, source: this.id, rawImageData: J, encoding: this.encoding };
                _.actor && _.state !== "expired" || (_.actor = this.dispatcher.getActor(), _.actor.send("loadDEMTile", oe, D.bind(this)));
              }
            }).bind(this)), _.neighboringTiles = this._getNeighboringTiles(_.tileID);
          }, v.prototype._getNeighboringTiles = function(_) {
            var w = _.canonical, R = Math.pow(2, w.z), D = (w.x - 1 + R) % R, k = w.x === 0 ? _.wrap - 1 : _.wrap, H = (w.x + 1 + R) % R, J = w.x + 1 === R ? _.wrap + 1 : _.wrap, oe = {};
            return oe[new o.OverscaledTileID(_.overscaledZ, k, w.z, D, w.y).key] = { backfilled: !1 }, oe[new o.OverscaledTileID(_.overscaledZ, J, w.z, H, w.y).key] = { backfilled: !1 }, w.y > 0 && (oe[new o.OverscaledTileID(_.overscaledZ, k, w.z, D, w.y - 1).key] = { backfilled: !1 }, oe[new o.OverscaledTileID(_.overscaledZ, _.wrap, w.z, w.x, w.y - 1).key] = { backfilled: !1 }, oe[new o.OverscaledTileID(_.overscaledZ, J, w.z, H, w.y - 1).key] = { backfilled: !1 }), w.y + 1 < R && (oe[new o.OverscaledTileID(_.overscaledZ, k, w.z, D, w.y + 1).key] = { backfilled: !1 }, oe[new o.OverscaledTileID(_.overscaledZ, _.wrap, w.z, w.x, w.y + 1).key] = { backfilled: !1 }, oe[new o.OverscaledTileID(_.overscaledZ, J, w.z, H, w.y + 1).key] = { backfilled: !1 }), oe;
          }, v.prototype.unloadTile = function(_) {
            _.demTexture && this.map.painter.saveTileTexture(_.demTexture), _.fbo && (_.fbo.destroy(), delete _.fbo), _.dem && delete _.dem, delete _.neighboringTiles, _.state = "unloaded", _.actor && _.actor.send("removeDEMTile", { uid: _.uid, source: this.id });
          }, v;
        })(Xe), at = (function(g) {
          function v(_, w, R, D) {
            g.call(this), this.id = _, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._loaded = !1, this.actor = R.getActor(), this.setEventedParent(D), this._data = w.data, this._options = o.extend({}, w), this._collectResourceTiming = w.collectResourceTiming, this._resourceTiming = [], w.maxzoom !== void 0 && (this.maxzoom = w.maxzoom), w.type && (this.type = w.type), w.attribution && (this.attribution = w.attribution), this.promoteId = w.promoteId;
            var k = o.EXTENT / this.tileSize;
            this.workerOptions = o.extend({ source: this.id, cluster: w.cluster || !1, geojsonVtOptions: { buffer: (w.buffer !== void 0 ? w.buffer : 128) * k, tolerance: (w.tolerance !== void 0 ? w.tolerance : 0.375) * k, extent: o.EXTENT, maxZoom: this.maxzoom, lineMetrics: w.lineMetrics || !1, generateId: w.generateId || !1 }, superclusterOptions: { maxZoom: w.clusterMaxZoom !== void 0 ? Math.min(w.clusterMaxZoom, this.maxzoom - 1) : this.maxzoom - 1, minPoints: Math.max(2, w.clusterMinPoints || 2), extent: o.EXTENT, radius: (w.clusterRadius || 50) * k, log: !1, generateId: w.generateId || !1 }, clusterProperties: w.clusterProperties, filter: w.filter }, w.workerOptions);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.load = function() {
            var _ = this;
            this.fire(new o.Event("dataloading", { dataType: "source" })), this._updateWorkerData((function(w) {
              if (w) _.fire(new o.ErrorEvent(w));
              else {
                var R = { dataType: "source", sourceDataType: "metadata" };
                _._collectResourceTiming && _._resourceTiming && _._resourceTiming.length > 0 && (R.resourceTiming = _._resourceTiming, _._resourceTiming = []), _.fire(new o.Event("data", R));
              }
            }));
          }, v.prototype.onAdd = function(_) {
            this.map = _, this.load();
          }, v.prototype.setData = function(_) {
            var w = this;
            return this._data = _, this.fire(new o.Event("dataloading", { dataType: "source" })), this._updateWorkerData((function(R) {
              if (R) w.fire(new o.ErrorEvent(R));
              else {
                var D = { dataType: "source", sourceDataType: "content" };
                w._collectResourceTiming && w._resourceTiming && w._resourceTiming.length > 0 && (D.resourceTiming = w._resourceTiming, w._resourceTiming = []), w.fire(new o.Event("data", D));
              }
            })), this;
          }, v.prototype.getClusterExpansionZoom = function(_, w) {
            return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: _, source: this.id }, w), this;
          }, v.prototype.getClusterChildren = function(_, w) {
            return this.actor.send("geojson.getClusterChildren", { clusterId: _, source: this.id }, w), this;
          }, v.prototype.getClusterLeaves = function(_, w, R, D) {
            return this.actor.send("geojson.getClusterLeaves", { source: this.id, clusterId: _, limit: w, offset: R }, D), this;
          }, v.prototype._updateWorkerData = function(_) {
            var w = this;
            this._loaded = !1;
            var R = o.extend({}, this.workerOptions), D = this._data;
            typeof D == "string" ? (R.request = this.map._requestManager.transformRequest(o.browser.resolveURL(D), o.ResourceType.Source), R.request.collectResourceTiming = this._collectResourceTiming) : R.data = JSON.stringify(D), this.actor.send(this.type + ".loadData", R, (function(k, H) {
              w._removed || H && H.abandoned || (w._loaded = !0, H && H.resourceTiming && H.resourceTiming[w.id] && (w._resourceTiming = H.resourceTiming[w.id].slice(0)), w.actor.send(w.type + ".coalesce", { source: R.source }, null), _(k));
            }));
          }, v.prototype.loaded = function() {
            return this._loaded;
          }, v.prototype.loadTile = function(_, w) {
            var R = this, D = _.actor ? "reloadTile" : "loadTile";
            _.actor = this.actor, _.request = this.actor.send(D, { type: this.type, uid: _.uid, tileID: _.tileID, zoom: _.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: o.browser.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId }, (function(k, H) {
              return delete _.request, _.unloadVectorData(), _.aborted ? w(null) : k ? w(k) : (_.loadVectorData(H, R.map.painter, D === "reloadTile"), w(null));
            }));
          }, v.prototype.abortTile = function(_) {
            _.request && (_.request.cancel(), delete _.request), _.aborted = !0;
          }, v.prototype.unloadTile = function(_) {
            _.unloadVectorData(), this.actor.send("removeTile", { uid: _.uid, type: this.type, source: this.id });
          }, v.prototype.onRemove = function() {
            this._removed = !0, this.actor.send("removeSource", { type: this.type, source: this.id });
          }, v.prototype.serialize = function() {
            return o.extend({}, this._options, { type: this.type, data: this._data });
          }, v.prototype.hasTransition = function() {
            return !1;
          }, v;
        })(o.Evented), ct = o.createLayout([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]), gt = (function(g) {
          function v(_, w, R, D) {
            g.call(this), this.id = _, this.dispatcher = R, this.coordinates = w.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(D), this.options = w;
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.load = function(_, w) {
            var R = this;
            this._loaded = !1, this.fire(new o.Event("dataloading", { dataType: "source" })), this.url = this.options.url, o.getImage(this.map._requestManager.transformRequest(this.url, o.ResourceType.Image), (function(D, k) {
              R._loaded = !0, D ? R.fire(new o.ErrorEvent(D)) : k && (R.image = k, _ && (R.coordinates = _), w && w(), R._finishLoading());
            }));
          }, v.prototype.loaded = function() {
            return this._loaded;
          }, v.prototype.updateImage = function(_) {
            var w = this;
            return this.image && _.url ? (this.options.url = _.url, this.load(_.coordinates, (function() {
              w.texture = null;
            })), this) : this;
          }, v.prototype._finishLoading = function() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new o.Event("data", { dataType: "source", sourceDataType: "metadata" })));
          }, v.prototype.onAdd = function(_) {
            this.map = _, this.load();
          }, v.prototype.setCoordinates = function(_) {
            var w = this;
            this.coordinates = _;
            var R = _.map(o.MercatorCoordinate.fromLngLat);
            this.tileID = (function(k) {
              for (var H = 1 / 0, J = 1 / 0, oe = -1 / 0, Ce = -1 / 0, Se = 0, Oe = k; Se < Oe.length; Se += 1) {
                var He = Oe[Se];
                H = Math.min(H, He.x), J = Math.min(J, He.y), oe = Math.max(oe, He.x), Ce = Math.max(Ce, He.y);
              }
              var ze = Math.max(oe - H, Ce - J), h = Math.max(0, Math.floor(-Math.log(ze) / Math.LN2)), f = Math.pow(2, h);
              return new o.CanonicalTileID(h, Math.floor((H + oe) / 2 * f), Math.floor((J + Ce) / 2 * f));
            })(R), this.minzoom = this.maxzoom = this.tileID.z;
            var D = R.map((function(k) {
              return w.tileID.getTilePoint(k)._round();
            }));
            return this._boundsArray = new o.StructArrayLayout4i8(), this._boundsArray.emplaceBack(D[0].x, D[0].y, 0, 0), this._boundsArray.emplaceBack(D[1].x, D[1].y, o.EXTENT, 0), this._boundsArray.emplaceBack(D[3].x, D[3].y, 0, o.EXTENT), this._boundsArray.emplaceBack(D[2].x, D[2].y, o.EXTENT, o.EXTENT), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new o.Event("data", { dataType: "source", sourceDataType: "content" })), this;
          }, v.prototype.prepare = function() {
            if (Object.keys(this.tiles).length !== 0 && this.image) {
              var _ = this.map.painter.context, w = _.gl;
              for (var R in this.boundsBuffer || (this.boundsBuffer = _.createVertexBuffer(this._boundsArray, ct.members)), this.boundsSegments || (this.boundsSegments = o.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new o.Texture(_, this.image, w.RGBA), this.texture.bind(w.LINEAR, w.CLAMP_TO_EDGE)), this.tiles) {
                var D = this.tiles[R];
                D.state !== "loaded" && (D.state = "loaded", D.texture = this.texture);
              }
            }
          }, v.prototype.loadTile = function(_, w) {
            this.tileID && this.tileID.equals(_.tileID.canonical) ? (this.tiles[String(_.tileID.wrap)] = _, _.buckets = {}, w(null)) : (_.state = "errored", w(null));
          }, v.prototype.serialize = function() {
            return { type: "image", url: this.options.url, coordinates: this.coordinates };
          }, v.prototype.hasTransition = function() {
            return !1;
          }, v;
        })(o.Evented), St = (function(g) {
          function v(_, w, R, D) {
            g.call(this, _, w, R, D), this.roundZoom = !0, this.type = "video", this.options = w;
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.load = function() {
            var _ = this;
            this._loaded = !1;
            var w = this.options;
            this.urls = [];
            for (var R = 0, D = w.urls; R < D.length; R += 1) this.urls.push(this.map._requestManager.transformRequest(D[R], o.ResourceType.Source).url);
            o.getVideo(this.urls, (function(k, H) {
              _._loaded = !0, k ? _.fire(new o.ErrorEvent(k)) : H && (_.video = H, _.video.loop = !0, _.video.setAttribute("playsinline", ""), _.video.addEventListener("playing", (function() {
                _.map.triggerRepaint();
              })), _.map && _.video.play(), _._finishLoading());
            }));
          }, v.prototype.pause = function() {
            this.video && this.video.pause();
          }, v.prototype.play = function() {
            this.video && this.video.play();
          }, v.prototype.seek = function(_) {
            if (this.video) {
              var w = this.video.seekable;
              _ < w.start(0) || _ > w.end(0) ? this.fire(new o.ErrorEvent(new o.ValidationError("sources." + this.id, null, "Playback for this video can be set only between the " + w.start(0) + " and " + w.end(0) + "-second mark."))) : this.video.currentTime = _;
            }
          }, v.prototype.getVideo = function() {
            return this.video;
          }, v.prototype.onAdd = function(_) {
            this.map || (this.map = _, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }, v.prototype.prepare = function() {
            if (!(Object.keys(this.tiles).length === 0 || this.video.readyState < 2)) {
              var _ = this.map.painter.context, w = _.gl;
              for (var R in this.boundsBuffer || (this.boundsBuffer = _.createVertexBuffer(this._boundsArray, ct.members)), this.boundsSegments || (this.boundsSegments = o.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(w.LINEAR, w.CLAMP_TO_EDGE), w.texSubImage2D(w.TEXTURE_2D, 0, 0, 0, w.RGBA, w.UNSIGNED_BYTE, this.video)) : (this.texture = new o.Texture(_, this.video, w.RGBA), this.texture.bind(w.LINEAR, w.CLAMP_TO_EDGE)), this.tiles) {
                var D = this.tiles[R];
                D.state !== "loaded" && (D.state = "loaded", D.texture = this.texture);
              }
            }
          }, v.prototype.serialize = function() {
            return { type: "video", urls: this.urls, coordinates: this.coordinates };
          }, v.prototype.hasTransition = function() {
            return this.video && !this.video.paused;
          }, v;
        })(gt), Ot = (function(g) {
          function v(_, w, R, D) {
            g.call(this, _, w, R, D), w.coordinates ? Array.isArray(w.coordinates) && w.coordinates.length === 4 && !w.coordinates.some((function(k) {
              return !Array.isArray(k) || k.length !== 2 || k.some((function(H) {
                return typeof H != "number";
              }));
            })) || this.fire(new o.ErrorEvent(new o.ValidationError("sources." + _, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new o.ErrorEvent(new o.ValidationError("sources." + _, null, 'missing required property "coordinates"'))), w.animate && typeof w.animate != "boolean" && this.fire(new o.ErrorEvent(new o.ValidationError("sources." + _, null, 'optional "animate" property must be a boolean value'))), w.canvas ? typeof w.canvas == "string" || w.canvas instanceof o.window.HTMLCanvasElement || this.fire(new o.ErrorEvent(new o.ValidationError("sources." + _, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new o.ErrorEvent(new o.ValidationError("sources." + _, null, 'missing required property "canvas"'))), this.options = w, this.animate = w.animate === void 0 || w.animate;
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.load = function() {
            this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof o.window.HTMLCanvasElement ? this.options.canvas : o.window.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new o.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
              this._playing = !0, this.map.triggerRepaint();
            }, this.pause = function() {
              this._playing && (this.prepare(), this._playing = !1);
            }, this._finishLoading());
          }, v.prototype.getCanvas = function() {
            return this.canvas;
          }, v.prototype.onAdd = function(_) {
            this.map = _, this.load(), this.canvas && this.animate && this.play();
          }, v.prototype.onRemove = function() {
            this.pause();
          }, v.prototype.prepare = function() {
            var _ = !1;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, _ = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, _ = !0), !this._hasInvalidDimensions() && Object.keys(this.tiles).length !== 0) {
              var w = this.map.painter.context, R = w.gl;
              for (var D in this.boundsBuffer || (this.boundsBuffer = w.createVertexBuffer(this._boundsArray, ct.members)), this.boundsSegments || (this.boundsSegments = o.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? (_ || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new o.Texture(w, this.canvas, R.RGBA, { premultiply: !0 }), this.tiles) {
                var k = this.tiles[D];
                k.state !== "loaded" && (k.state = "loaded", k.texture = this.texture);
              }
            }
          }, v.prototype.serialize = function() {
            return { type: "canvas", coordinates: this.coordinates };
          }, v.prototype.hasTransition = function() {
            return this._playing;
          }, v.prototype._hasInvalidDimensions = function() {
            for (var _ = 0, w = [this.canvas.width, this.canvas.height]; _ < w.length; _ += 1) {
              var R = w[_];
              if (isNaN(R) || R <= 0) return !0;
            }
            return !1;
          }, v;
        })(gt), dt = { vector: Ue, raster: Xe, "raster-dem": lt, geojson: at, video: St, image: gt, canvas: Ot };
        function _r(g, v) {
          var _ = o.identity([]);
          return o.translate(_, _, [1, 1, 0]), o.scale(_, _, [0.5 * g.width, 0.5 * g.height, 1]), o.multiply(_, _, g.calculatePosMatrix(v.toUnwrapped()));
        }
        function sr(g, v, _, w, R, D) {
          var k = (function(h, f, A) {
            if (h) for (var b = 0, T = h; b < T.length; b += 1) {
              var C = f[T[b]];
              if (C && C.source === A && C.type === "fill-extrusion") return !0;
            }
            else for (var I in f) {
              var B = f[I];
              if (B.source === A && B.type === "fill-extrusion") return !0;
            }
            return !1;
          })(R && R.layers, v, g.id), H = D.maxPitchScaleFactor(), J = g.tilesIn(w, H, k);
          J.sort(tr);
          for (var oe = [], Ce = 0, Se = J; Ce < Se.length; Ce += 1) {
            var Oe = Se[Ce];
            oe.push({ wrappedTileID: Oe.tileID.wrapped().key, queryResults: Oe.tile.queryRenderedFeatures(v, _, g._state, Oe.queryGeometry, Oe.cameraQueryGeometry, Oe.scale, R, D, H, _r(g.transform, Oe.tileID)) });
          }
          var He = (function(h) {
            for (var f = {}, A = {}, b = 0, T = h; b < T.length; b += 1) {
              var C = T[b], I = C.queryResults, B = C.wrappedTileID, F = A[B] = A[B] || {};
              for (var z in I) for (var W = I[z], ue = F[z] = F[z] || {}, Ie = f[z] = f[z] || [], Re = 0, Be = W; Re < Be.length; Re += 1) {
                var Ze = Be[Re];
                ue[Ze.featureIndex] || (ue[Ze.featureIndex] = !0, Ie.push(Ze));
              }
            }
            return f;
          })(oe);
          for (var ze in He) He[ze].forEach((function(h) {
            var f = h.feature, A = g.getFeatureState(f.layer["source-layer"], f.id);
            f.source = f.layer.source, f.layer["source-layer"] && (f.sourceLayer = f.layer["source-layer"]), f.state = A;
          }));
          return He;
        }
        function tr(g, v) {
          var _ = g.tileID, w = v.tileID;
          return _.overscaledZ - w.overscaledZ || _.canonical.y - w.canonical.y || _.wrap - w.wrap || _.canonical.x - w.canonical.x;
        }
        var Wt = function(g, v) {
          this.max = g, this.onRemove = v, this.reset();
        };
        Wt.prototype.reset = function() {
          for (var g in this.data) for (var v = 0, _ = this.data[g]; v < _.length; v += 1) {
            var w = _[v];
            w.timeout && clearTimeout(w.timeout), this.onRemove(w.value);
          }
          return this.data = {}, this.order = [], this;
        }, Wt.prototype.add = function(g, v, _) {
          var w = this, R = g.wrapped().key;
          this.data[R] === void 0 && (this.data[R] = []);
          var D = { value: v, timeout: void 0 };
          if (_ !== void 0 && (D.timeout = setTimeout((function() {
            w.remove(g, D);
          }), _)), this.data[R].push(D), this.order.push(R), this.order.length > this.max) {
            var k = this._getAndRemoveByKey(this.order[0]);
            k && this.onRemove(k);
          }
          return this;
        }, Wt.prototype.has = function(g) {
          return g.wrapped().key in this.data;
        }, Wt.prototype.getAndRemove = function(g) {
          return this.has(g) ? this._getAndRemoveByKey(g.wrapped().key) : null;
        }, Wt.prototype._getAndRemoveByKey = function(g) {
          var v = this.data[g].shift();
          return v.timeout && clearTimeout(v.timeout), this.data[g].length === 0 && delete this.data[g], this.order.splice(this.order.indexOf(g), 1), v.value;
        }, Wt.prototype.getByKey = function(g) {
          var v = this.data[g];
          return v ? v[0].value : null;
        }, Wt.prototype.get = function(g) {
          return this.has(g) ? this.data[g.wrapped().key][0].value : null;
        }, Wt.prototype.remove = function(g, v) {
          if (!this.has(g)) return this;
          var _ = g.wrapped().key, w = v === void 0 ? 0 : this.data[_].indexOf(v), R = this.data[_][w];
          return this.data[_].splice(w, 1), R.timeout && clearTimeout(R.timeout), this.data[_].length === 0 && delete this.data[_], this.onRemove(R.value), this.order.splice(this.order.indexOf(_), 1), this;
        }, Wt.prototype.setMaxSize = function(g) {
          for (this.max = g; this.order.length > this.max; ) {
            var v = this._getAndRemoveByKey(this.order[0]);
            v && this.onRemove(v);
          }
          return this;
        }, Wt.prototype.filter = function(g) {
          var v = [];
          for (var _ in this.data) for (var w = 0, R = this.data[_]; w < R.length; w += 1) {
            var D = R[w];
            g(D.value) || v.push(D);
          }
          for (var k = 0, H = v; k < H.length; k += 1) {
            var J = H[k];
            this.remove(J.value.tileID, J);
          }
        };
        var yr = function(g, v, _) {
          this.context = g;
          var w = g.gl;
          this.buffer = w.createBuffer(), this.dynamicDraw = !!_, this.context.unbindVAO(), g.bindElementBuffer.set(this.buffer), w.bufferData(w.ELEMENT_ARRAY_BUFFER, v.arrayBuffer, this.dynamicDraw ? w.DYNAMIC_DRAW : w.STATIC_DRAW), this.dynamicDraw || delete v.arrayBuffer;
        };
        yr.prototype.bind = function() {
          this.context.bindElementBuffer.set(this.buffer);
        }, yr.prototype.updateData = function(g) {
          var v = this.context.gl;
          this.context.unbindVAO(), this.bind(), v.bufferSubData(v.ELEMENT_ARRAY_BUFFER, 0, g.arrayBuffer);
        }, yr.prototype.destroy = function() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        };
        var An = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" }, Fr = function(g, v, _, w) {
          this.length = v.length, this.attributes = _, this.itemSize = v.bytesPerElement, this.dynamicDraw = w, this.context = g;
          var R = g.gl;
          this.buffer = R.createBuffer(), g.bindVertexBuffer.set(this.buffer), R.bufferData(R.ARRAY_BUFFER, v.arrayBuffer, this.dynamicDraw ? R.DYNAMIC_DRAW : R.STATIC_DRAW), this.dynamicDraw || delete v.arrayBuffer;
        };
        Fr.prototype.bind = function() {
          this.context.bindVertexBuffer.set(this.buffer);
        }, Fr.prototype.updateData = function(g) {
          var v = this.context.gl;
          this.bind(), v.bufferSubData(v.ARRAY_BUFFER, 0, g.arrayBuffer);
        }, Fr.prototype.enableAttributes = function(g, v) {
          for (var _ = 0; _ < this.attributes.length; _++) {
            var w = v.attributes[this.attributes[_].name];
            w !== void 0 && g.enableVertexAttribArray(w);
          }
        }, Fr.prototype.setVertexAttribPointers = function(g, v, _) {
          for (var w = 0; w < this.attributes.length; w++) {
            var R = this.attributes[w], D = v.attributes[R.name];
            D !== void 0 && g.vertexAttribPointer(D, R.components, g[An[R.type]], !1, this.itemSize, R.offset + this.itemSize * (_ || 0));
          }
        }, Fr.prototype.destroy = function() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        };
        var Pr = function(g) {
          this.gl = g.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
        };
        Pr.prototype.get = function() {
          return this.current;
        }, Pr.prototype.set = function(g) {
        }, Pr.prototype.getDefault = function() {
          return this.default;
        }, Pr.prototype.setDefault = function() {
          this.set(this.default);
        };
        var $n = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.getDefault = function() {
            return o.Color.transparent;
          }, v.prototype.set = function(_) {
            var w = this.current;
            (_.r !== w.r || _.g !== w.g || _.b !== w.b || _.a !== w.a || this.dirty) && (this.gl.clearColor(_.r, _.g, _.b, _.a), this.current = _, this.dirty = !1);
          }, v;
        })(Pr), xr = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.getDefault = function() {
            return 1;
          }, v.prototype.set = function(_) {
            (_ !== this.current || this.dirty) && (this.gl.clearDepth(_), this.current = _, this.dirty = !1);
          }, v;
        })(Pr), wr = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.getDefault = function() {
            return 0;
          }, v.prototype.set = function(_) {
            (_ !== this.current || this.dirty) && (this.gl.clearStencil(_), this.current = _, this.dirty = !1);
          }, v;
        })(Pr), gn = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.getDefault = function() {
            return [!0, !0, !0, !0];
          }, v.prototype.set = function(_) {
            var w = this.current;
            (_[0] !== w[0] || _[1] !== w[1] || _[2] !== w[2] || _[3] !== w[3] || this.dirty) && (this.gl.colorMask(_[0], _[1], _[2], _[3]), this.current = _, this.dirty = !1);
          }, v;
        })(Pr), zr = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.getDefault = function() {
            return !0;
          }, v.prototype.set = function(_) {
            (_ !== this.current || this.dirty) && (this.gl.depthMask(_), this.current = _, this.dirty = !1);
          }, v;
        })(Pr), ci = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.getDefault = function() {
            return 255;
          }, v.prototype.set = function(_) {
            (_ !== this.current || this.dirty) && (this.gl.stencilMask(_), this.current = _, this.dirty = !1);
          }, v;
        })(Pr), Jn = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.getDefault = function() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }, v.prototype.set = function(_) {
            var w = this.current;
            (_.func !== w.func || _.ref !== w.ref || _.mask !== w.mask || this.dirty) && (this.gl.stencilFunc(_.func, _.ref, _.mask), this.current = _, this.dirty = !1);
          }, v;
        })(Pr), wn = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.getDefault = function() {
            var _ = this.gl;
            return [_.KEEP, _.KEEP, _.KEEP];
          }, v.prototype.set = function(_) {
            var w = this.current;
            (_[0] !== w[0] || _[1] !== w[1] || _[2] !== w[2] || this.dirty) && (this.gl.stencilOp(_[0], _[1], _[2]), this.current = _, this.dirty = !1);
          }, v;
        })(Pr), ii = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.getDefault = function() {
            return !1;
          }, v.prototype.set = function(_) {
            if (_ !== this.current || this.dirty) {
              var w = this.gl;
              _ ? w.enable(w.STENCIL_TEST) : w.disable(w.STENCIL_TEST), this.current = _, this.dirty = !1;
            }
          }, v;
        })(Pr), qn = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.getDefault = function() {
            return [0, 1];
          }, v.prototype.set = function(_) {
            var w = this.current;
            (_[0] !== w[0] || _[1] !== w[1] || this.dirty) && (this.gl.depthRange(_[0], _[1]), this.current = _, this.dirty = !1);
          }, v;
        })(Pr), Rn = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.getDefault = function() {
            return !1;
          }, v.prototype.set = function(_) {
            if (_ !== this.current || this.dirty) {
              var w = this.gl;
              _ ? w.enable(w.DEPTH_TEST) : w.disable(w.DEPTH_TEST), this.current = _, this.dirty = !1;
            }
          }, v;
        })(Pr), ei = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.getDefault = function() {
            return this.gl.LESS;
          }, v.prototype.set = function(_) {
            (_ !== this.current || this.dirty) && (this.gl.depthFunc(_), this.current = _, this.dirty = !1);
          }, v;
        })(Pr), Zt = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.getDefault = function() {
            return !1;
          }, v.prototype.set = function(_) {
            if (_ !== this.current || this.dirty) {
              var w = this.gl;
              _ ? w.enable(w.BLEND) : w.disable(w.BLEND), this.current = _, this.dirty = !1;
            }
          }, v;
        })(Pr), br = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.getDefault = function() {
            var _ = this.gl;
            return [_.ONE, _.ZERO];
          }, v.prototype.set = function(_) {
            var w = this.current;
            (_[0] !== w[0] || _[1] !== w[1] || this.dirty) && (this.gl.blendFunc(_[0], _[1]), this.current = _, this.dirty = !1);
          }, v;
        })(Pr), Nr = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.getDefault = function() {
            return o.Color.transparent;
          }, v.prototype.set = function(_) {
            var w = this.current;
            (_.r !== w.r || _.g !== w.g || _.b !== w.b || _.a !== w.a || this.dirty) && (this.gl.blendColor(_.r, _.g, _.b, _.a), this.current = _, this.dirty = !1);
          }, v;
        })(Pr), on = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.getDefault = function() {
            return this.gl.FUNC_ADD;
          }, v.prototype.set = function(_) {
            (_ !== this.current || this.dirty) && (this.gl.blendEquation(_), this.current = _, this.dirty = !1);
          }, v;
        })(Pr), pi = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.getDefault = function() {
            return !1;
          }, v.prototype.set = function(_) {
            if (_ !== this.current || this.dirty) {
              var w = this.gl;
              _ ? w.enable(w.CULL_FACE) : w.disable(w.CULL_FACE), this.current = _, this.dirty = !1;
            }
          }, v;
        })(Pr), Le = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.getDefault = function() {
            return this.gl.BACK;
          }, v.prototype.set = function(_) {
            (_ !== this.current || this.dirty) && (this.gl.cullFace(_), this.current = _, this.dirty = !1);
          }, v;
        })(Pr), Gt = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.getDefault = function() {
            return this.gl.CCW;
          }, v.prototype.set = function(_) {
            (_ !== this.current || this.dirty) && (this.gl.frontFace(_), this.current = _, this.dirty = !1);
          }, v;
        })(Pr), Jt = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.getDefault = function() {
            return null;
          }, v.prototype.set = function(_) {
            (_ !== this.current || this.dirty) && (this.gl.useProgram(_), this.current = _, this.dirty = !1);
          }, v;
        })(Pr), pr = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.getDefault = function() {
            return this.gl.TEXTURE0;
          }, v.prototype.set = function(_) {
            (_ !== this.current || this.dirty) && (this.gl.activeTexture(_), this.current = _, this.dirty = !1);
          }, v;
        })(Pr), st = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.getDefault = function() {
            var _ = this.gl;
            return [0, 0, _.drawingBufferWidth, _.drawingBufferHeight];
          }, v.prototype.set = function(_) {
            var w = this.current;
            (_[0] !== w[0] || _[1] !== w[1] || _[2] !== w[2] || _[3] !== w[3] || this.dirty) && (this.gl.viewport(_[0], _[1], _[2], _[3]), this.current = _, this.dirty = !1);
          }, v;
        })(Pr), Ft = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.getDefault = function() {
            return null;
          }, v.prototype.set = function(_) {
            if (_ !== this.current || this.dirty) {
              var w = this.gl;
              w.bindFramebuffer(w.FRAMEBUFFER, _), this.current = _, this.dirty = !1;
            }
          }, v;
        })(Pr), _e = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.getDefault = function() {
            return null;
          }, v.prototype.set = function(_) {
            if (_ !== this.current || this.dirty) {
              var w = this.gl;
              w.bindRenderbuffer(w.RENDERBUFFER, _), this.current = _, this.dirty = !1;
            }
          }, v;
        })(Pr), Xt = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.getDefault = function() {
            return null;
          }, v.prototype.set = function(_) {
            if (_ !== this.current || this.dirty) {
              var w = this.gl;
              w.bindTexture(w.TEXTURE_2D, _), this.current = _, this.dirty = !1;
            }
          }, v;
        })(Pr), Ct = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.getDefault = function() {
            return null;
          }, v.prototype.set = function(_) {
            if (_ !== this.current || this.dirty) {
              var w = this.gl;
              w.bindBuffer(w.ARRAY_BUFFER, _), this.current = _, this.dirty = !1;
            }
          }, v;
        })(Pr), $ = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.getDefault = function() {
            return null;
          }, v.prototype.set = function(_) {
            var w = this.gl;
            w.bindBuffer(w.ELEMENT_ARRAY_BUFFER, _), this.current = _, this.dirty = !1;
          }, v;
        })(Pr), Et = (function(g) {
          function v(_) {
            g.call(this, _), this.vao = _.extVertexArrayObject;
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.getDefault = function() {
            return null;
          }, v.prototype.set = function(_) {
            this.vao && (_ !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(_), this.current = _, this.dirty = !1);
          }, v;
        })(Pr), Rt = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.getDefault = function() {
            return 4;
          }, v.prototype.set = function(_) {
            if (_ !== this.current || this.dirty) {
              var w = this.gl;
              w.pixelStorei(w.UNPACK_ALIGNMENT, _), this.current = _, this.dirty = !1;
            }
          }, v;
        })(Pr), Pe = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.getDefault = function() {
            return !1;
          }, v.prototype.set = function(_) {
            if (_ !== this.current || this.dirty) {
              var w = this.gl;
              w.pixelStorei(w.UNPACK_PREMULTIPLY_ALPHA_WEBGL, _), this.current = _, this.dirty = !1;
            }
          }, v;
        })(Pr), tt = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.getDefault = function() {
            return !1;
          }, v.prototype.set = function(_) {
            if (_ !== this.current || this.dirty) {
              var w = this.gl;
              w.pixelStorei(w.UNPACK_FLIP_Y_WEBGL, _), this.current = _, this.dirty = !1;
            }
          }, v;
        })(Pr), At = (function(g) {
          function v(_, w) {
            g.call(this, _), this.context = _, this.parent = w;
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.getDefault = function() {
            return null;
          }, v;
        })(Pr), Q = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.setDirty = function() {
            this.dirty = !0;
          }, v.prototype.set = function(_) {
            if (_ !== this.current || this.dirty) {
              this.context.bindFramebuffer.set(this.parent);
              var w = this.gl;
              w.framebufferTexture2D(w.FRAMEBUFFER, w.COLOR_ATTACHMENT0, w.TEXTURE_2D, _, 0), this.current = _, this.dirty = !1;
            }
          }, v;
        })(At), ie = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.set = function(_) {
            if (_ !== this.current || this.dirty) {
              this.context.bindFramebuffer.set(this.parent);
              var w = this.gl;
              w.framebufferRenderbuffer(w.FRAMEBUFFER, w.DEPTH_ATTACHMENT, w.RENDERBUFFER, _), this.current = _, this.dirty = !1;
            }
          }, v;
        })(At), ce = function(g, v, _, w) {
          this.context = g, this.width = v, this.height = _;
          var R = this.framebuffer = g.gl.createFramebuffer();
          this.colorAttachment = new Q(g, R), w && (this.depthAttachment = new ie(g, R));
        };
        ce.prototype.destroy = function() {
          var g = this.context.gl, v = this.colorAttachment.get();
          if (v && g.deleteTexture(v), this.depthAttachment) {
            var _ = this.depthAttachment.get();
            _ && g.deleteRenderbuffer(_);
          }
          g.deleteFramebuffer(this.framebuffer);
        };
        var we = function(g, v, _) {
          this.func = g, this.mask = v, this.range = _;
        };
        we.ReadOnly = !1, we.ReadWrite = !0, we.disabled = new we(519, we.ReadOnly, [0, 1]);
        var Ne = function(g, v, _, w, R, D) {
          this.test = g, this.ref = v, this.mask = _, this.fail = w, this.depthFail = R, this.pass = D;
        };
        Ne.disabled = new Ne({ func: 519, mask: 0 }, 0, 0, 7680, 7680, 7680);
        var pe = function(g, v, _) {
          this.blendFunction = g, this.blendColor = v, this.mask = _;
        };
        pe.disabled = new pe(pe.Replace = [1, 0], o.Color.transparent, [!1, !1, !1, !1]), pe.unblended = new pe(pe.Replace, o.Color.transparent, [!0, !0, !0, !0]), pe.alphaBlended = new pe([1, 771], o.Color.transparent, [!0, !0, !0, !0]);
        var Te = function(g, v, _) {
          this.enable = g, this.mode = v, this.frontFace = _;
        };
        Te.disabled = new Te(!1, 1029, 2305), Te.backCCW = new Te(!0, 1029, 2305);
        var le = function(g) {
          this.gl = g, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), this.clearColor = new $n(this), this.clearDepth = new xr(this), this.clearStencil = new wr(this), this.colorMask = new gn(this), this.depthMask = new zr(this), this.stencilMask = new ci(this), this.stencilFunc = new Jn(this), this.stencilOp = new wn(this), this.stencilTest = new ii(this), this.depthRange = new qn(this), this.depthTest = new Rn(this), this.depthFunc = new ei(this), this.blend = new Zt(this), this.blendFunc = new br(this), this.blendColor = new Nr(this), this.blendEquation = new on(this), this.cullFace = new pi(this), this.cullFaceSide = new Le(this), this.frontFace = new Gt(this), this.program = new Jt(this), this.activeTexture = new pr(this), this.viewport = new st(this), this.bindFramebuffer = new Ft(this), this.bindRenderbuffer = new _e(this), this.bindTexture = new Xt(this), this.bindVertexBuffer = new Ct(this), this.bindElementBuffer = new $(this), this.bindVertexArrayOES = this.extVertexArrayObject && new Et(this), this.pixelStoreUnpack = new Rt(this), this.pixelStoreUnpackPremultiplyAlpha = new Pe(this), this.pixelStoreUnpackFlipY = new tt(this), this.extTextureFilterAnisotropic = g.getExtension("EXT_texture_filter_anisotropic") || g.getExtension("MOZ_EXT_texture_filter_anisotropic") || g.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = g.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureHalfFloat = g.getExtension("OES_texture_half_float"), this.extTextureHalfFloat && (g.getExtension("OES_texture_half_float_linear"), this.extRenderToTextureHalfFloat = g.getExtension("EXT_color_buffer_half_float")), this.extTimerQuery = g.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = g.getParameter(g.MAX_TEXTURE_SIZE);
        };
        le.prototype.setDefault = function() {
          this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
        }, le.prototype.setDirty = function() {
          this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = !0), this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
        }, le.prototype.createIndexBuffer = function(g, v) {
          return new yr(this, g, v);
        }, le.prototype.createVertexBuffer = function(g, v, _) {
          return new Fr(this, g, v, _);
        }, le.prototype.createRenderbuffer = function(g, v, _) {
          var w = this.gl, R = w.createRenderbuffer();
          return this.bindRenderbuffer.set(R), w.renderbufferStorage(w.RENDERBUFFER, g, v, _), this.bindRenderbuffer.set(null), R;
        }, le.prototype.createFramebuffer = function(g, v, _) {
          return new ce(this, g, v, _);
        }, le.prototype.clear = function(g) {
          var v = g.color, _ = g.depth, w = this.gl, R = 0;
          v && (R |= w.COLOR_BUFFER_BIT, this.clearColor.set(v), this.colorMask.set([!0, !0, !0, !0])), _ !== void 0 && (R |= w.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(_), this.depthMask.set(!0)), w.clear(R);
        }, le.prototype.setCullFace = function(g) {
          g.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(g.mode), this.frontFace.set(g.frontFace));
        }, le.prototype.setDepthMode = function(g) {
          g.func !== this.gl.ALWAYS || g.mask ? (this.depthTest.set(!0), this.depthFunc.set(g.func), this.depthMask.set(g.mask), this.depthRange.set(g.range)) : this.depthTest.set(!1);
        }, le.prototype.setStencilMode = function(g) {
          g.test.func !== this.gl.ALWAYS || g.mask ? (this.stencilTest.set(!0), this.stencilMask.set(g.mask), this.stencilOp.set([g.fail, g.depthFail, g.pass]), this.stencilFunc.set({ func: g.test.func, ref: g.ref, mask: g.test.mask })) : this.stencilTest.set(!1);
        }, le.prototype.setColorMode = function(g) {
          o.deepEqual(g.blendFunction, pe.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(g.blendFunction), this.blendColor.set(g.blendColor)), this.colorMask.set(g.mask);
        }, le.prototype.unbindVAO = function() {
          this.extVertexArrayObject && this.bindVertexArrayOES.set(null);
        };
        var ge = (function(g) {
          function v(_, w, R) {
            var D = this;
            g.call(this), this.id = _, this.dispatcher = R, this.on("data", (function(k) {
              k.dataType === "source" && k.sourceDataType === "metadata" && (D._sourceLoaded = !0), D._sourceLoaded && !D._paused && k.dataType === "source" && k.sourceDataType === "content" && (D.reload(), D.transform && D.update(D.transform));
            })), this.on("error", (function() {
              D._sourceErrored = !0;
            })), this._source = (function(k, H, J, oe) {
              var Ce = new dt[H.type](k, H, J, oe);
              if (Ce.id !== k) throw new Error("Expected Source id to be " + k + " instead of " + Ce.id);
              return o.bindAll(["load", "abort", "unload", "serialize", "prepare"], Ce), Ce;
            })(_, w, R, this), this._tiles = {}, this._cache = new Wt(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new o.SourceFeatureState();
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.onAdd = function(_) {
            this.map = _, this._maxTileCacheSize = _ ? _._maxTileCacheSize : null, this._source && this._source.onAdd && this._source.onAdd(_);
          }, v.prototype.onRemove = function(_) {
            this._source && this._source.onRemove && this._source.onRemove(_);
          }, v.prototype.loaded = function() {
            if (this._sourceErrored) return !0;
            if (!this._sourceLoaded || !this._source.loaded()) return !1;
            for (var _ in this._tiles) {
              var w = this._tiles[_];
              if (w.state !== "loaded" && w.state !== "errored") return !1;
            }
            return !0;
          }, v.prototype.getSource = function() {
            return this._source;
          }, v.prototype.pause = function() {
            this._paused = !0;
          }, v.prototype.resume = function() {
            if (this._paused) {
              var _ = this._shouldReloadOnResume;
              this._paused = !1, this._shouldReloadOnResume = !1, _ && this.reload(), this.transform && this.update(this.transform);
            }
          }, v.prototype._loadTile = function(_, w) {
            return this._source.loadTile(_, w);
          }, v.prototype._unloadTile = function(_) {
            if (this._source.unloadTile) return this._source.unloadTile(_, (function() {
            }));
          }, v.prototype._abortTile = function(_) {
            if (this._source.abortTile) return this._source.abortTile(_, (function() {
            }));
          }, v.prototype.serialize = function() {
            return this._source.serialize();
          }, v.prototype.prepare = function(_) {
            for (var w in this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null), this._tiles) {
              var R = this._tiles[w];
              R.upload(_), R.prepare(this.map.style.imageManager);
            }
          }, v.prototype.getIds = function() {
            return o.values(this._tiles).map((function(_) {
              return _.tileID;
            })).sort(d).map((function(_) {
              return _.key;
            }));
          }, v.prototype.getRenderableIds = function(_) {
            var w = this, R = [];
            for (var D in this._tiles) this._isIdRenderable(D, _) && R.push(this._tiles[D]);
            return _ ? R.sort((function(k, H) {
              var J = k.tileID, oe = H.tileID, Ce = new o.Point(J.canonical.x, J.canonical.y)._rotate(w.transform.angle), Se = new o.Point(oe.canonical.x, oe.canonical.y)._rotate(w.transform.angle);
              return J.overscaledZ - oe.overscaledZ || Se.y - Ce.y || Se.x - Ce.x;
            })).map((function(k) {
              return k.tileID.key;
            })) : R.map((function(k) {
              return k.tileID;
            })).sort(d).map((function(k) {
              return k.key;
            }));
          }, v.prototype.hasRenderableParent = function(_) {
            var w = this.findLoadedParent(_, 0);
            return !!w && this._isIdRenderable(w.tileID.key);
          }, v.prototype._isIdRenderable = function(_, w) {
            return this._tiles[_] && this._tiles[_].hasData() && !this._coveredTiles[_] && (w || !this._tiles[_].holdingForFade());
          }, v.prototype.reload = function() {
            if (this._paused) this._shouldReloadOnResume = !0;
            else for (var _ in this._cache.reset(), this._tiles) this._tiles[_].state !== "errored" && this._reloadTile(_, "reloading");
          }, v.prototype._reloadTile = function(_, w) {
            var R = this._tiles[_];
            R && (R.state !== "loading" && (R.state = w), this._loadTile(R, this._tileLoaded.bind(this, R, _, w)));
          }, v.prototype._tileLoaded = function(_, w, R, D) {
            if (D) return _.state = "errored", void (D.status !== 404 ? this._source.fire(new o.ErrorEvent(D, { tile: _ })) : this.update(this.transform));
            _.timeAdded = o.browser.now(), R === "expired" && (_.refreshedUponExpiration = !0), this._setTileReloadTimer(w, _), this.getSource().type === "raster-dem" && _.dem && this._backfillDEM(_), this._state.initializeTileState(_, this.map ? this.map.painter : null), this._source.fire(new o.Event("data", { dataType: "source", tile: _, coord: _.tileID }));
          }, v.prototype._backfillDEM = function(_) {
            for (var w = this.getRenderableIds(), R = 0; R < w.length; R++) {
              var D = w[R];
              if (_.neighboringTiles && _.neighboringTiles[D]) {
                var k = this.getTileByID(D);
                H(_, k), H(k, _);
              }
            }
            function H(J, oe) {
              J.needsHillshadePrepare = !0;
              var Ce = oe.tileID.canonical.x - J.tileID.canonical.x, Se = oe.tileID.canonical.y - J.tileID.canonical.y, Oe = Math.pow(2, J.tileID.canonical.z), He = oe.tileID.key;
              Ce === 0 && Se === 0 || Math.abs(Se) > 1 || (Math.abs(Ce) > 1 && (Math.abs(Ce + Oe) === 1 ? Ce += Oe : Math.abs(Ce - Oe) === 1 && (Ce -= Oe)), oe.dem && J.dem && (J.dem.backfillBorder(oe.dem, Ce, Se), J.neighboringTiles && J.neighboringTiles[He] && (J.neighboringTiles[He].backfilled = !0)));
            }
          }, v.prototype.getTile = function(_) {
            return this.getTileByID(_.key);
          }, v.prototype.getTileByID = function(_) {
            return this._tiles[_];
          }, v.prototype._retainLoadedChildren = function(_, w, R, D) {
            for (var k in this._tiles) {
              var H = this._tiles[k];
              if (!(D[k] || !H.hasData() || H.tileID.overscaledZ <= w || H.tileID.overscaledZ > R)) {
                for (var J = H.tileID; H && H.tileID.overscaledZ > w + 1; ) {
                  var oe = H.tileID.scaledTo(H.tileID.overscaledZ - 1);
                  (H = this._tiles[oe.key]) && H.hasData() && (J = oe);
                }
                for (var Ce = J; Ce.overscaledZ > w; ) if (_[(Ce = Ce.scaledTo(Ce.overscaledZ - 1)).key]) {
                  D[J.key] = J;
                  break;
                }
              }
            }
          }, v.prototype.findLoadedParent = function(_, w) {
            if (_.key in this._loadedParentTiles) {
              var R = this._loadedParentTiles[_.key];
              return R && R.tileID.overscaledZ >= w ? R : null;
            }
            for (var D = _.overscaledZ - 1; D >= w; D--) {
              var k = _.scaledTo(D), H = this._getLoadedTile(k);
              if (H) return H;
            }
          }, v.prototype._getLoadedTile = function(_) {
            var w = this._tiles[_.key];
            return w && w.hasData() ? w : this._cache.getByKey(_.wrapped().key);
          }, v.prototype.updateCacheSize = function(_) {
            var w = Math.ceil(_.width / this._source.tileSize) + 1, R = Math.ceil(_.height / this._source.tileSize) + 1, D = Math.floor(w * R * 5), k = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, D) : D;
            this._cache.setMaxSize(k);
          }, v.prototype.handleWrapJump = function(_) {
            var w = Math.round((_ - (this._prevLng === void 0 ? _ : this._prevLng)) / 360);
            if (this._prevLng = _, w) {
              var R = {};
              for (var D in this._tiles) {
                var k = this._tiles[D];
                k.tileID = k.tileID.unwrapTo(k.tileID.wrap + w), R[k.tileID.key] = k;
              }
              for (var H in this._tiles = R, this._timers) clearTimeout(this._timers[H]), delete this._timers[H];
              for (var J in this._tiles) this._setTileReloadTimer(J, this._tiles[J]);
            }
          }, v.prototype.update = function(_) {
            var w = this;
            if (this.transform = _, this._sourceLoaded && !this._paused) {
              var R;
              this.updateCacheSize(_), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used ? this._source.tileID ? R = _.getVisibleUnwrappedCoordinates(this._source.tileID).map((function(F) {
                return new o.OverscaledTileID(F.canonical.z, F.wrap, F.canonical.z, F.canonical.x, F.canonical.y);
              })) : (R = _.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }), this._source.hasTile && (R = R.filter((function(F) {
                return w._source.hasTile(F);
              })))) : R = [];
              var D = _.coveringZoomLevel(this._source), k = Math.max(D - v.maxOverzooming, this._source.minzoom), H = Math.max(D + v.maxUnderzooming, this._source.minzoom), J = this._updateRetainedTiles(R, D);
              if (ee(this._source.type)) {
                for (var oe = {}, Ce = {}, Se = 0, Oe = Object.keys(J); Se < Oe.length; Se += 1) {
                  var He = Oe[Se], ze = J[He], h = this._tiles[He];
                  if (h && !(h.fadeEndTime && h.fadeEndTime <= o.browser.now())) {
                    var f = this.findLoadedParent(ze, k);
                    f && (this._addTile(f.tileID), oe[f.tileID.key] = f.tileID), Ce[He] = ze;
                  }
                }
                for (var A in this._retainLoadedChildren(Ce, D, H, J), oe) J[A] || (this._coveredTiles[A] = !0, J[A] = oe[A]);
              }
              for (var b in J) this._tiles[b].clearFadeHold();
              for (var T = 0, C = o.keysDifference(this._tiles, J); T < C.length; T += 1) {
                var I = C[T], B = this._tiles[I];
                B.hasSymbolBuckets && !B.holdingForFade() ? B.setHoldDuration(this.map._fadeDuration) : B.hasSymbolBuckets && !B.symbolFadeFinished() || this._removeTile(I);
              }
              this._updateLoadedParentTileCache();
            }
          }, v.prototype.releaseSymbolFadeTiles = function() {
            for (var _ in this._tiles) this._tiles[_].holdingForFade() && this._removeTile(_);
          }, v.prototype._updateRetainedTiles = function(_, w) {
            for (var R = {}, D = {}, k = Math.max(w - v.maxOverzooming, this._source.minzoom), H = Math.max(w + v.maxUnderzooming, this._source.minzoom), J = {}, oe = 0, Ce = _; oe < Ce.length; oe += 1) {
              var Se = Ce[oe], Oe = this._addTile(Se);
              R[Se.key] = Se, Oe.hasData() || w < this._source.maxzoom && (J[Se.key] = Se);
            }
            this._retainLoadedChildren(J, w, H, R);
            for (var He = 0, ze = _; He < ze.length; He += 1) {
              var h = ze[He], f = this._tiles[h.key];
              if (!f.hasData()) {
                if (w + 1 > this._source.maxzoom) {
                  var A = h.children(this._source.maxzoom)[0], b = this.getTile(A);
                  if (b && b.hasData()) {
                    R[A.key] = A;
                    continue;
                  }
                } else {
                  var T = h.children(this._source.maxzoom);
                  if (R[T[0].key] && R[T[1].key] && R[T[2].key] && R[T[3].key]) continue;
                }
                for (var C = f.wasRequested(), I = h.overscaledZ - 1; I >= k; --I) {
                  var B = h.scaledTo(I);
                  if (D[B.key] || (D[B.key] = !0, !(f = this.getTile(B)) && C && (f = this._addTile(B)), f && (R[B.key] = B, C = f.wasRequested(), f.hasData()))) break;
                }
              }
            }
            return R;
          }, v.prototype._updateLoadedParentTileCache = function() {
            for (var _ in this._loadedParentTiles = {}, this._tiles) {
              for (var w = [], R = void 0, D = this._tiles[_].tileID; D.overscaledZ > 0; ) {
                if (D.key in this._loadedParentTiles) {
                  R = this._loadedParentTiles[D.key];
                  break;
                }
                w.push(D.key);
                var k = D.scaledTo(D.overscaledZ - 1);
                if (R = this._getLoadedTile(k)) break;
                D = k;
              }
              for (var H = 0, J = w; H < J.length; H += 1) this._loadedParentTiles[J[H]] = R;
            }
          }, v.prototype._addTile = function(_) {
            var w = this._tiles[_.key];
            if (w) return w;
            (w = this._cache.getAndRemove(_)) && (this._setTileReloadTimer(_.key, w), w.tileID = _, this._state.initializeTileState(w, this.map ? this.map.painter : null), this._cacheTimers[_.key] && (clearTimeout(this._cacheTimers[_.key]), delete this._cacheTimers[_.key], this._setTileReloadTimer(_.key, w)));
            var R = !!w;
            return R || (w = new o.Tile(_, this._source.tileSize * _.overscaleFactor()), this._loadTile(w, this._tileLoaded.bind(this, w, _.key, w.state))), w ? (w.uses++, this._tiles[_.key] = w, R || this._source.fire(new o.Event("dataloading", { tile: w, coord: w.tileID, dataType: "source" })), w) : null;
          }, v.prototype._setTileReloadTimer = function(_, w) {
            var R = this;
            _ in this._timers && (clearTimeout(this._timers[_]), delete this._timers[_]);
            var D = w.getExpiryTimeout();
            D && (this._timers[_] = setTimeout((function() {
              R._reloadTile(_, "expired"), delete R._timers[_];
            }), D));
          }, v.prototype._removeTile = function(_) {
            var w = this._tiles[_];
            w && (w.uses--, delete this._tiles[_], this._timers[_] && (clearTimeout(this._timers[_]), delete this._timers[_]), w.uses > 0 || (w.hasData() && w.state !== "reloading" ? this._cache.add(w.tileID, w, w.getExpiryTimeout()) : (w.aborted = !0, this._abortTile(w), this._unloadTile(w))));
          }, v.prototype.clearTiles = function() {
            for (var _ in this._shouldReloadOnResume = !1, this._paused = !1, this._tiles) this._removeTile(_);
            this._cache.reset();
          }, v.prototype.tilesIn = function(_, w, R) {
            var D = this, k = [], H = this.transform;
            if (!H) return k;
            for (var J = R ? H.getCameraQueryGeometry(_) : _, oe = _.map((function(I) {
              return H.pointCoordinate(I);
            })), Ce = J.map((function(I) {
              return H.pointCoordinate(I);
            })), Se = this.getIds(), Oe = 1 / 0, He = 1 / 0, ze = -1 / 0, h = -1 / 0, f = 0, A = Ce; f < A.length; f += 1) {
              var b = A[f];
              Oe = Math.min(Oe, b.x), He = Math.min(He, b.y), ze = Math.max(ze, b.x), h = Math.max(h, b.y);
            }
            for (var T = function(I) {
              var B = D._tiles[Se[I]];
              if (!B.holdingForFade()) {
                var F = B.tileID, z = Math.pow(2, H.zoom - B.tileID.overscaledZ), W = w * B.queryPadding * o.EXTENT / B.tileSize / z, ue = [F.getTilePoint(new o.MercatorCoordinate(Oe, He)), F.getTilePoint(new o.MercatorCoordinate(ze, h))];
                if (ue[0].x - W < o.EXTENT && ue[0].y - W < o.EXTENT && ue[1].x + W >= 0 && ue[1].y + W >= 0) {
                  var Ie = oe.map((function(Be) {
                    return F.getTilePoint(Be);
                  })), Re = Ce.map((function(Be) {
                    return F.getTilePoint(Be);
                  }));
                  k.push({ tile: B, tileID: F, queryGeometry: Ie, cameraQueryGeometry: Re, scale: z });
                }
              }
            }, C = 0; C < Se.length; C++) T(C);
            return k;
          }, v.prototype.getVisibleCoordinates = function(_) {
            for (var w = this, R = this.getRenderableIds(_).map((function(J) {
              return w._tiles[J].tileID;
            })), D = 0, k = R; D < k.length; D += 1) {
              var H = k[D];
              H.posMatrix = this.transform.calculatePosMatrix(H.toUnwrapped());
            }
            return R;
          }, v.prototype.hasTransition = function() {
            if (this._source.hasTransition()) return !0;
            if (ee(this._source.type)) for (var _ in this._tiles) {
              var w = this._tiles[_];
              if (w.fadeEndTime !== void 0 && w.fadeEndTime >= o.browser.now()) return !0;
            }
            return !1;
          }, v.prototype.setFeatureState = function(_, w, R) {
            this._state.updateState(_ = _ || "_geojsonTileLayer", w, R);
          }, v.prototype.removeFeatureState = function(_, w, R) {
            this._state.removeFeatureState(_ = _ || "_geojsonTileLayer", w, R);
          }, v.prototype.getFeatureState = function(_, w) {
            return this._state.getState(_ = _ || "_geojsonTileLayer", w);
          }, v.prototype.setDependencies = function(_, w, R) {
            var D = this._tiles[_];
            D && D.setDependencies(w, R);
          }, v.prototype.reloadTilesForDependencies = function(_, w) {
            for (var R in this._tiles) this._tiles[R].hasDependency(_, w) && this._reloadTile(R, "reloading");
            this._cache.filter((function(D) {
              return !D.hasDependency(_, w);
            }));
          }, v;
        })(o.Evented);
        function d(g, v) {
          var _ = Math.abs(2 * g.wrap) - +(g.wrap < 0), w = Math.abs(2 * v.wrap) - +(v.wrap < 0);
          return g.overscaledZ - v.overscaledZ || w - _ || v.canonical.y - g.canonical.y || v.canonical.x - g.canonical.x;
        }
        function ee(g) {
          return g === "raster" || g === "image" || g === "video";
        }
        function It() {
          return new o.window.Worker(Mo.workerUrl);
        }
        ge.maxOverzooming = 10, ge.maxUnderzooming = 3;
        var nt = "mapboxgl_preloaded_worker_pool", Mt = function() {
          this.active = {};
        };
        Mt.prototype.acquire = function(g) {
          if (!this.workers) for (this.workers = []; this.workers.length < Mt.workerCount; ) this.workers.push(new It());
          return this.active[g] = !0, this.workers.slice();
        }, Mt.prototype.release = function(g) {
          delete this.active[g], this.numActive() === 0 && (this.workers.forEach((function(v) {
            v.terminate();
          })), this.workers = null);
        }, Mt.prototype.isPreloaded = function() {
          return !!this.active[nt];
        }, Mt.prototype.numActive = function() {
          return Object.keys(this.active).length;
        };
        var kt, zt = Math.floor(o.browser.hardwareConcurrency / 2);
        function _t() {
          return kt || (kt = new Mt()), kt;
        }
        function Vt(g, v) {
          var _ = {};
          for (var w in g) w !== "ref" && (_[w] = g[w]);
          return o.refProperties.forEach((function(R) {
            R in v && (_[R] = v[R]);
          })), _;
        }
        function Lt(g) {
          g = g.slice();
          for (var v = /* @__PURE__ */ Object.create(null), _ = 0; _ < g.length; _++) v[g[_].id] = g[_];
          for (var w = 0; w < g.length; w++) "ref" in g[w] && (g[w] = Vt(g[w], v[g[w].ref]));
          return g;
        }
        Mt.workerCount = Math.max(Math.min(zt, 6), 1);
        var Yt = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight" };
        function Hr(g, v, _) {
          _.push({ command: Yt.addSource, args: [g, v[g]] });
        }
        function ir(g, v, _) {
          v.push({ command: Yt.removeSource, args: [g] }), _[g] = !0;
        }
        function nn(g, v, _, w) {
          ir(g, _, w), Hr(g, v, _);
        }
        function un(g, v, _) {
          var w;
          for (w in g[_]) if (g[_].hasOwnProperty(w) && w !== "data" && !o.deepEqual(g[_][w], v[_][w])) return !1;
          for (w in v[_]) if (v[_].hasOwnProperty(w) && w !== "data" && !o.deepEqual(g[_][w], v[_][w])) return !1;
          return !0;
        }
        function Yr(g, v, _, w, R, D) {
          var k;
          for (k in v = v || {}, g = g || {}) g.hasOwnProperty(k) && (o.deepEqual(g[k], v[k]) || _.push({ command: D, args: [w, k, v[k], R] }));
          for (k in v) v.hasOwnProperty(k) && !g.hasOwnProperty(k) && (o.deepEqual(g[k], v[k]) || _.push({ command: D, args: [w, k, v[k], R] }));
        }
        function Qr(g) {
          return g.id;
        }
        function $r(g, v) {
          return g[v.id] = v, g;
        }
        var Ai = function(g, v) {
          this.reset(g, v);
        };
        Ai.prototype.reset = function(g, v) {
          this.points = g || [], this._distances = [0];
          for (var _ = 1; _ < this.points.length; _++) this._distances[_] = this._distances[_ - 1] + this.points[_].dist(this.points[_ - 1]);
          this.length = this._distances[this._distances.length - 1], this.padding = Math.min(v || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
        }, Ai.prototype.lerp = function(g) {
          if (this.points.length === 1) return this.points[0];
          g = o.clamp(g, 0, 1);
          for (var v = 1, _ = this._distances[v], w = g * this.paddedLength + this.padding; _ < w && v < this._distances.length; ) _ = this._distances[++v];
          var R = v - 1, D = this._distances[R], k = _ - D, H = k > 0 ? (w - D) / k : 0;
          return this.points[R].mult(1 - H).add(this.points[v].mult(H));
        };
        var Kr = function(g, v, _) {
          var w = this.boxCells = [], R = this.circleCells = [];
          this.xCellCount = Math.ceil(g / _), this.yCellCount = Math.ceil(v / _);
          for (var D = 0; D < this.xCellCount * this.yCellCount; D++) w.push([]), R.push([]);
          this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = g, this.height = v, this.xScale = this.xCellCount / g, this.yScale = this.yCellCount / v, this.boxUid = 0, this.circleUid = 0;
        };
        function hr(g, v, _, w, R) {
          var D = o.create();
          return v ? (o.scale(D, D, [1 / R, 1 / R, 1]), _ || o.rotateZ(D, D, w.angle)) : o.multiply(D, w.labelPlaneMatrix, g), D;
        }
        function ye(g, v, _, w, R) {
          if (v) {
            var D = o.clone(g);
            return o.scale(D, D, [R, R, 1]), _ || o.rotateZ(D, D, -w.angle), D;
          }
          return w.glCoordMatrix;
        }
        function er(g, v) {
          var _ = [g.x, g.y, 0, 1];
          fi(_, _, v);
          var w = _[3];
          return { point: new o.Point(_[0] / w, _[1] / w), signedDistanceFromCamera: w };
        }
        function sn(g, v) {
          return 0.5 + g / v * 0.5;
        }
        function Wi(g, v) {
          var _ = g[0] / g[3], w = g[1] / g[3];
          return _ >= -v[0] && _ <= v[0] && w >= -v[1] && w <= v[1];
        }
        function ma(g, v, _, w, R, D, k, H) {
          var J = w ? g.textSizeData : g.iconSizeData, oe = o.evaluateSizeForZoom(J, _.transform.zoom), Ce = [256 / _.width * 2 + 1, 256 / _.height * 2 + 1], Se = w ? g.text.dynamicLayoutVertexArray : g.icon.dynamicLayoutVertexArray;
          Se.clear();
          for (var Oe = g.lineVertexArray, He = w ? g.text.placedSymbolArray : g.icon.placedSymbolArray, ze = _.transform.width / _.transform.height, h = !1, f = 0; f < He.length; f++) {
            var A = He.get(f);
            if (A.hidden || A.writingMode === o.WritingMode.vertical && !h) Oi(A.numGlyphs, Se);
            else {
              h = !1;
              var b = [A.anchorX, A.anchorY, 0, 1];
              if (o.transformMat4(b, b, v), Wi(b, Ce)) {
                var T = sn(_.transform.cameraToCenterDistance, b[3]), C = o.evaluateSizeForFeature(J, oe, A), I = k ? C / T : C * T, B = new o.Point(A.anchorX, A.anchorY), F = er(B, R).point, z = {}, W = Ae(A, I, !1, H, v, R, D, g.glyphOffsetArray, Oe, Se, F, B, z, ze);
                h = W.useVertical, (W.notEnoughRoom || h || W.needsFlipping && Ae(A, I, !0, H, v, R, D, g.glyphOffsetArray, Oe, Se, F, B, z, ze).notEnoughRoom) && Oi(A.numGlyphs, Se);
              } else Oi(A.numGlyphs, Se);
            }
          }
          w ? g.text.dynamicLayoutVertexBuffer.updateData(Se) : g.icon.dynamicLayoutVertexBuffer.updateData(Se);
        }
        function ui(g, v, _, w, R, D, k, H, J, oe, Ce) {
          var Se = H.glyphStartIndex + H.numGlyphs, Oe = H.lineStartIndex, He = H.lineStartIndex + H.lineLength, ze = v.getoffsetX(H.glyphStartIndex), h = v.getoffsetX(Se - 1), f = Zn(g * ze, _, w, R, D, k, H.segment, Oe, He, J, oe, Ce);
          if (!f) return null;
          var A = Zn(g * h, _, w, R, D, k, H.segment, Oe, He, J, oe, Ce);
          return A ? { first: f, last: A } : null;
        }
        function Xn(g, v, _, w) {
          return g === o.WritingMode.horizontal && Math.abs(_.y - v.y) > Math.abs(_.x - v.x) * w ? { useVertical: !0 } : (g === o.WritingMode.vertical ? v.y < _.y : v.x > _.x) ? { needsFlipping: !0 } : null;
        }
        function Ae(g, v, _, w, R, D, k, H, J, oe, Ce, Se, Oe, He) {
          var ze, h = v / 24, f = g.lineOffsetX * h, A = g.lineOffsetY * h;
          if (g.numGlyphs > 1) {
            var b = g.glyphStartIndex + g.numGlyphs, T = g.lineStartIndex, C = g.lineStartIndex + g.lineLength, I = ui(h, H, f, A, _, Ce, Se, g, J, D, Oe);
            if (!I) return { notEnoughRoom: !0 };
            var B = er(I.first.point, k).point, F = er(I.last.point, k).point;
            if (w && !_) {
              var z = Xn(g.writingMode, B, F, He);
              if (z) return z;
            }
            ze = [I.first];
            for (var W = g.glyphStartIndex + 1; W < b - 1; W++) ze.push(Zn(h * H.getoffsetX(W), f, A, _, Ce, Se, g.segment, T, C, J, D, Oe));
            ze.push(I.last);
          } else {
            if (w && !_) {
              var ue = er(Se, R).point, Ie = g.lineStartIndex + g.segment + 1, Re = new o.Point(J.getx(Ie), J.gety(Ie)), Be = er(Re, R), Ze = Be.signedDistanceFromCamera > 0 ? Be.point : Ko(Se, Re, ue, 1, R), We = Xn(g.writingMode, ue, Ze, He);
              if (We) return We;
            }
            var rt = Zn(h * H.getoffsetX(g.glyphStartIndex), f, A, _, Ce, Se, g.segment, g.lineStartIndex, g.lineStartIndex + g.lineLength, J, D, Oe);
            if (!rt) return { notEnoughRoom: !0 };
            ze = [rt];
          }
          for (var et = 0, Je = ze; et < Je.length; et += 1) {
            var $e = Je[et];
            o.addDynamicAttributes(oe, $e.point, $e.angle);
          }
          return {};
        }
        function Ko(g, v, _, w, R) {
          var D = er(g.add(g.sub(v)._unit()), R).point, k = _.sub(D);
          return _.add(k._mult(w / k.mag()));
        }
        function Zn(g, v, _, w, R, D, k, H, J, oe, Ce, Se) {
          var Oe = w ? g - v : g + v, He = Oe > 0 ? 1 : -1, ze = 0;
          w && (He *= -1, ze = Math.PI), He < 0 && (ze += Math.PI);
          for (var h = He > 0 ? H + k : H + k + 1, f = R, A = R, b = 0, T = 0, C = Math.abs(Oe), I = []; b + T <= C; ) {
            if ((h += He) < H || h >= J) return null;
            if (A = f, I.push(f), (f = Se[h]) === void 0) {
              var B = new o.Point(oe.getx(h), oe.gety(h)), F = er(B, Ce);
              if (F.signedDistanceFromCamera > 0) f = Se[h] = F.point;
              else {
                var z = h - He;
                f = Ko(b === 0 ? D : new o.Point(oe.getx(z), oe.gety(z)), B, A, C - b + 1, Ce);
              }
            }
            b += T, T = A.dist(f);
          }
          var W = (C - b) / T, ue = f.sub(A), Ie = ue.mult(W)._add(A);
          Ie._add(ue._unit()._perp()._mult(_ * He));
          var Re = ze + Math.atan2(f.y - A.y, f.x - A.x);
          return I.push(Ie), { point: Ie, angle: Re, path: I };
        }
        Kr.prototype.keysLength = function() {
          return this.boxKeys.length + this.circleKeys.length;
        }, Kr.prototype.insert = function(g, v, _, w, R) {
          this._forEachCell(v, _, w, R, this._insertBoxCell, this.boxUid++), this.boxKeys.push(g), this.bboxes.push(v), this.bboxes.push(_), this.bboxes.push(w), this.bboxes.push(R);
        }, Kr.prototype.insertCircle = function(g, v, _, w) {
          this._forEachCell(v - w, _ - w, v + w, _ + w, this._insertCircleCell, this.circleUid++), this.circleKeys.push(g), this.circles.push(v), this.circles.push(_), this.circles.push(w);
        }, Kr.prototype._insertBoxCell = function(g, v, _, w, R, D) {
          this.boxCells[R].push(D);
        }, Kr.prototype._insertCircleCell = function(g, v, _, w, R, D) {
          this.circleCells[R].push(D);
        }, Kr.prototype._query = function(g, v, _, w, R, D) {
          if (_ < 0 || g > this.width || w < 0 || v > this.height) return !R && [];
          var k = [];
          if (g <= 0 && v <= 0 && this.width <= _ && this.height <= w) {
            if (R) return !0;
            for (var H = 0; H < this.boxKeys.length; H++) k.push({ key: this.boxKeys[H], x1: this.bboxes[4 * H], y1: this.bboxes[4 * H + 1], x2: this.bboxes[4 * H + 2], y2: this.bboxes[4 * H + 3] });
            for (var J = 0; J < this.circleKeys.length; J++) {
              var oe = this.circles[3 * J], Ce = this.circles[3 * J + 1], Se = this.circles[3 * J + 2];
              k.push({ key: this.circleKeys[J], x1: oe - Se, y1: Ce - Se, x2: oe + Se, y2: Ce + Se });
            }
            return D ? k.filter(D) : k;
          }
          return this._forEachCell(g, v, _, w, this._queryCell, k, { hitTest: R, seenUids: { box: {}, circle: {} } }, D), R ? k.length > 0 : k;
        }, Kr.prototype._queryCircle = function(g, v, _, w, R) {
          var D = g - _, k = g + _, H = v - _, J = v + _;
          if (k < 0 || D > this.width || J < 0 || H > this.height) return !w && [];
          var oe = [];
          return this._forEachCell(D, H, k, J, this._queryCellCircle, oe, { hitTest: w, circle: { x: g, y: v, radius: _ }, seenUids: { box: {}, circle: {} } }, R), w ? oe.length > 0 : oe;
        }, Kr.prototype.query = function(g, v, _, w, R) {
          return this._query(g, v, _, w, !1, R);
        }, Kr.prototype.hitTest = function(g, v, _, w, R) {
          return this._query(g, v, _, w, !0, R);
        }, Kr.prototype.hitTestCircle = function(g, v, _, w) {
          return this._queryCircle(g, v, _, !0, w);
        }, Kr.prototype._queryCell = function(g, v, _, w, R, D, k, H) {
          var J = k.seenUids, oe = this.boxCells[R];
          if (oe !== null) for (var Ce = this.bboxes, Se = 0, Oe = oe; Se < Oe.length; Se += 1) {
            var He = Oe[Se];
            if (!J.box[He]) {
              J.box[He] = !0;
              var ze = 4 * He;
              if (g <= Ce[ze + 2] && v <= Ce[ze + 3] && _ >= Ce[ze + 0] && w >= Ce[ze + 1] && (!H || H(this.boxKeys[He]))) {
                if (k.hitTest) return D.push(!0), !0;
                D.push({ key: this.boxKeys[He], x1: Ce[ze], y1: Ce[ze + 1], x2: Ce[ze + 2], y2: Ce[ze + 3] });
              }
            }
          }
          var h = this.circleCells[R];
          if (h !== null) for (var f = this.circles, A = 0, b = h; A < b.length; A += 1) {
            var T = b[A];
            if (!J.circle[T]) {
              J.circle[T] = !0;
              var C = 3 * T;
              if (this._circleAndRectCollide(f[C], f[C + 1], f[C + 2], g, v, _, w) && (!H || H(this.circleKeys[T]))) {
                if (k.hitTest) return D.push(!0), !0;
                var I = f[C], B = f[C + 1], F = f[C + 2];
                D.push({ key: this.circleKeys[T], x1: I - F, y1: B - F, x2: I + F, y2: B + F });
              }
            }
          }
        }, Kr.prototype._queryCellCircle = function(g, v, _, w, R, D, k, H) {
          var J = k.circle, oe = k.seenUids, Ce = this.boxCells[R];
          if (Ce !== null) for (var Se = this.bboxes, Oe = 0, He = Ce; Oe < He.length; Oe += 1) {
            var ze = He[Oe];
            if (!oe.box[ze]) {
              oe.box[ze] = !0;
              var h = 4 * ze;
              if (this._circleAndRectCollide(J.x, J.y, J.radius, Se[h + 0], Se[h + 1], Se[h + 2], Se[h + 3]) && (!H || H(this.boxKeys[ze]))) return D.push(!0), !0;
            }
          }
          var f = this.circleCells[R];
          if (f !== null) for (var A = this.circles, b = 0, T = f; b < T.length; b += 1) {
            var C = T[b];
            if (!oe.circle[C]) {
              oe.circle[C] = !0;
              var I = 3 * C;
              if (this._circlesCollide(A[I], A[I + 1], A[I + 2], J.x, J.y, J.radius) && (!H || H(this.circleKeys[C]))) return D.push(!0), !0;
            }
          }
        }, Kr.prototype._forEachCell = function(g, v, _, w, R, D, k, H) {
          for (var J = this._convertToXCellCoord(g), oe = this._convertToYCellCoord(v), Ce = this._convertToXCellCoord(_), Se = this._convertToYCellCoord(w), Oe = J; Oe <= Ce; Oe++) for (var He = oe; He <= Se; He++) if (R.call(this, g, v, _, w, this.xCellCount * He + Oe, D, k, H)) return;
        }, Kr.prototype._convertToXCellCoord = function(g) {
          return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(g * this.xScale)));
        }, Kr.prototype._convertToYCellCoord = function(g) {
          return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(g * this.yScale)));
        }, Kr.prototype._circlesCollide = function(g, v, _, w, R, D) {
          var k = w - g, H = R - v, J = _ + D;
          return J * J > k * k + H * H;
        }, Kr.prototype._circleAndRectCollide = function(g, v, _, w, R, D, k) {
          var H = (D - w) / 2, J = Math.abs(g - (w + H));
          if (J > H + _) return !1;
          var oe = (k - R) / 2, Ce = Math.abs(v - (R + oe));
          if (Ce > oe + _) return !1;
          if (J <= H || Ce <= oe) return !0;
          var Se = J - H, Oe = Ce - oe;
          return Se * Se + Oe * Oe <= _ * _;
        };
        var Qo = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
        function Oi(g, v) {
          for (var _ = 0; _ < g; _++) {
            var w = v.length;
            v.resize(w + 4), v.float32.set(Qo, 3 * w);
          }
        }
        function fi(g, v, _) {
          var w = v[0], R = v[1];
          return g[0] = _[0] * w + _[4] * R + _[12], g[1] = _[1] * w + _[5] * R + _[13], g[3] = _[3] * w + _[7] * R + _[15], g;
        }
        var Ci = function(g, v, _) {
          v === void 0 && (v = new Kr(g.width + 200, g.height + 200, 25)), _ === void 0 && (_ = new Kr(g.width + 200, g.height + 200, 25)), this.transform = g, this.grid = v, this.ignoredGrid = _, this.pitchfactor = Math.cos(g._pitch) * g.cameraToCenterDistance, this.screenRightBoundary = g.width + 100, this.screenBottomBoundary = g.height + 100, this.gridRightBoundary = g.width + 200, this.gridBottomBoundary = g.height + 200;
        };
        function Fn(g, v, _) {
          return v * (o.EXTENT / (g.tileSize * Math.pow(2, _ - g.tileID.overscaledZ)));
        }
        Ci.prototype.placeCollisionBox = function(g, v, _, w, R) {
          var D = this.projectAndGetPerspectiveRatio(w, g.anchorPointX, g.anchorPointY), k = _ * D.perspectiveRatio, H = g.x1 * k + D.point.x, J = g.y1 * k + D.point.y, oe = g.x2 * k + D.point.x, Ce = g.y2 * k + D.point.y;
          return !this.isInsideGrid(H, J, oe, Ce) || !v && this.grid.hitTest(H, J, oe, Ce, R) ? { box: [], offscreen: !1 } : { box: [H, J, oe, Ce], offscreen: this.isOffscreen(H, J, oe, Ce) };
        }, Ci.prototype.placeCollisionCircles = function(g, v, _, w, R, D, k, H, J, oe, Ce, Se, Oe) {
          var He = [], ze = new o.Point(v.anchorX, v.anchorY), h = er(ze, D), f = sn(this.transform.cameraToCenterDistance, h.signedDistanceFromCamera), A = (oe ? R / f : R * f) / o.ONE_EM, b = er(ze, k).point, T = ui(A, w, v.lineOffsetX * A, v.lineOffsetY * A, !1, b, ze, v, _, k, {}), C = !1, I = !1, B = !0;
          if (T) {
            for (var F = 0.5 * Se * f + Oe, z = new o.Point(-100, -100), W = new o.Point(this.screenRightBoundary, this.screenBottomBoundary), ue = new Ai(), Ie = T.first, Re = T.last, Be = [], Ze = Ie.path.length - 1; Ze >= 1; Ze--) Be.push(Ie.path[Ze]);
            for (var We = 1; We < Re.path.length; We++) Be.push(Re.path[We]);
            var rt = 2.5 * F;
            if (H) {
              var et = Be.map((function(Ys) {
                return er(Ys, H);
              }));
              Be = et.some((function(Ys) {
                return Ys.signedDistanceFromCamera <= 0;
              })) ? [] : et.map((function(Ys) {
                return Ys.point;
              }));
            }
            var Je = [];
            if (Be.length > 0) {
              for (var $e = Be[0].clone(), Bt = Be[0].clone(), Ht = 1; Ht < Be.length; Ht++) $e.x = Math.min($e.x, Be[Ht].x), $e.y = Math.min($e.y, Be[Ht].y), Bt.x = Math.max(Bt.x, Be[Ht].x), Bt.y = Math.max(Bt.y, Be[Ht].y);
              Je = $e.x >= z.x && Bt.x <= W.x && $e.y >= z.y && Bt.y <= W.y ? [Be] : Bt.x < z.x || $e.x > W.x || Bt.y < z.y || $e.y > W.y ? [] : o.clipLine([Be], z.x, z.y, W.x, W.y);
            }
            for (var Ut = 0, Or = Je; Ut < Or.length; Ut += 1) {
              var Cr;
              ue.reset(Or[Ut], 0.25 * F), Cr = ue.length <= 0.5 * F ? 1 : Math.ceil(ue.paddedLength / rt) + 1;
              for (var Gr = 0; Gr < Cr; Gr++) {
                var Sr = Gr / Math.max(Cr - 1, 1), ar = ue.lerp(Sr), jt = ar.x + 100, Wr = ar.y + 100;
                He.push(jt, Wr, F, 0);
                var fn = jt - F, Zr = Wr - F, _n = jt + F, si = Wr + F;
                if (B = B && this.isOffscreen(fn, Zr, _n, si), I = I || this.isInsideGrid(fn, Zr, _n, si), !g && this.grid.hitTestCircle(jt, Wr, F, Ce) && (C = !0, !J)) return { circles: [], offscreen: !1, collisionDetected: C };
              }
            }
          }
          return { circles: !J && C || !I ? [] : He, offscreen: B, collisionDetected: C };
        }, Ci.prototype.queryRenderedSymbols = function(g) {
          if (g.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
          for (var v = [], _ = 1 / 0, w = 1 / 0, R = -1 / 0, D = -1 / 0, k = 0, H = g; k < H.length; k += 1) {
            var J = H[k], oe = new o.Point(J.x + 100, J.y + 100);
            _ = Math.min(_, oe.x), w = Math.min(w, oe.y), R = Math.max(R, oe.x), D = Math.max(D, oe.y), v.push(oe);
          }
          for (var Ce = {}, Se = {}, Oe = 0, He = this.grid.query(_, w, R, D).concat(this.ignoredGrid.query(_, w, R, D)); Oe < He.length; Oe += 1) {
            var ze = He[Oe], h = ze.key;
            if (Ce[h.bucketInstanceId] === void 0 && (Ce[h.bucketInstanceId] = {}), !Ce[h.bucketInstanceId][h.featureIndex]) {
              var f = [new o.Point(ze.x1, ze.y1), new o.Point(ze.x2, ze.y1), new o.Point(ze.x2, ze.y2), new o.Point(ze.x1, ze.y2)];
              o.polygonIntersectsPolygon(v, f) && (Ce[h.bucketInstanceId][h.featureIndex] = !0, Se[h.bucketInstanceId] === void 0 && (Se[h.bucketInstanceId] = []), Se[h.bucketInstanceId].push(h.featureIndex));
            }
          }
          return Se;
        }, Ci.prototype.insertCollisionBox = function(g, v, _, w, R) {
          (v ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: _, featureIndex: w, collisionGroupID: R }, g[0], g[1], g[2], g[3]);
        }, Ci.prototype.insertCollisionCircles = function(g, v, _, w, R) {
          for (var D = v ? this.ignoredGrid : this.grid, k = { bucketInstanceId: _, featureIndex: w, collisionGroupID: R }, H = 0; H < g.length; H += 4) D.insertCircle(k, g[H], g[H + 1], g[H + 2]);
        }, Ci.prototype.projectAndGetPerspectiveRatio = function(g, v, _) {
          var w = [v, _, 0, 1];
          return fi(w, w, g), { point: new o.Point((w[0] / w[3] + 1) / 2 * this.transform.width + 100, (-w[1] / w[3] + 1) / 2 * this.transform.height + 100), perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / w[3] * 0.5 };
        }, Ci.prototype.isOffscreen = function(g, v, _, w) {
          return _ < 100 || g >= this.screenRightBoundary || w < 100 || v > this.screenBottomBoundary;
        }, Ci.prototype.isInsideGrid = function(g, v, _, w) {
          return _ >= 0 && g < this.gridRightBoundary && w >= 0 && v < this.gridBottomBoundary;
        }, Ci.prototype.getViewportMatrix = function() {
          var g = o.identity([]);
          return o.translate(g, g, [-100, -100, 0]), g;
        };
        var ms = function(g, v, _, w) {
          this.opacity = g ? Math.max(0, Math.min(1, g.opacity + (g.placed ? v : -v))) : w && _ ? 1 : 0, this.placed = _;
        };
        ms.prototype.isHidden = function() {
          return this.opacity === 0 && !this.placed;
        };
        var $i = function(g, v, _, w, R) {
          this.text = new ms(g ? g.text : null, v, _, R), this.icon = new ms(g ? g.icon : null, v, w, R);
        };
        $i.prototype.isHidden = function() {
          return this.text.isHidden() && this.icon.isHidden();
        };
        var Ms = function(g, v, _) {
          this.text = g, this.icon = v, this.skipFade = _;
        }, On = function() {
          this.invProjMatrix = o.create(), this.viewportMatrix = o.create(), this.circles = [];
        }, lf = function(g, v, _, w, R) {
          this.bucketInstanceId = g, this.featureIndex = v, this.sourceLayerIndex = _, this.bucketIndex = w, this.tileID = R;
        }, Ee = function(g) {
          this.crossSourceCollisions = g, this.maxGroupID = 0, this.collisionGroups = {};
        };
        function ke(g, v, _, w, R) {
          var D = o.getAnchorAlignment(g), k = -(D.horizontalAlign - 0.5) * v, H = -(D.verticalAlign - 0.5) * _, J = o.evaluateVariableOffset(g, w);
          return new o.Point(k + J[0] * R, H + J[1] * R);
        }
        function Ke(g, v, _, w, R, D) {
          var k = g.x1, H = g.x2, J = g.y1, oe = g.y2, Ce = g.anchorPointX, Se = g.anchorPointY, Oe = new o.Point(v, _);
          return w && Oe._rotate(R ? D : -D), { x1: k + Oe.x, y1: J + Oe.y, x2: H + Oe.x, y2: oe + Oe.y, anchorPointX: Ce, anchorPointY: Se };
        }
        Ee.prototype.get = function(g) {
          if (this.crossSourceCollisions) return { ID: 0, predicate: null };
          if (!this.collisionGroups[g]) {
            var v = ++this.maxGroupID;
            this.collisionGroups[g] = { ID: v, predicate: function(_) {
              return _.collisionGroupID === v;
            } };
          }
          return this.collisionGroups[g];
        };
        var bt = function(g, v, _, w) {
          this.transform = g.clone(), this.collisionIndex = new Ci(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = v, this.retainedQueryData = {}, this.collisionGroups = new Ee(_), this.collisionCircleArrays = {}, this.prevPlacement = w, w && (w.prevPlacement = void 0), this.placedOrientations = {};
        };
        function Qt(g, v, _, w, R) {
          g.emplaceBack(v ? 1 : 0, _ ? 1 : 0, w || 0, R || 0), g.emplaceBack(v ? 1 : 0, _ ? 1 : 0, w || 0, R || 0), g.emplaceBack(v ? 1 : 0, _ ? 1 : 0, w || 0, R || 0), g.emplaceBack(v ? 1 : 0, _ ? 1 : 0, w || 0, R || 0);
        }
        bt.prototype.getBucketParts = function(g, v, _, w) {
          var R = _.getBucket(v), D = _.latestFeatureIndex;
          if (R && D && v.id === R.layerIds[0]) {
            var k = _.collisionBoxArray, H = R.layers[0].layout, J = Math.pow(2, this.transform.zoom - _.tileID.overscaledZ), oe = _.tileSize / o.EXTENT, Ce = this.transform.calculatePosMatrix(_.tileID.toUnwrapped()), Se = H.get("text-pitch-alignment") === "map", Oe = H.get("text-rotation-alignment") === "map", He = Fn(_, 1, this.transform.zoom), ze = hr(Ce, Se, Oe, this.transform, He), h = null;
            if (Se) {
              var f = ye(Ce, Se, Oe, this.transform, He);
              h = o.multiply([], this.transform.labelPlaneMatrix, f);
            }
            this.retainedQueryData[R.bucketInstanceId] = new lf(R.bucketInstanceId, D, R.sourceLayerIndex, R.index, _.tileID);
            var A = { bucket: R, layout: H, posMatrix: Ce, textLabelPlaneMatrix: ze, labelToScreenMatrix: h, scale: J, textPixelRatio: oe, holdingForFade: _.holdingForFade(), collisionBoxArray: k, partiallyEvaluatedTextSize: o.evaluateSizeForZoom(R.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(R.sourceID) };
            if (w) for (var b = 0, T = R.sortKeyRanges; b < T.length; b += 1) {
              var C = T[b];
              g.push({ sortKey: C.sortKey, symbolInstanceStart: C.symbolInstanceStart, symbolInstanceEnd: C.symbolInstanceEnd, parameters: A });
            }
            else g.push({ symbolInstanceStart: 0, symbolInstanceEnd: R.symbolInstances.length, parameters: A });
          }
        }, bt.prototype.attemptAnchorPlacement = function(g, v, _, w, R, D, k, H, J, oe, Ce, Se, Oe, He, ze) {
          var h, f = [Se.textOffset0, Se.textOffset1], A = ke(g, _, w, f, R), b = this.collisionIndex.placeCollisionBox(Ke(v, A.x, A.y, D, k, this.transform.angle), Ce, H, J, oe.predicate);
          if (!ze || this.collisionIndex.placeCollisionBox(Ke(ze, A.x, A.y, D, k, this.transform.angle), Ce, H, J, oe.predicate).box.length !== 0) return b.box.length > 0 ? (this.prevPlacement && this.prevPlacement.variableOffsets[Se.crossTileID] && this.prevPlacement.placements[Se.crossTileID] && this.prevPlacement.placements[Se.crossTileID].text && (h = this.prevPlacement.variableOffsets[Se.crossTileID].anchor), this.variableOffsets[Se.crossTileID] = { textOffset: f, width: _, height: w, anchor: g, textBoxScale: R, prevAnchor: h }, this.markUsedJustification(Oe, g, Se, He), Oe.allowVerticalPlacement && (this.markUsedOrientation(Oe, He, Se), this.placedOrientations[Se.crossTileID] = He), { shift: A, placedGlyphBoxes: b }) : void 0;
        }, bt.prototype.placeLayerBucketPart = function(g, v, _) {
          var w = this, R = g.parameters, D = R.bucket, k = R.layout, H = R.posMatrix, J = R.textLabelPlaneMatrix, oe = R.labelToScreenMatrix, Ce = R.textPixelRatio, Se = R.holdingForFade, Oe = R.collisionBoxArray, He = R.partiallyEvaluatedTextSize, ze = R.collisionGroup, h = k.get("text-optional"), f = k.get("icon-optional"), A = k.get("text-allow-overlap"), b = k.get("icon-allow-overlap"), T = k.get("text-rotation-alignment") === "map", C = k.get("text-pitch-alignment") === "map", I = k.get("icon-text-fit") !== "none", B = k.get("symbol-z-order") === "viewport-y", F = A && (b || !D.hasIconData() || f), z = b && (A || !D.hasTextData() || h);
          !D.collisionArrays && Oe && D.deserializeCollisionBoxes(Oe);
          var W = function(We, rt) {
            if (!v[We.crossTileID]) if (Se) w.placements[We.crossTileID] = new Ms(!1, !1, !1);
            else {
              var et, Je = !1, $e = !1, Bt = !0, Ht = null, Ut = { box: null, offscreen: null }, Or = { box: null, offscreen: null }, Cr = null, Gr = null, Sr = 0, ar = 0, jt = 0;
              rt.textFeatureIndex ? Sr = rt.textFeatureIndex : We.useRuntimeCollisionCircles && (Sr = We.featureIndex), rt.verticalTextFeatureIndex && (ar = rt.verticalTextFeatureIndex);
              var Wr = rt.textBox;
              if (Wr) {
                var fn = function(Mn) {
                  var Ro = o.WritingMode.horizontal;
                  if (D.allowVerticalPlacement && !Mn && w.prevPlacement) {
                    var Ks = w.prevPlacement.placedOrientations[We.crossTileID];
                    Ks && (w.placedOrientations[We.crossTileID] = Ks, w.markUsedOrientation(D, Ro = Ks, We));
                  }
                  return Ro;
                }, Zr = function(Mn, Ro) {
                  if (D.allowVerticalPlacement && We.numVerticalGlyphVertices > 0 && rt.verticalTextBox) for (var Ks = 0, Rc = D.writingModes; Ks < Rc.length && (Rc[Ks] === o.WritingMode.vertical ? (Ut = Ro(), Or = Ut) : Ut = Mn(), !(Ut && Ut.box && Ut.box.length)); Ks += 1) ;
                  else Ut = Mn();
                };
                if (k.get("text-variable-anchor")) {
                  var _n = k.get("text-variable-anchor");
                  if (w.prevPlacement && w.prevPlacement.variableOffsets[We.crossTileID]) {
                    var si = w.prevPlacement.variableOffsets[We.crossTileID];
                    _n.indexOf(si.anchor) > 0 && (_n = _n.filter((function(Mn) {
                      return Mn !== si.anchor;
                    }))).unshift(si.anchor);
                  }
                  var Ys = function(Mn, Ro, Ks) {
                    for (var Rc = Mn.x2 - Mn.x1, Ry = Mn.y2 - Mn.y1, jh = We.textBoxScale, By = I && !b ? Ro : null, Cf = { box: [], offscreen: !1 }, B0 = A ? 2 * _n.length : _n.length, Iu = 0; Iu < B0; ++Iu) {
                      var Hh = w.attemptAnchorPlacement(_n[Iu % _n.length], Mn, Rc, Ry, jh, T, C, Ce, H, ze, Iu >= _n.length, We, D, Ks, By);
                      if (Hh && (Cf = Hh.placedGlyphBoxes) && Cf.box && Cf.box.length) {
                        Je = !0, Ht = Hh.shift;
                        break;
                      }
                    }
                    return Cf;
                  };
                  Zr((function() {
                    return Ys(Wr, rt.iconBox, o.WritingMode.horizontal);
                  }), (function() {
                    var Mn = rt.verticalTextBox;
                    return D.allowVerticalPlacement && !(Ut && Ut.box && Ut.box.length) && We.numVerticalGlyphVertices > 0 && Mn ? Ys(Mn, rt.verticalIconBox, o.WritingMode.vertical) : { box: null, offscreen: null };
                  })), Ut && (Je = Ut.box, Bt = Ut.offscreen);
                  var wf = fn(Ut && Ut.box);
                  if (!Je && w.prevPlacement) {
                    var Cu = w.prevPlacement.variableOffsets[We.crossTileID];
                    Cu && (w.variableOffsets[We.crossTileID] = Cu, w.markUsedJustification(D, Cu.anchor, We, wf));
                  }
                } else {
                  var Vl = function(Mn, Ro) {
                    var Ks = w.collisionIndex.placeCollisionBox(Mn, A, Ce, H, ze.predicate);
                    return Ks && Ks.box && Ks.box.length && (w.markUsedOrientation(D, Ro, We), w.placedOrientations[We.crossTileID] = Ro), Ks;
                  };
                  Zr((function() {
                    return Vl(Wr, o.WritingMode.horizontal);
                  }), (function() {
                    var Mn = rt.verticalTextBox;
                    return D.allowVerticalPlacement && We.numVerticalGlyphVertices > 0 && Mn ? Vl(Mn, o.WritingMode.vertical) : { box: null, offscreen: null };
                  })), fn(Ut && Ut.box && Ut.box.length);
                }
              }
              if (Je = (et = Ut) && et.box && et.box.length > 0, Bt = et && et.offscreen, We.useRuntimeCollisionCircles) {
                var Su = D.text.placedSymbolArray.get(We.centerJustifiedTextSymbolIndex), Tf = o.evaluateSizeForFeature(D.textSizeData, He, Su), Ca = k.get("text-padding");
                Cr = w.collisionIndex.placeCollisionCircles(A, Su, D.lineVertexArray, D.glyphOffsetArray, Tf, H, J, oe, _, C, ze.predicate, We.collisionCircleDiameter, Ca), Je = A || Cr.circles.length > 0 && !Cr.collisionDetected, Bt = Bt && Cr.offscreen;
              }
              if (rt.iconFeatureIndex && (jt = rt.iconFeatureIndex), rt.iconBox) {
                var Ef = function(Mn) {
                  var Ro = I && Ht ? Ke(Mn, Ht.x, Ht.y, T, C, w.transform.angle) : Mn;
                  return w.collisionIndex.placeCollisionBox(Ro, b, Ce, H, ze.predicate);
                };
                $e = Or && Or.box && Or.box.length && rt.verticalIconBox ? (Gr = Ef(rt.verticalIconBox)).box.length > 0 : (Gr = Ef(rt.iconBox)).box.length > 0, Bt = Bt && Gr.offscreen;
              }
              var Sa = h || We.numHorizontalGlyphVertices === 0 && We.numVerticalGlyphVertices === 0, Zi = f || We.numIconVertices === 0;
              if (Sa || Zi ? Zi ? Sa || ($e = $e && Je) : Je = $e && Je : $e = Je = $e && Je, Je && et && et.box && w.collisionIndex.insertCollisionBox(et.box, k.get("text-ignore-placement"), D.bucketInstanceId, Or && Or.box && ar ? ar : Sr, ze.ID), $e && Gr && w.collisionIndex.insertCollisionBox(Gr.box, k.get("icon-ignore-placement"), D.bucketInstanceId, jt, ze.ID), Cr && (Je && w.collisionIndex.insertCollisionCircles(Cr.circles, k.get("text-ignore-placement"), D.bucketInstanceId, Sr, ze.ID), _)) {
                var Ja = D.bucketInstanceId, jl = w.collisionCircleArrays[Ja];
                jl === void 0 && (jl = w.collisionCircleArrays[Ja] = new On());
                for (var Mc = 0; Mc < Cr.circles.length; Mc += 4) jl.circles.push(Cr.circles[Mc + 0]), jl.circles.push(Cr.circles[Mc + 1]), jl.circles.push(Cr.circles[Mc + 2]), jl.circles.push(Cr.collisionDetected ? 1 : 0);
              }
              w.placements[We.crossTileID] = new Ms(Je || F, $e || z, Bt || D.justReloaded), v[We.crossTileID] = !0;
            }
          };
          if (B) for (var ue = D.getSortedSymbolIndexes(this.transform.angle), Ie = ue.length - 1; Ie >= 0; --Ie) {
            var Re = ue[Ie];
            W(D.symbolInstances.get(Re), D.collisionArrays[Re]);
          }
          else for (var Be = g.symbolInstanceStart; Be < g.symbolInstanceEnd; Be++) W(D.symbolInstances.get(Be), D.collisionArrays[Be]);
          if (_ && D.bucketInstanceId in this.collisionCircleArrays) {
            var Ze = this.collisionCircleArrays[D.bucketInstanceId];
            o.invert(Ze.invProjMatrix, H), Ze.viewportMatrix = this.collisionIndex.getViewportMatrix();
          }
          D.justReloaded = !1;
        }, bt.prototype.markUsedJustification = function(g, v, _, w) {
          var R;
          R = w === o.WritingMode.vertical ? _.verticalPlacedTextSymbolIndex : { left: _.leftJustifiedTextSymbolIndex, center: _.centerJustifiedTextSymbolIndex, right: _.rightJustifiedTextSymbolIndex }[o.getAnchorJustification(v)];
          for (var D = 0, k = [_.leftJustifiedTextSymbolIndex, _.centerJustifiedTextSymbolIndex, _.rightJustifiedTextSymbolIndex, _.verticalPlacedTextSymbolIndex]; D < k.length; D += 1) {
            var H = k[D];
            H >= 0 && (g.text.placedSymbolArray.get(H).crossTileID = R >= 0 && H !== R ? 0 : _.crossTileID);
          }
        }, bt.prototype.markUsedOrientation = function(g, v, _) {
          for (var w = v === o.WritingMode.horizontal || v === o.WritingMode.horizontalOnly ? v : 0, R = v === o.WritingMode.vertical ? v : 0, D = 0, k = [_.leftJustifiedTextSymbolIndex, _.centerJustifiedTextSymbolIndex, _.rightJustifiedTextSymbolIndex]; D < k.length; D += 1) g.text.placedSymbolArray.get(k[D]).placedOrientation = w;
          _.verticalPlacedTextSymbolIndex && (g.text.placedSymbolArray.get(_.verticalPlacedTextSymbolIndex).placedOrientation = R);
        }, bt.prototype.commit = function(g) {
          this.commitTime = g, this.zoomAtLastRecencyCheck = this.transform.zoom;
          var v = this.prevPlacement, _ = !1;
          this.prevZoomAdjustment = v ? v.zoomAdjustment(this.transform.zoom) : 0;
          var w = v ? v.symbolFadeChange(g) : 1, R = v ? v.opacities : {}, D = v ? v.variableOffsets : {}, k = v ? v.placedOrientations : {};
          for (var H in this.placements) {
            var J = this.placements[H], oe = R[H];
            oe ? (this.opacities[H] = new $i(oe, w, J.text, J.icon), _ = _ || J.text !== oe.text.placed || J.icon !== oe.icon.placed) : (this.opacities[H] = new $i(null, w, J.text, J.icon, J.skipFade), _ = _ || J.text || J.icon);
          }
          for (var Ce in R) {
            var Se = R[Ce];
            if (!this.opacities[Ce]) {
              var Oe = new $i(Se, w, !1, !1);
              Oe.isHidden() || (this.opacities[Ce] = Oe, _ = _ || Se.text.placed || Se.icon.placed);
            }
          }
          for (var He in D) this.variableOffsets[He] || !this.opacities[He] || this.opacities[He].isHidden() || (this.variableOffsets[He] = D[He]);
          for (var ze in k) this.placedOrientations[ze] || !this.opacities[ze] || this.opacities[ze].isHidden() || (this.placedOrientations[ze] = k[ze]);
          _ ? this.lastPlacementChangeTime = g : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = v ? v.lastPlacementChangeTime : g);
        }, bt.prototype.updateLayerOpacities = function(g, v) {
          for (var _ = {}, w = 0, R = v; w < R.length; w += 1) {
            var D = R[w], k = D.getBucket(g);
            k && D.latestFeatureIndex && g.id === k.layerIds[0] && this.updateBucketOpacities(k, _, D.collisionBoxArray);
          }
        }, bt.prototype.updateBucketOpacities = function(g, v, _) {
          var w = this;
          g.hasTextData() && g.text.opacityVertexArray.clear(), g.hasIconData() && g.icon.opacityVertexArray.clear(), g.hasIconCollisionBoxData() && g.iconCollisionBox.collisionVertexArray.clear(), g.hasTextCollisionBoxData() && g.textCollisionBox.collisionVertexArray.clear();
          var R = g.layers[0].layout, D = new $i(null, 0, !1, !1, !0), k = R.get("text-allow-overlap"), H = R.get("icon-allow-overlap"), J = R.get("text-variable-anchor"), oe = R.get("text-rotation-alignment") === "map", Ce = R.get("text-pitch-alignment") === "map", Se = R.get("icon-text-fit") !== "none", Oe = new $i(null, 0, k && (H || !g.hasIconData() || R.get("icon-optional")), H && (k || !g.hasTextData() || R.get("text-optional")), !0);
          !g.collisionArrays && _ && (g.hasIconCollisionBoxData() || g.hasTextCollisionBoxData()) && g.deserializeCollisionBoxes(_);
          for (var He = function(A, b, T) {
            for (var C = 0; C < b / 4; C++) A.opacityVertexArray.emplaceBack(T);
          }, ze = function(A) {
            var b = g.symbolInstances.get(A), T = b.numHorizontalGlyphVertices, C = b.numVerticalGlyphVertices, I = b.crossTileID, B = w.opacities[I];
            v[I] ? B = D : B || (w.opacities[I] = B = Oe), v[I] = !0;
            var F = b.numIconVertices > 0, z = w.placedOrientations[b.crossTileID], W = z === o.WritingMode.vertical, ue = z === o.WritingMode.horizontal || z === o.WritingMode.horizontalOnly;
            if (T > 0 || C > 0) {
              var Ie = Th(B.text);
              He(g.text, T, W ? Tl : Ie), He(g.text, C, ue ? Tl : Ie);
              var Re = B.text.isHidden();
              [b.rightJustifiedTextSymbolIndex, b.centerJustifiedTextSymbolIndex, b.leftJustifiedTextSymbolIndex].forEach((function(Ut) {
                Ut >= 0 && (g.text.placedSymbolArray.get(Ut).hidden = Re || W ? 1 : 0);
              })), b.verticalPlacedTextSymbolIndex >= 0 && (g.text.placedSymbolArray.get(b.verticalPlacedTextSymbolIndex).hidden = Re || ue ? 1 : 0);
              var Be = w.variableOffsets[b.crossTileID];
              Be && w.markUsedJustification(g, Be.anchor, b, z);
              var Ze = w.placedOrientations[b.crossTileID];
              Ze && (w.markUsedJustification(g, "left", b, Ze), w.markUsedOrientation(g, Ze, b));
            }
            if (F) {
              var We = Th(B.icon), rt = !(Se && b.verticalPlacedIconSymbolIndex && W);
              b.placedIconSymbolIndex >= 0 && (He(g.icon, b.numIconVertices, rt ? We : Tl), g.icon.placedSymbolArray.get(b.placedIconSymbolIndex).hidden = B.icon.isHidden()), b.verticalPlacedIconSymbolIndex >= 0 && (He(g.icon, b.numVerticalIconVertices, rt ? Tl : We), g.icon.placedSymbolArray.get(b.verticalPlacedIconSymbolIndex).hidden = B.icon.isHidden());
            }
            if (g.hasIconCollisionBoxData() || g.hasTextCollisionBoxData()) {
              var et = g.collisionArrays[A];
              if (et) {
                var Je = new o.Point(0, 0);
                if (et.textBox || et.verticalTextBox) {
                  var $e = !0;
                  if (J) {
                    var Bt = w.variableOffsets[I];
                    Bt ? (Je = ke(Bt.anchor, Bt.width, Bt.height, Bt.textOffset, Bt.textBoxScale), oe && Je._rotate(Ce ? w.transform.angle : -w.transform.angle)) : $e = !1;
                  }
                  et.textBox && Qt(g.textCollisionBox.collisionVertexArray, B.text.placed, !$e || W, Je.x, Je.y), et.verticalTextBox && Qt(g.textCollisionBox.collisionVertexArray, B.text.placed, !$e || ue, Je.x, Je.y);
                }
                var Ht = !!(!ue && et.verticalIconBox);
                et.iconBox && Qt(g.iconCollisionBox.collisionVertexArray, B.icon.placed, Ht, Se ? Je.x : 0, Se ? Je.y : 0), et.verticalIconBox && Qt(g.iconCollisionBox.collisionVertexArray, B.icon.placed, !Ht, Se ? Je.x : 0, Se ? Je.y : 0);
              }
            }
          }, h = 0; h < g.symbolInstances.length; h++) ze(h);
          if (g.sortFeatures(this.transform.angle), this.retainedQueryData[g.bucketInstanceId] && (this.retainedQueryData[g.bucketInstanceId].featureSortOrder = g.featureSortOrder), g.hasTextData() && g.text.opacityVertexBuffer && g.text.opacityVertexBuffer.updateData(g.text.opacityVertexArray), g.hasIconData() && g.icon.opacityVertexBuffer && g.icon.opacityVertexBuffer.updateData(g.icon.opacityVertexArray), g.hasIconCollisionBoxData() && g.iconCollisionBox.collisionVertexBuffer && g.iconCollisionBox.collisionVertexBuffer.updateData(g.iconCollisionBox.collisionVertexArray), g.hasTextCollisionBoxData() && g.textCollisionBox.collisionVertexBuffer && g.textCollisionBox.collisionVertexBuffer.updateData(g.textCollisionBox.collisionVertexArray), g.bucketInstanceId in this.collisionCircleArrays) {
            var f = this.collisionCircleArrays[g.bucketInstanceId];
            g.placementInvProjMatrix = f.invProjMatrix, g.placementViewportMatrix = f.viewportMatrix, g.collisionCircleArray = f.circles, delete this.collisionCircleArrays[g.bucketInstanceId];
          }
        }, bt.prototype.symbolFadeChange = function(g) {
          return this.fadeDuration === 0 ? 1 : (g - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
        }, bt.prototype.zoomAdjustment = function(g) {
          return Math.max(0, (this.transform.zoom - g) / 1.5);
        }, bt.prototype.hasTransitions = function(g) {
          return this.stale || g - this.lastPlacementChangeTime < this.fadeDuration;
        }, bt.prototype.stillRecent = function(g, v) {
          var _ = this.zoomAtLastRecencyCheck === v ? 1 - this.zoomAdjustment(v) : 1;
          return this.zoomAtLastRecencyCheck = v, this.commitTime + this.fadeDuration * _ > g;
        }, bt.prototype.setStale = function() {
          this.stale = !0;
        };
        var Tr = Math.pow(2, 25), Tn = Math.pow(2, 24), bi = Math.pow(2, 17), mn = Math.pow(2, 16), Di = Math.pow(2, 9), qs = Math.pow(2, 8), wh = Math.pow(2, 1);
        function Th(g) {
          if (g.opacity === 0 && !g.placed) return 0;
          if (g.opacity === 1 && g.placed) return 4294967295;
          var v = g.placed ? 1 : 0, _ = Math.floor(127 * g.opacity);
          return _ * Tr + v * Tn + _ * bi + v * mn + _ * Di + v * qs + _ * wh + v;
        }
        var Tl = 0, au = function(g) {
          this._sortAcrossTiles = g.layout.get("symbol-z-order") !== "viewport-y" && g.layout.get("symbol-sort-key").constantOr(1) !== void 0, this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
        };
        au.prototype.continuePlacement = function(g, v, _, w, R) {
          for (var D = this._bucketParts; this._currentTileIndex < g.length; ) if (v.getBucketParts(D, w, g[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, R()) return !0;
          for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, D.sort((function(k, H) {
            return k.sortKey - H.sortKey;
          }))); this._currentPartIndex < D.length; ) if (v.placeLayerBucketPart(D[this._currentPartIndex], this._seenCrossTileIDs, _), this._currentPartIndex++, R()) return !0;
          return !1;
        };
        var Va = function(g, v, _, w, R, D, k) {
          this.placement = new bt(g, R, D, k), this._currentPlacementIndex = v.length - 1, this._forceFullPlacement = _, this._showCollisionBoxes = w, this._done = !1;
        };
        Va.prototype.isDone = function() {
          return this._done;
        }, Va.prototype.continuePlacement = function(g, v, _) {
          for (var w = this, R = o.browser.now(), D = function() {
            var J = o.browser.now() - R;
            return !w._forceFullPlacement && J > 2;
          }; this._currentPlacementIndex >= 0; ) {
            var k = v[g[this._currentPlacementIndex]], H = this.placement.collisionIndex.transform.zoom;
            if (k.type === "symbol" && (!k.minzoom || k.minzoom <= H) && (!k.maxzoom || k.maxzoom > H)) {
              if (this._inProgressLayer || (this._inProgressLayer = new au(k)), this._inProgressLayer.continuePlacement(_[k.source], this.placement, this._showCollisionBoxes, k, D)) return;
              delete this._inProgressLayer;
            }
            this._currentPlacementIndex--;
          }
          this._done = !0;
        }, Va.prototype.commit = function(g) {
          return this.placement.commit(g), this.placement;
        };
        var lu = 512 / o.EXTENT / 2, cu = function(g, v, _) {
          this.tileID = g, this.indexedSymbolInstances = {}, this.bucketInstanceId = _;
          for (var w = 0; w < v.length; w++) {
            var R = v.get(w), D = R.key;
            this.indexedSymbolInstances[D] || (this.indexedSymbolInstances[D] = []), this.indexedSymbolInstances[D].push({ crossTileID: R.crossTileID, coord: this.getScaledCoordinates(R, g) });
          }
        };
        cu.prototype.getScaledCoordinates = function(g, v) {
          var _ = lu / Math.pow(2, v.canonical.z - this.tileID.canonical.z);
          return { x: Math.floor((v.canonical.x * o.EXTENT + g.anchorX) * _), y: Math.floor((v.canonical.y * o.EXTENT + g.anchorY) * _) };
        }, cu.prototype.findMatches = function(g, v, _) {
          for (var w = this.tileID.canonical.z < v.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - v.canonical.z), R = 0; R < g.length; R++) {
            var D = g.get(R);
            if (!D.crossTileID) {
              var k = this.indexedSymbolInstances[D.key];
              if (k) for (var H = this.getScaledCoordinates(D, v), J = 0, oe = k; J < oe.length; J += 1) {
                var Ce = oe[J];
                if (Math.abs(Ce.coord.x - H.x) <= w && Math.abs(Ce.coord.y - H.y) <= w && !_[Ce.crossTileID]) {
                  _[Ce.crossTileID] = !0, D.crossTileID = Ce.crossTileID;
                  break;
                }
              }
            }
          }
        };
        var oo = function() {
          this.maxCrossTileID = 0;
        };
        oo.prototype.generate = function() {
          return ++this.maxCrossTileID;
        };
        var _a = function() {
          this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
        };
        _a.prototype.handleWrapJump = function(g) {
          var v = Math.round((g - this.lng) / 360);
          if (v !== 0) for (var _ in this.indexes) {
            var w = this.indexes[_], R = {};
            for (var D in w) {
              var k = w[D];
              k.tileID = k.tileID.unwrapTo(k.tileID.wrap + v), R[k.tileID.key] = k;
            }
            this.indexes[_] = R;
          }
          this.lng = g;
        }, _a.prototype.addBucket = function(g, v, _) {
          if (this.indexes[g.overscaledZ] && this.indexes[g.overscaledZ][g.key]) {
            if (this.indexes[g.overscaledZ][g.key].bucketInstanceId === v.bucketInstanceId) return !1;
            this.removeBucketCrossTileIDs(g.overscaledZ, this.indexes[g.overscaledZ][g.key]);
          }
          for (var w = 0; w < v.symbolInstances.length; w++) v.symbolInstances.get(w).crossTileID = 0;
          this.usedCrossTileIDs[g.overscaledZ] || (this.usedCrossTileIDs[g.overscaledZ] = {});
          var R = this.usedCrossTileIDs[g.overscaledZ];
          for (var D in this.indexes) {
            var k = this.indexes[D];
            if (Number(D) > g.overscaledZ) for (var H in k) {
              var J = k[H];
              J.tileID.isChildOf(g) && J.findMatches(v.symbolInstances, g, R);
            }
            else {
              var oe = k[g.scaledTo(Number(D)).key];
              oe && oe.findMatches(v.symbolInstances, g, R);
            }
          }
          for (var Ce = 0; Ce < v.symbolInstances.length; Ce++) {
            var Se = v.symbolInstances.get(Ce);
            Se.crossTileID || (Se.crossTileID = _.generate(), R[Se.crossTileID] = !0);
          }
          return this.indexes[g.overscaledZ] === void 0 && (this.indexes[g.overscaledZ] = {}), this.indexes[g.overscaledZ][g.key] = new cu(g, v.symbolInstances, v.bucketInstanceId), !0;
        }, _a.prototype.removeBucketCrossTileIDs = function(g, v) {
          for (var _ in v.indexedSymbolInstances) for (var w = 0, R = v.indexedSymbolInstances[_]; w < R.length; w += 1) delete this.usedCrossTileIDs[g][R[w].crossTileID];
        }, _a.prototype.removeStaleBuckets = function(g) {
          var v = !1;
          for (var _ in this.indexes) {
            var w = this.indexes[_];
            for (var R in w) g[w[R].bucketInstanceId] || (this.removeBucketCrossTileIDs(_, w[R]), delete w[R], v = !0);
          }
          return v;
        };
        var Jo = function() {
          this.layerIndexes = {}, this.crossTileIDs = new oo(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
        };
        Jo.prototype.addLayer = function(g, v, _) {
          var w = this.layerIndexes[g.id];
          w === void 0 && (w = this.layerIndexes[g.id] = new _a());
          var R = !1, D = {};
          w.handleWrapJump(_);
          for (var k = 0, H = v; k < H.length; k += 1) {
            var J = H[k], oe = J.getBucket(g);
            oe && g.id === oe.layerIds[0] && (oe.bucketInstanceId || (oe.bucketInstanceId = ++this.maxBucketInstanceId), w.addBucket(J.tileID, oe, this.crossTileIDs) && (R = !0), D[oe.bucketInstanceId] = !0);
          }
          return w.removeStaleBuckets(D) && (R = !0), R;
        }, Jo.prototype.pruneUnusedLayers = function(g) {
          var v = {};
          for (var _ in g.forEach((function(w) {
            v[w] = !0;
          })), this.layerIndexes) v[_] || delete this.layerIndexes[_];
        };
        var ja = function(g, v) {
          return o.emitValidationErrors(g, v && v.filter((function(_) {
            return _.identifier !== "source.canvas";
          })));
        }, No = o.pick(Yt, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData"]), Uo = o.pick(Yt, ["setCenter", "setZoom", "setBearing", "setPitch"]), uu = (function() {
          var g = {}, v = o.styleSpec.$version;
          for (var _ in o.styleSpec.$root) {
            var w, R = o.styleSpec.$root[_];
            R.required && (w = _ === "version" ? v : R.type === "array" ? [] : {}) != null && (g[_] = w);
          }
          return g;
        })(), _s = (function(g) {
          function v(_, w) {
            var R = this;
            w === void 0 && (w = {}), g.call(this), this.map = _, this.dispatcher = new Me(_t(), this), this.imageManager = new K(), this.imageManager.setEventedParent(this), this.glyphManager = new fe(_._requestManager, w.localIdeographFontFamily), this.lineAtlas = new re(256, 512), this.crossTileSymbolIndex = new Jo(), this._layers = {}, this._serializedLayers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new o.ZoomHistory(), this._loaded = !1, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("setReferrer", o.getReferrer());
            var D = this;
            this._rtlTextPluginCallback = v.registerForPluginStateChange((function(k) {
              D.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: k.pluginStatus, pluginURL: k.pluginURL }, (function(H, J) {
                if (o.triggerPluginCompletionEvent(H), J && J.every((function(Ce) {
                  return Ce;
                }))) for (var oe in D.sourceCaches) D.sourceCaches[oe].reload();
              }));
            })), this.on("data", (function(k) {
              if (k.dataType === "source" && k.sourceDataType === "metadata") {
                var H = R.sourceCaches[k.sourceId];
                if (H) {
                  var J = H.getSource();
                  if (J && J.vectorLayerIds) for (var oe in R._layers) {
                    var Ce = R._layers[oe];
                    Ce.source === J.id && R._validateLayer(Ce);
                  }
                }
              }
            }));
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.loadURL = function(_, w) {
            var R = this;
            w === void 0 && (w = {}), this.fire(new o.Event("dataloading", { dataType: "style" }));
            var D = typeof w.validate == "boolean" ? w.validate : !o.isMapboxURL(_);
            _ = this.map._requestManager.normalizeStyleURL(_, w.accessToken);
            var k = this.map._requestManager.transformRequest(_, o.ResourceType.Style);
            this._request = o.getJSON(k, (function(H, J) {
              R._request = null, H ? R.fire(new o.ErrorEvent(H)) : J && R._load(J, D);
            }));
          }, v.prototype.loadJSON = function(_, w) {
            var R = this;
            w === void 0 && (w = {}), this.fire(new o.Event("dataloading", { dataType: "style" })), this._request = o.browser.frame((function() {
              R._request = null, R._load(_, w.validate !== !1);
            }));
          }, v.prototype.loadEmpty = function() {
            this.fire(new o.Event("dataloading", { dataType: "style" })), this._load(uu, !1);
          }, v.prototype._load = function(_, w) {
            if (!w || !ja(this, o.validateStyle(_))) {
              for (var R in this._loaded = !0, this.stylesheet = _, _.sources) this.addSource(R, _.sources[R], { validate: !1 });
              _.sprite ? this._loadSprite(_.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(_.glyphs);
              var D = Lt(this.stylesheet.layers);
              this._order = D.map((function(oe) {
                return oe.id;
              })), this._layers = {}, this._serializedLayers = {};
              for (var k = 0, H = D; k < H.length; k += 1) {
                var J = H[k];
                (J = o.createStyleLayer(J)).setEventedParent(this, { layer: { id: J.id } }), this._layers[J.id] = J, this._serializedLayers[J.id] = J.serialize();
              }
              this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new X(this.stylesheet.light), this.fire(new o.Event("data", { dataType: "style" })), this.fire(new o.Event("style.load"));
            }
          }, v.prototype._loadSprite = function(_) {
            var w = this;
            this._spriteRequest = (function(R, D, k) {
              var H, J, oe, Ce = o.browser.devicePixelRatio > 1 ? "@2x" : "", Se = o.getJSON(D.transformRequest(D.normalizeSpriteURL(R, Ce, ".json"), o.ResourceType.SpriteJSON), (function(ze, h) {
                Se = null, oe || (oe = ze, H = h, He());
              })), Oe = o.getImage(D.transformRequest(D.normalizeSpriteURL(R, Ce, ".png"), o.ResourceType.SpriteImage), (function(ze, h) {
                Oe = null, oe || (oe = ze, J = h, He());
              }));
              function He() {
                if (oe) k(oe);
                else if (H && J) {
                  var ze = o.browser.getImageData(J), h = {};
                  for (var f in H) {
                    var A = H[f], b = A.width, T = A.height, C = A.x, I = A.y, B = A.sdf, F = A.pixelRatio, z = A.stretchX, W = A.stretchY, ue = A.content, Ie = new o.RGBAImage({ width: b, height: T });
                    o.RGBAImage.copy(ze, Ie, { x: C, y: I }, { x: 0, y: 0 }, { width: b, height: T }), h[f] = { data: Ie, pixelRatio: F, sdf: B, stretchX: z, stretchY: W, content: ue };
                  }
                  k(null, h);
                }
              }
              return { cancel: function() {
                Se && (Se.cancel(), Se = null), Oe && (Oe.cancel(), Oe = null);
              } };
            })(_, this.map._requestManager, (function(R, D) {
              if (w._spriteRequest = null, R) w.fire(new o.ErrorEvent(R));
              else if (D) for (var k in D) w.imageManager.addImage(k, D[k]);
              w.imageManager.setLoaded(!0), w._availableImages = w.imageManager.listImages(), w.dispatcher.broadcast("setImages", w._availableImages), w.fire(new o.Event("data", { dataType: "style" }));
            }));
          }, v.prototype._validateLayer = function(_) {
            var w = this.sourceCaches[_.source];
            if (w) {
              var R = _.sourceLayer;
              if (R) {
                var D = w.getSource();
                (D.type === "geojson" || D.vectorLayerIds && D.vectorLayerIds.indexOf(R) === -1) && this.fire(new o.ErrorEvent(new Error('Source layer "' + R + '" does not exist on source "' + D.id + '" as specified by style layer "' + _.id + '"')));
              }
            }
          }, v.prototype.loaded = function() {
            if (!this._loaded || Object.keys(this._updatedSources).length) return !1;
            for (var _ in this.sourceCaches) if (!this.sourceCaches[_].loaded()) return !1;
            return !!this.imageManager.isLoaded();
          }, v.prototype._serializeLayers = function(_) {
            for (var w = [], R = 0, D = _; R < D.length; R += 1) {
              var k = this._layers[D[R]];
              k.type !== "custom" && w.push(k.serialize());
            }
            return w;
          }, v.prototype.hasTransitions = function() {
            if (this.light && this.light.hasTransition()) return !0;
            for (var _ in this.sourceCaches) if (this.sourceCaches[_].hasTransition()) return !0;
            for (var w in this._layers) if (this._layers[w].hasTransition()) return !0;
            return !1;
          }, v.prototype._checkLoaded = function() {
            if (!this._loaded) throw new Error("Style is not done loading");
          }, v.prototype.update = function(_) {
            if (this._loaded) {
              var w = this._changed;
              if (this._changed) {
                var R = Object.keys(this._updatedLayers), D = Object.keys(this._removedLayers);
                for (var k in (R.length || D.length) && this._updateWorkerLayers(R, D), this._updatedSources) {
                  var H = this._updatedSources[k];
                  H === "reload" ? this._reloadSource(k) : H === "clear" && this._clearSource(k);
                }
                for (var J in this._updateTilesForChangedImages(), this._updatedPaintProps) this._layers[J].updateTransitions(_);
                this.light.updateTransitions(_), this._resetUpdates();
              }
              var oe = {};
              for (var Ce in this.sourceCaches) {
                var Se = this.sourceCaches[Ce];
                oe[Ce] = Se.used, Se.used = !1;
              }
              for (var Oe = 0, He = this._order; Oe < He.length; Oe += 1) {
                var ze = this._layers[He[Oe]];
                ze.recalculate(_, this._availableImages), !ze.isHidden(_.zoom) && ze.source && (this.sourceCaches[ze.source].used = !0);
              }
              for (var h in oe) {
                var f = this.sourceCaches[h];
                oe[h] !== f.used && f.fire(new o.Event("data", { sourceDataType: "visibility", dataType: "source", sourceId: h }));
              }
              this.light.recalculate(_), this.z = _.zoom, w && this.fire(new o.Event("data", { dataType: "style" }));
            }
          }, v.prototype._updateTilesForChangedImages = function() {
            var _ = Object.keys(this._changedImages);
            if (_.length) {
              for (var w in this.sourceCaches) this.sourceCaches[w].reloadTilesForDependencies(["icons", "patterns"], _);
              this._changedImages = {};
            }
          }, v.prototype._updateWorkerLayers = function(_, w) {
            this.dispatcher.broadcast("updateLayers", { layers: this._serializeLayers(_), removedIds: w });
          }, v.prototype._resetUpdates = function() {
            this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {};
          }, v.prototype.setState = function(_) {
            var w = this;
            if (this._checkLoaded(), ja(this, o.validateStyle(_))) return !1;
            (_ = o.clone$1(_)).layers = Lt(_.layers);
            var R = (function(k, H) {
              if (!k) return [{ command: Yt.setStyle, args: [H] }];
              var J = [];
              try {
                if (!o.deepEqual(k.version, H.version)) return [{ command: Yt.setStyle, args: [H] }];
                o.deepEqual(k.center, H.center) || J.push({ command: Yt.setCenter, args: [H.center] }), o.deepEqual(k.zoom, H.zoom) || J.push({ command: Yt.setZoom, args: [H.zoom] }), o.deepEqual(k.bearing, H.bearing) || J.push({ command: Yt.setBearing, args: [H.bearing] }), o.deepEqual(k.pitch, H.pitch) || J.push({ command: Yt.setPitch, args: [H.pitch] }), o.deepEqual(k.sprite, H.sprite) || J.push({ command: Yt.setSprite, args: [H.sprite] }), o.deepEqual(k.glyphs, H.glyphs) || J.push({ command: Yt.setGlyphs, args: [H.glyphs] }), o.deepEqual(k.transition, H.transition) || J.push({ command: Yt.setTransition, args: [H.transition] }), o.deepEqual(k.light, H.light) || J.push({ command: Yt.setLight, args: [H.light] });
                var oe = {}, Ce = [];
                (function(Oe, He, ze, h) {
                  var f;
                  for (f in He = He || {}, Oe = Oe || {}) Oe.hasOwnProperty(f) && (He.hasOwnProperty(f) || ir(f, ze, h));
                  for (f in He) He.hasOwnProperty(f) && (Oe.hasOwnProperty(f) ? o.deepEqual(Oe[f], He[f]) || (Oe[f].type === "geojson" && He[f].type === "geojson" && un(Oe, He, f) ? ze.push({ command: Yt.setGeoJSONSourceData, args: [f, He[f].data] }) : nn(f, He, ze, h)) : Hr(f, He, ze));
                })(k.sources, H.sources, Ce, oe);
                var Se = [];
                k.layers && k.layers.forEach((function(Oe) {
                  oe[Oe.source] ? J.push({ command: Yt.removeLayer, args: [Oe.id] }) : Se.push(Oe);
                })), J = J.concat(Ce), (function(Oe, He, ze) {
                  He = He || [];
                  var h, f, A, b, T, C, I, B = (Oe = Oe || []).map(Qr), F = He.map(Qr), z = Oe.reduce($r, {}), W = He.reduce($r, {}), ue = B.slice(), Ie = /* @__PURE__ */ Object.create(null);
                  for (h = 0, f = 0; h < B.length; h++) W.hasOwnProperty(A = B[h]) ? f++ : (ze.push({ command: Yt.removeLayer, args: [A] }), ue.splice(ue.indexOf(A, f), 1));
                  for (h = 0, f = 0; h < F.length; h++) ue[ue.length - 1 - h] !== (A = F[F.length - 1 - h]) && (z.hasOwnProperty(A) ? (ze.push({ command: Yt.removeLayer, args: [A] }), ue.splice(ue.lastIndexOf(A, ue.length - f), 1)) : f++, ze.push({ command: Yt.addLayer, args: [W[A], C = ue[ue.length - h]] }), ue.splice(ue.length - h, 0, A), Ie[A] = !0);
                  for (h = 0; h < F.length; h++) if (b = z[A = F[h]], T = W[A], !Ie[A] && !o.deepEqual(b, T)) if (o.deepEqual(b.source, T.source) && o.deepEqual(b["source-layer"], T["source-layer"]) && o.deepEqual(b.type, T.type)) {
                    for (I in Yr(b.layout, T.layout, ze, A, null, Yt.setLayoutProperty), Yr(b.paint, T.paint, ze, A, null, Yt.setPaintProperty), o.deepEqual(b.filter, T.filter) || ze.push({ command: Yt.setFilter, args: [A, T.filter] }), o.deepEqual(b.minzoom, T.minzoom) && o.deepEqual(b.maxzoom, T.maxzoom) || ze.push({ command: Yt.setLayerZoomRange, args: [A, T.minzoom, T.maxzoom] }), b) b.hasOwnProperty(I) && I !== "layout" && I !== "paint" && I !== "filter" && I !== "metadata" && I !== "minzoom" && I !== "maxzoom" && (I.indexOf("paint.") === 0 ? Yr(b[I], T[I], ze, A, I.slice(6), Yt.setPaintProperty) : o.deepEqual(b[I], T[I]) || ze.push({ command: Yt.setLayerProperty, args: [A, I, T[I]] }));
                    for (I in T) T.hasOwnProperty(I) && !b.hasOwnProperty(I) && I !== "layout" && I !== "paint" && I !== "filter" && I !== "metadata" && I !== "minzoom" && I !== "maxzoom" && (I.indexOf("paint.") === 0 ? Yr(b[I], T[I], ze, A, I.slice(6), Yt.setPaintProperty) : o.deepEqual(b[I], T[I]) || ze.push({ command: Yt.setLayerProperty, args: [A, I, T[I]] }));
                  } else ze.push({ command: Yt.removeLayer, args: [A] }), C = ue[ue.lastIndexOf(A) + 1], ze.push({ command: Yt.addLayer, args: [T, C] });
                })(Se, H.layers, J);
              } catch (Oe) {
                console.warn("Unable to compute style diff:", Oe), J = [{ command: Yt.setStyle, args: [H] }];
              }
              return J;
            })(this.serialize(), _).filter((function(k) {
              return !(k.command in Uo);
            }));
            if (R.length === 0) return !1;
            var D = R.filter((function(k) {
              return !(k.command in No);
            }));
            if (D.length > 0) throw new Error("Unimplemented: " + D.map((function(k) {
              return k.command;
            })).join(", ") + ".");
            return R.forEach((function(k) {
              k.command !== "setTransition" && w[k.command].apply(w, k.args);
            })), this.stylesheet = _, !0;
          }, v.prototype.addImage = function(_, w) {
            if (this.getImage(_)) return this.fire(new o.ErrorEvent(new Error("An image with this name already exists.")));
            this.imageManager.addImage(_, w), this._afterImageUpdated(_);
          }, v.prototype.updateImage = function(_, w) {
            this.imageManager.updateImage(_, w);
          }, v.prototype.getImage = function(_) {
            return this.imageManager.getImage(_);
          }, v.prototype.removeImage = function(_) {
            if (!this.getImage(_)) return this.fire(new o.ErrorEvent(new Error("No image with this name exists.")));
            this.imageManager.removeImage(_), this._afterImageUpdated(_);
          }, v.prototype._afterImageUpdated = function(_) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[_] = !0, this._changed = !0, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new o.Event("data", { dataType: "style" }));
          }, v.prototype.listImages = function() {
            return this._checkLoaded(), this.imageManager.listImages();
          }, v.prototype.addSource = function(_, w, R) {
            var D = this;
            if (R === void 0 && (R = {}), this._checkLoaded(), this.sourceCaches[_] !== void 0) throw new Error("There is already a source with this ID");
            if (!w.type) throw new Error("The type property must be defined, but only the following properties were given: " + Object.keys(w).join(", ") + ".");
            if (!(["vector", "raster", "geojson", "video", "image"].indexOf(w.type) >= 0 && this._validate(o.validateStyle.source, "sources." + _, w, null, R))) {
              this.map && this.map._collectResourceTiming && (w.collectResourceTiming = !0);
              var k = this.sourceCaches[_] = new ge(_, w, this.dispatcher);
              k.style = this, k.setEventedParent(this, (function() {
                return { isSourceLoaded: D.loaded(), source: k.serialize(), sourceId: _ };
              })), k.onAdd(this.map), this._changed = !0;
            }
          }, v.prototype.removeSource = function(_) {
            if (this._checkLoaded(), this.sourceCaches[_] === void 0) throw new Error("There is no source with this ID");
            for (var w in this._layers) if (this._layers[w].source === _) return this.fire(new o.ErrorEvent(new Error('Source "' + _ + '" cannot be removed while layer "' + w + '" is using it.')));
            var R = this.sourceCaches[_];
            delete this.sourceCaches[_], delete this._updatedSources[_], R.fire(new o.Event("data", { sourceDataType: "metadata", dataType: "source", sourceId: _ })), R.setEventedParent(null), R.clearTiles(), R.onRemove && R.onRemove(this.map), this._changed = !0;
          }, v.prototype.setGeoJSONSourceData = function(_, w) {
            this._checkLoaded(), this.sourceCaches[_].getSource().setData(w), this._changed = !0;
          }, v.prototype.getSource = function(_) {
            return this.sourceCaches[_] && this.sourceCaches[_].getSource();
          }, v.prototype.addLayer = function(_, w, R) {
            R === void 0 && (R = {}), this._checkLoaded();
            var D = _.id;
            if (this.getLayer(D)) this.fire(new o.ErrorEvent(new Error('Layer with id "' + D + '" already exists on this map')));
            else {
              var k;
              if (_.type === "custom") {
                if (ja(this, o.validateCustomStyleLayer(_))) return;
                k = o.createStyleLayer(_);
              } else {
                if (typeof _.source == "object" && (this.addSource(D, _.source), _ = o.clone$1(_), _ = o.extend(_, { source: D })), this._validate(o.validateStyle.layer, "layers." + D, _, { arrayIndex: -1 }, R)) return;
                k = o.createStyleLayer(_), this._validateLayer(k), k.setEventedParent(this, { layer: { id: D } }), this._serializedLayers[k.id] = k.serialize();
              }
              var H = w ? this._order.indexOf(w) : this._order.length;
              if (w && H === -1) this.fire(new o.ErrorEvent(new Error('Layer with id "' + w + '" does not exist on this map.')));
              else {
                if (this._order.splice(H, 0, D), this._layerOrderChanged = !0, this._layers[D] = k, this._removedLayers[D] && k.source && k.type !== "custom") {
                  var J = this._removedLayers[D];
                  delete this._removedLayers[D], J.type !== k.type ? this._updatedSources[k.source] = "clear" : (this._updatedSources[k.source] = "reload", this.sourceCaches[k.source].pause());
                }
                this._updateLayer(k), k.onAdd && k.onAdd(this.map);
              }
            }
          }, v.prototype.moveLayer = function(_, w) {
            if (this._checkLoaded(), this._changed = !0, this._layers[_]) {
              if (_ !== w) {
                var R = this._order.indexOf(_);
                this._order.splice(R, 1);
                var D = w ? this._order.indexOf(w) : this._order.length;
                w && D === -1 ? this.fire(new o.ErrorEvent(new Error('Layer with id "' + w + '" does not exist on this map.'))) : (this._order.splice(D, 0, _), this._layerOrderChanged = !0);
              }
            } else this.fire(new o.ErrorEvent(new Error("The layer '" + _ + "' does not exist in the map's style and cannot be moved.")));
          }, v.prototype.removeLayer = function(_) {
            this._checkLoaded();
            var w = this._layers[_];
            if (w) {
              w.setEventedParent(null);
              var R = this._order.indexOf(_);
              this._order.splice(R, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[_] = w, delete this._layers[_], delete this._serializedLayers[_], delete this._updatedLayers[_], delete this._updatedPaintProps[_], w.onRemove && w.onRemove(this.map);
            } else this.fire(new o.ErrorEvent(new Error("The layer '" + _ + "' does not exist in the map's style and cannot be removed.")));
          }, v.prototype.getLayer = function(_) {
            return this._layers[_];
          }, v.prototype.hasLayer = function(_) {
            return _ in this._layers;
          }, v.prototype.setLayerZoomRange = function(_, w, R) {
            this._checkLoaded();
            var D = this.getLayer(_);
            D ? D.minzoom === w && D.maxzoom === R || (w != null && (D.minzoom = w), R != null && (D.maxzoom = R), this._updateLayer(D)) : this.fire(new o.ErrorEvent(new Error("The layer '" + _ + "' does not exist in the map's style and cannot have zoom extent.")));
          }, v.prototype.setFilter = function(_, w, R) {
            R === void 0 && (R = {}), this._checkLoaded();
            var D = this.getLayer(_);
            if (D) {
              if (!o.deepEqual(D.filter, w)) return w == null ? (D.filter = void 0, void this._updateLayer(D)) : void (this._validate(o.validateStyle.filter, "layers." + D.id + ".filter", w, null, R) || (D.filter = o.clone$1(w), this._updateLayer(D)));
            } else this.fire(new o.ErrorEvent(new Error("The layer '" + _ + "' does not exist in the map's style and cannot be filtered.")));
          }, v.prototype.getFilter = function(_) {
            return o.clone$1(this.getLayer(_).filter);
          }, v.prototype.setLayoutProperty = function(_, w, R, D) {
            D === void 0 && (D = {}), this._checkLoaded();
            var k = this.getLayer(_);
            k ? o.deepEqual(k.getLayoutProperty(w), R) || (k.setLayoutProperty(w, R, D), this._updateLayer(k)) : this.fire(new o.ErrorEvent(new Error("The layer '" + _ + "' does not exist in the map's style and cannot be styled.")));
          }, v.prototype.getLayoutProperty = function(_, w) {
            var R = this.getLayer(_);
            if (R) return R.getLayoutProperty(w);
            this.fire(new o.ErrorEvent(new Error("The layer '" + _ + "' does not exist in the map's style.")));
          }, v.prototype.setPaintProperty = function(_, w, R, D) {
            D === void 0 && (D = {}), this._checkLoaded();
            var k = this.getLayer(_);
            k ? o.deepEqual(k.getPaintProperty(w), R) || (k.setPaintProperty(w, R, D) && this._updateLayer(k), this._changed = !0, this._updatedPaintProps[_] = !0) : this.fire(new o.ErrorEvent(new Error("The layer '" + _ + "' does not exist in the map's style and cannot be styled.")));
          }, v.prototype.getPaintProperty = function(_, w) {
            return this.getLayer(_).getPaintProperty(w);
          }, v.prototype.setFeatureState = function(_, w) {
            this._checkLoaded();
            var R = _.source, D = _.sourceLayer, k = this.sourceCaches[R];
            if (k !== void 0) {
              var H = k.getSource().type;
              H === "geojson" && D ? this.fire(new o.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : H !== "vector" || D ? (_.id === void 0 && this.fire(new o.ErrorEvent(new Error("The feature id parameter must be provided."))), k.setFeatureState(D, _.id, w)) : this.fire(new o.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
            } else this.fire(new o.ErrorEvent(new Error("The source '" + R + "' does not exist in the map's style.")));
          }, v.prototype.removeFeatureState = function(_, w) {
            this._checkLoaded();
            var R = _.source, D = this.sourceCaches[R];
            if (D !== void 0) {
              var k = D.getSource().type, H = k === "vector" ? _.sourceLayer : void 0;
              k !== "vector" || H ? w && typeof _.id != "string" && typeof _.id != "number" ? this.fire(new o.ErrorEvent(new Error("A feature id is required to remove its specific state property."))) : D.removeFeatureState(H, _.id, w) : this.fire(new o.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
            } else this.fire(new o.ErrorEvent(new Error("The source '" + R + "' does not exist in the map's style.")));
          }, v.prototype.getFeatureState = function(_) {
            this._checkLoaded();
            var w = _.source, R = _.sourceLayer, D = this.sourceCaches[w];
            if (D !== void 0) {
              if (D.getSource().type !== "vector" || R) return _.id === void 0 && this.fire(new o.ErrorEvent(new Error("The feature id parameter must be provided."))), D.getFeatureState(R, _.id);
              this.fire(new o.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
            } else this.fire(new o.ErrorEvent(new Error("The source '" + w + "' does not exist in the map's style.")));
          }, v.prototype.getTransition = function() {
            return o.extend({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
          }, v.prototype.serialize = function() {
            return o.filterObject({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, light: this.stylesheet.light, center: this.stylesheet.center, zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, sources: o.mapObject(this.sourceCaches, (function(_) {
              return _.serialize();
            })), layers: this._serializeLayers(this._order) }, (function(_) {
              return _ !== void 0;
            }));
          }, v.prototype._updateLayer = function(_) {
            this._updatedLayers[_.id] = !0, _.source && !this._updatedSources[_.source] && this.sourceCaches[_.source].getSource().type !== "raster" && (this._updatedSources[_.source] = "reload", this.sourceCaches[_.source].pause()), this._changed = !0;
          }, v.prototype._flattenAndSortRenderedFeatures = function(_) {
            for (var w = this, R = function(z) {
              return w._layers[z].type === "fill-extrusion";
            }, D = {}, k = [], H = this._order.length - 1; H >= 0; H--) {
              var J = this._order[H];
              if (R(J)) {
                D[J] = H;
                for (var oe = 0, Ce = _; oe < Ce.length; oe += 1) {
                  var Se = Ce[oe][J];
                  if (Se) for (var Oe = 0, He = Se; Oe < He.length; Oe += 1) k.push(He[Oe]);
                }
              }
            }
            k.sort((function(z, W) {
              return W.intersectionZ - z.intersectionZ;
            }));
            for (var ze = [], h = this._order.length - 1; h >= 0; h--) {
              var f = this._order[h];
              if (R(f)) for (var A = k.length - 1; A >= 0; A--) {
                var b = k[A].feature;
                if (D[b.layer.id] < h) break;
                ze.push(b), k.pop();
              }
              else for (var T = 0, C = _; T < C.length; T += 1) {
                var I = C[T][f];
                if (I) for (var B = 0, F = I; B < F.length; B += 1) ze.push(F[B].feature);
              }
            }
            return ze;
          }, v.prototype.queryRenderedFeatures = function(_, w, R) {
            w && w.filter && this._validate(o.validateStyle.filter, "queryRenderedFeatures.filter", w.filter, null, w);
            var D = {};
            if (w && w.layers) {
              if (!Array.isArray(w.layers)) return this.fire(new o.ErrorEvent(new Error("parameters.layers must be an Array."))), [];
              for (var k = 0, H = w.layers; k < H.length; k += 1) {
                var J = H[k], oe = this._layers[J];
                if (!oe) return this.fire(new o.ErrorEvent(new Error("The layer '" + J + "' does not exist in the map's style and cannot be queried for features."))), [];
                D[oe.source] = !0;
              }
            }
            var Ce = [];
            for (var Se in w.availableImages = this._availableImages, this.sourceCaches) w.layers && !D[Se] || Ce.push(sr(this.sourceCaches[Se], this._layers, this._serializedLayers, _, w, R));
            return this.placement && Ce.push((function(Oe, He, ze, h, f, A, b) {
              for (var T = {}, C = A.queryRenderedSymbols(h), I = [], B = 0, F = Object.keys(C).map(Number); B < F.length; B += 1) I.push(b[F[B]]);
              I.sort(tr);
              for (var z = function() {
                var Be = ue[W], Ze = Be.featureIndex.lookupSymbolFeatures(C[Be.bucketInstanceId], He, Be.bucketIndex, Be.sourceLayerIndex, f.filter, f.layers, f.availableImages, Oe);
                for (var We in Ze) {
                  var rt = T[We] = T[We] || [], et = Ze[We];
                  et.sort((function(Bt, Ht) {
                    var Ut = Be.featureSortOrder;
                    if (Ut) {
                      var Or = Ut.indexOf(Bt.featureIndex);
                      return Ut.indexOf(Ht.featureIndex) - Or;
                    }
                    return Ht.featureIndex - Bt.featureIndex;
                  }));
                  for (var Je = 0, $e = et; Je < $e.length; Je += 1) rt.push($e[Je]);
                }
              }, W = 0, ue = I; W < ue.length; W += 1) z();
              var Ie = function(Be) {
                T[Be].forEach((function(Ze) {
                  var We = Ze.feature, rt = ze[Oe[Be].source].getFeatureState(We.layer["source-layer"], We.id);
                  We.source = We.layer.source, We.layer["source-layer"] && (We.sourceLayer = We.layer["source-layer"]), We.state = rt;
                }));
              };
              for (var Re in T) Ie(Re);
              return T;
            })(this._layers, this._serializedLayers, this.sourceCaches, _, w, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(Ce);
          }, v.prototype.querySourceFeatures = function(_, w) {
            w && w.filter && this._validate(o.validateStyle.filter, "querySourceFeatures.filter", w.filter, null, w);
            var R = this.sourceCaches[_];
            return R ? (function(D, k) {
              for (var H = D.getRenderableIds().map((function(He) {
                return D.getTileByID(He);
              })), J = [], oe = {}, Ce = 0; Ce < H.length; Ce++) {
                var Se = H[Ce], Oe = Se.tileID.canonical.key;
                oe[Oe] || (oe[Oe] = !0, Se.querySourceFeatures(J, k));
              }
              return J;
            })(R, w) : [];
          }, v.prototype.addSourceType = function(_, w, R) {
            return v.getSourceType(_) ? R(new Error('A source type called "' + _ + '" already exists.')) : (v.setSourceType(_, w), w.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: _, url: w.workerSourceURL }, R) : R(null, null));
          }, v.prototype.getLight = function() {
            return this.light.getLight();
          }, v.prototype.setLight = function(_, w) {
            w === void 0 && (w = {}), this._checkLoaded();
            var R = this.light.getLight(), D = !1;
            for (var k in _) if (!o.deepEqual(_[k], R[k])) {
              D = !0;
              break;
            }
            if (D) {
              var H = { now: o.browser.now(), transition: o.extend({ duration: 300, delay: 0 }, this.stylesheet.transition) };
              this.light.setLight(_, w), this.light.updateTransitions(H);
            }
          }, v.prototype._validate = function(_, w, R, D, k) {
            return k === void 0 && (k = {}), (!k || k.validate !== !1) && ja(this, _.call(o.validateStyle, o.extend({ key: w, style: this.serialize(), value: R, styleSpec: o.styleSpec }, D)));
          }, v.prototype._remove = function() {
            for (var _ in this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), o.evented.off("pluginStateChange", this._rtlTextPluginCallback), this._layers) this._layers[_].setEventedParent(null);
            for (var w in this.sourceCaches) this.sourceCaches[w].clearTiles(), this.sourceCaches[w].setEventedParent(null);
            this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();
          }, v.prototype._clearSource = function(_) {
            this.sourceCaches[_].clearTiles();
          }, v.prototype._reloadSource = function(_) {
            this.sourceCaches[_].resume(), this.sourceCaches[_].reload();
          }, v.prototype._updateSources = function(_) {
            for (var w in this.sourceCaches) this.sourceCaches[w].update(_);
          }, v.prototype._generateCollisionBoxes = function() {
            for (var _ in this.sourceCaches) this._reloadSource(_);
          }, v.prototype._updatePlacement = function(_, w, R, D, k) {
            k === void 0 && (k = !1);
            for (var H = !1, J = !1, oe = {}, Ce = 0, Se = this._order; Ce < Se.length; Ce += 1) {
              var Oe = this._layers[Se[Ce]];
              if (Oe.type === "symbol") {
                if (!oe[Oe.source]) {
                  var He = this.sourceCaches[Oe.source];
                  oe[Oe.source] = He.getRenderableIds(!0).map((function(b) {
                    return He.getTileByID(b);
                  })).sort((function(b, T) {
                    return T.tileID.overscaledZ - b.tileID.overscaledZ || (b.tileID.isLessThan(T.tileID) ? -1 : 1);
                  }));
                }
                var ze = this.crossTileSymbolIndex.addLayer(Oe, oe[Oe.source], _.center.lng);
                H = H || ze;
              }
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((k = k || this._layerOrderChanged || R === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(o.browser.now(), _.zoom)) && (this.pauseablePlacement = new Va(_, this._order, k, w, R, D, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, oe), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(o.browser.now()), J = !0), H && this.pauseablePlacement.placement.setStale()), J || H) for (var h = 0, f = this._order; h < f.length; h += 1) {
              var A = this._layers[f[h]];
              A.type === "symbol" && this.placement.updateLayerOpacities(A, oe[A.source]);
            }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(o.browser.now());
          }, v.prototype._releaseSymbolFadeTiles = function() {
            for (var _ in this.sourceCaches) this.sourceCaches[_].releaseSymbolFadeTiles();
          }, v.prototype.getImages = function(_, w, R) {
            this.imageManager.getImages(w.icons, R), this._updateTilesForChangedImages();
            var D = this.sourceCaches[w.source];
            D && D.setDependencies(w.tileID.key, w.type, w.icons);
          }, v.prototype.getGlyphs = function(_, w, R) {
            this.glyphManager.getGlyphs(w.stacks, R);
          }, v.prototype.getResource = function(_, w, R) {
            return o.makeRequest(w, R);
          }, v;
        })(o.Evented);
        _s.getSourceType = function(g) {
          return dt[g];
        }, _s.setSourceType = function(g, v) {
          dt[g] = v;
        }, _s.registerForPluginStateChange = o.registerForPluginStateChange;
        var gi = o.createLayout([{ name: "a_pos", type: "Int16", components: 2 }]), Ha = Dn(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}`), Eh = Dn(`uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), Hp = Dn(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), Gp = Dn(`varying vec3 v_data;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,0,1);} else {gl_Position=u_matrix*vec4(circle_center,0,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), cf = Dn("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), qi = Dn(`uniform highp float u_intensity;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}`), ea = Dn(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), rs = Dn("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,0.0,1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"), fu = Dn("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), uf = Dn("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,0,1);}"), hu = Dn(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_FragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);}`), Ac = Dn(`varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`), gc = Dn(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`), Ch = Dn(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), Ui = Dn(`varying vec4 v_color;void main() {gl_FragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), El = Dn(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), Rs = Dn(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), ta = Dn(`uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;
#define PI 3.141592653589793
void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"), ya = Dn(`uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}`), zo = Dn(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}`), Bs = Dn(`uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), Os = Dn(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`), va = Dn(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), ra = Dn(`uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0),0.0,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));}`), du = Dn(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), Sh = Dn(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`);
        function Dn(g, v) {
          var _ = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, w = v.match(/attribute ([\w]+) ([\w]+)/g), R = g.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), D = v.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), k = D ? D.concat(R) : R, H = {};
          return { fragmentSource: g = g.replace(_, (function(J, oe, Ce, Se, Oe) {
            return H[Oe] = !0, oe === "define" ? `
#ifndef HAS_UNIFORM_u_` + Oe + `
varying ` + Ce + " " + Se + " " + Oe + `;
#else
uniform ` + Ce + " " + Se + " u_" + Oe + `;
#endif
` : `
#ifdef HAS_UNIFORM_u_` + Oe + `
    ` + Ce + " " + Se + " " + Oe + " = u_" + Oe + `;
#endif
`;
          })), vertexSource: v = v.replace(_, (function(J, oe, Ce, Se, Oe) {
            var He = Se === "float" ? "vec2" : "vec4", ze = Oe.match(/color/) ? "color" : He;
            return H[Oe] ? oe === "define" ? `
#ifndef HAS_UNIFORM_u_` + Oe + `
uniform lowp float u_` + Oe + `_t;
attribute ` + Ce + " " + He + " a_" + Oe + `;
varying ` + Ce + " " + Se + " " + Oe + `;
#else
uniform ` + Ce + " " + Se + " u_" + Oe + `;
#endif
` : ze === "vec4" ? `
#ifndef HAS_UNIFORM_u_` + Oe + `
    ` + Oe + " = a_" + Oe + `;
#else
    ` + Ce + " " + Se + " " + Oe + " = u_" + Oe + `;
#endif
` : `
#ifndef HAS_UNIFORM_u_` + Oe + `
    ` + Oe + " = unpack_mix_" + ze + "(a_" + Oe + ", u_" + Oe + `_t);
#else
    ` + Ce + " " + Se + " " + Oe + " = u_" + Oe + `;
#endif
` : oe === "define" ? `
#ifndef HAS_UNIFORM_u_` + Oe + `
uniform lowp float u_` + Oe + `_t;
attribute ` + Ce + " " + He + " a_" + Oe + `;
#else
uniform ` + Ce + " " + Se + " u_" + Oe + `;
#endif
` : ze === "vec4" ? `
#ifndef HAS_UNIFORM_u_` + Oe + `
    ` + Ce + " " + Se + " " + Oe + " = a_" + Oe + `;
#else
    ` + Ce + " " + Se + " " + Oe + " = u_" + Oe + `;
#endif
` : `
#ifndef HAS_UNIFORM_u_` + Oe + `
    ` + Ce + " " + Se + " " + Oe + " = unpack_mix_" + ze + "(a_" + Oe + ", u_" + Oe + `_t);
#else
    ` + Ce + " " + Se + " " + Oe + " = u_" + Oe + `;
#endif
`;
          })), staticAttributes: w, staticUniforms: k };
        }
        var Ih = Object.freeze({ __proto__: null, prelude: Ha, background: Eh, backgroundPattern: Hp, circle: Gp, clippingMask: cf, heatmap: qi, heatmapTexture: ea, collisionBox: rs, collisionCircle: fu, debug: uf, fill: hu, fillOutline: Ac, fillOutlinePattern: gc, fillPattern: Ch, fillExtrusion: Ui, fillExtrusionPattern: El, hillshadePrepare: Rs, hillshade: ta, line: ya, lineGradient: zo, linePattern: Bs, lineSDF: Os, raster: va, symbolIcon: ra, symbolSDF: du, symbolTextAndIcon: Sh }), pu = function() {
          this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
        };
        function Ph(g) {
          for (var v = [], _ = 0; _ < g.length; _++) if (g[_] !== null) {
            var w = g[_].split(" ");
            v.push(w.pop());
          }
          return v;
        }
        pu.prototype.bind = function(g, v, _, w, R, D, k, H) {
          this.context = g;
          for (var J = this.boundPaintVertexBuffers.length !== w.length, oe = 0; !J && oe < w.length; oe++) this.boundPaintVertexBuffers[oe] !== w[oe] && (J = !0);
          g.extVertexArrayObject && this.vao && this.boundProgram === v && this.boundLayoutVertexBuffer === _ && !J && this.boundIndexBuffer === R && this.boundVertexOffset === D && this.boundDynamicVertexBuffer === k && this.boundDynamicVertexBuffer2 === H ? (g.bindVertexArrayOES.set(this.vao), k && k.bind(), R && R.dynamicDraw && R.bind(), H && H.bind()) : this.freshBind(v, _, w, R, D, k, H);
        }, pu.prototype.freshBind = function(g, v, _, w, R, D, k) {
          var H, J = g.numAttributes, oe = this.context, Ce = oe.gl;
          if (oe.extVertexArrayObject) this.vao && this.destroy(), this.vao = oe.extVertexArrayObject.createVertexArrayOES(), oe.bindVertexArrayOES.set(this.vao), H = 0, this.boundProgram = g, this.boundLayoutVertexBuffer = v, this.boundPaintVertexBuffers = _, this.boundIndexBuffer = w, this.boundVertexOffset = R, this.boundDynamicVertexBuffer = D, this.boundDynamicVertexBuffer2 = k;
          else {
            H = oe.currentNumAttributes || 0;
            for (var Se = J; Se < H; Se++) Ce.disableVertexAttribArray(Se);
          }
          v.enableAttributes(Ce, g);
          for (var Oe = 0, He = _; Oe < He.length; Oe += 1) He[Oe].enableAttributes(Ce, g);
          D && D.enableAttributes(Ce, g), k && k.enableAttributes(Ce, g), v.bind(), v.setVertexAttribPointers(Ce, g, R);
          for (var ze = 0, h = _; ze < h.length; ze += 1) {
            var f = h[ze];
            f.bind(), f.setVertexAttribPointers(Ce, g, R);
          }
          D && (D.bind(), D.setVertexAttribPointers(Ce, g, R)), w && w.bind(), k && (k.bind(), k.setVertexAttribPointers(Ce, g, R)), oe.currentNumAttributes = J;
        }, pu.prototype.destroy = function() {
          this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);
        };
        var Mh = function(g, v, _, w, R, D) {
          var k = g.gl;
          this.program = k.createProgram();
          for (var H = Ph(_.staticAttributes), J = w ? w.getBinderAttributes() : [], oe = H.concat(J), Ce = _.staticUniforms ? Ph(_.staticUniforms) : [], Se = w ? w.getBinderUniforms() : [], Oe = [], He = 0, ze = Ce.concat(Se); He < ze.length; He += 1) {
            var h = ze[He];
            Oe.indexOf(h) < 0 && Oe.push(h);
          }
          var f = w ? w.defines() : [];
          D && f.push("#define OVERDRAW_INSPECTOR;");
          var A = f.concat(Ha.fragmentSource, _.fragmentSource).join(`
`), b = f.concat(Ha.vertexSource, _.vertexSource).join(`
`), T = k.createShader(k.FRAGMENT_SHADER);
          if (k.isContextLost()) this.failedToCreate = !0;
          else {
            k.shaderSource(T, A), k.compileShader(T), k.attachShader(this.program, T);
            var C = k.createShader(k.VERTEX_SHADER);
            if (k.isContextLost()) this.failedToCreate = !0;
            else {
              k.shaderSource(C, b), k.compileShader(C), k.attachShader(this.program, C), this.attributes = {};
              var I = {};
              this.numAttributes = oe.length;
              for (var B = 0; B < this.numAttributes; B++) oe[B] && (k.bindAttribLocation(this.program, B, oe[B]), this.attributes[oe[B]] = B);
              k.linkProgram(this.program), k.deleteShader(C), k.deleteShader(T);
              for (var F = 0; F < Oe.length; F++) {
                var z = Oe[F];
                if (z && !I[z]) {
                  var W = k.getUniformLocation(this.program, z);
                  W && (I[z] = W);
                }
              }
              this.fixedUniforms = R(g, I), this.binderUniforms = w ? w.getUniforms(g, I) : [];
            }
          }
        };
        function Rh(g, v, _) {
          var w = 1 / Fn(_, 1, v.transform.tileZoom), R = Math.pow(2, _.tileID.overscaledZ), D = _.tileSize * Math.pow(2, v.transform.tileZoom) / R, k = D * (_.tileID.canonical.x + _.tileID.wrap * R), H = D * _.tileID.canonical.y;
          return { u_image: 0, u_texsize: _.imageAtlasTexture.size, u_scale: [w, g.fromScale, g.toScale], u_fade: g.t, u_pixel_coord_upper: [k >> 16, H >> 16], u_pixel_coord_lower: [65535 & k, 65535 & H] };
        }
        Mh.prototype.draw = function(g, v, _, w, R, D, k, H, J, oe, Ce, Se, Oe, He, ze, h) {
          var f, A = g.gl;
          if (!this.failedToCreate) {
            for (var b in g.program.set(this.program), g.setDepthMode(_), g.setStencilMode(w), g.setColorMode(R), g.setCullFace(D), this.fixedUniforms) this.fixedUniforms[b].set(k[b]);
            He && He.setUniforms(g, this.binderUniforms, Se, { zoom: Oe });
            for (var T = (f = {}, f[A.LINES] = 2, f[A.TRIANGLES] = 3, f[A.LINE_STRIP] = 1, f)[v], C = 0, I = Ce.get(); C < I.length; C += 1) {
              var B = I[C], F = B.vaos || (B.vaos = {});
              (F[H] || (F[H] = new pu())).bind(g, this, J, He ? He.getPaintVertexBuffers() : [], oe, B.vertexOffset, ze, h), A.drawElements(v, B.primitiveLength * T, A.UNSIGNED_SHORT, B.primitiveOffset * T * 2);
            }
          }
        };
        var Bh = function(g, v, _, w) {
          var R = v.style.light, D = R.properties.get("position"), k = [D.x, D.y, D.z], H = o.create$1();
          R.properties.get("anchor") === "viewport" && o.fromRotation(H, -v.transform.angle), o.transformMat3(k, k, H);
          var J = R.properties.get("color");
          return { u_matrix: g, u_lightpos: k, u_lightintensity: R.properties.get("intensity"), u_lightcolor: [J.r, J.g, J.b], u_vertical_gradient: +_, u_opacity: w };
        }, Ga = function(g, v, _, w, R, D, k) {
          return o.extend(Bh(g, v, _, w), Rh(D, v, k), { u_height_factor: -Math.pow(2, R.overscaledZ) / k.tileSize / 8 });
        }, ba = function(g) {
          return { u_matrix: g };
        }, Wa = function(g, v, _, w) {
          return o.extend(ba(g), Rh(_, v, w));
        }, mc = function(g, v) {
          return { u_matrix: g, u_world: v };
        }, Oh = function(g, v, _, w, R) {
          return o.extend(Wa(g, v, _, w), { u_world: R });
        }, ff = function(g, v, _, w) {
          var R, D, k = g.transform;
          if (w.paint.get("circle-pitch-alignment") === "map") {
            var H = Fn(_, 1, k.zoom);
            R = !0, D = [H, H];
          } else R = !1, D = k.pixelsToGLUnits;
          return { u_camera_to_center_distance: k.cameraToCenterDistance, u_scale_with_map: +(w.paint.get("circle-pitch-scale") === "map"), u_matrix: g.translatePosMatrix(v.posMatrix, _, w.paint.get("circle-translate"), w.paint.get("circle-translate-anchor")), u_pitch_with_map: +R, u_device_pixel_ratio: o.browser.devicePixelRatio, u_extrude_scale: D };
        }, $a = function(g, v, _) {
          var w = Fn(_, 1, v.zoom), R = Math.pow(2, v.zoom - _.tileID.overscaledZ), D = _.tileID.overscaleFactor();
          return { u_matrix: g, u_camera_to_center_distance: v.cameraToCenterDistance, u_pixels_to_tile_units: w, u_extrude_scale: [v.pixelsToGLUnits[0] / (w * R), v.pixelsToGLUnits[1] / (w * R)], u_overscale_factor: D };
        }, Cl = function(g, v, _) {
          return { u_matrix: g, u_inv_matrix: v, u_camera_to_center_distance: _.cameraToCenterDistance, u_viewport_size: [_.width, _.height] };
        }, qa = function(g, v, _) {
          return _ === void 0 && (_ = 1), { u_matrix: g, u_color: v, u_overlay: 0, u_overlay_scale: _ };
        }, na = function(g) {
          return { u_matrix: g };
        }, hf = function(g, v, _, w) {
          return { u_matrix: g, u_extrude_scale: Fn(v, 1, _), u_intensity: w };
        }, Vo = function(g, v, _) {
          var w = g.transform;
          return { u_matrix: df(g, v, _), u_ratio: 1 / Fn(v, 1, w.zoom), u_device_pixel_ratio: o.browser.devicePixelRatio, u_units_to_pixels: [1 / w.pixelsToGLUnits[0], 1 / w.pixelsToGLUnits[1]] };
        }, Un = function(g, v, _, w) {
          return o.extend(Vo(g, v, _), { u_image: 0, u_image_height: w });
        }, Sl = function(g, v, _, w) {
          var R = g.transform, D = Il(v, R);
          return { u_matrix: df(g, v, _), u_texsize: v.imageAtlasTexture.size, u_ratio: 1 / Fn(v, 1, R.zoom), u_device_pixel_ratio: o.browser.devicePixelRatio, u_image: 0, u_scale: [D, w.fromScale, w.toScale], u_fade: w.t, u_units_to_pixels: [1 / R.pixelsToGLUnits[0], 1 / R.pixelsToGLUnits[1]] };
        }, Dh = function(g, v, _, w, R) {
          var D = g.lineAtlas, k = Il(v, g.transform), H = _.layout.get("line-cap") === "round", J = D.getDash(w.from, H), oe = D.getDash(w.to, H), Ce = J.width * R.fromScale, Se = oe.width * R.toScale;
          return o.extend(Vo(g, v, _), { u_patternscale_a: [k / Ce, -J.height / 2], u_patternscale_b: [k / Se, -oe.height / 2], u_sdfgamma: D.width / (256 * Math.min(Ce, Se) * o.browser.devicePixelRatio) / 2, u_image: 0, u_tex_y_a: J.y, u_tex_y_b: oe.y, u_mix: R.t });
        };
        function Il(g, v) {
          return 1 / Fn(g, 1, v.tileZoom);
        }
        function df(g, v, _) {
          return g.translatePosMatrix(v.tileID.posMatrix, v, _.paint.get("line-translate"), _.paint.get("line-translate-anchor"));
        }
        var pf = function(g, v, _, w, R) {
          return { u_matrix: g, u_tl_parent: v, u_scale_parent: _, u_buffer_scale: 1, u_fade_t: w.mix, u_opacity: w.opacity * R.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: R.paint.get("raster-brightness-min"), u_brightness_high: R.paint.get("raster-brightness-max"), u_saturation_factor: (k = R.paint.get("raster-saturation"), k > 0 ? 1 - 1 / (1.001 - k) : -k), u_contrast_factor: (D = R.paint.get("raster-contrast"), D > 0 ? 1 / (1 - D) : 1 + D), u_spin_weights: Au(R.paint.get("raster-hue-rotate")) };
          var D, k;
        };
        function Au(g) {
          g *= Math.PI / 180;
          var v = Math.sin(g), _ = Math.cos(g);
          return [(2 * _ + 1) / 3, (-Math.sqrt(3) * v - _ + 1) / 3, (Math.sqrt(3) * v - _ + 1) / 3];
        }
        var Pl, jo = function(g, v, _, w, R, D, k, H, J, oe) {
          var Ce = R.transform;
          return { u_is_size_zoom_constant: +(g === "constant" || g === "source"), u_is_size_feature_constant: +(g === "constant" || g === "camera"), u_size_t: v ? v.uSizeT : 0, u_size: v ? v.uSize : 0, u_camera_to_center_distance: Ce.cameraToCenterDistance, u_pitch: Ce.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +_, u_aspect_ratio: Ce.width / Ce.height, u_fade_change: R.options.fadeDuration ? R.symbolFadeChange : 1, u_matrix: D, u_label_plane_matrix: k, u_coord_matrix: H, u_is_text: +J, u_pitch_with_map: +w, u_texsize: oe, u_texture: 0 };
        }, Bn = function(g, v, _, w, R, D, k, H, J, oe, Ce) {
          var Se = R.transform;
          return o.extend(jo(g, v, _, w, R, D, k, H, J, oe), { u_gamma_scale: w ? Math.cos(Se._pitch) * Se.cameraToCenterDistance : 1, u_device_pixel_ratio: o.browser.devicePixelRatio, u_is_halo: 1 });
        }, gu = function(g, v, _, w, R, D, k, H, J, oe) {
          return o.extend(Bn(g, v, _, w, R, D, k, H, !0, J), { u_texsize_icon: oe, u_texture_icon: 1 });
        }, Ml = function(g, v, _) {
          return { u_matrix: g, u_opacity: v, u_color: _ };
        }, Xa = function(g, v, _, w, R, D) {
          return o.extend((function(k, H, J, oe) {
            var Ce = J.imageManager.getPattern(k.from.toString()), Se = J.imageManager.getPattern(k.to.toString()), Oe = J.imageManager.getPixelSize(), He = Oe.width, ze = Oe.height, h = Math.pow(2, oe.tileID.overscaledZ), f = oe.tileSize * Math.pow(2, J.transform.tileZoom) / h, A = f * (oe.tileID.canonical.x + oe.tileID.wrap * h), b = f * oe.tileID.canonical.y;
            return { u_image: 0, u_pattern_tl_a: Ce.tl, u_pattern_br_a: Ce.br, u_pattern_tl_b: Se.tl, u_pattern_br_b: Se.br, u_texsize: [He, ze], u_mix: H.t, u_pattern_size_a: Ce.displaySize, u_pattern_size_b: Se.displaySize, u_scale_a: H.fromScale, u_scale_b: H.toScale, u_tile_units_to_pixels: 1 / Fn(oe, 1, J.transform.tileZoom), u_pixel_coord_upper: [A >> 16, b >> 16], u_pixel_coord_lower: [65535 & A, 65535 & b] };
          })(w, D, _, R), { u_matrix: g, u_opacity: v });
        }, Lh = { fillExtrusion: function(g, v) {
          return { u_matrix: new o.UniformMatrix4f(g, v.u_matrix), u_lightpos: new o.Uniform3f(g, v.u_lightpos), u_lightintensity: new o.Uniform1f(g, v.u_lightintensity), u_lightcolor: new o.Uniform3f(g, v.u_lightcolor), u_vertical_gradient: new o.Uniform1f(g, v.u_vertical_gradient), u_opacity: new o.Uniform1f(g, v.u_opacity) };
        }, fillExtrusionPattern: function(g, v) {
          return { u_matrix: new o.UniformMatrix4f(g, v.u_matrix), u_lightpos: new o.Uniform3f(g, v.u_lightpos), u_lightintensity: new o.Uniform1f(g, v.u_lightintensity), u_lightcolor: new o.Uniform3f(g, v.u_lightcolor), u_vertical_gradient: new o.Uniform1f(g, v.u_vertical_gradient), u_height_factor: new o.Uniform1f(g, v.u_height_factor), u_image: new o.Uniform1i(g, v.u_image), u_texsize: new o.Uniform2f(g, v.u_texsize), u_pixel_coord_upper: new o.Uniform2f(g, v.u_pixel_coord_upper), u_pixel_coord_lower: new o.Uniform2f(g, v.u_pixel_coord_lower), u_scale: new o.Uniform3f(g, v.u_scale), u_fade: new o.Uniform1f(g, v.u_fade), u_opacity: new o.Uniform1f(g, v.u_opacity) };
        }, fill: function(g, v) {
          return { u_matrix: new o.UniformMatrix4f(g, v.u_matrix) };
        }, fillPattern: function(g, v) {
          return { u_matrix: new o.UniformMatrix4f(g, v.u_matrix), u_image: new o.Uniform1i(g, v.u_image), u_texsize: new o.Uniform2f(g, v.u_texsize), u_pixel_coord_upper: new o.Uniform2f(g, v.u_pixel_coord_upper), u_pixel_coord_lower: new o.Uniform2f(g, v.u_pixel_coord_lower), u_scale: new o.Uniform3f(g, v.u_scale), u_fade: new o.Uniform1f(g, v.u_fade) };
        }, fillOutline: function(g, v) {
          return { u_matrix: new o.UniformMatrix4f(g, v.u_matrix), u_world: new o.Uniform2f(g, v.u_world) };
        }, fillOutlinePattern: function(g, v) {
          return { u_matrix: new o.UniformMatrix4f(g, v.u_matrix), u_world: new o.Uniform2f(g, v.u_world), u_image: new o.Uniform1i(g, v.u_image), u_texsize: new o.Uniform2f(g, v.u_texsize), u_pixel_coord_upper: new o.Uniform2f(g, v.u_pixel_coord_upper), u_pixel_coord_lower: new o.Uniform2f(g, v.u_pixel_coord_lower), u_scale: new o.Uniform3f(g, v.u_scale), u_fade: new o.Uniform1f(g, v.u_fade) };
        }, circle: function(g, v) {
          return { u_camera_to_center_distance: new o.Uniform1f(g, v.u_camera_to_center_distance), u_scale_with_map: new o.Uniform1i(g, v.u_scale_with_map), u_pitch_with_map: new o.Uniform1i(g, v.u_pitch_with_map), u_extrude_scale: new o.Uniform2f(g, v.u_extrude_scale), u_device_pixel_ratio: new o.Uniform1f(g, v.u_device_pixel_ratio), u_matrix: new o.UniformMatrix4f(g, v.u_matrix) };
        }, collisionBox: function(g, v) {
          return { u_matrix: new o.UniformMatrix4f(g, v.u_matrix), u_camera_to_center_distance: new o.Uniform1f(g, v.u_camera_to_center_distance), u_pixels_to_tile_units: new o.Uniform1f(g, v.u_pixels_to_tile_units), u_extrude_scale: new o.Uniform2f(g, v.u_extrude_scale), u_overscale_factor: new o.Uniform1f(g, v.u_overscale_factor) };
        }, collisionCircle: function(g, v) {
          return { u_matrix: new o.UniformMatrix4f(g, v.u_matrix), u_inv_matrix: new o.UniformMatrix4f(g, v.u_inv_matrix), u_camera_to_center_distance: new o.Uniform1f(g, v.u_camera_to_center_distance), u_viewport_size: new o.Uniform2f(g, v.u_viewport_size) };
        }, debug: function(g, v) {
          return { u_color: new o.UniformColor(g, v.u_color), u_matrix: new o.UniformMatrix4f(g, v.u_matrix), u_overlay: new o.Uniform1i(g, v.u_overlay), u_overlay_scale: new o.Uniform1f(g, v.u_overlay_scale) };
        }, clippingMask: function(g, v) {
          return { u_matrix: new o.UniformMatrix4f(g, v.u_matrix) };
        }, heatmap: function(g, v) {
          return { u_extrude_scale: new o.Uniform1f(g, v.u_extrude_scale), u_intensity: new o.Uniform1f(g, v.u_intensity), u_matrix: new o.UniformMatrix4f(g, v.u_matrix) };
        }, heatmapTexture: function(g, v) {
          return { u_matrix: new o.UniformMatrix4f(g, v.u_matrix), u_world: new o.Uniform2f(g, v.u_world), u_image: new o.Uniform1i(g, v.u_image), u_color_ramp: new o.Uniform1i(g, v.u_color_ramp), u_opacity: new o.Uniform1f(g, v.u_opacity) };
        }, hillshade: function(g, v) {
          return { u_matrix: new o.UniformMatrix4f(g, v.u_matrix), u_image: new o.Uniform1i(g, v.u_image), u_latrange: new o.Uniform2f(g, v.u_latrange), u_light: new o.Uniform2f(g, v.u_light), u_shadow: new o.UniformColor(g, v.u_shadow), u_highlight: new o.UniformColor(g, v.u_highlight), u_accent: new o.UniformColor(g, v.u_accent) };
        }, hillshadePrepare: function(g, v) {
          return { u_matrix: new o.UniformMatrix4f(g, v.u_matrix), u_image: new o.Uniform1i(g, v.u_image), u_dimension: new o.Uniform2f(g, v.u_dimension), u_zoom: new o.Uniform1f(g, v.u_zoom), u_unpack: new o.Uniform4f(g, v.u_unpack) };
        }, line: function(g, v) {
          return { u_matrix: new o.UniformMatrix4f(g, v.u_matrix), u_ratio: new o.Uniform1f(g, v.u_ratio), u_device_pixel_ratio: new o.Uniform1f(g, v.u_device_pixel_ratio), u_units_to_pixels: new o.Uniform2f(g, v.u_units_to_pixels) };
        }, lineGradient: function(g, v) {
          return { u_matrix: new o.UniformMatrix4f(g, v.u_matrix), u_ratio: new o.Uniform1f(g, v.u_ratio), u_device_pixel_ratio: new o.Uniform1f(g, v.u_device_pixel_ratio), u_units_to_pixels: new o.Uniform2f(g, v.u_units_to_pixels), u_image: new o.Uniform1i(g, v.u_image), u_image_height: new o.Uniform1f(g, v.u_image_height) };
        }, linePattern: function(g, v) {
          return { u_matrix: new o.UniformMatrix4f(g, v.u_matrix), u_texsize: new o.Uniform2f(g, v.u_texsize), u_ratio: new o.Uniform1f(g, v.u_ratio), u_device_pixel_ratio: new o.Uniform1f(g, v.u_device_pixel_ratio), u_image: new o.Uniform1i(g, v.u_image), u_units_to_pixels: new o.Uniform2f(g, v.u_units_to_pixels), u_scale: new o.Uniform3f(g, v.u_scale), u_fade: new o.Uniform1f(g, v.u_fade) };
        }, lineSDF: function(g, v) {
          return { u_matrix: new o.UniformMatrix4f(g, v.u_matrix), u_ratio: new o.Uniform1f(g, v.u_ratio), u_device_pixel_ratio: new o.Uniform1f(g, v.u_device_pixel_ratio), u_units_to_pixels: new o.Uniform2f(g, v.u_units_to_pixels), u_patternscale_a: new o.Uniform2f(g, v.u_patternscale_a), u_patternscale_b: new o.Uniform2f(g, v.u_patternscale_b), u_sdfgamma: new o.Uniform1f(g, v.u_sdfgamma), u_image: new o.Uniform1i(g, v.u_image), u_tex_y_a: new o.Uniform1f(g, v.u_tex_y_a), u_tex_y_b: new o.Uniform1f(g, v.u_tex_y_b), u_mix: new o.Uniform1f(g, v.u_mix) };
        }, raster: function(g, v) {
          return { u_matrix: new o.UniformMatrix4f(g, v.u_matrix), u_tl_parent: new o.Uniform2f(g, v.u_tl_parent), u_scale_parent: new o.Uniform1f(g, v.u_scale_parent), u_buffer_scale: new o.Uniform1f(g, v.u_buffer_scale), u_fade_t: new o.Uniform1f(g, v.u_fade_t), u_opacity: new o.Uniform1f(g, v.u_opacity), u_image0: new o.Uniform1i(g, v.u_image0), u_image1: new o.Uniform1i(g, v.u_image1), u_brightness_low: new o.Uniform1f(g, v.u_brightness_low), u_brightness_high: new o.Uniform1f(g, v.u_brightness_high), u_saturation_factor: new o.Uniform1f(g, v.u_saturation_factor), u_contrast_factor: new o.Uniform1f(g, v.u_contrast_factor), u_spin_weights: new o.Uniform3f(g, v.u_spin_weights) };
        }, symbolIcon: function(g, v) {
          return { u_is_size_zoom_constant: new o.Uniform1i(g, v.u_is_size_zoom_constant), u_is_size_feature_constant: new o.Uniform1i(g, v.u_is_size_feature_constant), u_size_t: new o.Uniform1f(g, v.u_size_t), u_size: new o.Uniform1f(g, v.u_size), u_camera_to_center_distance: new o.Uniform1f(g, v.u_camera_to_center_distance), u_pitch: new o.Uniform1f(g, v.u_pitch), u_rotate_symbol: new o.Uniform1i(g, v.u_rotate_symbol), u_aspect_ratio: new o.Uniform1f(g, v.u_aspect_ratio), u_fade_change: new o.Uniform1f(g, v.u_fade_change), u_matrix: new o.UniformMatrix4f(g, v.u_matrix), u_label_plane_matrix: new o.UniformMatrix4f(g, v.u_label_plane_matrix), u_coord_matrix: new o.UniformMatrix4f(g, v.u_coord_matrix), u_is_text: new o.Uniform1i(g, v.u_is_text), u_pitch_with_map: new o.Uniform1i(g, v.u_pitch_with_map), u_texsize: new o.Uniform2f(g, v.u_texsize), u_texture: new o.Uniform1i(g, v.u_texture) };
        }, symbolSDF: function(g, v) {
          return { u_is_size_zoom_constant: new o.Uniform1i(g, v.u_is_size_zoom_constant), u_is_size_feature_constant: new o.Uniform1i(g, v.u_is_size_feature_constant), u_size_t: new o.Uniform1f(g, v.u_size_t), u_size: new o.Uniform1f(g, v.u_size), u_camera_to_center_distance: new o.Uniform1f(g, v.u_camera_to_center_distance), u_pitch: new o.Uniform1f(g, v.u_pitch), u_rotate_symbol: new o.Uniform1i(g, v.u_rotate_symbol), u_aspect_ratio: new o.Uniform1f(g, v.u_aspect_ratio), u_fade_change: new o.Uniform1f(g, v.u_fade_change), u_matrix: new o.UniformMatrix4f(g, v.u_matrix), u_label_plane_matrix: new o.UniformMatrix4f(g, v.u_label_plane_matrix), u_coord_matrix: new o.UniformMatrix4f(g, v.u_coord_matrix), u_is_text: new o.Uniform1i(g, v.u_is_text), u_pitch_with_map: new o.Uniform1i(g, v.u_pitch_with_map), u_texsize: new o.Uniform2f(g, v.u_texsize), u_texture: new o.Uniform1i(g, v.u_texture), u_gamma_scale: new o.Uniform1f(g, v.u_gamma_scale), u_device_pixel_ratio: new o.Uniform1f(g, v.u_device_pixel_ratio), u_is_halo: new o.Uniform1i(g, v.u_is_halo) };
        }, symbolTextAndIcon: function(g, v) {
          return { u_is_size_zoom_constant: new o.Uniform1i(g, v.u_is_size_zoom_constant), u_is_size_feature_constant: new o.Uniform1i(g, v.u_is_size_feature_constant), u_size_t: new o.Uniform1f(g, v.u_size_t), u_size: new o.Uniform1f(g, v.u_size), u_camera_to_center_distance: new o.Uniform1f(g, v.u_camera_to_center_distance), u_pitch: new o.Uniform1f(g, v.u_pitch), u_rotate_symbol: new o.Uniform1i(g, v.u_rotate_symbol), u_aspect_ratio: new o.Uniform1f(g, v.u_aspect_ratio), u_fade_change: new o.Uniform1f(g, v.u_fade_change), u_matrix: new o.UniformMatrix4f(g, v.u_matrix), u_label_plane_matrix: new o.UniformMatrix4f(g, v.u_label_plane_matrix), u_coord_matrix: new o.UniformMatrix4f(g, v.u_coord_matrix), u_is_text: new o.Uniform1i(g, v.u_is_text), u_pitch_with_map: new o.Uniform1i(g, v.u_pitch_with_map), u_texsize: new o.Uniform2f(g, v.u_texsize), u_texsize_icon: new o.Uniform2f(g, v.u_texsize_icon), u_texture: new o.Uniform1i(g, v.u_texture), u_texture_icon: new o.Uniform1i(g, v.u_texture_icon), u_gamma_scale: new o.Uniform1f(g, v.u_gamma_scale), u_device_pixel_ratio: new o.Uniform1f(g, v.u_device_pixel_ratio), u_is_halo: new o.Uniform1i(g, v.u_is_halo) };
        }, background: function(g, v) {
          return { u_matrix: new o.UniformMatrix4f(g, v.u_matrix), u_opacity: new o.Uniform1f(g, v.u_opacity), u_color: new o.UniformColor(g, v.u_color) };
        }, backgroundPattern: function(g, v) {
          return { u_matrix: new o.UniformMatrix4f(g, v.u_matrix), u_opacity: new o.Uniform1f(g, v.u_opacity), u_image: new o.Uniform1i(g, v.u_image), u_pattern_tl_a: new o.Uniform2f(g, v.u_pattern_tl_a), u_pattern_br_a: new o.Uniform2f(g, v.u_pattern_br_a), u_pattern_tl_b: new o.Uniform2f(g, v.u_pattern_tl_b), u_pattern_br_b: new o.Uniform2f(g, v.u_pattern_br_b), u_texsize: new o.Uniform2f(g, v.u_texsize), u_mix: new o.Uniform1f(g, v.u_mix), u_pattern_size_a: new o.Uniform2f(g, v.u_pattern_size_a), u_pattern_size_b: new o.Uniform2f(g, v.u_pattern_size_b), u_scale_a: new o.Uniform1f(g, v.u_scale_a), u_scale_b: new o.Uniform1f(g, v.u_scale_b), u_pixel_coord_upper: new o.Uniform2f(g, v.u_pixel_coord_upper), u_pixel_coord_lower: new o.Uniform2f(g, v.u_pixel_coord_lower), u_tile_units_to_pixels: new o.Uniform1f(g, v.u_tile_units_to_pixels) };
        } };
        function Rl(g, v, _, w, R, D, k) {
          for (var H = g.context, J = H.gl, oe = g.useProgram("collisionBox"), Ce = [], Se = 0, Oe = 0, He = 0; He < w.length; He++) {
            var ze = w[He], h = v.getTile(ze), f = h.getBucket(_);
            if (f) {
              var A = ze.posMatrix;
              R[0] === 0 && R[1] === 0 || (A = g.translatePosMatrix(ze.posMatrix, h, R, D));
              var b = k ? f.textCollisionBox : f.iconCollisionBox, T = f.collisionCircleArray;
              if (T.length > 0) {
                var C = o.create(), I = A;
                o.mul(C, f.placementInvProjMatrix, g.transform.glCoordMatrix), o.mul(C, C, f.placementViewportMatrix), Ce.push({ circleArray: T, circleOffset: Oe, transform: I, invTransform: C }), Oe = Se += T.length / 4;
              }
              b && oe.draw(H, J.LINES, we.disabled, Ne.disabled, g.colorModeForRenderPass(), Te.disabled, $a(A, g.transform, h), _.id, b.layoutVertexBuffer, b.indexBuffer, b.segments, null, g.transform.zoom, null, null, b.collisionVertexBuffer);
            }
          }
          if (k && Ce.length) {
            var B = g.useProgram("collisionCircle"), F = new o.StructArrayLayout2f1f2i16();
            F.resize(4 * Se), F._trim();
            for (var z = 0, W = 0, ue = Ce; W < ue.length; W += 1) for (var Ie = ue[W], Re = 0; Re < Ie.circleArray.length / 4; Re++) {
              var Be = 4 * Re, Ze = Ie.circleArray[Be + 0], We = Ie.circleArray[Be + 1], rt = Ie.circleArray[Be + 2], et = Ie.circleArray[Be + 3];
              F.emplace(z++, Ze, We, rt, et, 0), F.emplace(z++, Ze, We, rt, et, 1), F.emplace(z++, Ze, We, rt, et, 2), F.emplace(z++, Ze, We, rt, et, 3);
            }
            (!Pl || Pl.length < 2 * Se) && (Pl = (function(Cr) {
              var Gr = 2 * Cr, Sr = new o.StructArrayLayout3ui6();
              Sr.resize(Gr), Sr._trim();
              for (var ar = 0; ar < Gr; ar++) {
                var jt = 6 * ar;
                Sr.uint16[jt + 0] = 4 * ar + 0, Sr.uint16[jt + 1] = 4 * ar + 1, Sr.uint16[jt + 2] = 4 * ar + 2, Sr.uint16[jt + 3] = 4 * ar + 2, Sr.uint16[jt + 4] = 4 * ar + 3, Sr.uint16[jt + 5] = 4 * ar + 0;
              }
              return Sr;
            })(Se));
            for (var Je = H.createIndexBuffer(Pl, !0), $e = H.createVertexBuffer(F, o.collisionCircleLayout.members, !0), Bt = 0, Ht = Ce; Bt < Ht.length; Bt += 1) {
              var Ut = Ht[Bt], Or = Cl(Ut.transform, Ut.invTransform, g.transform);
              B.draw(H, J.TRIANGLES, we.disabled, Ne.disabled, g.colorModeForRenderPass(), Te.disabled, Or, _.id, $e, Je, o.SegmentVector.simpleSegment(0, 2 * Ut.circleOffset, Ut.circleArray.length, Ut.circleArray.length / 2), null, g.transform.zoom, null, null, null);
            }
            $e.destroy(), Je.destroy();
          }
        }
        var vo = o.identity(new Float32Array(16));
        function kh(g, v, _, w, R, D) {
          var k = o.getAnchorAlignment(g), H = -(k.horizontalAlign - 0.5) * v, J = -(k.verticalAlign - 0.5) * _, oe = o.evaluateVariableOffset(g, w);
          return new o.Point((H / R + oe[0]) * D, (J / R + oe[1]) * D);
        }
        function ys(g, v, _, w, R, D, k, H, J, oe, Ce) {
          var Se = g.text.placedSymbolArray, Oe = g.text.dynamicLayoutVertexArray, He = g.icon.dynamicLayoutVertexArray, ze = {};
          Oe.clear();
          for (var h = 0; h < Se.length; h++) {
            var f = Se.get(h), A = f.hidden || !f.crossTileID || g.allowVerticalPlacement && !f.placedOrientation ? null : w[f.crossTileID];
            if (A) {
              var b = new o.Point(f.anchorX, f.anchorY), T = er(b, _ ? H : k), C = sn(D.cameraToCenterDistance, T.signedDistanceFromCamera), I = R.evaluateSizeForFeature(g.textSizeData, oe, f) * C / o.ONE_EM;
              _ && (I *= g.tilePixelRatio / J);
              for (var B = kh(A.anchor, A.width, A.height, A.textOffset, A.textBoxScale, I), F = _ ? er(b.add(B), k).point : T.point.add(v ? B.rotate(-D.angle) : B), z = g.allowVerticalPlacement && f.placedOrientation === o.WritingMode.vertical ? Math.PI / 2 : 0, W = 0; W < f.numGlyphs; W++) o.addDynamicAttributes(Oe, F, z);
              Ce && f.associatedIconIndex >= 0 && (ze[f.associatedIconIndex] = { shiftedAnchor: F, angle: z });
            } else Oi(f.numGlyphs, Oe);
          }
          if (Ce) {
            He.clear();
            for (var ue = g.icon.placedSymbolArray, Ie = 0; Ie < ue.length; Ie++) {
              var Re = ue.get(Ie);
              if (Re.hidden) Oi(Re.numGlyphs, He);
              else {
                var Be = ze[Ie];
                if (Be) for (var Ze = 0; Ze < Re.numGlyphs; Ze++) o.addDynamicAttributes(He, Be.shiftedAnchor, Be.angle);
                else Oi(Re.numGlyphs, He);
              }
            }
            g.icon.dynamicLayoutVertexBuffer.updateData(He);
          }
          g.text.dynamicLayoutVertexBuffer.updateData(Oe);
        }
        function mu(g, v, _) {
          return _.iconsInText && v ? "symbolTextAndIcon" : g ? "symbolSDF" : "symbolIcon";
        }
        function Xs(g, v, _, w, R, D, k, H, J, oe, Ce, Se) {
          for (var Oe = g.context, He = Oe.gl, ze = g.transform, h = H === "map", f = J === "map", A = h && _.layout.get("symbol-placement") !== "point", b = h && !f && !A, T = _.layout.get("symbol-sort-key").constantOr(1) !== void 0, C = !1, I = g.depthModeForSublayer(0, we.ReadOnly), B = _.layout.get("text-variable-anchor"), F = [], z = 0, W = w; z < W.length; z += 1) {
            var ue = W[z], Ie = v.getTile(ue), Re = Ie.getBucket(_);
            if (Re) {
              var Be = R ? Re.text : Re.icon;
              if (Be && Be.segments.get().length) {
                var Ze = Be.programConfigurations.get(_.id), We = R || Re.sdfIcons, rt = R ? Re.textSizeData : Re.iconSizeData, et = f || ze.pitch !== 0, Je = g.useProgram(mu(We, R, Re), Ze), $e = o.evaluateSizeForZoom(rt, ze.zoom), Bt = void 0, Ht = [0, 0], Ut = void 0, Or = void 0, Cr = null, Gr = void 0;
                if (R) Ut = Ie.glyphAtlasTexture, Or = He.LINEAR, Bt = Ie.glyphAtlasTexture.size, Re.iconsInText && (Ht = Ie.imageAtlasTexture.size, Cr = Ie.imageAtlasTexture, Gr = et || g.options.rotating || g.options.zooming || rt.kind === "composite" || rt.kind === "camera" ? He.LINEAR : He.NEAREST);
                else {
                  var Sr = _.layout.get("icon-size").constantOr(0) !== 1 || Re.iconsNeedLinear;
                  Ut = Ie.imageAtlasTexture, Or = We || g.options.rotating || g.options.zooming || Sr || et ? He.LINEAR : He.NEAREST, Bt = Ie.imageAtlasTexture.size;
                }
                var ar = Fn(Ie, 1, g.transform.zoom), jt = hr(ue.posMatrix, f, h, g.transform, ar), Wr = ye(ue.posMatrix, f, h, g.transform, ar), fn = B && Re.hasTextData(), Zr = _.layout.get("icon-text-fit") !== "none" && fn && Re.hasIconData();
                A && ma(Re, ue.posMatrix, g, R, jt, Wr, f, oe);
                var _n = g.translatePosMatrix(ue.posMatrix, Ie, D, k), si = A || R && B || Zr ? vo : jt, Ys = g.translatePosMatrix(Wr, Ie, D, k, !0), wf = We && _.paint.get(R ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0, Cu = { program: Je, buffers: Be, uniformValues: We ? Re.iconsInText ? gu(rt.kind, $e, b, f, g, _n, si, Ys, Bt, Ht) : Bn(rt.kind, $e, b, f, g, _n, si, Ys, R, Bt) : jo(rt.kind, $e, b, f, g, _n, si, Ys, R, Bt), atlasTexture: Ut, atlasTextureIcon: Cr, atlasInterpolation: Or, atlasInterpolationIcon: Gr, isSDF: We, hasHalo: wf };
                if (T && Re.canOverlap) {
                  C = !0;
                  for (var Vl = 0, Su = Be.segments.get(); Vl < Su.length; Vl += 1) {
                    var Tf = Su[Vl];
                    F.push({ segments: new o.SegmentVector([Tf]), sortKey: Tf.sortKey, state: Cu });
                  }
                } else F.push({ segments: Be.segments, sortKey: 0, state: Cu });
              }
            }
          }
          C && F.sort((function(jl, Mc) {
            return jl.sortKey - Mc.sortKey;
          }));
          for (var Ca = 0, Ef = F; Ca < Ef.length; Ca += 1) {
            var Sa = Ef[Ca], Zi = Sa.state;
            if (Oe.activeTexture.set(He.TEXTURE0), Zi.atlasTexture.bind(Zi.atlasInterpolation, He.CLAMP_TO_EDGE), Zi.atlasTextureIcon && (Oe.activeTexture.set(He.TEXTURE1), Zi.atlasTextureIcon && Zi.atlasTextureIcon.bind(Zi.atlasInterpolationIcon, He.CLAMP_TO_EDGE)), Zi.isSDF) {
              var Ja = Zi.uniformValues;
              Zi.hasHalo && (Ja.u_is_halo = 1, _c(Zi.buffers, Sa.segments, _, g, Zi.program, I, Ce, Se, Ja)), Ja.u_is_halo = 0;
            }
            _c(Zi.buffers, Sa.segments, _, g, Zi.program, I, Ce, Se, Zi.uniformValues);
          }
        }
        function _c(g, v, _, w, R, D, k, H, J) {
          var oe = w.context;
          R.draw(oe, oe.gl.TRIANGLES, D, k, H, Te.disabled, J, _.id, g.layoutVertexBuffer, g.indexBuffer, v, _.paint, w.transform.zoom, g.programConfigurations.get(_.id), g.dynamicLayoutVertexBuffer, g.opacityVertexBuffer);
        }
        function Bl(g, v, _, w, R, D, k) {
          var H, J, oe, Ce, Se, Oe = g.context.gl, He = _.paint.get("fill-pattern"), ze = He && He.constantOr(1), h = _.getCrossfadeParameters();
          k ? (J = ze && !_.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", H = Oe.LINES) : (J = ze ? "fillPattern" : "fill", H = Oe.TRIANGLES);
          for (var f = 0, A = w; f < A.length; f += 1) {
            var b = A[f], T = v.getTile(b);
            if (!ze || T.patternsLoaded()) {
              var C = T.getBucket(_);
              if (C) {
                var I = C.programConfigurations.get(_.id), B = g.useProgram(J, I);
                ze && (g.context.activeTexture.set(Oe.TEXTURE0), T.imageAtlasTexture.bind(Oe.LINEAR, Oe.CLAMP_TO_EDGE), I.updatePaintBuffers(h));
                var F = He.constantOr(null);
                if (F && T.imageAtlas) {
                  var z = T.imageAtlas, W = z.patternPositions[F.to.toString()], ue = z.patternPositions[F.from.toString()];
                  W && ue && I.setConstantPatternPositions(W, ue);
                }
                var Ie = g.translatePosMatrix(b.posMatrix, T, _.paint.get("fill-translate"), _.paint.get("fill-translate-anchor"));
                if (k) {
                  Ce = C.indexBuffer2, Se = C.segments2;
                  var Re = [Oe.drawingBufferWidth, Oe.drawingBufferHeight];
                  oe = J === "fillOutlinePattern" && ze ? Oh(Ie, g, h, T, Re) : mc(Ie, Re);
                } else Ce = C.indexBuffer, Se = C.segments, oe = ze ? Wa(Ie, g, h, T) : ba(Ie);
                B.draw(g.context, H, R, g.stencilModeForClipping(b), D, Te.disabled, oe, _.id, C.layoutVertexBuffer, Ce, Se, _.paint, g.transform.zoom, I);
              }
            }
          }
        }
        function Af(g, v, _, w, R, D, k) {
          for (var H = g.context, J = H.gl, oe = _.paint.get("fill-extrusion-pattern"), Ce = oe.constantOr(1), Se = _.getCrossfadeParameters(), Oe = _.paint.get("fill-extrusion-opacity"), He = 0, ze = w; He < ze.length; He += 1) {
            var h = ze[He], f = v.getTile(h), A = f.getBucket(_);
            if (A) {
              var b = A.programConfigurations.get(_.id), T = g.useProgram(Ce ? "fillExtrusionPattern" : "fillExtrusion", b);
              Ce && (g.context.activeTexture.set(J.TEXTURE0), f.imageAtlasTexture.bind(J.LINEAR, J.CLAMP_TO_EDGE), b.updatePaintBuffers(Se));
              var C = oe.constantOr(null);
              if (C && f.imageAtlas) {
                var I = f.imageAtlas, B = I.patternPositions[C.to.toString()], F = I.patternPositions[C.from.toString()];
                B && F && b.setConstantPatternPositions(B, F);
              }
              var z = g.translatePosMatrix(h.posMatrix, f, _.paint.get("fill-extrusion-translate"), _.paint.get("fill-extrusion-translate-anchor")), W = _.paint.get("fill-extrusion-vertical-gradient"), ue = Ce ? Ga(z, g, W, Oe, h, Se, f) : Bh(z, g, W, Oe);
              T.draw(H, H.gl.TRIANGLES, R, D, k, Te.backCCW, ue, _.id, A.layoutVertexBuffer, A.indexBuffer, A.segments, _.paint, g.transform.zoom, b);
            }
          }
        }
        function vs(g, v, _, w, R, D) {
          var k = g.context, H = k.gl, J = v.fbo;
          if (J) {
            var oe = g.useProgram("hillshade");
            k.activeTexture.set(H.TEXTURE0), H.bindTexture(H.TEXTURE_2D, J.colorAttachment.get());
            var Ce = (function(Se, Oe, He) {
              var ze = He.paint.get("hillshade-shadow-color"), h = He.paint.get("hillshade-highlight-color"), f = He.paint.get("hillshade-accent-color"), A = He.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
              He.paint.get("hillshade-illumination-anchor") === "viewport" && (A -= Se.transform.angle);
              var b, T, C, I = !Se.options.moving;
              return { u_matrix: Se.transform.calculatePosMatrix(Oe.tileID.toUnwrapped(), I), u_image: 0, u_latrange: (b = Oe.tileID, T = Math.pow(2, b.canonical.z), C = b.canonical.y, [new o.MercatorCoordinate(0, C / T).toLngLat().lat, new o.MercatorCoordinate(0, (C + 1) / T).toLngLat().lat]), u_light: [He.paint.get("hillshade-exaggeration"), A], u_shadow: ze, u_highlight: h, u_accent: f };
            })(g, v, _);
            oe.draw(k, H.TRIANGLES, w, R, D, Te.disabled, Ce, _.id, g.rasterBoundsBuffer, g.quadTriangleIndexBuffer, g.rasterBoundsSegments);
          }
        }
        function gf(g, v, _, w, R, D) {
          var k = g.context, H = k.gl, J = v.dem;
          if (J && J.data) {
            var oe = J.dim, Ce = J.stride, Se = J.getPixels();
            if (k.activeTexture.set(H.TEXTURE1), k.pixelStoreUnpackPremultiplyAlpha.set(!1), v.demTexture = v.demTexture || g.getTileTexture(Ce), v.demTexture) {
              var Oe = v.demTexture;
              Oe.update(Se, { premultiply: !1 }), Oe.bind(H.NEAREST, H.CLAMP_TO_EDGE);
            } else v.demTexture = new o.Texture(k, Se, H.RGBA, { premultiply: !1 }), v.demTexture.bind(H.NEAREST, H.CLAMP_TO_EDGE);
            k.activeTexture.set(H.TEXTURE0);
            var He = v.fbo;
            if (!He) {
              var ze = new o.Texture(k, { width: oe, height: oe, data: null }, H.RGBA);
              ze.bind(H.LINEAR, H.CLAMP_TO_EDGE), (He = v.fbo = k.createFramebuffer(oe, oe, !0)).colorAttachment.set(ze.texture);
            }
            k.bindFramebuffer.set(He.framebuffer), k.viewport.set([0, 0, oe, oe]), g.useProgram("hillshadePrepare").draw(k, H.TRIANGLES, w, R, D, Te.disabled, (function(h, f) {
              var A = f.stride, b = o.create();
              return o.ortho(b, 0, o.EXTENT, -o.EXTENT, 0, 0, 1), o.translate(b, b, [0, -o.EXTENT, 0]), { u_matrix: b, u_image: 1, u_dimension: [A, A], u_zoom: h.overscaledZ, u_unpack: f.getUnpackVector() };
            })(v.tileID, J), _.id, g.rasterBoundsBuffer, g.quadTriangleIndexBuffer, g.rasterBoundsSegments), v.needsHillshadePrepare = !1;
          }
        }
        function Ol(g, v, _, w, R) {
          var D = w.paint.get("raster-fade-duration");
          if (D > 0) {
            var k = o.browser.now(), H = (k - g.timeAdded) / D, J = v ? (k - v.timeAdded) / D : -1, oe = _.getSource(), Ce = R.coveringZoomLevel({ tileSize: oe.tileSize, roundZoom: oe.roundZoom }), Se = !v || Math.abs(v.tileID.overscaledZ - Ce) > Math.abs(g.tileID.overscaledZ - Ce), Oe = Se && g.refreshedUponExpiration ? 1 : o.clamp(Se ? H : 1 - J, 0, 1);
            return g.refreshedUponExpiration && H >= 1 && (g.refreshedUponExpiration = !1), v ? { opacity: 1, mix: 1 - Oe } : { opacity: Oe, mix: 0 };
          }
          return { opacity: 1, mix: 0 };
        }
        var xa = new o.Color(1, 0, 0, 1), wa = new o.Color(0, 1, 0, 1), Za = new o.Color(0, 0, 1, 1), _u = new o.Color(1, 0, 1, 1), yu = new o.Color(0, 1, 1, 1);
        function mf(g, v, _, w) {
          vc(g, 0, v + _ / 2, g.transform.width, _, w);
        }
        function yc(g, v, _, w) {
          vc(g, v - _ / 2, 0, _, g.transform.height, w);
        }
        function vc(g, v, _, w, R, D) {
          var k = g.context, H = k.gl;
          H.enable(H.SCISSOR_TEST), H.scissor(v * o.browser.devicePixelRatio, _ * o.browser.devicePixelRatio, w * o.browser.devicePixelRatio, R * o.browser.devicePixelRatio), k.clear({ color: D }), H.disable(H.SCISSOR_TEST);
        }
        function Fh(g, v, _) {
          var w = g.context, R = w.gl, D = _.posMatrix, k = g.useProgram("debug"), H = we.disabled, J = Ne.disabled, oe = g.colorModeForRenderPass();
          w.activeTexture.set(R.TEXTURE0), g.emptyTexture.bind(R.LINEAR, R.CLAMP_TO_EDGE), k.draw(w, R.LINE_STRIP, H, J, oe, Te.disabled, qa(D, o.Color.red), "$debug", g.debugBuffer, g.tileBorderIndexBuffer, g.debugSegments);
          var Ce = v.getTileByID(_.key).latestRawTileData, Se = Math.floor((Ce && Ce.byteLength || 0) / 1024), Oe = v.getTile(_).tileSize, He = 512 / Math.min(Oe, 512) * (_.overscaledZ / g.transform.zoom) * 0.5, ze = _.canonical.toString();
          _.overscaledZ !== _.canonical.z && (ze += " => " + _.overscaledZ), (function(h, f) {
            h.initDebugOverlayCanvas();
            var A = h.debugOverlayCanvas, b = h.context.gl, T = h.debugOverlayCanvas.getContext("2d");
            T.clearRect(0, 0, A.width, A.height), T.shadowColor = "white", T.shadowBlur = 2, T.lineWidth = 1.5, T.strokeStyle = "white", T.textBaseline = "top", T.font = "bold 36px Open Sans, sans-serif", T.fillText(f, 5, 5), T.strokeText(f, 5, 5), h.debugOverlayTexture.update(A), h.debugOverlayTexture.bind(b.LINEAR, b.CLAMP_TO_EDGE);
          })(g, ze + " " + Se + "kb"), k.draw(w, R.TRIANGLES, H, J, pe.alphaBlended, Te.disabled, qa(D, o.Color.transparent, He), "$debug", g.debugBuffer, g.quadTriangleIndexBuffer, g.debugSegments);
        }
        var ia = { symbol: function(g, v, _, w, R) {
          if (g.renderPass === "translucent") {
            var D = Ne.disabled, k = g.colorModeForRenderPass();
            _.layout.get("text-variable-anchor") && (function(H, J, oe, Ce, Se, Oe, He) {
              for (var ze = J.transform, h = Se === "map", f = Oe === "map", A = 0, b = H; A < b.length; A += 1) {
                var T = b[A], C = Ce.getTile(T), I = C.getBucket(oe);
                if (I && I.text && I.text.segments.get().length) {
                  var B = o.evaluateSizeForZoom(I.textSizeData, ze.zoom), F = Fn(C, 1, J.transform.zoom), z = hr(T.posMatrix, f, h, J.transform, F), W = oe.layout.get("icon-text-fit") !== "none" && I.hasIconData();
                  if (B) {
                    var ue = Math.pow(2, ze.zoom - C.tileID.overscaledZ);
                    ys(I, h, f, He, o.symbolSize, ze, z, T.posMatrix, ue, B, W);
                  }
                }
              }
            })(w, g, _, v, _.layout.get("text-rotation-alignment"), _.layout.get("text-pitch-alignment"), R), _.paint.get("icon-opacity").constantOr(1) !== 0 && Xs(g, v, _, w, !1, _.paint.get("icon-translate"), _.paint.get("icon-translate-anchor"), _.layout.get("icon-rotation-alignment"), _.layout.get("icon-pitch-alignment"), _.layout.get("icon-keep-upright"), D, k), _.paint.get("text-opacity").constantOr(1) !== 0 && Xs(g, v, _, w, !0, _.paint.get("text-translate"), _.paint.get("text-translate-anchor"), _.layout.get("text-rotation-alignment"), _.layout.get("text-pitch-alignment"), _.layout.get("text-keep-upright"), D, k), v.map.showCollisionBoxes && (Rl(g, v, _, w, _.paint.get("text-translate"), _.paint.get("text-translate-anchor"), !0), Rl(g, v, _, w, _.paint.get("icon-translate"), _.paint.get("icon-translate-anchor"), !1));
          }
        }, circle: function(g, v, _, w) {
          if (g.renderPass === "translucent") {
            var R = _.paint.get("circle-opacity"), D = _.paint.get("circle-stroke-width"), k = _.paint.get("circle-stroke-opacity"), H = _.layout.get("circle-sort-key").constantOr(1) !== void 0;
            if (R.constantOr(1) !== 0 || D.constantOr(1) !== 0 && k.constantOr(1) !== 0) {
              for (var J = g.context, oe = J.gl, Ce = g.depthModeForSublayer(0, we.ReadOnly), Se = Ne.disabled, Oe = g.colorModeForRenderPass(), He = [], ze = 0; ze < w.length; ze++) {
                var h = w[ze], f = v.getTile(h), A = f.getBucket(_);
                if (A) {
                  var b = A.programConfigurations.get(_.id), T = { programConfiguration: b, program: g.useProgram("circle", b), layoutVertexBuffer: A.layoutVertexBuffer, indexBuffer: A.indexBuffer, uniformValues: ff(g, h, f, _) };
                  if (H) for (var C = 0, I = A.segments.get(); C < I.length; C += 1) {
                    var B = I[C];
                    He.push({ segments: new o.SegmentVector([B]), sortKey: B.sortKey, state: T });
                  }
                  else He.push({ segments: A.segments, sortKey: 0, state: T });
                }
              }
              H && He.sort((function(Ie, Re) {
                return Ie.sortKey - Re.sortKey;
              }));
              for (var F = 0, z = He; F < z.length; F += 1) {
                var W = z[F], ue = W.state;
                ue.program.draw(J, oe.TRIANGLES, Ce, Se, Oe, Te.disabled, ue.uniformValues, _.id, ue.layoutVertexBuffer, ue.indexBuffer, W.segments, _.paint, g.transform.zoom, ue.programConfiguration);
              }
            }
          }
        }, heatmap: function(g, v, _, w) {
          if (_.paint.get("heatmap-opacity") !== 0) if (g.renderPass === "offscreen") {
            var R = g.context, D = R.gl, k = Ne.disabled, H = new pe([D.ONE, D.ONE], o.Color.transparent, [!0, !0, !0, !0]);
            (function(He, ze, h) {
              var f = He.gl;
              He.activeTexture.set(f.TEXTURE1), He.viewport.set([0, 0, ze.width / 4, ze.height / 4]);
              var A = h.heatmapFbo;
              if (A) f.bindTexture(f.TEXTURE_2D, A.colorAttachment.get()), He.bindFramebuffer.set(A.framebuffer);
              else {
                var b = f.createTexture();
                f.bindTexture(f.TEXTURE_2D, b), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_S, f.CLAMP_TO_EDGE), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_T, f.CLAMP_TO_EDGE), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MIN_FILTER, f.LINEAR), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MAG_FILTER, f.LINEAR), A = h.heatmapFbo = He.createFramebuffer(ze.width / 4, ze.height / 4, !1), (function(T, C, I, B) {
                  var F = T.gl;
                  F.texImage2D(F.TEXTURE_2D, 0, F.RGBA, C.width / 4, C.height / 4, 0, F.RGBA, T.extRenderToTextureHalfFloat ? T.extTextureHalfFloat.HALF_FLOAT_OES : F.UNSIGNED_BYTE, null), B.colorAttachment.set(I);
                })(He, ze, b, A);
              }
            })(R, g, _), R.clear({ color: o.Color.transparent });
            for (var J = 0; J < w.length; J++) {
              var oe = w[J];
              if (!v.hasRenderableParent(oe)) {
                var Ce = v.getTile(oe), Se = Ce.getBucket(_);
                if (Se) {
                  var Oe = Se.programConfigurations.get(_.id);
                  g.useProgram("heatmap", Oe).draw(R, D.TRIANGLES, we.disabled, k, H, Te.disabled, hf(oe.posMatrix, Ce, g.transform.zoom, _.paint.get("heatmap-intensity")), _.id, Se.layoutVertexBuffer, Se.indexBuffer, Se.segments, _.paint, g.transform.zoom, Oe);
                }
              }
            }
            R.viewport.set([0, 0, g.width, g.height]);
          } else g.renderPass === "translucent" && (g.context.setColorMode(g.colorModeForRenderPass()), (function(He, ze) {
            var h = He.context, f = h.gl, A = ze.heatmapFbo;
            if (A) {
              h.activeTexture.set(f.TEXTURE0), f.bindTexture(f.TEXTURE_2D, A.colorAttachment.get()), h.activeTexture.set(f.TEXTURE1);
              var b = ze.colorRampTexture;
              b || (b = ze.colorRampTexture = new o.Texture(h, ze.colorRamp, f.RGBA)), b.bind(f.LINEAR, f.CLAMP_TO_EDGE), He.useProgram("heatmapTexture").draw(h, f.TRIANGLES, we.disabled, Ne.disabled, He.colorModeForRenderPass(), Te.disabled, (function(T, C, I, B) {
                var F = o.create();
                o.ortho(F, 0, T.width, T.height, 0, 0, 1);
                var z = T.context.gl;
                return { u_matrix: F, u_world: [z.drawingBufferWidth, z.drawingBufferHeight], u_image: 0, u_color_ramp: 1, u_opacity: C.paint.get("heatmap-opacity") };
              })(He, ze), ze.id, He.viewportBuffer, He.quadTriangleIndexBuffer, He.viewportSegments, ze.paint, He.transform.zoom);
            }
          })(g, _));
        }, line: function(g, v, _, w) {
          if (g.renderPass === "translucent") {
            var R = _.paint.get("line-opacity"), D = _.paint.get("line-width");
            if (R.constantOr(1) !== 0 && D.constantOr(1) !== 0) for (var k = g.depthModeForSublayer(0, we.ReadOnly), H = g.colorModeForRenderPass(), J = _.paint.get("line-dasharray"), oe = _.paint.get("line-pattern"), Ce = oe.constantOr(1), Se = _.paint.get("line-gradient"), Oe = _.getCrossfadeParameters(), He = Ce ? "linePattern" : J ? "lineSDF" : Se ? "lineGradient" : "line", ze = g.context, h = ze.gl, f = !0, A = 0, b = w; A < b.length; A += 1) {
              var T = b[A], C = v.getTile(T);
              if (!Ce || C.patternsLoaded()) {
                var I = C.getBucket(_);
                if (I) {
                  var B = I.programConfigurations.get(_.id), F = g.context.program.get(), z = g.useProgram(He, B), W = f || z.program !== F, ue = oe.constantOr(null);
                  if (ue && C.imageAtlas) {
                    var Ie = C.imageAtlas, Re = Ie.patternPositions[ue.to.toString()], Be = Ie.patternPositions[ue.from.toString()];
                    Re && Be && B.setConstantPatternPositions(Re, Be);
                  }
                  var Ze = Ce ? Sl(g, C, _, Oe) : J ? Dh(g, C, _, J, Oe) : Se ? Un(g, C, _, I.lineClipsArray.length) : Vo(g, C, _);
                  if (Ce) ze.activeTexture.set(h.TEXTURE0), C.imageAtlasTexture.bind(h.LINEAR, h.CLAMP_TO_EDGE), B.updatePaintBuffers(Oe);
                  else if (J && (W || g.lineAtlas.dirty)) ze.activeTexture.set(h.TEXTURE0), g.lineAtlas.bind(ze);
                  else if (Se) {
                    var We = I.gradients[_.id], rt = We.texture;
                    if (_.gradientVersion !== We.version) {
                      var et = 256;
                      if (_.stepInterpolant) {
                        var Je = v.getSource().maxzoom, $e = T.canonical.z === Je ? Math.ceil(1 << g.transform.maxZoom - T.canonical.z) : 1;
                        et = o.clamp(o.nextPowerOfTwo(I.maxLineLength / o.EXTENT * 1024 * $e), 256, ze.maxTextureSize);
                      }
                      We.gradient = o.renderColorRamp({ expression: _.gradientExpression(), evaluationKey: "lineProgress", resolution: et, image: We.gradient || void 0, clips: I.lineClipsArray }), We.texture ? We.texture.update(We.gradient) : We.texture = new o.Texture(ze, We.gradient, h.RGBA), We.version = _.gradientVersion, rt = We.texture;
                    }
                    ze.activeTexture.set(h.TEXTURE0), rt.bind(_.stepInterpolant ? h.NEAREST : h.LINEAR, h.CLAMP_TO_EDGE);
                  }
                  z.draw(ze, h.TRIANGLES, k, g.stencilModeForClipping(T), H, Te.disabled, Ze, _.id, I.layoutVertexBuffer, I.indexBuffer, I.segments, _.paint, g.transform.zoom, B, I.layoutVertexBuffer2), f = !1;
                }
              }
            }
          }
        }, fill: function(g, v, _, w) {
          var R = _.paint.get("fill-color"), D = _.paint.get("fill-opacity");
          if (D.constantOr(1) !== 0) {
            var k = g.colorModeForRenderPass(), H = _.paint.get("fill-pattern"), J = g.opaquePassEnabledForLayer() && !H.constantOr(1) && R.constantOr(o.Color.transparent).a === 1 && D.constantOr(0) === 1 ? "opaque" : "translucent";
            if (g.renderPass === J) {
              var oe = g.depthModeForSublayer(1, g.renderPass === "opaque" ? we.ReadWrite : we.ReadOnly);
              Bl(g, v, _, w, oe, k, !1);
            }
            if (g.renderPass === "translucent" && _.paint.get("fill-antialias")) {
              var Ce = g.depthModeForSublayer(_.getPaintProperty("fill-outline-color") ? 2 : 0, we.ReadOnly);
              Bl(g, v, _, w, Ce, k, !0);
            }
          }
        }, "fill-extrusion": function(g, v, _, w) {
          var R = _.paint.get("fill-extrusion-opacity");
          if (R !== 0 && g.renderPass === "translucent") {
            var D = new we(g.context.gl.LEQUAL, we.ReadWrite, g.depthRangeFor3D);
            if (R !== 1 || _.paint.get("fill-extrusion-pattern").constantOr(1)) Af(g, v, _, w, D, Ne.disabled, pe.disabled), Af(g, v, _, w, D, g.stencilModeFor3D(), g.colorModeForRenderPass());
            else {
              var k = g.colorModeForRenderPass();
              Af(g, v, _, w, D, Ne.disabled, k);
            }
          }
        }, hillshade: function(g, v, _, w) {
          if (g.renderPass === "offscreen" || g.renderPass === "translucent") {
            for (var R = g.context, D = g.depthModeForSublayer(0, we.ReadOnly), k = g.colorModeForRenderPass(), H = g.renderPass === "translucent" ? g.stencilConfigForOverlap(w) : [{}, w], J = H[0], oe = 0, Ce = H[1]; oe < Ce.length; oe += 1) {
              var Se = Ce[oe], Oe = v.getTile(Se);
              Oe.needsHillshadePrepare && g.renderPass === "offscreen" ? gf(g, Oe, _, D, Ne.disabled, k) : g.renderPass === "translucent" && vs(g, Oe, _, D, J[Se.overscaledZ], k);
            }
            R.viewport.set([0, 0, g.width, g.height]);
          }
        }, raster: function(g, v, _, w) {
          if (g.renderPass === "translucent" && _.paint.get("raster-opacity") !== 0 && w.length) for (var R = g.context, D = R.gl, k = v.getSource(), H = g.useProgram("raster"), J = g.colorModeForRenderPass(), oe = k instanceof gt ? [{}, w] : g.stencilConfigForOverlap(w), Ce = oe[0], Se = oe[1], Oe = Se[Se.length - 1].overscaledZ, He = !g.options.moving, ze = 0, h = Se; ze < h.length; ze += 1) {
            var f = h[ze], A = g.depthModeForSublayer(f.overscaledZ - Oe, _.paint.get("raster-opacity") === 1 ? we.ReadWrite : we.ReadOnly, D.LESS), b = v.getTile(f), T = g.transform.calculatePosMatrix(f.toUnwrapped(), He);
            b.registerFadeDuration(_.paint.get("raster-fade-duration"));
            var C = v.findLoadedParent(f, 0), I = Ol(b, C, v, _, g.transform), B = void 0, F = void 0, z = _.paint.get("raster-resampling") === "nearest" ? D.NEAREST : D.LINEAR;
            R.activeTexture.set(D.TEXTURE0), b.texture.bind(z, D.CLAMP_TO_EDGE, D.LINEAR_MIPMAP_NEAREST), R.activeTexture.set(D.TEXTURE1), C ? (C.texture.bind(z, D.CLAMP_TO_EDGE, D.LINEAR_MIPMAP_NEAREST), B = Math.pow(2, C.tileID.overscaledZ - b.tileID.overscaledZ), F = [b.tileID.canonical.x * B % 1, b.tileID.canonical.y * B % 1]) : b.texture.bind(z, D.CLAMP_TO_EDGE, D.LINEAR_MIPMAP_NEAREST);
            var W = pf(T, F || [0, 0], B || 1, I, _);
            k instanceof gt ? H.draw(R, D.TRIANGLES, A, Ne.disabled, J, Te.disabled, W, _.id, k.boundsBuffer, g.quadTriangleIndexBuffer, k.boundsSegments) : H.draw(R, D.TRIANGLES, A, Ce[f.overscaledZ], J, Te.disabled, W, _.id, g.rasterBoundsBuffer, g.quadTriangleIndexBuffer, g.rasterBoundsSegments);
          }
        }, background: function(g, v, _) {
          var w = _.paint.get("background-color"), R = _.paint.get("background-opacity");
          if (R !== 0) {
            var D = g.context, k = D.gl, H = g.transform, J = H.tileSize, oe = _.paint.get("background-pattern");
            if (!g.isPatternMissing(oe)) {
              var Ce = !oe && w.a === 1 && R === 1 && g.opaquePassEnabledForLayer() ? "opaque" : "translucent";
              if (g.renderPass === Ce) {
                var Se = Ne.disabled, Oe = g.depthModeForSublayer(0, Ce === "opaque" ? we.ReadWrite : we.ReadOnly), He = g.colorModeForRenderPass(), ze = g.useProgram(oe ? "backgroundPattern" : "background"), h = H.coveringTiles({ tileSize: J });
                oe && (D.activeTexture.set(k.TEXTURE0), g.imageManager.bind(g.context));
                for (var f = _.getCrossfadeParameters(), A = 0, b = h; A < b.length; A += 1) {
                  var T = b[A], C = g.transform.calculatePosMatrix(T.toUnwrapped()), I = oe ? Xa(C, R, g, oe, { tileID: T, tileSize: J }, f) : Ml(C, R, w);
                  ze.draw(D, k.TRIANGLES, Oe, Se, He, Te.disabled, I, _.id, g.tileExtentBuffer, g.quadTriangleIndexBuffer, g.tileExtentSegments);
                }
              }
            }
          }
        }, debug: function(g, v, _) {
          for (var w = 0; w < _.length; w++) Fh(g, v, _[w]);
        }, custom: function(g, v, _) {
          var w = g.context, R = _.implementation;
          if (g.renderPass === "offscreen") {
            var D = R.prerender;
            D && (g.setCustomLayerDefaults(), w.setColorMode(g.colorModeForRenderPass()), D.call(R, w.gl, g.transform.customLayerMatrix()), w.setDirty(), g.setBaseState());
          } else if (g.renderPass === "translucent") {
            g.setCustomLayerDefaults(), w.setColorMode(g.colorModeForRenderPass()), w.setStencilMode(Ne.disabled);
            var k = R.renderingMode === "3d" ? new we(g.context.gl.LEQUAL, we.ReadWrite, g.depthRangeFor3D) : g.depthModeForSublayer(0, we.ReadOnly);
            w.setDepthMode(k), R.render(w.gl, g.transform.customLayerMatrix()), w.setDirty(), g.setBaseState(), w.bindFramebuffer.set(null);
          }
        } }, Gn = function(g, v) {
          this.context = new le(g), this.transform = v, this._tileTextures = {}, this.setup(), this.numSublayers = ge.maxUnderzooming + ge.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Jo(), this.gpuTimers = {};
        };
        Gn.prototype.resize = function(g, v) {
          if (this.width = g * o.browser.devicePixelRatio, this.height = v * o.browser.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (var _ = 0, w = this.style._order; _ < w.length; _ += 1) this.style._layers[w[_]].resize();
        }, Gn.prototype.setup = function() {
          var g = this.context, v = new o.StructArrayLayout2i4();
          v.emplaceBack(0, 0), v.emplaceBack(o.EXTENT, 0), v.emplaceBack(0, o.EXTENT), v.emplaceBack(o.EXTENT, o.EXTENT), this.tileExtentBuffer = g.createVertexBuffer(v, gi.members), this.tileExtentSegments = o.SegmentVector.simpleSegment(0, 0, 4, 2);
          var _ = new o.StructArrayLayout2i4();
          _.emplaceBack(0, 0), _.emplaceBack(o.EXTENT, 0), _.emplaceBack(0, o.EXTENT), _.emplaceBack(o.EXTENT, o.EXTENT), this.debugBuffer = g.createVertexBuffer(_, gi.members), this.debugSegments = o.SegmentVector.simpleSegment(0, 0, 4, 5);
          var w = new o.StructArrayLayout4i8();
          w.emplaceBack(0, 0, 0, 0), w.emplaceBack(o.EXTENT, 0, o.EXTENT, 0), w.emplaceBack(0, o.EXTENT, 0, o.EXTENT), w.emplaceBack(o.EXTENT, o.EXTENT, o.EXTENT, o.EXTENT), this.rasterBoundsBuffer = g.createVertexBuffer(w, ct.members), this.rasterBoundsSegments = o.SegmentVector.simpleSegment(0, 0, 4, 2);
          var R = new o.StructArrayLayout2i4();
          R.emplaceBack(0, 0), R.emplaceBack(1, 0), R.emplaceBack(0, 1), R.emplaceBack(1, 1), this.viewportBuffer = g.createVertexBuffer(R, gi.members), this.viewportSegments = o.SegmentVector.simpleSegment(0, 0, 4, 2);
          var D = new o.StructArrayLayout1ui2();
          D.emplaceBack(0), D.emplaceBack(1), D.emplaceBack(3), D.emplaceBack(2), D.emplaceBack(0), this.tileBorderIndexBuffer = g.createIndexBuffer(D);
          var k = new o.StructArrayLayout3ui6();
          k.emplaceBack(0, 1, 2), k.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = g.createIndexBuffer(k), this.emptyTexture = new o.Texture(g, { width: 1, height: 1, data: new Uint8Array([0, 0, 0, 0]) }, g.gl.RGBA);
          var H = this.context.gl;
          this.stencilClearMode = new Ne({ func: H.ALWAYS, mask: 0 }, 0, 255, H.ZERO, H.ZERO, H.ZERO);
        }, Gn.prototype.clearStencil = function() {
          var g = this.context, v = g.gl;
          this.nextStencilID = 1, this.currentStencilSource = void 0;
          var _ = o.create();
          o.ortho(_, 0, this.width, this.height, 0, 0, 1), o.scale(_, _, [v.drawingBufferWidth, v.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(g, v.TRIANGLES, we.disabled, this.stencilClearMode, pe.disabled, Te.disabled, na(_), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
        }, Gn.prototype._renderTileClippingMasks = function(g, v) {
          if (this.currentStencilSource !== g.source && g.isTileClipped() && v && v.length) {
            this.currentStencilSource = g.source;
            var _ = this.context, w = _.gl;
            this.nextStencilID + v.length > 256 && this.clearStencil(), _.setColorMode(pe.disabled), _.setDepthMode(we.disabled);
            var R = this.useProgram("clippingMask");
            this._tileClippingMaskIDs = {};
            for (var D = 0, k = v; D < k.length; D += 1) {
              var H = k[D], J = this._tileClippingMaskIDs[H.key] = this.nextStencilID++;
              R.draw(_, w.TRIANGLES, we.disabled, new Ne({ func: w.ALWAYS, mask: 0 }, J, 255, w.KEEP, w.KEEP, w.REPLACE), pe.disabled, Te.disabled, na(H.posMatrix), "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
            }
          }
        }, Gn.prototype.stencilModeFor3D = function() {
          this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
          var g = this.nextStencilID++, v = this.context.gl;
          return new Ne({ func: v.NOTEQUAL, mask: 255 }, g, 255, v.KEEP, v.KEEP, v.REPLACE);
        }, Gn.prototype.stencilModeForClipping = function(g) {
          var v = this.context.gl;
          return new Ne({ func: v.EQUAL, mask: 255 }, this._tileClippingMaskIDs[g.key], 0, v.KEEP, v.KEEP, v.REPLACE);
        }, Gn.prototype.stencilConfigForOverlap = function(g) {
          var v, _ = this.context.gl, w = g.sort((function(J, oe) {
            return oe.overscaledZ - J.overscaledZ;
          })), R = w[w.length - 1].overscaledZ, D = w[0].overscaledZ - R + 1;
          if (D > 1) {
            this.currentStencilSource = void 0, this.nextStencilID + D > 256 && this.clearStencil();
            for (var k = {}, H = 0; H < D; H++) k[H + R] = new Ne({ func: _.GEQUAL, mask: 255 }, H + this.nextStencilID, 255, _.KEEP, _.KEEP, _.REPLACE);
            return this.nextStencilID += D, [k, w];
          }
          return [(v = {}, v[R] = Ne.disabled, v), w];
        }, Gn.prototype.colorModeForRenderPass = function() {
          var g = this.context.gl;
          return this._showOverdrawInspector ? new pe([g.CONSTANT_COLOR, g.ONE], new o.Color(1 / 8, 1 / 8, 1 / 8, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? pe.unblended : pe.alphaBlended;
        }, Gn.prototype.depthModeForSublayer = function(g, v, _) {
          if (!this.opaquePassEnabledForLayer()) return we.disabled;
          var w = 1 - ((1 + this.currentLayer) * this.numSublayers + g) * this.depthEpsilon;
          return new we(_ || this.context.gl.LEQUAL, v, [w, w]);
        }, Gn.prototype.opaquePassEnabledForLayer = function() {
          return this.currentLayer < this.opaquePassCutoff;
        }, Gn.prototype.render = function(g, v) {
          var _ = this;
          this.style = g, this.options = v, this.lineAtlas = g.lineAtlas, this.imageManager = g.imageManager, this.glyphManager = g.glyphManager, this.symbolFadeChange = g.placement.symbolFadeChange(o.browser.now()), this.imageManager.beginFrame();
          var w = this.style._order, R = this.style.sourceCaches;
          for (var D in R) {
            var k = R[D];
            k.used && k.prepare(this.context);
          }
          var H, J, oe = {}, Ce = {}, Se = {};
          for (var Oe in R) {
            var He = R[Oe];
            oe[Oe] = He.getVisibleCoordinates(), Ce[Oe] = oe[Oe].slice().reverse(), Se[Oe] = He.getVisibleCoordinates(!0).reverse();
          }
          this.opaquePassCutoff = 1 / 0;
          for (var ze = 0; ze < w.length; ze++) if (this.style._layers[w[ze]].is3D()) {
            this.opaquePassCutoff = ze;
            break;
          }
          this.renderPass = "offscreen";
          for (var h = 0, f = w; h < f.length; h += 1) {
            var A = this.style._layers[f[h]];
            if (A.hasOffscreenPass() && !A.isHidden(this.transform.zoom)) {
              var b = Ce[A.source];
              (A.type === "custom" || b.length) && this.renderLayer(this, R[A.source], A, b);
            }
          }
          for (this.context.bindFramebuffer.set(null), this.context.clear({ color: v.showOverdrawInspector ? o.Color.black : o.Color.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = v.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (g._order.length + 2) * this.numSublayers * this.depthEpsilon], this.renderPass = "opaque", this.currentLayer = w.length - 1; this.currentLayer >= 0; this.currentLayer--) {
            var T = this.style._layers[w[this.currentLayer]], C = R[T.source], I = oe[T.source];
            this._renderTileClippingMasks(T, I), this.renderLayer(this, C, T, I);
          }
          for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < w.length; this.currentLayer++) {
            var B = this.style._layers[w[this.currentLayer]], F = R[B.source], z = (B.type === "symbol" ? Se : Ce)[B.source];
            this._renderTileClippingMasks(B, oe[B.source]), this.renderLayer(this, F, B, z);
          }
          this.options.showTileBoundaries && (o.values(this.style._layers).forEach((function(W) {
            W.source && !W.isHidden(_.transform.zoom) && (W.source !== (J && J.id) && (J = _.style.sourceCaches[W.source]), (!H || H.getSource().maxzoom < J.getSource().maxzoom) && (H = J));
          })), H && ia.debug(this, H, H.getVisibleCoordinates())), this.options.showPadding && (function(W) {
            var ue = W.transform.padding;
            mf(W, W.transform.height - (ue.top || 0), 3, xa), mf(W, ue.bottom || 0, 3, wa), yc(W, ue.left || 0, 3, Za), yc(W, W.transform.width - (ue.right || 0), 3, _u);
            var Ie = W.transform.centerPoint;
            (function(Re, Be, Ze, We) {
              vc(Re, Be - 1, Ze - 10, 2, 20, We), vc(Re, Be - 10, Ze - 1, 20, 2, We);
            })(W, Ie.x, W.transform.height - Ie.y, yu);
          })(this), this.context.setDefault();
        }, Gn.prototype.renderLayer = function(g, v, _, w) {
          _.isHidden(this.transform.zoom) || (_.type === "background" || _.type === "custom" || w.length) && (this.id = _.id, this.gpuTimingStart(_), ia[_.type](g, v, _, w, this.style.placement.variableOffsets), this.gpuTimingEnd());
        }, Gn.prototype.gpuTimingStart = function(g) {
          if (this.options.gpuTiming) {
            var v = this.context.extTimerQuery, _ = this.gpuTimers[g.id];
            _ || (_ = this.gpuTimers[g.id] = { calls: 0, cpuTime: 0, query: v.createQueryEXT() }), _.calls++, v.beginQueryEXT(v.TIME_ELAPSED_EXT, _.query);
          }
        }, Gn.prototype.gpuTimingEnd = function() {
          if (this.options.gpuTiming) {
            var g = this.context.extTimerQuery;
            g.endQueryEXT(g.TIME_ELAPSED_EXT);
          }
        }, Gn.prototype.collectGpuTimers = function() {
          var g = this.gpuTimers;
          return this.gpuTimers = {}, g;
        }, Gn.prototype.queryGpuTimers = function(g) {
          var v = {};
          for (var _ in g) {
            var w = g[_], R = this.context.extTimerQuery, D = R.getQueryObjectEXT(w.query, R.QUERY_RESULT_EXT) / 1e6;
            R.deleteQueryEXT(w.query), v[_] = D;
          }
          return v;
        }, Gn.prototype.translatePosMatrix = function(g, v, _, w, R) {
          if (!_[0] && !_[1]) return g;
          var D = R ? w === "map" ? this.transform.angle : 0 : w === "viewport" ? -this.transform.angle : 0;
          if (D) {
            var k = Math.sin(D), H = Math.cos(D);
            _ = [_[0] * H - _[1] * k, _[0] * k + _[1] * H];
          }
          var J = [R ? _[0] : Fn(v, _[0], this.transform.zoom), R ? _[1] : Fn(v, _[1], this.transform.zoom), 0], oe = new Float32Array(16);
          return o.translate(oe, g, J), oe;
        }, Gn.prototype.saveTileTexture = function(g) {
          var v = this._tileTextures[g.size[0]];
          v ? v.push(g) : this._tileTextures[g.size[0]] = [g];
        }, Gn.prototype.getTileTexture = function(g) {
          var v = this._tileTextures[g];
          return v && v.length > 0 ? v.pop() : null;
        }, Gn.prototype.isPatternMissing = function(g) {
          if (!g) return !1;
          if (!g.from || !g.to) return !0;
          var v = this.imageManager.getPattern(g.from.toString()), _ = this.imageManager.getPattern(g.to.toString());
          return !v || !_;
        }, Gn.prototype.useProgram = function(g, v) {
          this.cache = this.cache || {};
          var _ = "" + g + (v ? v.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "");
          return this.cache[_] || (this.cache[_] = new Mh(this.context, g, Ih[g], v, Lh[g], this._showOverdrawInspector)), this.cache[_];
        }, Gn.prototype.setCustomLayerDefaults = function() {
          this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
        }, Gn.prototype.setBaseState = function() {
          var g = this.context.gl;
          this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(g.FUNC_ADD);
        }, Gn.prototype.initDebugOverlayCanvas = function() {
          this.debugOverlayCanvas == null && (this.debugOverlayCanvas = o.window.document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new o.Texture(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
        }, Gn.prototype.destroy = function() {
          this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy();
        };
        var Dl = function(g, v) {
          this.points = g, this.planes = v;
        };
        Dl.fromInvProjectionMatrix = function(g, v, _) {
          var w = Math.pow(2, _), R = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((function(k) {
            return o.transformMat4([], k, g);
          })).map((function(k) {
            return o.scale$1([], k, 1 / k[3] / v * w);
          })), D = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((function(k) {
            var H = o.sub([], R[k[0]], R[k[1]]), J = o.sub([], R[k[2]], R[k[1]]), oe = o.normalize([], o.cross([], H, J)), Ce = -o.dot(oe, R[k[1]]);
            return oe.concat(Ce);
          }));
          return new Dl(R, D);
        };
        var bo = function(g, v) {
          this.min = g, this.max = v, this.center = o.scale$2([], o.add([], this.min, this.max), 0.5);
        };
        bo.prototype.quadrant = function(g) {
          for (var v = [g % 2 == 0, g < 2], _ = o.clone$2(this.min), w = o.clone$2(this.max), R = 0; R < v.length; R++) _[R] = v[R] ? this.min[R] : this.center[R], w[R] = v[R] ? this.center[R] : this.max[R];
          return w[2] = this.max[2], new bo(_, w);
        }, bo.prototype.distanceX = function(g) {
          return Math.max(Math.min(this.max[0], g[0]), this.min[0]) - g[0];
        }, bo.prototype.distanceY = function(g) {
          return Math.max(Math.min(this.max[1], g[1]), this.min[1]) - g[1];
        }, bo.prototype.intersects = function(g) {
          for (var v = [[this.min[0], this.min[1], 0, 1], [this.max[0], this.min[1], 0, 1], [this.max[0], this.max[1], 0, 1], [this.min[0], this.max[1], 0, 1]], _ = !0, w = 0; w < g.planes.length; w++) {
            for (var R = g.planes[w], D = 0, k = 0; k < v.length; k++) D += o.dot$1(R, v[k]) >= 0;
            if (D === 0) return 0;
            D !== v.length && (_ = !1);
          }
          if (_) return 2;
          for (var H = 0; H < 3; H++) {
            for (var J = Number.MAX_VALUE, oe = -Number.MAX_VALUE, Ce = 0; Ce < g.points.length; Ce++) {
              var Se = g.points[Ce][H] - this.min[H];
              J = Math.min(J, Se), oe = Math.max(oe, Se);
            }
            if (oe < 0 || J > this.max[H] - this.min[H]) return 0;
          }
          return 1;
        };
        var Zs = function(g, v, _, w) {
          if (g === void 0 && (g = 0), v === void 0 && (v = 0), _ === void 0 && (_ = 0), w === void 0 && (w = 0), isNaN(g) || g < 0 || isNaN(v) || v < 0 || isNaN(_) || _ < 0 || isNaN(w) || w < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
          this.top = g, this.bottom = v, this.left = _, this.right = w;
        };
        Zs.prototype.interpolate = function(g, v, _) {
          return v.top != null && g.top != null && (this.top = o.number(g.top, v.top, _)), v.bottom != null && g.bottom != null && (this.bottom = o.number(g.bottom, v.bottom, _)), v.left != null && g.left != null && (this.left = o.number(g.left, v.left, _)), v.right != null && g.right != null && (this.right = o.number(g.right, v.right, _)), this;
        }, Zs.prototype.getCenter = function(g, v) {
          var _ = o.clamp((this.left + g - this.right) / 2, 0, g), w = o.clamp((this.top + v - this.bottom) / 2, 0, v);
          return new o.Point(_, w);
        }, Zs.prototype.equals = function(g) {
          return this.top === g.top && this.bottom === g.bottom && this.left === g.left && this.right === g.right;
        }, Zs.prototype.clone = function() {
          return new Zs(this.top, this.bottom, this.left, this.right);
        }, Zs.prototype.toJSON = function() {
          return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
        };
        var qr = function(g, v, _, w, R) {
          this.tileSize = 512, this.maxValidLatitude = 85.051129, this._renderWorldCopies = R === void 0 || R, this._minZoom = g || 0, this._maxZoom = v || 22, this._minPitch = _ ?? 0, this._maxPitch = w ?? 60, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new o.LngLat(0, 0), this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = !0, this._edgeInsets = new Zs(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
        }, zn = { minZoom: { configurable: !0 }, maxZoom: { configurable: !0 }, minPitch: { configurable: !0 }, maxPitch: { configurable: !0 }, renderWorldCopies: { configurable: !0 }, worldSize: { configurable: !0 }, centerOffset: { configurable: !0 }, size: { configurable: !0 }, bearing: { configurable: !0 }, pitch: { configurable: !0 }, fov: { configurable: !0 }, zoom: { configurable: !0 }, center: { configurable: !0 }, padding: { configurable: !0 }, centerPoint: { configurable: !0 }, unmodified: { configurable: !0 }, point: { configurable: !0 } };
        qr.prototype.clone = function() {
          var g = new qr(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
          return g.tileSize = this.tileSize, g.latRange = this.latRange, g.width = this.width, g.height = this.height, g._center = this._center, g.zoom = this.zoom, g.angle = this.angle, g._fov = this._fov, g._pitch = this._pitch, g._unmodified = this._unmodified, g._edgeInsets = this._edgeInsets.clone(), g._calcMatrices(), g;
        }, zn.minZoom.get = function() {
          return this._minZoom;
        }, zn.minZoom.set = function(g) {
          this._minZoom !== g && (this._minZoom = g, this.zoom = Math.max(this.zoom, g));
        }, zn.maxZoom.get = function() {
          return this._maxZoom;
        }, zn.maxZoom.set = function(g) {
          this._maxZoom !== g && (this._maxZoom = g, this.zoom = Math.min(this.zoom, g));
        }, zn.minPitch.get = function() {
          return this._minPitch;
        }, zn.minPitch.set = function(g) {
          this._minPitch !== g && (this._minPitch = g, this.pitch = Math.max(this.pitch, g));
        }, zn.maxPitch.get = function() {
          return this._maxPitch;
        }, zn.maxPitch.set = function(g) {
          this._maxPitch !== g && (this._maxPitch = g, this.pitch = Math.min(this.pitch, g));
        }, zn.renderWorldCopies.get = function() {
          return this._renderWorldCopies;
        }, zn.renderWorldCopies.set = function(g) {
          g === void 0 ? g = !0 : g === null && (g = !1), this._renderWorldCopies = g;
        }, zn.worldSize.get = function() {
          return this.tileSize * this.scale;
        }, zn.centerOffset.get = function() {
          return this.centerPoint._sub(this.size._div(2));
        }, zn.size.get = function() {
          return new o.Point(this.width, this.height);
        }, zn.bearing.get = function() {
          return -this.angle / Math.PI * 180;
        }, zn.bearing.set = function(g) {
          var v = -o.wrap(g, -180, 180) * Math.PI / 180;
          this.angle !== v && (this._unmodified = !1, this.angle = v, this._calcMatrices(), this.rotationMatrix = o.create$2(), o.rotate(this.rotationMatrix, this.rotationMatrix, this.angle));
        }, zn.pitch.get = function() {
          return this._pitch / Math.PI * 180;
        }, zn.pitch.set = function(g) {
          var v = o.clamp(g, this.minPitch, this.maxPitch) / 180 * Math.PI;
          this._pitch !== v && (this._unmodified = !1, this._pitch = v, this._calcMatrices());
        }, zn.fov.get = function() {
          return this._fov / Math.PI * 180;
        }, zn.fov.set = function(g) {
          g = Math.max(0.01, Math.min(60, g)), this._fov !== g && (this._unmodified = !1, this._fov = g / 180 * Math.PI, this._calcMatrices());
        }, zn.zoom.get = function() {
          return this._zoom;
        }, zn.zoom.set = function(g) {
          var v = Math.min(Math.max(g, this.minZoom), this.maxZoom);
          this._zoom !== v && (this._unmodified = !1, this._zoom = v, this.scale = this.zoomScale(v), this.tileZoom = Math.floor(v), this.zoomFraction = v - this.tileZoom, this._constrain(), this._calcMatrices());
        }, zn.center.get = function() {
          return this._center;
        }, zn.center.set = function(g) {
          g.lat === this._center.lat && g.lng === this._center.lng || (this._unmodified = !1, this._center = g, this._constrain(), this._calcMatrices());
        }, zn.padding.get = function() {
          return this._edgeInsets.toJSON();
        }, zn.padding.set = function(g) {
          this._edgeInsets.equals(g) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, g, 1), this._calcMatrices());
        }, zn.centerPoint.get = function() {
          return this._edgeInsets.getCenter(this.width, this.height);
        }, qr.prototype.isPaddingEqual = function(g) {
          return this._edgeInsets.equals(g);
        }, qr.prototype.interpolatePadding = function(g, v, _) {
          this._unmodified = !1, this._edgeInsets.interpolate(g, v, _), this._constrain(), this._calcMatrices();
        }, qr.prototype.coveringZoomLevel = function(g) {
          var v = (g.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / g.tileSize));
          return Math.max(0, v);
        }, qr.prototype.getVisibleUnwrappedCoordinates = function(g) {
          var v = [new o.UnwrappedTileID(0, g)];
          if (this._renderWorldCopies) for (var _ = this.pointCoordinate(new o.Point(0, 0)), w = this.pointCoordinate(new o.Point(this.width, 0)), R = this.pointCoordinate(new o.Point(this.width, this.height)), D = this.pointCoordinate(new o.Point(0, this.height)), k = Math.floor(Math.min(_.x, w.x, R.x, D.x)), H = Math.floor(Math.max(_.x, w.x, R.x, D.x)), J = k - 1; J <= H + 1; J++) J !== 0 && v.push(new o.UnwrappedTileID(J, g));
          return v;
        }, qr.prototype.coveringTiles = function(g) {
          var v = this.coveringZoomLevel(g), _ = v;
          if (g.minzoom !== void 0 && v < g.minzoom) return [];
          g.maxzoom !== void 0 && v > g.maxzoom && (v = g.maxzoom);
          var w = o.MercatorCoordinate.fromLngLat(this.center), R = Math.pow(2, v), D = [R * w.x, R * w.y, 0], k = Dl.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, v), H = g.minzoom || 0;
          this.pitch <= 60 && this._edgeInsets.top < 0.1 && (H = v);
          var J = function(W) {
            return { aabb: new bo([W * R, 0, 0], [(W + 1) * R, R, 0]), zoom: 0, x: 0, y: 0, wrap: W, fullyVisible: !1 };
          }, oe = [], Ce = [], Se = v, Oe = g.reparseOverscaled ? _ : v;
          if (this._renderWorldCopies) for (var He = 1; He <= 3; He++) oe.push(J(-He)), oe.push(J(He));
          for (oe.push(J(0)); oe.length > 0; ) {
            var ze = oe.pop(), h = ze.x, f = ze.y, A = ze.fullyVisible;
            if (!A) {
              var b = ze.aabb.intersects(k);
              if (b === 0) continue;
              A = b === 2;
            }
            var T = ze.aabb.distanceX(D), C = ze.aabb.distanceY(D), I = Math.max(Math.abs(T), Math.abs(C));
            if (ze.zoom === Se || I > 3 + (1 << Se - ze.zoom) - 2 && ze.zoom >= H) Ce.push({ tileID: new o.OverscaledTileID(ze.zoom === Se ? Oe : ze.zoom, ze.wrap, ze.zoom, h, f), distanceSq: o.sqrLen([D[0] - 0.5 - h, D[1] - 0.5 - f]) });
            else for (var B = 0; B < 4; B++) {
              var F = (h << 1) + B % 2, z = (f << 1) + (B >> 1);
              oe.push({ aabb: ze.aabb.quadrant(B), zoom: ze.zoom + 1, x: F, y: z, wrap: ze.wrap, fullyVisible: A });
            }
          }
          return Ce.sort((function(W, ue) {
            return W.distanceSq - ue.distanceSq;
          })).map((function(W) {
            return W.tileID;
          }));
        }, qr.prototype.resize = function(g, v) {
          this.width = g, this.height = v, this.pixelsToGLUnits = [2 / g, -2 / v], this._constrain(), this._calcMatrices();
        }, zn.unmodified.get = function() {
          return this._unmodified;
        }, qr.prototype.zoomScale = function(g) {
          return Math.pow(2, g);
        }, qr.prototype.scaleZoom = function(g) {
          return Math.log(g) / Math.LN2;
        }, qr.prototype.project = function(g) {
          var v = o.clamp(g.lat, -this.maxValidLatitude, this.maxValidLatitude);
          return new o.Point(o.mercatorXfromLng(g.lng) * this.worldSize, o.mercatorYfromLat(v) * this.worldSize);
        }, qr.prototype.unproject = function(g) {
          return new o.MercatorCoordinate(g.x / this.worldSize, g.y / this.worldSize).toLngLat();
        }, zn.point.get = function() {
          return this.project(this.center);
        }, qr.prototype.setLocationAtPoint = function(g, v) {
          var _ = this.pointCoordinate(v), w = this.pointCoordinate(this.centerPoint), R = this.locationCoordinate(g), D = new o.MercatorCoordinate(R.x - (_.x - w.x), R.y - (_.y - w.y));
          this.center = this.coordinateLocation(D), this._renderWorldCopies && (this.center = this.center.wrap());
        }, qr.prototype.locationPoint = function(g) {
          return this.coordinatePoint(this.locationCoordinate(g));
        }, qr.prototype.pointLocation = function(g) {
          return this.coordinateLocation(this.pointCoordinate(g));
        }, qr.prototype.locationCoordinate = function(g) {
          return o.MercatorCoordinate.fromLngLat(g);
        }, qr.prototype.coordinateLocation = function(g) {
          return g.toLngLat();
        }, qr.prototype.pointCoordinate = function(g) {
          var v = [g.x, g.y, 0, 1], _ = [g.x, g.y, 1, 1];
          o.transformMat4(v, v, this.pixelMatrixInverse), o.transformMat4(_, _, this.pixelMatrixInverse);
          var w = v[3], R = _[3], D = v[1] / w, k = _[1] / R, H = v[2] / w, J = _[2] / R, oe = H === J ? 0 : (0 - H) / (J - H);
          return new o.MercatorCoordinate(o.number(v[0] / w, _[0] / R, oe) / this.worldSize, o.number(D, k, oe) / this.worldSize);
        }, qr.prototype.coordinatePoint = function(g) {
          var v = [g.x * this.worldSize, g.y * this.worldSize, 0, 1];
          return o.transformMat4(v, v, this.pixelMatrix), new o.Point(v[0] / v[3], v[1] / v[3]);
        }, qr.prototype.getBounds = function() {
          return new o.LngLatBounds().extend(this.pointLocation(new o.Point(0, 0))).extend(this.pointLocation(new o.Point(this.width, 0))).extend(this.pointLocation(new o.Point(this.width, this.height))).extend(this.pointLocation(new o.Point(0, this.height)));
        }, qr.prototype.getMaxBounds = function() {
          return this.latRange && this.latRange.length === 2 && this.lngRange && this.lngRange.length === 2 ? new o.LngLatBounds([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;
        }, qr.prototype.setMaxBounds = function(g) {
          g ? (this.lngRange = [g.getWest(), g.getEast()], this.latRange = [g.getSouth(), g.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-this.maxValidLatitude, this.maxValidLatitude]);
        }, qr.prototype.calculatePosMatrix = function(g, v) {
          v === void 0 && (v = !1);
          var _ = g.key, w = v ? this._alignedPosMatrixCache : this._posMatrixCache;
          if (w[_]) return w[_];
          var R = g.canonical, D = this.worldSize / this.zoomScale(R.z), k = R.x + Math.pow(2, R.z) * g.wrap, H = o.identity(new Float64Array(16));
          return o.translate(H, H, [k * D, R.y * D, 0]), o.scale(H, H, [D / o.EXTENT, D / o.EXTENT, 1]), o.multiply(H, v ? this.alignedProjMatrix : this.projMatrix, H), w[_] = new Float32Array(H), w[_];
        }, qr.prototype.customLayerMatrix = function() {
          return this.mercatorMatrix.slice();
        }, qr.prototype._constrain = function() {
          if (this.center && this.width && this.height && !this._constraining) {
            this._constraining = !0;
            var g, v, _, w, R = -90, D = 90, k = -180, H = 180, J = this.size, oe = this._unmodified;
            if (this.latRange) {
              var Ce = this.latRange;
              R = o.mercatorYfromLat(Ce[1]) * this.worldSize, g = (D = o.mercatorYfromLat(Ce[0]) * this.worldSize) - R < J.y ? J.y / (D - R) : 0;
            }
            if (this.lngRange) {
              var Se = this.lngRange;
              k = o.mercatorXfromLng(Se[0]) * this.worldSize, v = (H = o.mercatorXfromLng(Se[1]) * this.worldSize) - k < J.x ? J.x / (H - k) : 0;
            }
            var Oe = this.point, He = Math.max(v || 0, g || 0);
            if (He) return this.center = this.unproject(new o.Point(v ? (H + k) / 2 : Oe.x, g ? (D + R) / 2 : Oe.y)), this.zoom += this.scaleZoom(He), this._unmodified = oe, void (this._constraining = !1);
            if (this.latRange) {
              var ze = Oe.y, h = J.y / 2;
              ze - h < R && (w = R + h), ze + h > D && (w = D - h);
            }
            if (this.lngRange) {
              var f = Oe.x, A = J.x / 2;
              f - A < k && (_ = k + A), f + A > H && (_ = H - A);
            }
            _ === void 0 && w === void 0 || (this.center = this.unproject(new o.Point(_ !== void 0 ? _ : Oe.x, w !== void 0 ? w : Oe.y))), this._unmodified = oe, this._constraining = !1;
          }
        }, qr.prototype._calcMatrices = function() {
          if (this.height) {
            var g = this.centerOffset;
            this.cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * this.height;
            var v = Math.PI / 2 + this._pitch, _ = this._fov * (0.5 + g.y / this.height), w = Math.sin(_) * this.cameraToCenterDistance / Math.sin(o.clamp(Math.PI - v - _, 0.01, Math.PI - 0.01)), R = this.point, D = R.x, k = R.y, H = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * w + this.cameraToCenterDistance), J = this.height / 50, oe = new Float64Array(16);
            o.perspective(oe, this._fov, this.width / this.height, J, H), oe[8] = 2 * -g.x / this.width, oe[9] = 2 * g.y / this.height, o.scale(oe, oe, [1, -1, 1]), o.translate(oe, oe, [0, 0, -this.cameraToCenterDistance]), o.rotateX(oe, oe, this._pitch), o.rotateZ(oe, oe, this.angle), o.translate(oe, oe, [-D, -k, 0]), this.mercatorMatrix = o.scale([], oe, [this.worldSize, this.worldSize, this.worldSize]), o.scale(oe, oe, [1, 1, o.mercatorZfromAltitude(1, this.center.lat) * this.worldSize, 1]), this.projMatrix = oe, this.invProjMatrix = o.invert([], this.projMatrix);
            var Ce = this.width % 2 / 2, Se = this.height % 2 / 2, Oe = Math.cos(this.angle), He = Math.sin(this.angle), ze = D - Math.round(D) + Oe * Ce + He * Se, h = k - Math.round(k) + Oe * Se + He * Ce, f = new Float64Array(oe);
            if (o.translate(f, f, [ze > 0.5 ? ze - 1 : ze, h > 0.5 ? h - 1 : h, 0]), this.alignedProjMatrix = f, oe = o.create(), o.scale(oe, oe, [this.width / 2, -this.height / 2, 1]), o.translate(oe, oe, [1, -1, 0]), this.labelPlaneMatrix = oe, oe = o.create(), o.scale(oe, oe, [1, -1, 1]), o.translate(oe, oe, [-1, -1, 0]), o.scale(oe, oe, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = oe, this.pixelMatrix = o.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix), !(oe = o.invert(new Float64Array(16), this.pixelMatrix))) throw new Error("failed to invert matrix");
            this.pixelMatrixInverse = oe, this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
          }
        }, qr.prototype.maxPitchScaleFactor = function() {
          if (!this.pixelMatrixInverse) return 1;
          var g = this.pointCoordinate(new o.Point(0, 0)), v = [g.x * this.worldSize, g.y * this.worldSize, 0, 1];
          return o.transformMat4(v, v, this.pixelMatrix)[3] / this.cameraToCenterDistance;
        }, qr.prototype.getCameraPoint = function() {
          var g = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
          return this.centerPoint.add(new o.Point(0, g));
        }, qr.prototype.getCameraQueryGeometry = function(g) {
          var v = this.getCameraPoint();
          if (g.length === 1) return [g[0], v];
          for (var _ = v.x, w = v.y, R = v.x, D = v.y, k = 0, H = g; k < H.length; k += 1) {
            var J = H[k];
            _ = Math.min(_, J.x), w = Math.min(w, J.y), R = Math.max(R, J.x), D = Math.max(D, J.y);
          }
          return [new o.Point(_, w), new o.Point(R, w), new o.Point(R, D), new o.Point(_, D), new o.Point(_, w)];
        }, Object.defineProperties(qr.prototype, zn);
        var ns = function(g) {
          var v, _, w, R;
          this._hashName = g && encodeURIComponent(g), o.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = (v = this._updateHashUnthrottled.bind(this), _ = !1, w = null, R = function() {
            w = null, _ && (v(), w = setTimeout(R, 300), _ = !1);
          }, function() {
            return _ = !0, w || R(), w;
          });
        };
        ns.prototype.addTo = function(g) {
          return this._map = g, o.window.addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;
        }, ns.prototype.remove = function() {
          return o.window.removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this;
        }, ns.prototype.getHashString = function(g) {
          var v = this._map.getCenter(), _ = Math.round(100 * this._map.getZoom()) / 100, w = Math.ceil((_ * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), R = Math.pow(10, w), D = Math.round(v.lng * R) / R, k = Math.round(v.lat * R) / R, H = this._map.getBearing(), J = this._map.getPitch(), oe = "";
          if (oe += g ? "/" + D + "/" + k + "/" + _ : _ + "/" + k + "/" + D, (H || J) && (oe += "/" + Math.round(10 * H) / 10), J && (oe += "/" + Math.round(J)), this._hashName) {
            var Ce = this._hashName, Se = !1, Oe = o.window.location.hash.slice(1).split("&").map((function(He) {
              var ze = He.split("=")[0];
              return ze === Ce ? (Se = !0, ze + "=" + oe) : He;
            })).filter((function(He) {
              return He;
            }));
            return Se || Oe.push(Ce + "=" + oe), "#" + Oe.join("&");
          }
          return "#" + oe;
        }, ns.prototype._getCurrentHash = function() {
          var g, v = this, _ = o.window.location.hash.replace("#", "");
          return this._hashName ? (_.split("&").map((function(w) {
            return w.split("=");
          })).forEach((function(w) {
            w[0] === v._hashName && (g = w);
          })), (g && g[1] || "").split("/")) : _.split("/");
        }, ns.prototype._onHashChange = function() {
          var g = this._getCurrentHash();
          if (g.length >= 3 && !g.some((function(_) {
            return isNaN(_);
          }))) {
            var v = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(g[3] || 0) : this._map.getBearing();
            return this._map.jumpTo({ center: [+g[2], +g[1]], zoom: +g[0], bearing: v, pitch: +(g[4] || 0) }), !0;
          }
          return !1;
        }, ns.prototype._updateHashUnthrottled = function() {
          var g = o.window.location.href.replace(/(#.+)?$/, this.getHashString());
          try {
            o.window.history.replaceState(o.window.history.state, null, g);
          } catch {
          }
        };
        var bc = { linearity: 0.3, easing: o.bezier(0, 0, 0.3, 1) }, Ll = o.extend({ deceleration: 2500, maxSpeed: 1400 }, bc), xc = o.extend({ deceleration: 20, maxSpeed: 1400 }, bc), Nh = o.extend({ deceleration: 1e3, maxSpeed: 360 }, bc), Wp = o.extend({ deceleration: 1e3, maxSpeed: 90 }, bc), wc = function(g) {
          this._map = g, this.clear();
        };
        function Tc(g, v) {
          (!g.duration || g.duration < v.duration) && (g.duration = v.duration, g.easing = v.easing);
        }
        function ao(g, v, _) {
          var w = _.maxSpeed, R = _.linearity, D = _.deceleration, k = o.clamp(g * R / (v / 1e3), -w, w), H = Math.abs(k) / (D * R);
          return { easing: _.easing, duration: 1e3 * H, amount: k * (H / 2) };
        }
        wc.prototype.clear = function() {
          this._inertiaBuffer = [];
        }, wc.prototype.record = function(g) {
          this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: o.browser.now(), settings: g });
        }, wc.prototype._drainInertiaBuffer = function() {
          for (var g = this._inertiaBuffer, v = o.browser.now(); g.length > 0 && v - g[0].time > 160; ) g.shift();
        }, wc.prototype._onMoveEnd = function(g) {
          if (this._drainInertiaBuffer(), !(this._inertiaBuffer.length < 2)) {
            for (var v = { zoom: 0, bearing: 0, pitch: 0, pan: new o.Point(0, 0), pinchAround: void 0, around: void 0 }, _ = 0, w = this._inertiaBuffer; _ < w.length; _ += 1) {
              var R = w[_].settings;
              v.zoom += R.zoomDelta || 0, v.bearing += R.bearingDelta || 0, v.pitch += R.pitchDelta || 0, R.panDelta && v.pan._add(R.panDelta), R.around && (v.around = R.around), R.pinchAround && (v.pinchAround = R.pinchAround);
            }
            var D = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, k = {};
            if (v.pan.mag()) {
              var H = ao(v.pan.mag(), D, o.extend({}, Ll, g || {}));
              k.offset = v.pan.mult(H.amount / v.pan.mag()), k.center = this._map.transform.center, Tc(k, H);
            }
            if (v.zoom) {
              var J = ao(v.zoom, D, xc);
              k.zoom = this._map.transform.zoom + J.amount, Tc(k, J);
            }
            if (v.bearing) {
              var oe = ao(v.bearing, D, Nh);
              k.bearing = this._map.transform.bearing + o.clamp(oe.amount, -179, 179), Tc(k, oe);
            }
            if (v.pitch) {
              var Ce = ao(v.pitch, D, Wp);
              k.pitch = this._map.transform.pitch + Ce.amount, Tc(k, Ce);
            }
            if (k.zoom || k.bearing) {
              var Se = v.pinchAround === void 0 ? v.around : v.pinchAround;
              k.around = Se ? this._map.unproject(Se) : this._map.getCenter();
            }
            return this.clear(), o.extend(k, { noMoveStart: !0 });
          }
        };
        var xi = (function(g) {
          function v(w, R, D, k) {
            k === void 0 && (k = {});
            var H = u.mousePos(R.getCanvasContainer(), D), J = R.unproject(H);
            g.call(this, w, o.extend({ point: H, lngLat: J, originalEvent: D }, k)), this._defaultPrevented = !1, this.target = R;
          }
          g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v;
          var _ = { defaultPrevented: { configurable: !0 } };
          return v.prototype.preventDefault = function() {
            this._defaultPrevented = !0;
          }, _.defaultPrevented.get = function() {
            return this._defaultPrevented;
          }, Object.defineProperties(v.prototype, _), v;
        })(o.Event), Ya = (function(g) {
          function v(w, R, D) {
            var k = w === "touchend" ? D.changedTouches : D.touches, H = u.touchPos(R.getCanvasContainer(), k), J = H.map((function(Se) {
              return R.unproject(Se);
            })), oe = H.reduce((function(Se, Oe, He, ze) {
              return Se.add(Oe.div(ze.length));
            }), new o.Point(0, 0)), Ce = R.unproject(oe);
            g.call(this, w, { points: H, point: oe, lngLats: J, lngLat: Ce, originalEvent: D }), this._defaultPrevented = !1;
          }
          g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v;
          var _ = { defaultPrevented: { configurable: !0 } };
          return v.prototype.preventDefault = function() {
            this._defaultPrevented = !0;
          }, _.defaultPrevented.get = function() {
            return this._defaultPrevented;
          }, Object.defineProperties(v.prototype, _), v;
        })(o.Event), Uh = (function(g) {
          function v(w, R, D) {
            g.call(this, w, { originalEvent: D }), this._defaultPrevented = !1;
          }
          g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v;
          var _ = { defaultPrevented: { configurable: !0 } };
          return v.prototype.preventDefault = function() {
            this._defaultPrevented = !0;
          }, _.defaultPrevented.get = function() {
            return this._defaultPrevented;
          }, Object.defineProperties(v.prototype, _), v;
        })(o.Event), wi = function(g, v) {
          this._map = g, this._clickTolerance = v.clickTolerance;
        };
        wi.prototype.reset = function() {
          delete this._mousedownPos;
        }, wi.prototype.wheel = function(g) {
          return this._firePreventable(new Uh(g.type, this._map, g));
        }, wi.prototype.mousedown = function(g, v) {
          return this._mousedownPos = v, this._firePreventable(new xi(g.type, this._map, g));
        }, wi.prototype.mouseup = function(g) {
          this._map.fire(new xi(g.type, this._map, g));
        }, wi.prototype.click = function(g, v) {
          this._mousedownPos && this._mousedownPos.dist(v) >= this._clickTolerance || this._map.fire(new xi(g.type, this._map, g));
        }, wi.prototype.dblclick = function(g) {
          return this._firePreventable(new xi(g.type, this._map, g));
        }, wi.prototype.mouseover = function(g) {
          this._map.fire(new xi(g.type, this._map, g));
        }, wi.prototype.mouseout = function(g) {
          this._map.fire(new xi(g.type, this._map, g));
        }, wi.prototype.touchstart = function(g) {
          return this._firePreventable(new Ya(g.type, this._map, g));
        }, wi.prototype.touchmove = function(g) {
          this._map.fire(new Ya(g.type, this._map, g));
        }, wi.prototype.touchend = function(g) {
          this._map.fire(new Ya(g.type, this._map, g));
        }, wi.prototype.touchcancel = function(g) {
          this._map.fire(new Ya(g.type, this._map, g));
        }, wi.prototype._firePreventable = function(g) {
          if (this._map.fire(g), g.defaultPrevented) return {};
        }, wi.prototype.isEnabled = function() {
          return !0;
        }, wi.prototype.isActive = function() {
          return !1;
        }, wi.prototype.enable = function() {
        }, wi.prototype.disable = function() {
        };
        var ur = function(g) {
          this._map = g;
        };
        ur.prototype.reset = function() {
          this._delayContextMenu = !1, delete this._contextMenuEvent;
        }, ur.prototype.mousemove = function(g) {
          this._map.fire(new xi(g.type, this._map, g));
        }, ur.prototype.mousedown = function() {
          this._delayContextMenu = !0;
        }, ur.prototype.mouseup = function() {
          this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new xi("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
        }, ur.prototype.contextmenu = function(g) {
          this._delayContextMenu ? this._contextMenuEvent = g : this._map.fire(new xi(g.type, this._map, g)), this._map.listens("contextmenu") && g.preventDefault();
        }, ur.prototype.isEnabled = function() {
          return !0;
        }, ur.prototype.isActive = function() {
          return !1;
        }, ur.prototype.enable = function() {
        }, ur.prototype.disable = function() {
        };
        var Ds = function(g, v) {
          this._map = g, this._el = g.getCanvasContainer(), this._container = g.getContainer(), this._clickTolerance = v.clickTolerance || 1;
        };
        function vu(g, v) {
          for (var _ = {}, w = 0; w < g.length; w++) _[g[w].identifier] = v[w];
          return _;
        }
        Ds.prototype.isEnabled = function() {
          return !!this._enabled;
        }, Ds.prototype.isActive = function() {
          return !!this._active;
        }, Ds.prototype.enable = function() {
          this.isEnabled() || (this._enabled = !0);
        }, Ds.prototype.disable = function() {
          this.isEnabled() && (this._enabled = !1);
        }, Ds.prototype.mousedown = function(g, v) {
          this.isEnabled() && g.shiftKey && g.button === 0 && (u.disableDrag(), this._startPos = this._lastPos = v, this._active = !0);
        }, Ds.prototype.mousemoveWindow = function(g, v) {
          if (this._active) {
            var _ = v;
            if (!(this._lastPos.equals(_) || !this._box && _.dist(this._startPos) < this._clickTolerance)) {
              var w = this._startPos;
              this._lastPos = _, this._box || (this._box = u.create("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", g));
              var R = Math.min(w.x, _.x), D = Math.max(w.x, _.x), k = Math.min(w.y, _.y), H = Math.max(w.y, _.y);
              u.setTransform(this._box, "translate(" + R + "px," + k + "px)"), this._box.style.width = D - R + "px", this._box.style.height = H - k + "px";
            }
          }
        }, Ds.prototype.mouseupWindow = function(g, v) {
          var _ = this;
          if (this._active && g.button === 0) {
            var w = this._startPos, R = v;
            if (this.reset(), u.suppressClick(), w.x !== R.x || w.y !== R.y) return this._map.fire(new o.Event("boxzoomend", { originalEvent: g })), { cameraAnimation: function(D) {
              return D.fitScreenCoordinates(w, R, _._map.getBearing(), { linear: !0 });
            } };
            this._fireEvent("boxzoomcancel", g);
          }
        }, Ds.prototype.keydown = function(g) {
          this._active && g.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", g));
        }, Ds.prototype.blur = function() {
          this.reset();
        }, Ds.prototype.reset = function() {
          this._active = !1, this._container.classList.remove("mapboxgl-crosshair"), this._box && (u.remove(this._box), this._box = null), u.enableDrag(), delete this._startPos, delete this._lastPos;
        }, Ds.prototype._fireEvent = function(g, v) {
          return this._map.fire(new o.Event(g, { originalEvent: v }));
        };
        var kl = function(g) {
          this.reset(), this.numTouches = g.numTouches;
        };
        kl.prototype.reset = function() {
          delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;
        }, kl.prototype.touchstart = function(g, v, _) {
          (this.centroid || _.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = g.timeStamp), _.length === this.numTouches && (this.centroid = (function(w) {
            for (var R = new o.Point(0, 0), D = 0, k = w; D < k.length; D += 1) R._add(k[D]);
            return R.div(w.length);
          })(v), this.touches = vu(_, v)));
        }, kl.prototype.touchmove = function(g, v, _) {
          if (!this.aborted && this.centroid) {
            var w = vu(_, v);
            for (var R in this.touches) {
              var D = w[R];
              (!D || D.dist(this.touches[R]) > 30) && (this.aborted = !0);
            }
          }
        }, kl.prototype.touchend = function(g, v, _) {
          if ((!this.centroid || g.timeStamp - this.startTime > 500) && (this.aborted = !0), _.length === 0) {
            var w = !this.aborted && this.centroid;
            if (this.reset(), w) return w;
          }
        };
        var xo = function(g) {
          this.singleTap = new kl(g), this.numTaps = g.numTaps, this.reset();
        };
        xo.prototype.reset = function() {
          this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
        }, xo.prototype.touchstart = function(g, v, _) {
          this.singleTap.touchstart(g, v, _);
        }, xo.prototype.touchmove = function(g, v, _) {
          this.singleTap.touchmove(g, v, _);
        }, xo.prototype.touchend = function(g, v, _) {
          var w = this.singleTap.touchend(g, v, _);
          if (w) {
            var R = g.timeStamp - this.lastTime < 500, D = !this.lastTap || this.lastTap.dist(w) < 30;
            if (R && D || this.reset(), this.count++, this.lastTime = g.timeStamp, this.lastTap = w, this.count === this.numTaps) return this.reset(), w;
          }
        };
        var bs = function() {
          this._zoomIn = new xo({ numTouches: 1, numTaps: 2 }), this._zoomOut = new xo({ numTouches: 2, numTaps: 1 }), this.reset();
        };
        bs.prototype.reset = function() {
          this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
        }, bs.prototype.touchstart = function(g, v, _) {
          this._zoomIn.touchstart(g, v, _), this._zoomOut.touchstart(g, v, _);
        }, bs.prototype.touchmove = function(g, v, _) {
          this._zoomIn.touchmove(g, v, _), this._zoomOut.touchmove(g, v, _);
        }, bs.prototype.touchend = function(g, v, _) {
          var w = this, R = this._zoomIn.touchend(g, v, _), D = this._zoomOut.touchend(g, v, _);
          return R ? (this._active = !0, g.preventDefault(), setTimeout((function() {
            return w.reset();
          }), 0), { cameraAnimation: function(k) {
            return k.easeTo({ duration: 300, zoom: k.getZoom() + 1, around: k.unproject(R) }, { originalEvent: g });
          } }) : D ? (this._active = !0, g.preventDefault(), setTimeout((function() {
            return w.reset();
          }), 0), { cameraAnimation: function(k) {
            return k.easeTo({ duration: 300, zoom: k.getZoom() - 1, around: k.unproject(D) }, { originalEvent: g });
          } }) : void 0;
        }, bs.prototype.touchcancel = function() {
          this.reset();
        }, bs.prototype.enable = function() {
          this._enabled = !0;
        }, bs.prototype.disable = function() {
          this._enabled = !1, this.reset();
        }, bs.prototype.isEnabled = function() {
          return this._enabled;
        }, bs.prototype.isActive = function() {
          return this._active;
        };
        var _f = { 0: 1, 2: 2 }, nr = function(g) {
          this.reset(), this._clickTolerance = g.clickTolerance || 1;
        };
        nr.prototype.blur = function() {
          this.reset();
        }, nr.prototype.reset = function() {
          this._active = !1, this._moved = !1, delete this._lastPoint, delete this._eventButton;
        }, nr.prototype._correctButton = function(g, v) {
          return !1;
        }, nr.prototype._move = function(g, v) {
          return {};
        }, nr.prototype.mousedown = function(g, v) {
          if (!this._lastPoint) {
            var _ = u.mouseButton(g);
            this._correctButton(g, _) && (this._lastPoint = v, this._eventButton = _);
          }
        }, nr.prototype.mousemoveWindow = function(g, v) {
          var _ = this._lastPoint;
          if (_) {
            if (g.preventDefault(), (function(w, R) {
              var D = _f[R];
              return w.buttons === void 0 || (w.buttons & D) !== D;
            })(g, this._eventButton)) this.reset();
            else if (this._moved || !(v.dist(_) < this._clickTolerance)) return this._moved = !0, this._lastPoint = v, this._move(_, v);
          }
        }, nr.prototype.mouseupWindow = function(g) {
          this._lastPoint && u.mouseButton(g) === this._eventButton && (this._moved && u.suppressClick(), this.reset());
        }, nr.prototype.enable = function() {
          this._enabled = !0;
        }, nr.prototype.disable = function() {
          this._enabled = !1, this.reset();
        }, nr.prototype.isEnabled = function() {
          return this._enabled;
        }, nr.prototype.isActive = function() {
          return this._active;
        };
        var wo = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.mousedown = function(_, w) {
            g.prototype.mousedown.call(this, _, w), this._lastPoint && (this._active = !0);
          }, v.prototype._correctButton = function(_, w) {
            return w === 0 && !_.ctrlKey;
          }, v.prototype._move = function(_, w) {
            return { around: w, panDelta: w.sub(_) };
          }, v;
        })(nr), Ec = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype._correctButton = function(_, w) {
            return w === 0 && _.ctrlKey || w === 2;
          }, v.prototype._move = function(_, w) {
            var R = 0.8 * (w.x - _.x);
            if (R) return this._active = !0, { bearingDelta: R };
          }, v.prototype.contextmenu = function(_) {
            _.preventDefault();
          }, v;
        })(nr), yf = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype._correctButton = function(_, w) {
            return w === 0 && _.ctrlKey || w === 2;
          }, v.prototype._move = function(_, w) {
            var R = -0.5 * (w.y - _.y);
            if (R) return this._active = !0, { pitchDelta: R };
          }, v.prototype.contextmenu = function(_) {
            _.preventDefault();
          }, v;
        })(nr), lo = function(g) {
          this._minTouches = 1, this._clickTolerance = g.clickTolerance || 1, this.reset();
        };
        lo.prototype.reset = function() {
          this._active = !1, this._touches = {}, this._sum = new o.Point(0, 0);
        }, lo.prototype.touchstart = function(g, v, _) {
          return this._calculateTransform(g, v, _);
        }, lo.prototype.touchmove = function(g, v, _) {
          if (this._active && !(_.length < this._minTouches)) return g.preventDefault(), this._calculateTransform(g, v, _);
        }, lo.prototype.touchend = function(g, v, _) {
          this._calculateTransform(g, v, _), this._active && _.length < this._minTouches && this.reset();
        }, lo.prototype.touchcancel = function() {
          this.reset();
        }, lo.prototype._calculateTransform = function(g, v, _) {
          _.length > 0 && (this._active = !0);
          var w = vu(_, v), R = new o.Point(0, 0), D = new o.Point(0, 0), k = 0;
          for (var H in w) {
            var J = w[H], oe = this._touches[H];
            oe && (R._add(J), D._add(J.sub(oe)), k++, w[H] = J);
          }
          if (this._touches = w, !(k < this._minTouches) && D.mag()) {
            var Ce = D.div(k);
            if (this._sum._add(Ce), !(this._sum.mag() < this._clickTolerance)) return { around: R.div(k), panDelta: Ce };
          }
        }, lo.prototype.enable = function() {
          this._enabled = !0;
        }, lo.prototype.disable = function() {
          this._enabled = !1, this.reset();
        }, lo.prototype.isEnabled = function() {
          return this._enabled;
        }, lo.prototype.isActive = function() {
          return this._active;
        };
        var Ls = function() {
          this.reset();
        };
        function bu(g, v, _) {
          for (var w = 0; w < g.length; w++) if (g[w].identifier === _) return v[w];
        }
        function xu(g, v) {
          return Math.log(g / v) / Math.LN2;
        }
        Ls.prototype.reset = function() {
          this._active = !1, delete this._firstTwoTouches;
        }, Ls.prototype._start = function(g) {
        }, Ls.prototype._move = function(g, v, _) {
          return {};
        }, Ls.prototype.touchstart = function(g, v, _) {
          this._firstTwoTouches || _.length < 2 || (this._firstTwoTouches = [_[0].identifier, _[1].identifier], this._start([v[0], v[1]]));
        }, Ls.prototype.touchmove = function(g, v, _) {
          if (this._firstTwoTouches) {
            g.preventDefault();
            var w = this._firstTwoTouches, R = w[1], D = bu(_, v, w[0]), k = bu(_, v, R);
            if (D && k) {
              var H = this._aroundCenter ? null : D.add(k).div(2);
              return this._move([D, k], H, g);
            }
          }
        }, Ls.prototype.touchend = function(g, v, _) {
          if (this._firstTwoTouches) {
            var w = this._firstTwoTouches, R = w[1], D = bu(_, v, w[0]), k = bu(_, v, R);
            D && k || (this._active && u.suppressClick(), this.reset());
          }
        }, Ls.prototype.touchcancel = function() {
          this.reset();
        }, Ls.prototype.enable = function(g) {
          this._enabled = !0, this._aroundCenter = !!g && g.around === "center";
        }, Ls.prototype.disable = function() {
          this._enabled = !1, this.reset();
        }, Ls.prototype.isEnabled = function() {
          return this._enabled;
        }, Ls.prototype.isActive = function() {
          return this._active;
        };
        var Si = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.reset = function() {
            g.prototype.reset.call(this), delete this._distance, delete this._startDistance;
          }, v.prototype._start = function(_) {
            this._startDistance = this._distance = _[0].dist(_[1]);
          }, v.prototype._move = function(_, w) {
            var R = this._distance;
            if (this._distance = _[0].dist(_[1]), this._active || !(Math.abs(xu(this._distance, this._startDistance)) < 0.1)) return this._active = !0, { zoomDelta: xu(this._distance, R), pinchAround: w };
          }, v;
        })(Ls);
        function To(g, v) {
          return 180 * g.angleWith(v) / Math.PI;
        }
        var zh = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.reset = function() {
            g.prototype.reset.call(this), delete this._minDiameter, delete this._startVector, delete this._vector;
          }, v.prototype._start = function(_) {
            this._startVector = this._vector = _[0].sub(_[1]), this._minDiameter = _[0].dist(_[1]);
          }, v.prototype._move = function(_, w) {
            var R = this._vector;
            if (this._vector = _[0].sub(_[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, { bearingDelta: To(this._vector, R), pinchAround: w };
          }, v.prototype._isBelowThreshold = function(_) {
            this._minDiameter = Math.min(this._minDiameter, _.mag());
            var w = 25 / (Math.PI * this._minDiameter) * 360, R = To(_, this._startVector);
            return Math.abs(R) < w;
          }, v;
        })(Ls);
        function Ta(g) {
          return Math.abs(g.y) > Math.abs(g.x);
        }
        var wu = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.reset = function() {
            g.prototype.reset.call(this), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
          }, v.prototype._start = function(_) {
            this._lastPoints = _, Ta(_[0].sub(_[1])) && (this._valid = !1);
          }, v.prototype._move = function(_, w, R) {
            var D = _[0].sub(this._lastPoints[0]), k = _[1].sub(this._lastPoints[1]);
            if (this._valid = this.gestureBeginsVertically(D, k, R.timeStamp), this._valid) return this._lastPoints = _, this._active = !0, { pitchDelta: (D.y + k.y) / 2 * -0.5 };
          }, v.prototype.gestureBeginsVertically = function(_, w, R) {
            if (this._valid !== void 0) return this._valid;
            var D = _.mag() >= 2, k = w.mag() >= 2;
            if (D || k) {
              if (!D || !k) return this._firstMove === void 0 && (this._firstMove = R), R - this._firstMove < 100 && void 0;
              var H = _.y > 0 == w.y > 0;
              return Ta(_) && Ta(w) && H;
            }
          }, v;
        })(Ls), vf = { panStep: 100, bearingStep: 15, pitchStep: 10 }, Eo = function() {
          var g = vf;
          this._panStep = g.panStep, this._bearingStep = g.bearingStep, this._pitchStep = g.pitchStep, this._rotationDisabled = !1;
        };
        function is(g) {
          return g * (2 - g);
        }
        Eo.prototype.blur = function() {
          this.reset();
        }, Eo.prototype.reset = function() {
          this._active = !1;
        }, Eo.prototype.keydown = function(g) {
          var v = this;
          if (!(g.altKey || g.ctrlKey || g.metaKey)) {
            var _ = 0, w = 0, R = 0, D = 0, k = 0;
            switch (g.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                _ = 1;
                break;
              case 189:
              case 109:
              case 173:
                _ = -1;
                break;
              case 37:
                g.shiftKey ? w = -1 : (g.preventDefault(), D = -1);
                break;
              case 39:
                g.shiftKey ? w = 1 : (g.preventDefault(), D = 1);
                break;
              case 38:
                g.shiftKey ? R = 1 : (g.preventDefault(), k = -1);
                break;
              case 40:
                g.shiftKey ? R = -1 : (g.preventDefault(), k = 1);
                break;
              default:
                return;
            }
            return this._rotationDisabled && (w = 0, R = 0), { cameraAnimation: function(H) {
              var J = H.getZoom();
              H.easeTo({ duration: 300, easeId: "keyboardHandler", easing: is, zoom: _ ? Math.round(J) + _ * (g.shiftKey ? 2 : 1) : J, bearing: H.getBearing() + w * v._bearingStep, pitch: H.getPitch() + R * v._pitchStep, offset: [-D * v._panStep, -k * v._panStep], center: H.getCenter() }, { originalEvent: g });
            } };
          }
        }, Eo.prototype.enable = function() {
          this._enabled = !0;
        }, Eo.prototype.disable = function() {
          this._enabled = !1, this.reset();
        }, Eo.prototype.isEnabled = function() {
          return this._enabled;
        }, Eo.prototype.isActive = function() {
          return this._active;
        }, Eo.prototype.disableRotation = function() {
          this._rotationDisabled = !0;
        }, Eo.prototype.enableRotation = function() {
          this._rotationDisabled = !1;
        };
        var cn = function(g, v) {
          this._map = g, this._el = g.getCanvasContainer(), this._handler = v, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 1 / 450, o.bindAll(["_onTimeout"], this);
        };
        cn.prototype.setZoomRate = function(g) {
          this._defaultZoomRate = g;
        }, cn.prototype.setWheelZoomRate = function(g) {
          this._wheelZoomRate = g;
        }, cn.prototype.isEnabled = function() {
          return !!this._enabled;
        }, cn.prototype.isActive = function() {
          return !!this._active || this._finishTimeout !== void 0;
        }, cn.prototype.isZooming = function() {
          return !!this._zooming;
        }, cn.prototype.enable = function(g) {
          this.isEnabled() || (this._enabled = !0, this._aroundCenter = g && g.around === "center");
        }, cn.prototype.disable = function() {
          this.isEnabled() && (this._enabled = !1);
        }, cn.prototype.wheel = function(g) {
          if (this.isEnabled()) {
            var v = g.deltaMode === o.window.WheelEvent.DOM_DELTA_LINE ? 40 * g.deltaY : g.deltaY, _ = o.browser.now(), w = _ - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = _, v !== 0 && v % 4.000244140625 == 0 ? this._type = "wheel" : v !== 0 && Math.abs(v) < 4 ? this._type = "trackpad" : w > 400 ? (this._type = null, this._lastValue = v, this._timeout = setTimeout(this._onTimeout, 40, g)) : this._type || (this._type = Math.abs(w * v) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, v += this._lastValue)), g.shiftKey && v && (v /= 4), this._type && (this._lastWheelEvent = g, this._delta -= v, this._active || this._start(g)), g.preventDefault();
          }
        }, cn.prototype._onTimeout = function(g) {
          this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(g);
        }, cn.prototype._start = function(g) {
          if (this._delta) {
            this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            var v = u.mousePos(this._el, g);
            this._around = o.LngLat.convert(this._aroundCenter ? this._map.getCenter() : this._map.unproject(v)), this._aroundPoint = this._map.transform.locationPoint(this._around), this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame());
          }
        }, cn.prototype.renderFrame = function() {
          var g = this;
          if (this._frameId && (this._frameId = null, this.isActive())) {
            var v = this._map.transform;
            if (this._delta !== 0) {
              var _ = this._type === "wheel" && Math.abs(this._delta) > 4.000244140625 ? this._wheelZoomRate : this._defaultZoomRate, w = 2 / (1 + Math.exp(-Math.abs(this._delta * _)));
              this._delta < 0 && w !== 0 && (w = 1 / w);
              var R = typeof this._targetZoom == "number" ? v.zoomScale(this._targetZoom) : v.scale;
              this._targetZoom = Math.min(v.maxZoom, Math.max(v.minZoom, v.scaleZoom(R * w))), this._type === "wheel" && (this._startZoom = v.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
            }
            var D, k = typeof this._targetZoom == "number" ? this._targetZoom : v.zoom, H = this._startZoom, J = this._easing, oe = !1;
            if (this._type === "wheel" && H && J) {
              var Ce = Math.min((o.browser.now() - this._lastWheelEventTime) / 200, 1), Se = J(Ce);
              D = o.number(H, k, Se), Ce < 1 ? this._frameId || (this._frameId = !0) : oe = !0;
            } else D = k, oe = !0;
            return this._active = !0, oe && (this._active = !1, this._finishTimeout = setTimeout((function() {
              g._zooming = !1, g._handler._triggerRenderFrame(), delete g._targetZoom, delete g._finishTimeout;
            }), 200)), { noInertia: !0, needsRenderFrame: !oe, zoomDelta: D - v.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
          }
        }, cn.prototype._smoothOutEasing = function(g) {
          var v = o.ease;
          if (this._prevEase) {
            var _ = this._prevEase, w = (o.browser.now() - _.start) / _.duration, R = _.easing(w + 0.01) - _.easing(w), D = 0.27 / Math.sqrt(R * R + 1e-4) * 0.01, k = Math.sqrt(0.0729 - D * D);
            v = o.bezier(D, k, 0.25, 1);
          }
          return this._prevEase = { start: o.browser.now(), duration: g, easing: v }, v;
        }, cn.prototype.blur = function() {
          this.reset();
        }, cn.prototype.reset = function() {
          this._active = !1;
        };
        var ks = function(g, v) {
          this._clickZoom = g, this._tapZoom = v;
        };
        ks.prototype.enable = function() {
          this._clickZoom.enable(), this._tapZoom.enable();
        }, ks.prototype.disable = function() {
          this._clickZoom.disable(), this._tapZoom.disable();
        }, ks.prototype.isEnabled = function() {
          return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
        }, ks.prototype.isActive = function() {
          return this._clickZoom.isActive() || this._tapZoom.isActive();
        };
        var Fs = function() {
          this.reset();
        };
        Fs.prototype.reset = function() {
          this._active = !1;
        }, Fs.prototype.blur = function() {
          this.reset();
        }, Fs.prototype.dblclick = function(g, v) {
          return g.preventDefault(), { cameraAnimation: function(_) {
            _.easeTo({ duration: 300, zoom: _.getZoom() + (g.shiftKey ? -1 : 1), around: _.unproject(v) }, { originalEvent: g });
          } };
        }, Fs.prototype.enable = function() {
          this._enabled = !0;
        }, Fs.prototype.disable = function() {
          this._enabled = !1, this.reset();
        }, Fs.prototype.isEnabled = function() {
          return this._enabled;
        }, Fs.prototype.isActive = function() {
          return this._active;
        };
        var Li = function() {
          this._tap = new xo({ numTouches: 1, numTaps: 1 }), this.reset();
        };
        Li.prototype.reset = function() {
          this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, this._tap.reset();
        }, Li.prototype.touchstart = function(g, v, _) {
          this._swipePoint || (this._tapTime && g.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? _.length > 0 && (this._swipePoint = v[0], this._swipeTouch = _[0].identifier) : this._tap.touchstart(g, v, _));
        }, Li.prototype.touchmove = function(g, v, _) {
          if (this._tapTime) {
            if (this._swipePoint) {
              if (_[0].identifier !== this._swipeTouch) return;
              var w = v[0], R = w.y - this._swipePoint.y;
              return this._swipePoint = w, g.preventDefault(), this._active = !0, { zoomDelta: R / 128 };
            }
          } else this._tap.touchmove(g, v, _);
        }, Li.prototype.touchend = function(g, v, _) {
          this._tapTime ? this._swipePoint && _.length === 0 && this.reset() : this._tap.touchend(g, v, _) && (this._tapTime = g.timeStamp);
        }, Li.prototype.touchcancel = function() {
          this.reset();
        }, Li.prototype.enable = function() {
          this._enabled = !0;
        }, Li.prototype.disable = function() {
          this._enabled = !1, this.reset();
        }, Li.prototype.isEnabled = function() {
          return this._enabled;
        }, Li.prototype.isActive = function() {
          return this._active;
        };
        var Ea = function(g, v, _) {
          this._el = g, this._mousePan = v, this._touchPan = _;
        };
        Ea.prototype.enable = function(g) {
          this._inertiaOptions = g || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
        }, Ea.prototype.disable = function() {
          this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
        }, Ea.prototype.isEnabled = function() {
          return this._mousePan.isEnabled() && this._touchPan.isEnabled();
        }, Ea.prototype.isActive = function() {
          return this._mousePan.isActive() || this._touchPan.isActive();
        };
        var Co = function(g, v, _) {
          this._pitchWithRotate = g.pitchWithRotate, this._mouseRotate = v, this._mousePitch = _;
        };
        Co.prototype.enable = function() {
          this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
        }, Co.prototype.disable = function() {
          this._mouseRotate.disable(), this._mousePitch.disable();
        }, Co.prototype.isEnabled = function() {
          return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
        }, Co.prototype.isActive = function() {
          return this._mouseRotate.isActive() || this._mousePitch.isActive();
        };
        var co = function(g, v, _, w) {
          this._el = g, this._touchZoom = v, this._touchRotate = _, this._tapDragZoom = w, this._rotationDisabled = !1, this._enabled = !0;
        };
        co.prototype.enable = function(g) {
          this._touchZoom.enable(g), this._rotationDisabled || this._touchRotate.enable(g), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
        }, co.prototype.disable = function() {
          this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
        }, co.prototype.isEnabled = function() {
          return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
        }, co.prototype.isActive = function() {
          return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
        }, co.prototype.disableRotation = function() {
          this._rotationDisabled = !0, this._touchRotate.disable();
        }, co.prototype.enableRotation = function() {
          this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
        };
        var cs = function(g) {
          return g.zoom || g.drag || g.pitch || g.rotate;
        }, Cc = (function(g) {
          function v() {
            g.apply(this, arguments);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v;
        })(o.Event);
        function Mr(g) {
          return g.panDelta && g.panDelta.mag() || g.zoomDelta || g.bearingDelta || g.pitchDelta;
        }
        var Ar = function(g, v) {
          this._map = g, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new wc(g), this._bearingSnap = v.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(v), o.bindAll(["handleEvent", "handleWindowEvent"], this);
          var _ = this._el;
          this._listeners = [[_, "touchstart", { passive: !0 }], [_, "touchmove", { passive: !1 }], [_, "touchend", void 0], [_, "touchcancel", void 0], [_, "mousedown", void 0], [_, "mousemove", void 0], [_, "mouseup", void 0], [o.window.document, "mousemove", { capture: !0 }], [o.window.document, "mouseup", void 0], [_, "mouseover", void 0], [_, "mouseout", void 0], [_, "dblclick", void 0], [_, "click", void 0], [_, "keydown", { capture: !1 }], [_, "keyup", void 0], [_, "wheel", { passive: !1 }], [_, "contextmenu", void 0], [o.window, "blur", void 0]];
          for (var w = 0, R = this._listeners; w < R.length; w += 1) {
            var D = R[w], k = D[0];
            u.addEventListener(k, D[1], k === o.window.document ? this.handleWindowEvent : this.handleEvent, D[2]);
          }
        };
        Ar.prototype.destroy = function() {
          for (var g = 0, v = this._listeners; g < v.length; g += 1) {
            var _ = v[g], w = _[0];
            u.removeEventListener(w, _[1], w === o.window.document ? this.handleWindowEvent : this.handleEvent, _[2]);
          }
        }, Ar.prototype._addDefaultHandlers = function(g) {
          var v = this._map, _ = v.getCanvasContainer();
          this._add("mapEvent", new wi(v, g));
          var w = v.boxZoom = new Ds(v, g);
          this._add("boxZoom", w);
          var R = new bs(), D = new Fs();
          v.doubleClickZoom = new ks(D, R), this._add("tapZoom", R), this._add("clickZoom", D);
          var k = new Li();
          this._add("tapDragZoom", k);
          var H = v.touchPitch = new wu();
          this._add("touchPitch", H);
          var J = new Ec(g), oe = new yf(g);
          v.dragRotate = new Co(g, J, oe), this._add("mouseRotate", J, ["mousePitch"]), this._add("mousePitch", oe, ["mouseRotate"]);
          var Ce = new wo(g), Se = new lo(g);
          v.dragPan = new Ea(_, Ce, Se), this._add("mousePan", Ce), this._add("touchPan", Se, ["touchZoom", "touchRotate"]);
          var Oe = new zh(), He = new Si();
          v.touchZoomRotate = new co(_, He, Oe, k), this._add("touchRotate", Oe, ["touchPan", "touchZoom"]), this._add("touchZoom", He, ["touchPan", "touchRotate"]);
          var ze = v.scrollZoom = new cn(v, this);
          this._add("scrollZoom", ze, ["mousePan"]);
          var h = v.keyboard = new Eo();
          this._add("keyboard", h), this._add("blockableMapEvent", new ur(v));
          for (var f = 0, A = ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"]; f < A.length; f += 1) {
            var b = A[f];
            g.interactive && g[b] && v[b].enable(g[b]);
          }
        }, Ar.prototype._add = function(g, v, _) {
          this._handlers.push({ handlerName: g, handler: v, allowed: _ }), this._handlersById[g] = v;
        }, Ar.prototype.stop = function(g) {
          if (!this._updatingCamera) {
            for (var v = 0, _ = this._handlers; v < _.length; v += 1) _[v].handler.reset();
            this._inertia.clear(), this._fireEvents({}, {}, g), this._changes = [];
          }
        }, Ar.prototype.isActive = function() {
          for (var g = 0, v = this._handlers; g < v.length; g += 1) if (v[g].handler.isActive()) return !0;
          return !1;
        }, Ar.prototype.isZooming = function() {
          return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
        }, Ar.prototype.isRotating = function() {
          return !!this._eventsInProgress.rotate;
        }, Ar.prototype.isMoving = function() {
          return !!cs(this._eventsInProgress) || this.isZooming();
        }, Ar.prototype._blockedByActive = function(g, v, _) {
          for (var w in g) if (w !== _ && (!v || v.indexOf(w) < 0)) return !0;
          return !1;
        }, Ar.prototype.handleWindowEvent = function(g) {
          this.handleEvent(g, g.type + "Window");
        }, Ar.prototype._getMapTouches = function(g) {
          for (var v = [], _ = 0, w = g; _ < w.length; _ += 1) {
            var R = w[_];
            this._el.contains(R.target) && v.push(R);
          }
          return v;
        }, Ar.prototype.handleEvent = function(g, v) {
          this._updatingCamera = !0;
          for (var _ = g.type === "renderFrame" ? void 0 : g, w = { needsRenderFrame: !1 }, R = {}, D = {}, k = g.touches ? this._getMapTouches(g.touches) : void 0, H = k ? u.touchPos(this._el, k) : u.mousePos(this._el, g), J = 0, oe = this._handlers; J < oe.length; J += 1) {
            var Ce = oe[J], Se = Ce.handlerName, Oe = Ce.handler, He = Ce.allowed;
            if (Oe.isEnabled()) {
              var ze = void 0;
              this._blockedByActive(D, He, Se) ? Oe.reset() : Oe[v || g.type] && (ze = Oe[v || g.type](g, H, k), this.mergeHandlerResult(w, R, ze, Se, _), ze && ze.needsRenderFrame && this._triggerRenderFrame()), (ze || Oe.isActive()) && (D[Se] = Oe);
            }
          }
          var h = {};
          for (var f in this._previousActiveHandlers) D[f] || (h[f] = _);
          this._previousActiveHandlers = D, (Object.keys(h).length || Mr(w)) && (this._changes.push([w, R, h]), this._triggerRenderFrame()), (Object.keys(D).length || Mr(w)) && this._map._stop(!0), this._updatingCamera = !1;
          var A = w.cameraAnimation;
          A && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], A(this._map));
        }, Ar.prototype.mergeHandlerResult = function(g, v, _, w, R) {
          if (_) {
            o.extend(g, _);
            var D = { handlerName: w, originalEvent: _.originalEvent || R };
            _.zoomDelta !== void 0 && (v.zoom = D), _.panDelta !== void 0 && (v.drag = D), _.pitchDelta !== void 0 && (v.pitch = D), _.bearingDelta !== void 0 && (v.rotate = D);
          }
        }, Ar.prototype._applyChanges = function() {
          for (var g = {}, v = {}, _ = {}, w = 0, R = this._changes; w < R.length; w += 1) {
            var D = R[w], k = D[0], H = D[1], J = D[2];
            k.panDelta && (g.panDelta = (g.panDelta || new o.Point(0, 0))._add(k.panDelta)), k.zoomDelta && (g.zoomDelta = (g.zoomDelta || 0) + k.zoomDelta), k.bearingDelta && (g.bearingDelta = (g.bearingDelta || 0) + k.bearingDelta), k.pitchDelta && (g.pitchDelta = (g.pitchDelta || 0) + k.pitchDelta), k.around !== void 0 && (g.around = k.around), k.pinchAround !== void 0 && (g.pinchAround = k.pinchAround), k.noInertia && (g.noInertia = k.noInertia), o.extend(v, H), o.extend(_, J);
          }
          this._updateMapTransform(g, v, _), this._changes = [];
        }, Ar.prototype._updateMapTransform = function(g, v, _) {
          var w = this._map, R = w.transform;
          if (!Mr(g)) return this._fireEvents(v, _, !0);
          var D = g.panDelta, k = g.zoomDelta, H = g.bearingDelta, J = g.pitchDelta, oe = g.around, Ce = g.pinchAround;
          Ce !== void 0 && (oe = Ce), w._stop(!0), oe = oe || w.transform.centerPoint;
          var Se = R.pointLocation(D ? oe.sub(D) : oe);
          H && (R.bearing += H), J && (R.pitch += J), k && (R.zoom += k), R.setLocationAtPoint(Se, oe), this._map._update(), g.noInertia || this._inertia.record(g), this._fireEvents(v, _, !0);
        }, Ar.prototype._fireEvents = function(g, v, _) {
          var w = this, R = cs(this._eventsInProgress), D = cs(g), k = {};
          for (var H in g) this._eventsInProgress[H] || (k[H + "start"] = g[H].originalEvent), this._eventsInProgress[H] = g[H];
          for (var J in !R && D && this._fireEvent("movestart", D.originalEvent), k) this._fireEvent(J, k[J]);
          for (var oe in D && this._fireEvent("move", D.originalEvent), g) this._fireEvent(oe, g[oe].originalEvent);
          var Ce, Se = {};
          for (var Oe in this._eventsInProgress) {
            var He = this._eventsInProgress[Oe], ze = He.handlerName, h = He.originalEvent;
            this._handlersById[ze].isActive() || (delete this._eventsInProgress[Oe], Se[Oe + "end"] = Ce = v[ze] || h);
          }
          for (var f in Se) this._fireEvent(f, Se[f]);
          var A = cs(this._eventsInProgress);
          if (_ && (R || D) && !A) {
            this._updatingCamera = !0;
            var b = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), T = function(C) {
              return C !== 0 && -w._bearingSnap < C && C < w._bearingSnap;
            };
            b ? (T(b.bearing || this._map.getBearing()) && (b.bearing = 0), this._map.easeTo(b, { originalEvent: Ce })) : (this._map.fire(new o.Event("moveend", { originalEvent: Ce })), T(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1;
          }
        }, Ar.prototype._fireEvent = function(g, v) {
          this._map.fire(new o.Event(g, v ? { originalEvent: v } : {}));
        }, Ar.prototype._requestFrame = function() {
          var g = this;
          return this._map.triggerRepaint(), this._map._renderTaskQueue.add((function(v) {
            delete g._frameId, g.handleEvent(new Cc("renderFrame", { timeStamp: v })), g._applyChanges();
          }));
        }, Ar.prototype._triggerRenderFrame = function() {
          this._frameId === void 0 && (this._frameId = this._requestFrame());
        };
        var Tu = (function(g) {
          function v(_, w) {
            g.call(this), this._moving = !1, this._zooming = !1, this.transform = _, this._bearingSnap = w.bearingSnap, o.bindAll(["_renderFrameCallback"], this);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.getCenter = function() {
            return new o.LngLat(this.transform.center.lng, this.transform.center.lat);
          }, v.prototype.setCenter = function(_, w) {
            return this.jumpTo({ center: _ }, w);
          }, v.prototype.panBy = function(_, w, R) {
            return _ = o.Point.convert(_).mult(-1), this.panTo(this.transform.center, o.extend({ offset: _ }, w), R);
          }, v.prototype.panTo = function(_, w, R) {
            return this.easeTo(o.extend({ center: _ }, w), R);
          }, v.prototype.getZoom = function() {
            return this.transform.zoom;
          }, v.prototype.setZoom = function(_, w) {
            return this.jumpTo({ zoom: _ }, w), this;
          }, v.prototype.zoomTo = function(_, w, R) {
            return this.easeTo(o.extend({ zoom: _ }, w), R);
          }, v.prototype.zoomIn = function(_, w) {
            return this.zoomTo(this.getZoom() + 1, _, w), this;
          }, v.prototype.zoomOut = function(_, w) {
            return this.zoomTo(this.getZoom() - 1, _, w), this;
          }, v.prototype.getBearing = function() {
            return this.transform.bearing;
          }, v.prototype.setBearing = function(_, w) {
            return this.jumpTo({ bearing: _ }, w), this;
          }, v.prototype.getPadding = function() {
            return this.transform.padding;
          }, v.prototype.setPadding = function(_, w) {
            return this.jumpTo({ padding: _ }, w), this;
          }, v.prototype.rotateTo = function(_, w, R) {
            return this.easeTo(o.extend({ bearing: _ }, w), R);
          }, v.prototype.resetNorth = function(_, w) {
            return this.rotateTo(0, o.extend({ duration: 1e3 }, _), w), this;
          }, v.prototype.resetNorthPitch = function(_, w) {
            return this.easeTo(o.extend({ bearing: 0, pitch: 0, duration: 1e3 }, _), w), this;
          }, v.prototype.snapToNorth = function(_, w) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(_, w) : this;
          }, v.prototype.getPitch = function() {
            return this.transform.pitch;
          }, v.prototype.setPitch = function(_, w) {
            return this.jumpTo({ pitch: _ }, w), this;
          }, v.prototype.cameraForBounds = function(_, w) {
            _ = o.LngLatBounds.convert(_);
            var R = w && w.bearing || 0;
            return this._cameraForBoxAndBearing(_.getNorthWest(), _.getSouthEast(), R, w);
          }, v.prototype._cameraForBoxAndBearing = function(_, w, R, D) {
            var k = { top: 0, bottom: 0, right: 0, left: 0 };
            if (typeof (D = o.extend({ padding: k, offset: [0, 0], maxZoom: this.transform.maxZoom }, D)).padding == "number") {
              var H = D.padding;
              D.padding = { top: H, bottom: H, right: H, left: H };
            }
            D.padding = o.extend(k, D.padding);
            var J = this.transform, oe = J.padding, Ce = J.project(o.LngLat.convert(_)), Se = J.project(o.LngLat.convert(w)), Oe = Ce.rotate(-R * Math.PI / 180), He = Se.rotate(-R * Math.PI / 180), ze = new o.Point(Math.max(Oe.x, He.x), Math.max(Oe.y, He.y)), h = new o.Point(Math.min(Oe.x, He.x), Math.min(Oe.y, He.y)), f = ze.sub(h), A = (J.width - (oe.left + oe.right + D.padding.left + D.padding.right)) / f.x, b = (J.height - (oe.top + oe.bottom + D.padding.top + D.padding.bottom)) / f.y;
            if (!(b < 0 || A < 0)) {
              var T = Math.min(J.scaleZoom(J.scale * Math.min(A, b)), D.maxZoom), C = typeof D.offset.x == "number" ? new o.Point(D.offset.x, D.offset.y) : o.Point.convert(D.offset), I = new o.Point((D.padding.left - D.padding.right) / 2, (D.padding.top - D.padding.bottom) / 2).rotate(R * Math.PI / 180), B = C.add(I).mult(J.scale / J.zoomScale(T));
              return { center: J.unproject(Ce.add(Se).div(2).sub(B)), zoom: T, bearing: R };
            }
            o.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
          }, v.prototype.fitBounds = function(_, w, R) {
            return this._fitInternal(this.cameraForBounds(_, w), w, R);
          }, v.prototype.fitScreenCoordinates = function(_, w, R, D, k) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(o.Point.convert(_)), this.transform.pointLocation(o.Point.convert(w)), R, D), D, k);
          }, v.prototype._fitInternal = function(_, w, R) {
            return _ ? (delete (w = o.extend(_, w)).padding, w.linear ? this.easeTo(w, R) : this.flyTo(w, R)) : this;
          }, v.prototype.jumpTo = function(_, w) {
            this.stop();
            var R = this.transform, D = !1, k = !1, H = !1;
            return "zoom" in _ && R.zoom !== +_.zoom && (D = !0, R.zoom = +_.zoom), _.center !== void 0 && (R.center = o.LngLat.convert(_.center)), "bearing" in _ && R.bearing !== +_.bearing && (k = !0, R.bearing = +_.bearing), "pitch" in _ && R.pitch !== +_.pitch && (H = !0, R.pitch = +_.pitch), _.padding == null || R.isPaddingEqual(_.padding) || (R.padding = _.padding), this.fire(new o.Event("movestart", w)).fire(new o.Event("move", w)), D && this.fire(new o.Event("zoomstart", w)).fire(new o.Event("zoom", w)).fire(new o.Event("zoomend", w)), k && this.fire(new o.Event("rotatestart", w)).fire(new o.Event("rotate", w)).fire(new o.Event("rotateend", w)), H && this.fire(new o.Event("pitchstart", w)).fire(new o.Event("pitch", w)).fire(new o.Event("pitchend", w)), this.fire(new o.Event("moveend", w));
          }, v.prototype.easeTo = function(_, w) {
            var R = this;
            this._stop(!1, _.easeId), ((_ = o.extend({ offset: [0, 0], duration: 500, easing: o.ease }, _)).animate === !1 || !_.essential && o.browser.prefersReducedMotion) && (_.duration = 0);
            var D = this.transform, k = this.getZoom(), H = this.getBearing(), J = this.getPitch(), oe = this.getPadding(), Ce = "zoom" in _ ? +_.zoom : k, Se = "bearing" in _ ? this._normalizeBearing(_.bearing, H) : H, Oe = "pitch" in _ ? +_.pitch : J, He = "padding" in _ ? _.padding : D.padding, ze = o.Point.convert(_.offset), h = D.centerPoint.add(ze), f = D.pointLocation(h), A = o.LngLat.convert(_.center || f);
            this._normalizeCenter(A);
            var b, T, C = D.project(f), I = D.project(A).sub(C), B = D.zoomScale(Ce - k);
            _.around && (b = o.LngLat.convert(_.around), T = D.locationPoint(b));
            var F = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
            return this._zooming = this._zooming || Ce !== k, this._rotating = this._rotating || H !== Se, this._pitching = this._pitching || Oe !== J, this._padding = !D.isPaddingEqual(He), this._easeId = _.easeId, this._prepareEase(w, _.noMoveStart, F), this._ease((function(z) {
              if (R._zooming && (D.zoom = o.number(k, Ce, z)), R._rotating && (D.bearing = o.number(H, Se, z)), R._pitching && (D.pitch = o.number(J, Oe, z)), R._padding && (D.interpolatePadding(oe, He, z), h = D.centerPoint.add(ze)), b) D.setLocationAtPoint(b, T);
              else {
                var W = D.zoomScale(D.zoom - k), ue = Ce > k ? Math.min(2, B) : Math.max(0.5, B), Ie = Math.pow(ue, 1 - z), Re = D.unproject(C.add(I.mult(z * Ie)).mult(W));
                D.setLocationAtPoint(D.renderWorldCopies ? Re.wrap() : Re, h);
              }
              R._fireMoveEvents(w);
            }), (function(z) {
              R._afterEase(w, z);
            }), _), this;
          }, v.prototype._prepareEase = function(_, w, R) {
            R === void 0 && (R = {}), this._moving = !0, w || R.moving || this.fire(new o.Event("movestart", _)), this._zooming && !R.zooming && this.fire(new o.Event("zoomstart", _)), this._rotating && !R.rotating && this.fire(new o.Event("rotatestart", _)), this._pitching && !R.pitching && this.fire(new o.Event("pitchstart", _));
          }, v.prototype._fireMoveEvents = function(_) {
            this.fire(new o.Event("move", _)), this._zooming && this.fire(new o.Event("zoom", _)), this._rotating && this.fire(new o.Event("rotate", _)), this._pitching && this.fire(new o.Event("pitch", _));
          }, v.prototype._afterEase = function(_, w) {
            if (!this._easeId || !w || this._easeId !== w) {
              delete this._easeId;
              var R = this._zooming, D = this._rotating, k = this._pitching;
              this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, R && this.fire(new o.Event("zoomend", _)), D && this.fire(new o.Event("rotateend", _)), k && this.fire(new o.Event("pitchend", _)), this.fire(new o.Event("moveend", _));
            }
          }, v.prototype.flyTo = function(_, w) {
            var R = this;
            if (!_.essential && o.browser.prefersReducedMotion) {
              var D = o.pick(_, ["center", "zoom", "bearing", "pitch", "around"]);
              return this.jumpTo(D, w);
            }
            this.stop(), _ = o.extend({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: o.ease }, _);
            var k = this.transform, H = this.getZoom(), J = this.getBearing(), oe = this.getPitch(), Ce = this.getPadding(), Se = "zoom" in _ ? o.clamp(+_.zoom, k.minZoom, k.maxZoom) : H, Oe = "bearing" in _ ? this._normalizeBearing(_.bearing, J) : J, He = "pitch" in _ ? +_.pitch : oe, ze = "padding" in _ ? _.padding : k.padding, h = k.zoomScale(Se - H), f = o.Point.convert(_.offset), A = k.centerPoint.add(f), b = k.pointLocation(A), T = o.LngLat.convert(_.center || b);
            this._normalizeCenter(T);
            var C = k.project(b), I = k.project(T).sub(C), B = _.curve, F = Math.max(k.width, k.height), z = F / h, W = I.mag();
            if ("minZoom" in _) {
              var ue = o.clamp(Math.min(_.minZoom, H, Se), k.minZoom, k.maxZoom), Ie = F / k.zoomScale(ue - H);
              B = Math.sqrt(Ie / W * 2);
            }
            var Re = B * B;
            function Be(Ht) {
              var Ut = (z * z - F * F + (Ht ? -1 : 1) * Re * Re * W * W) / (2 * (Ht ? z : F) * Re * W);
              return Math.log(Math.sqrt(Ut * Ut + 1) - Ut);
            }
            function Ze(Ht) {
              return (Math.exp(Ht) - Math.exp(-Ht)) / 2;
            }
            function We(Ht) {
              return (Math.exp(Ht) + Math.exp(-Ht)) / 2;
            }
            var rt = Be(0), et = function(Ht) {
              return We(rt) / We(rt + B * Ht);
            }, Je = function(Ht) {
              return F * ((We(rt) * (Ze(Ut = rt + B * Ht) / We(Ut)) - Ze(rt)) / Re) / W;
              var Ut;
            }, $e = (Be(1) - rt) / B;
            if (Math.abs(W) < 1e-6 || !isFinite($e)) {
              if (Math.abs(F - z) < 1e-6) return this.easeTo(_, w);
              var Bt = z < F ? -1 : 1;
              $e = Math.abs(Math.log(z / F)) / B, Je = function() {
                return 0;
              }, et = function(Ht) {
                return Math.exp(Bt * B * Ht);
              };
            }
            return _.duration = "duration" in _ ? +_.duration : 1e3 * $e / ("screenSpeed" in _ ? +_.screenSpeed / B : +_.speed), _.maxDuration && _.duration > _.maxDuration && (_.duration = 0), this._zooming = !0, this._rotating = J !== Oe, this._pitching = He !== oe, this._padding = !k.isPaddingEqual(ze), this._prepareEase(w, !1), this._ease((function(Ht) {
              var Ut = Ht * $e, Or = 1 / et(Ut);
              k.zoom = Ht === 1 ? Se : H + k.scaleZoom(Or), R._rotating && (k.bearing = o.number(J, Oe, Ht)), R._pitching && (k.pitch = o.number(oe, He, Ht)), R._padding && (k.interpolatePadding(Ce, ze, Ht), A = k.centerPoint.add(f));
              var Cr = Ht === 1 ? T : k.unproject(C.add(I.mult(Je(Ut))).mult(Or));
              k.setLocationAtPoint(k.renderWorldCopies ? Cr.wrap() : Cr, A), R._fireMoveEvents(w);
            }), (function() {
              return R._afterEase(w);
            }), _), this;
          }, v.prototype.isEasing = function() {
            return !!this._easeFrameId;
          }, v.prototype.stop = function() {
            return this._stop();
          }, v.prototype._stop = function(_, w) {
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              var R = this._onEaseEnd;
              delete this._onEaseEnd, R.call(this, w);
            }
            if (!_) {
              var D = this.handlers;
              D && D.stop(!1);
            }
            return this;
          }, v.prototype._ease = function(_, w, R) {
            R.animate === !1 || R.duration === 0 ? (_(1), w()) : (this._easeStart = o.browser.now(), this._easeOptions = R, this._onEaseFrame = _, this._onEaseEnd = w, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }, v.prototype._renderFrameCallback = function() {
            var _ = Math.min((o.browser.now() - this._easeStart) / this._easeOptions.duration, 1);
            this._onEaseFrame(this._easeOptions.easing(_)), _ < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
          }, v.prototype._normalizeBearing = function(_, w) {
            _ = o.wrap(_, -180, 180);
            var R = Math.abs(_ - w);
            return Math.abs(_ - 360 - w) < R && (_ -= 360), Math.abs(_ + 360 - w) < R && (_ += 360), _;
          }, v.prototype._normalizeCenter = function(_) {
            var w = this.transform;
            if (w.renderWorldCopies && !w.lngRange) {
              var R = _.lng - w.center.lng;
              _.lng += R > 180 ? -360 : R < -180 ? 360 : 0;
            }
          }, v;
        })(o.Evented), us = function(g) {
          g === void 0 && (g = {}), this.options = g, o.bindAll(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);
        };
        us.prototype.getDefaultPosition = function() {
          return "bottom-right";
        }, us.prototype.onAdd = function(g) {
          var v = this.options && this.options.compact;
          return this._map = g, this._container = u.create("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = u.create("button", "mapboxgl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = u.create("div", "mapboxgl-ctrl-attrib-inner", this._container), this._innerContainer.setAttribute("role", "list"), v && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), v === void 0 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
        }, us.prototype.onRemove = function() {
          u.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
        }, us.prototype._setElementTitle = function(g, v) {
          var _ = this._map._getUIString("AttributionControl." + v);
          g.title = _, g.setAttribute("aria-label", _);
        }, us.prototype._toggleAttribution = function() {
          this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-pressed", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-pressed", "true"));
        }, us.prototype._updateEditLink = function() {
          var g = this._editLink;
          g || (g = this._editLink = this._container.querySelector(".mapbox-improve-map"));
          var v = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || o.config.ACCESS_TOKEN }];
          if (g) {
            var _ = v.reduce((function(w, R, D) {
              return R.value && (w += R.key + "=" + R.value + (D < v.length - 1 ? "&" : "")), w;
            }), "?");
            g.href = o.config.FEEDBACK_URL + "/" + _ + (this._map._hash ? this._map._hash.getHashString(!0) : ""), g.rel = "noopener nofollow", this._setElementTitle(g, "MapFeedback");
          }
        }, us.prototype._updateData = function(g) {
          !g || g.sourceDataType !== "metadata" && g.sourceDataType !== "visibility" && g.dataType !== "style" || (this._updateAttributions(), this._updateEditLink());
        }, us.prototype._updateAttributions = function() {
          if (this._map.style) {
            var g = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? g = g.concat(this.options.customAttribution.map((function(H) {
              return typeof H != "string" ? "" : H;
            }))) : typeof this.options.customAttribution == "string" && g.push(this.options.customAttribution)), this._map.style.stylesheet) {
              var v = this._map.style.stylesheet;
              this.styleOwner = v.owner, this.styleId = v.id;
            }
            var _ = this._map.style.sourceCaches;
            for (var w in _) {
              var R = _[w];
              if (R.used) {
                var D = R.getSource();
                D.attribution && g.indexOf(D.attribution) < 0 && g.push(D.attribution);
              }
            }
            g.sort((function(H, J) {
              return H.length - J.length;
            }));
            var k = (g = g.filter((function(H, J) {
              for (var oe = J + 1; oe < g.length; oe++) if (g[oe].indexOf(H) >= 0) return !1;
              return !0;
            }))).join(" | ");
            k !== this._attribHTML && (this._attribHTML = k, g.length ? (this._innerContainer.innerHTML = k, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
          }
        }, us.prototype._updateCompact = function() {
          this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
        };
        var So = function() {
          o.bindAll(["_updateLogo"], this), o.bindAll(["_updateCompact"], this);
        };
        So.prototype.onAdd = function(g) {
          this._map = g, this._container = u.create("div", "mapboxgl-ctrl");
          var v = u.create("a", "mapboxgl-ctrl-logo");
          return v.target = "_blank", v.rel = "noopener nofollow", v.href = "https://www.mapbox.com/", v.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), v.setAttribute("rel", "noopener nofollow"), this._container.appendChild(v), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
        }, So.prototype.onRemove = function() {
          u.remove(this._container), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
        }, So.prototype.getDefaultPosition = function() {
          return "bottom-left";
        }, So.prototype._updateLogo = function(g) {
          g && g.sourceDataType !== "metadata" || (this._container.style.display = this._logoRequired() ? "block" : "none");
        }, So.prototype._logoRequired = function() {
          if (this._map.style) {
            var g = this._map.style.sourceCaches;
            for (var v in g) if (g[v].getSource().mapbox_logo) return !0;
            return !1;
          }
        }, So.prototype._updateCompact = function() {
          var g = this._container.children;
          if (g.length) {
            var v = g[0];
            this._map.getCanvasContainer().offsetWidth < 250 ? v.classList.add("mapboxgl-compact") : v.classList.remove("mapboxgl-compact");
          }
        };
        var Xi = function() {
          this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
        };
        Xi.prototype.add = function(g) {
          var v = ++this._id;
          return this._queue.push({ callback: g, id: v, cancelled: !1 }), v;
        }, Xi.prototype.remove = function(g) {
          for (var v = this._currentlyRunning, _ = 0, w = v ? this._queue.concat(v) : this._queue; _ < w.length; _ += 1) {
            var R = w[_];
            if (R.id === g) return void (R.cancelled = !0);
          }
        }, Xi.prototype.run = function(g) {
          g === void 0 && (g = 0);
          var v = this._currentlyRunning = this._queue;
          this._queue = [];
          for (var _ = 0, w = v; _ < w.length; _ += 1) {
            var R = w[_];
            if (!R.cancelled && (R.callback(g), this._cleared)) break;
          }
          this._cleared = !1, this._currentlyRunning = !1;
        }, Xi.prototype.clear = function() {
          this._currentlyRunning && (this._cleared = !0), this._queue = [];
        };
        var Ho = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm" }, Eu = o.window.HTMLImageElement, Sc = o.window.HTMLElement, Xr = o.window.ImageBitmap, zi = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, interactive: !0, scrollZoom: !0, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: !0, hash: !1, attributionControl: !0, failIfMajorPerformanceCaveat: !1, preserveDrawingBuffer: !1, trackResize: !0, renderWorldCopies: !0, refreshExpiredTiles: !0, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", transformRequest: null, accessToken: null, fadeDuration: 300, crossSourceCollisions: !0 }, Vh = (function(g) {
          function v(w) {
            var R = this;
            if ((w = o.extend({}, zi, w)).minZoom != null && w.maxZoom != null && w.minZoom > w.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (w.minPitch != null && w.maxPitch != null && w.minPitch > w.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (w.minPitch != null && w.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (w.maxPitch != null && w.maxPitch > 60) throw new Error("maxPitch must be less than or equal to 60");
            var D = new qr(w.minZoom, w.maxZoom, w.minPitch, w.maxPitch, w.renderWorldCopies);
            if (g.call(this, D, w), this._interactive = w.interactive, this._maxTileCacheSize = w.maxTileCacheSize, this._failIfMajorPerformanceCaveat = w.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = w.preserveDrawingBuffer, this._antialias = w.antialias, this._trackResize = w.trackResize, this._bearingSnap = w.bearingSnap, this._refreshExpiredTiles = w.refreshExpiredTiles, this._fadeDuration = w.fadeDuration, this._crossSourceCollisions = w.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = w.collectResourceTiming, this._renderTaskQueue = new Xi(), this._controls = [], this._mapId = o.uniqueId(), this._locale = o.extend({}, Ho, w.locale), this._clickTolerance = w.clickTolerance, this._requestManager = new o.RequestManager(w.transformRequest, w.accessToken), typeof w.container == "string") {
              if (this._container = o.window.document.getElementById(w.container), !this._container) throw new Error("Container '" + w.container + "' not found.");
            } else {
              if (!(w.container instanceof Sc)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = w.container;
            }
            if (w.maxBounds && this.setMaxBounds(w.maxBounds), o.bindAll(["_onWindowOnline", "_onWindowResize", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), this.painter === void 0) throw new Error("Failed to initialize WebGL.");
            this.on("move", (function() {
              return R._update(!1);
            })), this.on("moveend", (function() {
              return R._update(!1);
            })), this.on("zoom", (function() {
              return R._update(!0);
            })), o.window !== void 0 && (o.window.addEventListener("online", this._onWindowOnline, !1), o.window.addEventListener("resize", this._onWindowResize, !1), o.window.addEventListener("orientationchange", this._onWindowResize, !1)), this.handlers = new Ar(this, w), this._hash = w.hash && new ns(typeof w.hash == "string" && w.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: w.center, zoom: w.zoom, bearing: w.bearing, pitch: w.pitch }), w.bounds && (this.resize(), this.fitBounds(w.bounds, o.extend({}, w.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = w.localIdeographFontFamily, w.style && this.setStyle(w.style, { localIdeographFontFamily: w.localIdeographFontFamily }), w.attributionControl && this.addControl(new us({ customAttribution: w.customAttribution })), this.addControl(new So(), w.logoPosition), this.on("style.load", (function() {
              R.transform.unmodified && R.jumpTo(R.style.stylesheet);
            })), this.on("data", (function(k) {
              R._update(k.dataType === "style"), R.fire(new o.Event(k.dataType + "data", k));
            })), this.on("dataloading", (function(k) {
              R.fire(new o.Event(k.dataType + "dataloading", k));
            }));
          }
          g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v;
          var _ = { showTileBoundaries: { configurable: !0 }, showPadding: { configurable: !0 }, showCollisionBoxes: { configurable: !0 }, showOverdrawInspector: { configurable: !0 }, repaint: { configurable: !0 }, vertices: { configurable: !0 }, version: { configurable: !0 } };
          return v.prototype._getMapId = function() {
            return this._mapId;
          }, v.prototype.addControl = function(w, R) {
            if (R === void 0 && (R = w.getDefaultPosition ? w.getDefaultPosition() : "top-right"), !w || !w.onAdd) return this.fire(new o.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            var D = w.onAdd(this);
            this._controls.push(w);
            var k = this._controlPositions[R];
            return R.indexOf("bottom") !== -1 ? k.insertBefore(D, k.firstChild) : k.appendChild(D), this;
          }, v.prototype.removeControl = function(w) {
            if (!w || !w.onRemove) return this.fire(new o.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            var R = this._controls.indexOf(w);
            return R > -1 && this._controls.splice(R, 1), w.onRemove(this), this;
          }, v.prototype.hasControl = function(w) {
            return this._controls.indexOf(w) > -1;
          }, v.prototype.resize = function(w) {
            var R = this._containerDimensions(), D = R[0], k = R[1];
            if (D === this.transform.width && k === this.transform.height) return this;
            this._resizeCanvas(D, k), this.transform.resize(D, k), this.painter.resize(D, k);
            var H = !this._moving;
            return H && this.fire(new o.Event("movestart", w)).fire(new o.Event("move", w)), this.fire(new o.Event("resize", w)), H && this.fire(new o.Event("moveend", w)), this;
          }, v.prototype.getBounds = function() {
            return this.transform.getBounds();
          }, v.prototype.getMaxBounds = function() {
            return this.transform.getMaxBounds();
          }, v.prototype.setMaxBounds = function(w) {
            return this.transform.setMaxBounds(o.LngLatBounds.convert(w)), this._update();
          }, v.prototype.setMinZoom = function(w) {
            if ((w = w ?? -2) >= -2 && w <= this.transform.maxZoom) return this.transform.minZoom = w, this._update(), this.getZoom() < w && this.setZoom(w), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }, v.prototype.getMinZoom = function() {
            return this.transform.minZoom;
          }, v.prototype.setMaxZoom = function(w) {
            if ((w = w ?? 22) >= this.transform.minZoom) return this.transform.maxZoom = w, this._update(), this.getZoom() > w && this.setZoom(w), this;
            throw new Error("maxZoom must be greater than the current minZoom");
          }, v.prototype.getMaxZoom = function() {
            return this.transform.maxZoom;
          }, v.prototype.setMinPitch = function(w) {
            if ((w = w ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (w >= 0 && w <= this.transform.maxPitch) return this.transform.minPitch = w, this._update(), this.getPitch() < w && this.setPitch(w), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }, v.prototype.getMinPitch = function() {
            return this.transform.minPitch;
          }, v.prototype.setMaxPitch = function(w) {
            if ((w = w ?? 60) > 60) throw new Error("maxPitch must be less than or equal to 60");
            if (w >= this.transform.minPitch) return this.transform.maxPitch = w, this._update(), this.getPitch() > w && this.setPitch(w), this;
            throw new Error("maxPitch must be greater than the current minPitch");
          }, v.prototype.getMaxPitch = function() {
            return this.transform.maxPitch;
          }, v.prototype.getRenderWorldCopies = function() {
            return this.transform.renderWorldCopies;
          }, v.prototype.setRenderWorldCopies = function(w) {
            return this.transform.renderWorldCopies = w, this._update();
          }, v.prototype.project = function(w) {
            return this.transform.locationPoint(o.LngLat.convert(w));
          }, v.prototype.unproject = function(w) {
            return this.transform.pointLocation(o.Point.convert(w));
          }, v.prototype.isMoving = function() {
            return this._moving || this.handlers.isMoving();
          }, v.prototype.isZooming = function() {
            return this._zooming || this.handlers.isZooming();
          }, v.prototype.isRotating = function() {
            return this._rotating || this.handlers.isRotating();
          }, v.prototype._createDelegatedListener = function(w, R, D) {
            var k, H = this;
            if (w === "mouseenter" || w === "mouseover") {
              var J = !1;
              return { layer: R, listener: D, delegates: { mousemove: function(Ce) {
                var Se = H.getLayer(R) ? H.queryRenderedFeatures(Ce.point, { layers: [R] }) : [];
                Se.length ? J || (J = !0, D.call(H, new xi(w, H, Ce.originalEvent, { features: Se }))) : J = !1;
              }, mouseout: function() {
                J = !1;
              } } };
            }
            if (w === "mouseleave" || w === "mouseout") {
              var oe = !1;
              return { layer: R, listener: D, delegates: { mousemove: function(Ce) {
                (H.getLayer(R) ? H.queryRenderedFeatures(Ce.point, { layers: [R] }) : []).length ? oe = !0 : oe && (oe = !1, D.call(H, new xi(w, H, Ce.originalEvent)));
              }, mouseout: function(Ce) {
                oe && (oe = !1, D.call(H, new xi(w, H, Ce.originalEvent)));
              } } };
            }
            return { layer: R, listener: D, delegates: (k = {}, k[w] = function(Ce) {
              var Se = H.getLayer(R) ? H.queryRenderedFeatures(Ce.point, { layers: [R] }) : [];
              Se.length && (Ce.features = Se, D.call(H, Ce), delete Ce.features);
            }, k) };
          }, v.prototype.on = function(w, R, D) {
            if (D === void 0) return g.prototype.on.call(this, w, R);
            var k = this._createDelegatedListener(w, R, D);
            for (var H in this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[w] = this._delegatedListeners[w] || [], this._delegatedListeners[w].push(k), k.delegates) this.on(H, k.delegates[H]);
            return this;
          }, v.prototype.once = function(w, R, D) {
            if (D === void 0) return g.prototype.once.call(this, w, R);
            var k = this._createDelegatedListener(w, R, D);
            for (var H in k.delegates) this.once(H, k.delegates[H]);
            return this;
          }, v.prototype.off = function(w, R, D) {
            var k = this;
            return D === void 0 ? g.prototype.off.call(this, w, R) : (this._delegatedListeners && this._delegatedListeners[w] && (function(H) {
              for (var J = H[w], oe = 0; oe < J.length; oe++) {
                var Ce = J[oe];
                if (Ce.layer === R && Ce.listener === D) {
                  for (var Se in Ce.delegates) k.off(Se, Ce.delegates[Se]);
                  return J.splice(oe, 1), k;
                }
              }
            })(this._delegatedListeners), this);
          }, v.prototype.queryRenderedFeatures = function(w, R) {
            if (!this.style) return [];
            var D;
            if (R !== void 0 || w === void 0 || w instanceof o.Point || Array.isArray(w) || (R = w, w = void 0), R = R || {}, (w = w || [[0, 0], [this.transform.width, this.transform.height]]) instanceof o.Point || typeof w[0] == "number") D = [o.Point.convert(w)];
            else {
              var k = o.Point.convert(w[0]), H = o.Point.convert(w[1]);
              D = [k, new o.Point(H.x, k.y), H, new o.Point(k.x, H.y), k];
            }
            return this.style.queryRenderedFeatures(D, R, this.transform);
          }, v.prototype.querySourceFeatures = function(w, R) {
            return this.style.querySourceFeatures(w, R);
          }, v.prototype.setStyle = function(w, R) {
            return (R = o.extend({}, { localIdeographFontFamily: this._localIdeographFontFamily }, R)).diff !== !1 && R.localIdeographFontFamily === this._localIdeographFontFamily && this.style && w ? (this._diffStyle(w, R), this) : (this._localIdeographFontFamily = R.localIdeographFontFamily, this._updateStyle(w, R));
          }, v.prototype._getUIString = function(w) {
            var R = this._locale[w];
            if (R == null) throw new Error("Missing UI string '" + w + "'");
            return R;
          }, v.prototype._updateStyle = function(w, R) {
            return this.style && (this.style.setEventedParent(null), this.style._remove()), w ? (this.style = new _s(this, R || {}), this.style.setEventedParent(this, { style: this.style }), typeof w == "string" ? this.style.loadURL(w) : this.style.loadJSON(w), this) : (delete this.style, this);
          }, v.prototype._lazyInitEmptyStyle = function() {
            this.style || (this.style = new _s(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
          }, v.prototype._diffStyle = function(w, R) {
            var D = this;
            if (typeof w == "string") {
              var k = this._requestManager.normalizeStyleURL(w), H = this._requestManager.transformRequest(k, o.ResourceType.Style);
              o.getJSON(H, (function(J, oe) {
                J ? D.fire(new o.ErrorEvent(J)) : oe && D._updateDiff(oe, R);
              }));
            } else typeof w == "object" && this._updateDiff(w, R);
          }, v.prototype._updateDiff = function(w, R) {
            try {
              this.style.setState(w) && this._update(!0);
            } catch (D) {
              o.warnOnce("Unable to perform style diff: " + (D.message || D.error || D) + ".  Rebuilding the style from scratch."), this._updateStyle(w, R);
            }
          }, v.prototype.getStyle = function() {
            if (this.style) return this.style.serialize();
          }, v.prototype.isStyleLoaded = function() {
            return this.style ? this.style.loaded() : o.warnOnce("There is no style added to the map.");
          }, v.prototype.addSource = function(w, R) {
            return this._lazyInitEmptyStyle(), this.style.addSource(w, R), this._update(!0);
          }, v.prototype.isSourceLoaded = function(w) {
            var R = this.style && this.style.sourceCaches[w];
            if (R !== void 0) return R.loaded();
            this.fire(new o.ErrorEvent(new Error("There is no source with ID '" + w + "'")));
          }, v.prototype.areTilesLoaded = function() {
            var w = this.style && this.style.sourceCaches;
            for (var R in w) {
              var D = w[R]._tiles;
              for (var k in D) {
                var H = D[k];
                if (H.state !== "loaded" && H.state !== "errored") return !1;
              }
            }
            return !0;
          }, v.prototype.addSourceType = function(w, R, D) {
            return this._lazyInitEmptyStyle(), this.style.addSourceType(w, R, D);
          }, v.prototype.removeSource = function(w) {
            return this.style.removeSource(w), this._update(!0);
          }, v.prototype.getSource = function(w) {
            return this.style.getSource(w);
          }, v.prototype.addImage = function(w, R, D) {
            D === void 0 && (D = {});
            var k = D.pixelRatio;
            k === void 0 && (k = 1);
            var H = D.sdf;
            H === void 0 && (H = !1);
            var J = D.stretchX, oe = D.stretchY, Ce = D.content;
            if (this._lazyInitEmptyStyle(), R instanceof Eu || Xr && R instanceof Xr) {
              var Se = o.browser.getImageData(R);
              this.style.addImage(w, { data: new o.RGBAImage({ width: Se.width, height: Se.height }, Se.data), pixelRatio: k, stretchX: J, stretchY: oe, content: Ce, sdf: H, version: 0 });
            } else {
              if (R.width === void 0 || R.height === void 0) return this.fire(new o.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              var Oe = R;
              this.style.addImage(w, { data: new o.RGBAImage({ width: R.width, height: R.height }, new Uint8Array(R.data)), pixelRatio: k, stretchX: J, stretchY: oe, content: Ce, sdf: H, version: 0, userImage: Oe }), Oe.onAdd && Oe.onAdd(this, w);
            }
          }, v.prototype.updateImage = function(w, R) {
            var D = this.style.getImage(w);
            if (!D) return this.fire(new o.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            var k = R instanceof Eu || Xr && R instanceof Xr ? o.browser.getImageData(R) : R, H = k.width, J = k.height, oe = k.data;
            return H === void 0 || J === void 0 ? this.fire(new o.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"))) : H !== D.data.width || J !== D.data.height ? this.fire(new o.ErrorEvent(new Error("The width and height of the updated image must be that same as the previous version of the image"))) : (D.data.replace(oe, !(R instanceof Eu || Xr && R instanceof Xr)), void this.style.updateImage(w, D));
          }, v.prototype.hasImage = function(w) {
            return w ? !!this.style.getImage(w) : (this.fire(new o.ErrorEvent(new Error("Missing required image id"))), !1);
          }, v.prototype.removeImage = function(w) {
            this.style.removeImage(w);
          }, v.prototype.loadImage = function(w, R) {
            o.getImage(this._requestManager.transformRequest(w, o.ResourceType.Image), R);
          }, v.prototype.listImages = function() {
            return this.style.listImages();
          }, v.prototype.addLayer = function(w, R) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(w, R), this._update(!0);
          }, v.prototype.moveLayer = function(w, R) {
            return this.style.moveLayer(w, R), this._update(!0);
          }, v.prototype.removeLayer = function(w) {
            return this.style.removeLayer(w), this._update(!0);
          }, v.prototype.getLayer = function(w) {
            return this.style.getLayer(w);
          }, v.prototype.setLayerZoomRange = function(w, R, D) {
            return this.style.setLayerZoomRange(w, R, D), this._update(!0);
          }, v.prototype.setFilter = function(w, R, D) {
            return D === void 0 && (D = {}), this.style.setFilter(w, R, D), this._update(!0);
          }, v.prototype.getFilter = function(w) {
            return this.style.getFilter(w);
          }, v.prototype.setPaintProperty = function(w, R, D, k) {
            return k === void 0 && (k = {}), this.style.setPaintProperty(w, R, D, k), this._update(!0);
          }, v.prototype.getPaintProperty = function(w, R) {
            return this.style.getPaintProperty(w, R);
          }, v.prototype.setLayoutProperty = function(w, R, D, k) {
            return k === void 0 && (k = {}), this.style.setLayoutProperty(w, R, D, k), this._update(!0);
          }, v.prototype.getLayoutProperty = function(w, R) {
            return this.style.getLayoutProperty(w, R);
          }, v.prototype.setLight = function(w, R) {
            return R === void 0 && (R = {}), this._lazyInitEmptyStyle(), this.style.setLight(w, R), this._update(!0);
          }, v.prototype.getLight = function() {
            return this.style.getLight();
          }, v.prototype.setFeatureState = function(w, R) {
            return this.style.setFeatureState(w, R), this._update();
          }, v.prototype.removeFeatureState = function(w, R) {
            return this.style.removeFeatureState(w, R), this._update();
          }, v.prototype.getFeatureState = function(w) {
            return this.style.getFeatureState(w);
          }, v.prototype.getContainer = function() {
            return this._container;
          }, v.prototype.getCanvasContainer = function() {
            return this._canvasContainer;
          }, v.prototype.getCanvas = function() {
            return this._canvas;
          }, v.prototype._containerDimensions = function() {
            var w = 0, R = 0;
            return this._container && (w = this._container.clientWidth || 400, R = this._container.clientHeight || 300), [w, R];
          }, v.prototype._detectMissingCSS = function() {
            o.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") !== "rgb(250, 128, 114)" && o.warnOnce("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
          }, v.prototype._setupContainer = function() {
            var w = this._container;
            w.classList.add("mapboxgl-map"), (this._missingCSSCanary = u.create("div", "mapboxgl-canary", w)).style.visibility = "hidden", this._detectMissingCSS();
            var R = this._canvasContainer = u.create("div", "mapboxgl-canvas-container", w);
            this._interactive && R.classList.add("mapboxgl-interactive"), this._canvas = u.create("canvas", "mapboxgl-canvas", R), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"), this._canvas.setAttribute("role", "region");
            var D = this._containerDimensions();
            this._resizeCanvas(D[0], D[1]);
            var k = this._controlContainer = u.create("div", "mapboxgl-control-container", w), H = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((function(J) {
              H[J] = u.create("div", "mapboxgl-ctrl-" + J, k);
            })), this._container.addEventListener("scroll", this._onMapScroll, !1);
          }, v.prototype._resizeCanvas = function(w, R) {
            var D = o.browser.devicePixelRatio || 1;
            this._canvas.width = D * w, this._canvas.height = D * R, this._canvas.style.width = w + "px", this._canvas.style.height = R + "px";
          }, v.prototype._setupPainter = function() {
            var w = o.extend({}, l.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || !1 }), R = this._canvas.getContext("webgl", w) || this._canvas.getContext("experimental-webgl", w);
            R ? (this.painter = new Gn(R, this.transform), o.webpSupported.testSupport(R)) : this.fire(new o.ErrorEvent(new Error("Failed to initialize WebGL")));
          }, v.prototype._contextLost = function(w) {
            w.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new o.Event("webglcontextlost", { originalEvent: w }));
          }, v.prototype._contextRestored = function(w) {
            this._setupPainter(), this.resize(), this._update(), this.fire(new o.Event("webglcontextrestored", { originalEvent: w }));
          }, v.prototype._onMapScroll = function(w) {
            if (w.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
          }, v.prototype.loaded = function() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }, v.prototype._update = function(w) {
            return this.style ? (this._styleDirty = this._styleDirty || w, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
          }, v.prototype._requestRenderFrame = function(w) {
            return this._update(), this._renderTaskQueue.add(w);
          }, v.prototype._cancelRenderFrame = function(w) {
            this._renderTaskQueue.remove(w);
          }, v.prototype._render = function(w) {
            var R, D = this, k = 0, H = this.painter.context.extTimerQuery;
            if (this.listens("gpu-timing-frame") && (R = H.createQueryEXT(), H.beginQueryEXT(H.TIME_ELAPSED_EXT, R), k = o.browser.now()), this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(w), !this._removed) {
              var J = !1;
              if (this.style && this._styleDirty) {
                this._styleDirty = !1;
                var oe = this.transform.zoom, Ce = o.browser.now();
                this.style.zoomHistory.update(oe, Ce);
                var Se = new o.EvaluationParameters(oe, { now: Ce, fadeDuration: this._fadeDuration, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), Oe = Se.crossFadingFactor();
                Oe === 1 && Oe === this._crossFadingFactor || (J = !0, this._crossFadingFactor = Oe), this.style.update(Se);
              }
              if (this.style && this._sourcesDirty && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, this._fadeDuration, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: this._fadeDuration, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer") }), this.fire(new o.Event("render")), this.loaded() && !this._loaded && (this._loaded = !0, this.fire(new o.Event("load"))), this.style && (this.style.hasTransitions() || J) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), this.listens("gpu-timing-frame")) {
                var He = o.browser.now() - k;
                H.endQueryEXT(H.TIME_ELAPSED_EXT, R), setTimeout((function() {
                  var f = H.getQueryObjectEXT(R, H.QUERY_RESULT_EXT) / 1e6;
                  H.deleteQueryEXT(R), D.fire(new o.Event("gpu-timing-frame", { cpuTime: He, gpuTime: f }));
                }), 50);
              }
              if (this.listens("gpu-timing-layer")) {
                var ze = this.painter.collectGpuTimers();
                setTimeout((function() {
                  var f = D.painter.queryGpuTimers(ze);
                  D.fire(new o.Event("gpu-timing-layer", { layerTimes: f }));
                }), 50);
              }
              var h = this._sourcesDirty || this._styleDirty || this._placementDirty;
              return h || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new o.Event("idle")), !this._loaded || this._fullyLoaded || h || (this._fullyLoaded = !0), this;
            }
          }, v.prototype.remove = function() {
            this._hash && this._hash.remove();
            for (var w = 0, R = this._controls; w < R.length; w += 1) R[w].onRemove(this);
            this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), o.window !== void 0 && (o.window.removeEventListener("resize", this._onWindowResize, !1), o.window.removeEventListener("orientationchange", this._onWindowResize, !1), o.window.removeEventListener("online", this._onWindowOnline, !1));
            var D = this.painter.context.gl.getExtension("WEBGL_lose_context");
            D && D.loseContext(), Io(this._canvasContainer), Io(this._controlContainer), Io(this._missingCSSCanary), this._container.classList.remove("mapboxgl-map"), this._removed = !0, this.fire(new o.Event("remove"));
          }, v.prototype.triggerRepaint = function() {
            var w = this;
            this.style && !this._frame && (this._frame = o.browser.frame((function(R) {
              w._frame = null, w._render(R);
            })));
          }, v.prototype._onWindowOnline = function() {
            this._update();
          }, v.prototype._onWindowResize = function(w) {
            this._trackResize && this.resize({ originalEvent: w })._update();
          }, _.showTileBoundaries.get = function() {
            return !!this._showTileBoundaries;
          }, _.showTileBoundaries.set = function(w) {
            this._showTileBoundaries !== w && (this._showTileBoundaries = w, this._update());
          }, _.showPadding.get = function() {
            return !!this._showPadding;
          }, _.showPadding.set = function(w) {
            this._showPadding !== w && (this._showPadding = w, this._update());
          }, _.showCollisionBoxes.get = function() {
            return !!this._showCollisionBoxes;
          }, _.showCollisionBoxes.set = function(w) {
            this._showCollisionBoxes !== w && (this._showCollisionBoxes = w, w ? this.style._generateCollisionBoxes() : this._update());
          }, _.showOverdrawInspector.get = function() {
            return !!this._showOverdrawInspector;
          }, _.showOverdrawInspector.set = function(w) {
            this._showOverdrawInspector !== w && (this._showOverdrawInspector = w, this._update());
          }, _.repaint.get = function() {
            return !!this._repaint;
          }, _.repaint.set = function(w) {
            this._repaint !== w && (this._repaint = w, this.triggerRepaint());
          }, _.vertices.get = function() {
            return !!this._vertices;
          }, _.vertices.set = function(w) {
            this._vertices = w, this._update();
          }, v.prototype._setCacheLimits = function(w, R) {
            o.setCacheLimits(w, R);
          }, _.version.get = function() {
            return o.version;
          }, Object.defineProperties(v.prototype, _), v;
        })(Tu);
        function Io(g) {
          g.parentNode && g.parentNode.removeChild(g);
        }
        var Ns = { showCompass: !0, showZoom: !0, visualizePitch: !1 }, sa = function(g) {
          var v = this;
          this.options = o.extend({}, Ns, g), this._container = u.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (function(_) {
            return _.preventDefault();
          })), this.options.showZoom && (o.bindAll(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", (function(_) {
            return v._map.zoomIn({}, { originalEvent: _ });
          })), u.create("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", !0), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", (function(_) {
            return v._map.zoomOut({}, { originalEvent: _ });
          })), u.create("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", !0)), this.options.showCompass && (o.bindAll(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", (function(_) {
            v.options.visualizePitch ? v._map.resetNorthPitch({}, { originalEvent: _ }) : v._map.resetNorth({}, { originalEvent: _ });
          })), this._compassIcon = u.create("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", !0));
        };
        sa.prototype._updateZoomButtons = function() {
          var g = this._map.getZoom(), v = g === this._map.getMaxZoom(), _ = g === this._map.getMinZoom();
          this._zoomInButton.disabled = v, this._zoomOutButton.disabled = _, this._zoomInButton.setAttribute("aria-disabled", v.toString()), this._zoomOutButton.setAttribute("aria-disabled", _.toString());
        }, sa.prototype._rotateCompassArrow = function() {
          var g = this.options.visualizePitch ? "scale(" + 1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5) + ") rotateX(" + this._map.transform.pitch + "deg) rotateZ(" + this._map.transform.angle * (180 / Math.PI) + "deg)" : "rotate(" + this._map.transform.angle * (180 / Math.PI) + "deg)";
          this._compassIcon.style.transform = g;
        }, sa.prototype.onAdd = function(g) {
          return this._map = g, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Us(this._map, this._compass, this.options.visualizePitch)), this._container;
        }, sa.prototype.onRemove = function() {
          u.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
        }, sa.prototype._createButton = function(g, v) {
          var _ = u.create("button", g, this._container);
          return _.type = "button", _.addEventListener("click", v), _;
        }, sa.prototype._setButtonTitle = function(g, v) {
          var _ = this._map._getUIString("NavigationControl." + v);
          g.title = _, g.setAttribute("aria-label", _);
        };
        var Us = function(g, v, _) {
          _ === void 0 && (_ = !1), this._clickTolerance = 10, this.element = v, this.mouseRotate = new Ec({ clickTolerance: g.dragRotate._mouseRotate._clickTolerance }), this.map = g, _ && (this.mousePitch = new yf({ clickTolerance: g.dragRotate._mousePitch._clickTolerance })), o.bindAll(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), u.addEventListener(v, "mousedown", this.mousedown), u.addEventListener(v, "touchstart", this.touchstart, { passive: !1 }), u.addEventListener(v, "touchmove", this.touchmove), u.addEventListener(v, "touchend", this.touchend), u.addEventListener(v, "touchcancel", this.reset);
        };
        function Fl(g, v, _) {
          if (g = new o.LngLat(g.lng, g.lat), v) {
            var w = new o.LngLat(g.lng - 360, g.lat), R = new o.LngLat(g.lng + 360, g.lat), D = _.locationPoint(g).distSqr(v);
            _.locationPoint(w).distSqr(v) < D ? g = w : _.locationPoint(R).distSqr(v) < D && (g = R);
          }
          for (; Math.abs(g.lng - _.center.lng) > 180; ) {
            var k = _.locationPoint(g);
            if (k.x >= 0 && k.y >= 0 && k.x <= _.width && k.y <= _.height) break;
            g.lng > _.center.lng ? g.lng -= 360 : g.lng += 360;
          }
          return g;
        }
        Us.prototype.down = function(g, v) {
          this.mouseRotate.mousedown(g, v), this.mousePitch && this.mousePitch.mousedown(g, v), u.disableDrag();
        }, Us.prototype.move = function(g, v) {
          var _ = this.map, w = this.mouseRotate.mousemoveWindow(g, v);
          if (w && w.bearingDelta && _.setBearing(_.getBearing() + w.bearingDelta), this.mousePitch) {
            var R = this.mousePitch.mousemoveWindow(g, v);
            R && R.pitchDelta && _.setPitch(_.getPitch() + R.pitchDelta);
          }
        }, Us.prototype.off = function() {
          var g = this.element;
          u.removeEventListener(g, "mousedown", this.mousedown), u.removeEventListener(g, "touchstart", this.touchstart, { passive: !1 }), u.removeEventListener(g, "touchmove", this.touchmove), u.removeEventListener(g, "touchend", this.touchend), u.removeEventListener(g, "touchcancel", this.reset), this.offTemp();
        }, Us.prototype.offTemp = function() {
          u.enableDrag(), u.removeEventListener(o.window, "mousemove", this.mousemove), u.removeEventListener(o.window, "mouseup", this.mouseup);
        }, Us.prototype.mousedown = function(g) {
          this.down(o.extend({}, g, { ctrlKey: !0, preventDefault: function() {
            return g.preventDefault();
          } }), u.mousePos(this.element, g)), u.addEventListener(o.window, "mousemove", this.mousemove), u.addEventListener(o.window, "mouseup", this.mouseup);
        }, Us.prototype.mousemove = function(g) {
          this.move(g, u.mousePos(this.element, g));
        }, Us.prototype.mouseup = function(g) {
          this.mouseRotate.mouseupWindow(g), this.mousePitch && this.mousePitch.mouseupWindow(g), this.offTemp();
        }, Us.prototype.touchstart = function(g) {
          g.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = u.touchPos(this.element, g.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: !0, preventDefault: function() {
            return g.preventDefault();
          } }, this._startPos));
        }, Us.prototype.touchmove = function(g) {
          g.targetTouches.length !== 1 ? this.reset() : (this._lastPos = u.touchPos(this.element, g.targetTouches)[0], this.move({ preventDefault: function() {
            return g.preventDefault();
          } }, this._lastPos));
        }, Us.prototype.touchend = function(g) {
          g.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
        }, Us.prototype.reset = function() {
          this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
        };
        var Po = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
        function Ic(g, v, _) {
          var w = g.classList;
          for (var R in Po) w.remove("mapboxgl-" + _ + "-anchor-" + R);
          w.add("mapboxgl-" + _ + "-anchor-" + v);
        }
        var Ka, Nl = (function(g) {
          function v(_, w) {
            if (g.call(this), (_ instanceof o.window.HTMLElement || w) && (_ = o.extend({ element: _ }, w)), o.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress"], this), this._anchor = _ && _.anchor || "center", this._color = _ && _.color || "#3FB1CE", this._scale = _ && _.scale || 1, this._draggable = _ && _.draggable || !1, this._clickTolerance = _ && _.clickTolerance || 0, this._isDragging = !1, this._state = "inactive", this._rotation = _ && _.rotation || 0, this._rotationAlignment = _ && _.rotationAlignment || "auto", this._pitchAlignment = _ && _.pitchAlignment && _.pitchAlignment !== "auto" ? _.pitchAlignment : this._rotationAlignment, _ && _.element) this._element = _.element, this._offset = o.Point.convert(_ && _.offset || [0, 0]);
            else {
              this._defaultMarker = !0, this._element = u.create("div"), this._element.setAttribute("aria-label", "Map marker");
              var R = u.createNS("http://www.w3.org/2000/svg", "svg");
              R.setAttributeNS(null, "display", "block"), R.setAttributeNS(null, "height", "41px"), R.setAttributeNS(null, "width", "27px"), R.setAttributeNS(null, "viewBox", "0 0 27 41");
              var D = u.createNS("http://www.w3.org/2000/svg", "g");
              D.setAttributeNS(null, "stroke", "none"), D.setAttributeNS(null, "stroke-width", "1"), D.setAttributeNS(null, "fill", "none"), D.setAttributeNS(null, "fill-rule", "evenodd");
              var k = u.createNS("http://www.w3.org/2000/svg", "g");
              k.setAttributeNS(null, "fill-rule", "nonzero");
              var H = u.createNS("http://www.w3.org/2000/svg", "g");
              H.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), H.setAttributeNS(null, "fill", "#000000");
              for (var J = 0, oe = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }]; J < oe.length; J += 1) {
                var Ce = oe[J], Se = u.createNS("http://www.w3.org/2000/svg", "ellipse");
                Se.setAttributeNS(null, "opacity", "0.04"), Se.setAttributeNS(null, "cx", "10.5"), Se.setAttributeNS(null, "cy", "5.80029008"), Se.setAttributeNS(null, "rx", Ce.rx), Se.setAttributeNS(null, "ry", Ce.ry), H.appendChild(Se);
              }
              var Oe = u.createNS("http://www.w3.org/2000/svg", "g");
              Oe.setAttributeNS(null, "fill", this._color);
              var He = u.createNS("http://www.w3.org/2000/svg", "path");
              He.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), Oe.appendChild(He);
              var ze = u.createNS("http://www.w3.org/2000/svg", "g");
              ze.setAttributeNS(null, "opacity", "0.25"), ze.setAttributeNS(null, "fill", "#000000");
              var h = u.createNS("http://www.w3.org/2000/svg", "path");
              h.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), ze.appendChild(h);
              var f = u.createNS("http://www.w3.org/2000/svg", "g");
              f.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), f.setAttributeNS(null, "fill", "#FFFFFF");
              var A = u.createNS("http://www.w3.org/2000/svg", "g");
              A.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              var b = u.createNS("http://www.w3.org/2000/svg", "circle");
              b.setAttributeNS(null, "fill", "#000000"), b.setAttributeNS(null, "opacity", "0.25"), b.setAttributeNS(null, "cx", "5.5"), b.setAttributeNS(null, "cy", "5.5"), b.setAttributeNS(null, "r", "5.4999962");
              var T = u.createNS("http://www.w3.org/2000/svg", "circle");
              T.setAttributeNS(null, "fill", "#FFFFFF"), T.setAttributeNS(null, "cx", "5.5"), T.setAttributeNS(null, "cy", "5.5"), T.setAttributeNS(null, "r", "5.4999962"), A.appendChild(b), A.appendChild(T), k.appendChild(H), k.appendChild(Oe), k.appendChild(ze), k.appendChild(f), k.appendChild(A), R.appendChild(k), R.setAttributeNS(null, "height", 41 * this._scale + "px"), R.setAttributeNS(null, "width", 27 * this._scale + "px"), this._element.appendChild(R), this._offset = o.Point.convert(_ && _.offset || [0, -14]);
            }
            this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", (function(C) {
              C.preventDefault();
            })), this._element.addEventListener("mousedown", (function(C) {
              C.preventDefault();
            })), Ic(this._element, this._anchor, "marker"), this._popup = null;
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.addTo = function(_) {
            return this.remove(), this._map = _, _.getCanvasContainer().appendChild(this._element), _.on("move", this._update), _.on("moveend", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
          }, v.prototype.remove = function() {
            return this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), u.remove(this._element), this._popup && this._popup.remove(), this;
          }, v.prototype.getLngLat = function() {
            return this._lngLat;
          }, v.prototype.setLngLat = function(_) {
            return this._lngLat = o.LngLat.convert(_), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
          }, v.prototype.getElement = function() {
            return this._element;
          }, v.prototype.setPopup = function(_) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), _) {
              if (!("offset" in _.options)) {
                var w = Math.sqrt(Math.pow(13.5, 2) / 2);
                _.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [w, -1 * (24.6 + w)], "bottom-right": [-w, -1 * (24.6 + w)], left: [13.5, -24.6], right: [-13.5, -24.6] } : this._offset;
              }
              this._popup = _, this._lngLat && this._popup.setLngLat(this._lngLat), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
            }
            return this;
          }, v.prototype._onKeyPress = function(_) {
            var w = _.code, R = _.charCode || _.keyCode;
            w !== "Space" && w !== "Enter" && R !== 32 && R !== 13 || this.togglePopup();
          }, v.prototype._onMapClick = function(_) {
            var w = _.originalEvent.target, R = this._element;
            this._popup && (w === R || R.contains(w)) && this.togglePopup();
          }, v.prototype.getPopup = function() {
            return this._popup;
          }, v.prototype.togglePopup = function() {
            var _ = this._popup;
            return _ ? (_.isOpen() ? _.remove() : _.addTo(this._map), this) : this;
          }, v.prototype._update = function(_) {
            if (this._map) {
              this._map.transform.renderWorldCopies && (this._lngLat = Fl(this._lngLat, this._pos, this._map.transform)), this._pos = this._map.project(this._lngLat)._add(this._offset);
              var w = "";
              this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? w = "rotateZ(" + this._rotation + "deg)" : this._rotationAlignment === "map" && (w = "rotateZ(" + (this._rotation - this._map.getBearing()) + "deg)");
              var R = "";
              this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? R = "rotateX(0deg)" : this._pitchAlignment === "map" && (R = "rotateX(" + this._map.getPitch() + "deg)"), _ && _.type !== "moveend" || (this._pos = this._pos.round()), u.setTransform(this._element, Po[this._anchor] + " translate(" + this._pos.x + "px, " + this._pos.y + "px) " + R + " " + w);
            }
          }, v.prototype.getOffset = function() {
            return this._offset;
          }, v.prototype.setOffset = function(_) {
            return this._offset = o.Point.convert(_), this._update(), this;
          }, v.prototype._onMove = function(_) {
            if (!this._isDragging) {
              var w = this._clickTolerance || this._map._clickTolerance;
              this._isDragging = _.point.dist(this._pointerdownPos) >= w;
            }
            this._isDragging && (this._pos = _.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new o.Event("dragstart"))), this.fire(new o.Event("drag")));
          }, v.prototype._onUp = function() {
            this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new o.Event("dragend")), this._state = "inactive";
          }, v.prototype._addDragHandler = function(_) {
            this._element.contains(_.originalEvent.target) && (_.preventDefault(), this._positionDelta = _.point.sub(this._pos).add(this._offset), this._pointerdownPos = _.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
          }, v.prototype.setDraggable = function(_) {
            return this._draggable = !!_, this._map && (_ ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
          }, v.prototype.isDraggable = function() {
            return this._draggable;
          }, v.prototype.setRotation = function(_) {
            return this._rotation = _ || 0, this._update(), this;
          }, v.prototype.getRotation = function() {
            return this._rotation;
          }, v.prototype.setRotationAlignment = function(_) {
            return this._rotationAlignment = _ || "auto", this._update(), this;
          }, v.prototype.getRotationAlignment = function() {
            return this._rotationAlignment;
          }, v.prototype.setPitchAlignment = function(_) {
            return this._pitchAlignment = _ && _ !== "auto" ? _ : this._rotationAlignment, this._update(), this;
          }, v.prototype.getPitchAlignment = function() {
            return this._pitchAlignment;
          }, v;
        })(o.Evented), bf = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0 }, Ul = 0, Qa = !1, xf = (function(g) {
          function v(_) {
            g.call(this), this.options = o.extend({}, bf, _), o.bindAll(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker"], this);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.onAdd = function(_) {
            var w;
            return this._map = _, this._container = u.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), w = this._setupUI, Ka !== void 0 ? w(Ka) : o.window.navigator.permissions !== void 0 ? o.window.navigator.permissions.query({ name: "geolocation" }).then((function(R) {
              w(Ka = R.state !== "denied");
            })) : w(Ka = !!o.window.navigator.geolocation), this._container;
          }, v.prototype.onRemove = function() {
            this._geolocationWatchID !== void 0 && (o.window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), u.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, Ul = 0, Qa = !1;
          }, v.prototype._isOutOfMapMaxBounds = function(_) {
            var w = this._map.getMaxBounds(), R = _.coords;
            return w && (R.longitude < w.getWest() || R.longitude > w.getEast() || R.latitude < w.getSouth() || R.latitude > w.getNorth());
          }, v.prototype._setErrorState = function() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
            }
          }, v.prototype._onSuccess = function(_) {
            if (this._map) {
              if (this._isOutOfMapMaxBounds(_)) return this._setErrorState(), this.fire(new o.Event("outofmaxbounds", _)), this._updateMarker(), void this._finish();
              if (this.options.trackUserLocation) switch (this._lastKnownPosition = _, this._watchState) {
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "BACKGROUND":
                case "BACKGROUND_ERROR":
                  this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
              }
              this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(_), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(_), this.options.showUserLocation && this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"), this.fire(new o.Event("geolocate", _)), this._finish();
            }
          }, v.prototype._updateCamera = function(_) {
            var w = new o.LngLat(_.coords.longitude, _.coords.latitude), R = _.coords.accuracy, D = this._map.getBearing(), k = o.extend({ bearing: D }, this.options.fitBoundsOptions);
            this._map.fitBounds(w.toBounds(R), k, { geolocateSource: !0 });
          }, v.prototype._updateMarker = function(_) {
            if (_) {
              var w = new o.LngLat(_.coords.longitude, _.coords.latitude);
              this._accuracyCircleMarker.setLngLat(w).addTo(this._map), this._userLocationDotMarker.setLngLat(w).addTo(this._map), this._accuracy = _.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
          }, v.prototype._updateCircleRadius = function() {
            var _ = this._map._container.clientHeight / 2, w = this._map.unproject([0, _]), R = this._map.unproject([1, _]), D = w.distanceTo(R), k = Math.ceil(2 * this._accuracy / D);
            this._circleElement.style.width = k + "px", this._circleElement.style.height = k + "px";
          }, v.prototype._onZoom = function() {
            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          }, v.prototype._onError = function(_) {
            if (this._map) {
              if (this.options.trackUserLocation) if (_.code === 1) {
                this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                var w = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.title = w, this._geolocateButton.setAttribute("aria-label", w), this._geolocationWatchID !== void 0 && this._clearWatch();
              } else {
                if (_.code === 3 && Qa) return;
                this._setErrorState();
              }
              this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("mapboxgl-user-location-dot-stale"), this.fire(new o.Event("error", _)), this._finish();
            }
          }, v.prototype._finish = function() {
            this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
          }, v.prototype._setupUI = function(_) {
            var w = this;
            if (this._container.addEventListener("contextmenu", (function(k) {
              return k.preventDefault();
            })), this._geolocateButton = u.create("button", "mapboxgl-ctrl-geolocate", this._container), u.create("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", !0), this._geolocateButton.type = "button", _ === !1) {
              o.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");
              var R = this._map._getUIString("GeolocateControl.LocationNotAvailable");
              this._geolocateButton.disabled = !0, this._geolocateButton.title = R, this._geolocateButton.setAttribute("aria-label", R);
            } else {
              var D = this._map._getUIString("GeolocateControl.FindMyLocation");
              this._geolocateButton.title = D, this._geolocateButton.setAttribute("aria-label", D);
            }
            this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = u.create("div", "mapboxgl-user-location-dot"), this._userLocationDotMarker = new Nl(this._dotElement), this._circleElement = u.create("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Nl({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (function(k) {
              k.geolocateSource || w._watchState !== "ACTIVE_LOCK" || k.originalEvent && k.originalEvent.type === "resize" || (w._watchState = "BACKGROUND", w._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), w._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), w.fire(new o.Event("trackuserlocationend")));
            }));
          }, v.prototype.trigger = function() {
            if (!this._setup) return o.warnOnce("Geolocate control triggered before added to a map"), !1;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new o.Event("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  Ul--, Qa = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new o.Event("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new o.Event("trackuserlocationstart"));
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_ERROR":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                  break;
                case "BACKGROUND":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                  break;
                case "BACKGROUND_ERROR":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
              }
              if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
              else if (this._geolocationWatchID === void 0) {
                var _;
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), ++Ul > 1 ? (_ = { maximumAge: 6e5, timeout: 0 }, Qa = !0) : (_ = this.options.positionOptions, Qa = !1), this._geolocationWatchID = o.window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, _);
              }
            } else o.window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return !0;
          }, v.prototype._clearWatch = function() {
            o.window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }, v;
        })(o.Evented), xs = { maxWidth: 100, unit: "metric" }, ss = function(g) {
          this.options = o.extend({}, xs, g), o.bindAll(["_onMove", "setUnit"], this);
        };
        function Ur(g, v, _) {
          var w = _ && _.maxWidth || 100, R = g._container.clientHeight / 2, D = g.unproject([0, R]), k = g.unproject([w, R]), H = D.distanceTo(k);
          if (_ && _.unit === "imperial") {
            var J = 3.2808 * H;
            J > 5280 ? Ii(v, w, J / 5280, g._getUIString("ScaleControl.Miles")) : Ii(v, w, J, g._getUIString("ScaleControl.Feet"));
          } else _ && _.unit === "nautical" ? Ii(v, w, H / 1852, g._getUIString("ScaleControl.NauticalMiles")) : H >= 1e3 ? Ii(v, w, H / 1e3, g._getUIString("ScaleControl.Kilometers")) : Ii(v, w, H, g._getUIString("ScaleControl.Meters"));
        }
        function Ii(g, v, _, w) {
          var R, D, k, H = (R = _, (D = Math.pow(10, ("" + Math.floor(R)).length - 1)) * (k = (k = R / D) >= 10 ? 10 : k >= 5 ? 5 : k >= 3 ? 3 : k >= 2 ? 2 : k >= 1 ? 1 : (function(J) {
            var oe = Math.pow(10, Math.ceil(-Math.log(J) / Math.LN10));
            return Math.round(J * oe) / oe;
          })(k)));
          g.style.width = v * (H / _) + "px", g.innerHTML = H + "&nbsp;" + w;
        }
        ss.prototype.getDefaultPosition = function() {
          return "bottom-left";
        }, ss.prototype._onMove = function() {
          Ur(this._map, this._container, this.options);
        }, ss.prototype.onAdd = function(g) {
          return this._map = g, this._container = u.create("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", g.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
        }, ss.prototype.onRemove = function() {
          u.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
        }, ss.prototype.setUnit = function(g) {
          this.options.unit = g, Ur(this._map, this._container, this.options);
        };
        var Er = function(g) {
          this._fullscreen = !1, g && g.container && (g.container instanceof o.window.HTMLElement ? this._container = g.container : o.warnOnce("Full screen control 'container' must be a DOM element.")), o.bindAll(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in o.window.document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in o.window.document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in o.window.document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in o.window.document && (this._fullscreenchange = "MSFullscreenChange");
        };
        Er.prototype.onAdd = function(g) {
          return this._map = g, this._container || (this._container = this._map.getContainer()), this._controlContainer = u.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", o.warnOnce("This device does not support fullscreen mode.")), this._controlContainer;
        }, Er.prototype.onRemove = function() {
          u.remove(this._controlContainer), this._map = null, o.window.document.removeEventListener(this._fullscreenchange, this._changeIcon);
        }, Er.prototype._checkFullscreenSupport = function() {
          return !!(o.window.document.fullscreenEnabled || o.window.document.mozFullScreenEnabled || o.window.document.msFullscreenEnabled || o.window.document.webkitFullscreenEnabled);
        }, Er.prototype._setupUI = function() {
          var g = this._fullscreenButton = u.create("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
          u.create("span", "mapboxgl-ctrl-icon", g).setAttribute("aria-hidden", !0), g.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), o.window.document.addEventListener(this._fullscreenchange, this._changeIcon);
        }, Er.prototype._updateTitle = function() {
          var g = this._getTitle();
          this._fullscreenButton.setAttribute("aria-label", g), this._fullscreenButton.title = g;
        }, Er.prototype._getTitle = function() {
          return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
        }, Er.prototype._isFullscreen = function() {
          return this._fullscreen;
        }, Er.prototype._changeIcon = function() {
          (o.window.document.fullscreenElement || o.window.document.mozFullScreenElement || o.window.document.webkitFullscreenElement || o.window.document.msFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
        }, Er.prototype._onClickFullscreen = function() {
          this._isFullscreen() ? o.window.document.exitFullscreen ? o.window.document.exitFullscreen() : o.window.document.mozCancelFullScreen ? o.window.document.mozCancelFullScreen() : o.window.document.msExitFullscreen ? o.window.document.msExitFullscreen() : o.window.document.webkitCancelFullScreen && o.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
        };
        var Vi = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px" }, zl = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", "), Pc = (function(g) {
          function v(_) {
            g.call(this), this.options = o.extend(Object.create(Vi), _), o.bindAll(["_update", "_onClose", "remove", "_onMouseMove", "_onMouseUp", "_onDrag"], this);
          }
          return g && (v.__proto__ = g), (v.prototype = Object.create(g && g.prototype)).constructor = v, v.prototype.addTo = function(_) {
            return this._map && this.remove(), this._map = _, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("mapboxgl-track-pointer")) : this._map.on("move", this._update), this.fire(new o.Event("open")), this;
          }, v.prototype.isOpen = function() {
            return !!this._map;
          }, v.prototype.remove = function() {
            return this._content && u.remove(this._content), this._container && (u.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), delete this._map), this.fire(new o.Event("close")), this;
          }, v.prototype.getLngLat = function() {
            return this._lngLat;
          }, v.prototype.setLngLat = function(_) {
            return this._lngLat = o.LngLat.convert(_), this._pos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
          }, v.prototype.trackPointer = function() {
            return this._trackPointer = !0, this._pos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
          }, v.prototype.getElement = function() {
            return this._container;
          }, v.prototype.setText = function(_) {
            return this.setDOMContent(o.window.document.createTextNode(_));
          }, v.prototype.setHTML = function(_) {
            var w, R = o.window.document.createDocumentFragment(), D = o.window.document.createElement("body");
            for (D.innerHTML = _; w = D.firstChild; ) R.appendChild(w);
            return this.setDOMContent(R);
          }, v.prototype.getMaxWidth = function() {
            return this._container && this._container.style.maxWidth;
          }, v.prototype.setMaxWidth = function(_) {
            return this.options.maxWidth = _, this._update(), this;
          }, v.prototype.setDOMContent = function(_) {
            if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else this._content = u.create("div", "mapboxgl-popup-content", this._container);
            return this._content.appendChild(_), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
          }, v.prototype.addClassName = function(_) {
            this._container && this._container.classList.add(_);
          }, v.prototype.removeClassName = function(_) {
            this._container && this._container.classList.remove(_);
          }, v.prototype.setOffset = function(_) {
            return this.options.offset = _, this._update(), this;
          }, v.prototype.toggleClassName = function(_) {
            if (this._container) return this._container.classList.toggle(_);
          }, v.prototype._createCloseButton = function() {
            this.options.closeButton && (this._closeButton = u.create("button", "mapboxgl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
          }, v.prototype._onMouseUp = function(_) {
            this._update(_.point);
          }, v.prototype._onMouseMove = function(_) {
            this._update(_.point);
          }, v.prototype._onDrag = function(_) {
            this._update(_.point);
          }, v.prototype._update = function(_) {
            var w = this;
            if (this._map && (this._lngLat || this._trackPointer) && this._content && (this._container || (this._container = u.create("div", "mapboxgl-popup", this._map.getContainer()), this._tip = u.create("div", "mapboxgl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className && this.options.className.split(" ").forEach((function(Se) {
              return w._container.classList.add(Se);
            })), this._trackPointer && this._container.classList.add("mapboxgl-popup-track-pointer")), this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._map.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = Fl(this._lngLat, this._pos, this._map.transform)), !this._trackPointer || _)) {
              var R = this._pos = this._trackPointer && _ ? _ : this._map.project(this._lngLat), D = this.options.anchor, k = (function Se(Oe) {
                if (Oe) {
                  if (typeof Oe == "number") {
                    var He = Math.round(Math.sqrt(0.5 * Math.pow(Oe, 2)));
                    return { center: new o.Point(0, 0), top: new o.Point(0, Oe), "top-left": new o.Point(He, He), "top-right": new o.Point(-He, He), bottom: new o.Point(0, -Oe), "bottom-left": new o.Point(He, -He), "bottom-right": new o.Point(-He, -He), left: new o.Point(Oe, 0), right: new o.Point(-Oe, 0) };
                  }
                  if (Oe instanceof o.Point || Array.isArray(Oe)) {
                    var ze = o.Point.convert(Oe);
                    return { center: ze, top: ze, "top-left": ze, "top-right": ze, bottom: ze, "bottom-left": ze, "bottom-right": ze, left: ze, right: ze };
                  }
                  return { center: o.Point.convert(Oe.center || [0, 0]), top: o.Point.convert(Oe.top || [0, 0]), "top-left": o.Point.convert(Oe["top-left"] || [0, 0]), "top-right": o.Point.convert(Oe["top-right"] || [0, 0]), bottom: o.Point.convert(Oe.bottom || [0, 0]), "bottom-left": o.Point.convert(Oe["bottom-left"] || [0, 0]), "bottom-right": o.Point.convert(Oe["bottom-right"] || [0, 0]), left: o.Point.convert(Oe.left || [0, 0]), right: o.Point.convert(Oe.right || [0, 0]) };
                }
                return Se(new o.Point(0, 0));
              })(this.options.offset);
              if (!D) {
                var H, J = this._container.offsetWidth, oe = this._container.offsetHeight;
                H = R.y + k.bottom.y < oe ? ["top"] : R.y > this._map.transform.height - oe ? ["bottom"] : [], R.x < J / 2 ? H.push("left") : R.x > this._map.transform.width - J / 2 && H.push("right"), D = H.length === 0 ? "bottom" : H.join("-");
              }
              var Ce = R.add(k[D]).round();
              u.setTransform(this._container, Po[D] + " translate(" + Ce.x + "px," + Ce.y + "px)"), Ic(this._container, D, "popup");
            }
          }, v.prototype._focusFirstElement = function() {
            if (this.options.focusAfterOpen && this._container) {
              var _ = this._container.querySelector(zl);
              _ && _.focus();
            }
          }, v.prototype._onClose = function() {
            this.remove();
          }, v;
        })(o.Evented), Mo = { version: o.version, supported: l, setRTLTextPlugin: o.setRTLTextPlugin, getRTLTextPluginStatus: o.getRTLTextPluginStatus, Map: Vh, NavigationControl: sa, GeolocateControl: xf, AttributionControl: us, ScaleControl: ss, FullscreenControl: Er, Popup: Pc, Marker: Nl, Style: _s, LngLat: o.LngLat, LngLatBounds: o.LngLatBounds, Point: o.Point, MercatorCoordinate: o.MercatorCoordinate, Evented: o.Evented, config: o.config, prewarm: function() {
          _t().acquire(nt);
        }, clearPrewarmedResources: function() {
          var g = kt;
          g && (g.isPreloaded() && g.numActive() === 1 ? (g.release(nt), kt = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, get accessToken() {
          return o.config.ACCESS_TOKEN;
        }, set accessToken(g) {
          o.config.ACCESS_TOKEN = g;
        }, get baseApiUrl() {
          return o.config.API_URL;
        }, set baseApiUrl(g) {
          o.config.API_URL = g;
        }, get workerCount() {
          return Mt.workerCount;
        }, set workerCount(g) {
          Mt.workerCount = g;
        }, get maxParallelImageRequests() {
          return o.config.MAX_PARALLEL_IMAGE_REQUESTS;
        }, set maxParallelImageRequests(g) {
          o.config.MAX_PARALLEL_IMAGE_REQUESTS = g;
        }, clearStorage: function(g) {
          o.clearTileCache(g);
        }, workerUrl: "" };
        return Mo;
      })), i;
    }));
  })(Im)), Im.exports;
}
var Bee = Ree();
const cc = /* @__PURE__ */ dh(Bee);
var Oee = 1e-7;
function c2(r) {
  return Array.isArray(r) || ArrayBuffer.isView(r);
}
function _D(r, e) {
  if (r === e)
    return !0;
  if (c2(r) && c2(e)) {
    if (r.length !== e.length)
      return !1;
    for (var t = 0; t < r.length; ++t)
      if (!_D(r[t], e[t]))
        return !1;
    return !0;
  }
  return Math.abs(r - e) <= Oee;
}
function Og(r, e, t) {
  return Math.max(e, Math.min(t, r));
}
function h_(r, e, t) {
  return c2(r) ? r.map(function(n, i) {
    return h_(n, e[i], t);
  }) : t * e + (1 - t) * r;
}
function ll(r, e) {
  if (!r)
    throw new Error(e || "react-map-gl: assertion failed.");
}
function YS(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function KS(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? YS(Object(t), !0).forEach(function(n) {
      Br(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : YS(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
var qf = {
  minZoom: 0,
  maxZoom: 24,
  minPitch: 0,
  maxPitch: 60
}, i1 = {
  pitch: 0,
  bearing: 0,
  altitude: 1.5
}, QS = 5, Dee = 1.2, up = (function() {
  function r(e) {
    var t = e.width, n = e.height, i = e.latitude, s = e.longitude, o = e.zoom, l = e.bearing, u = l === void 0 ? i1.bearing : l, m = e.pitch, y = m === void 0 ? i1.pitch : m, E = e.altitude, P = E === void 0 ? i1.altitude : E, L = e.maxZoom, U = L === void 0 ? qf.maxZoom : L, V = e.minZoom, q = V === void 0 ? qf.minZoom : V, j = e.maxPitch, K = j === void 0 ? qf.maxPitch : j, Y = e.minPitch, de = Y === void 0 ? qf.minPitch : Y, ne = e.transitionDuration, ae = e.transitionEasing, De = e.transitionInterpolator, Ge = e.transitionInterruption, fe = e.startPanLngLat, ve = e.startZoomLngLat, me = e.startRotatePos, X = e.startBearing, re = e.startPitch, Me = e.startZoom;
    ef(this, r), ll(Number.isFinite(t), "`width` must be supplied"), ll(Number.isFinite(n), "`height` must be supplied"), ll(Number.isFinite(s), "`longitude` must be supplied"), ll(Number.isFinite(i), "`latitude` must be supplied"), ll(Number.isFinite(o), "`zoom` must be supplied"), this._viewportProps = this._applyConstraints({
      width: t,
      height: n,
      latitude: i,
      longitude: s,
      zoom: o,
      bearing: u,
      pitch: y,
      altitude: P,
      maxZoom: U,
      minZoom: q,
      maxPitch: K,
      minPitch: de,
      transitionDuration: ne,
      transitionEasing: ae,
      transitionInterpolator: De,
      transitionInterruption: Ge
    }), this._state = {
      startPanLngLat: fe,
      startZoomLngLat: ve,
      startRotatePos: me,
      startBearing: X,
      startPitch: re,
      startZoom: Me
    };
  }
  return Ju(r, [{
    key: "getViewportProps",
    value: function() {
      return this._viewportProps;
    }
  }, {
    key: "getState",
    value: function() {
      return this._state;
    }
  }, {
    key: "panStart",
    value: function(t) {
      var n = t.pos;
      return this._getUpdatedMapState({
        startPanLngLat: this._unproject(n)
      });
    }
  }, {
    key: "pan",
    value: function(t) {
      var n = t.pos, i = t.startPos, s = this._state.startPanLngLat || this._unproject(i);
      if (!s)
        return this;
      var o = this._calculateNewLngLat({
        startPanLngLat: s,
        pos: n
      }), l = gs(o, 2), u = l[0], m = l[1];
      return this._getUpdatedMapState({
        longitude: u,
        latitude: m
      });
    }
  }, {
    key: "panEnd",
    value: function() {
      return this._getUpdatedMapState({
        startPanLngLat: null
      });
    }
  }, {
    key: "rotateStart",
    value: function(t) {
      var n = t.pos;
      return this._getUpdatedMapState({
        startRotatePos: n,
        startBearing: this._viewportProps.bearing,
        startPitch: this._viewportProps.pitch
      });
    }
  }, {
    key: "rotate",
    value: function(t) {
      var n = t.pos, i = t.deltaAngleX, s = i === void 0 ? 0 : i, o = t.deltaAngleY, l = o === void 0 ? 0 : o, u = this._state, m = u.startRotatePos, y = u.startBearing, E = u.startPitch;
      if (!Number.isFinite(y) || !Number.isFinite(E))
        return this;
      var P;
      return n ? P = this._calculateNewPitchAndBearing(KS(KS({}, this._getRotationParams(n, m)), {}, {
        startBearing: y,
        startPitch: E
      })) : P = {
        bearing: y + s,
        pitch: E + l
      }, this._getUpdatedMapState(P);
    }
  }, {
    key: "rotateEnd",
    value: function() {
      return this._getUpdatedMapState({
        startBearing: null,
        startPitch: null
      });
    }
  }, {
    key: "zoomStart",
    value: function(t) {
      var n = t.pos;
      return this._getUpdatedMapState({
        startZoomLngLat: this._unproject(n),
        startZoom: this._viewportProps.zoom
      });
    }
  }, {
    key: "zoom",
    value: function(t) {
      var n = t.pos, i = t.startPos, s = t.scale;
      ll(s > 0, "`scale` must be a positive number");
      var o = this._state, l = o.startZoom, u = o.startZoomLngLat;
      Number.isFinite(l) || (l = this._viewportProps.zoom, u = this._unproject(i) || this._unproject(n)), ll(u, "`startZoomLngLat` prop is required for zoom behavior to calculate where to position the map.");
      var m = this._calculateNewZoom({
        scale: s,
        startZoom: l || 0
      }), y = new oc(Object.assign({}, this._viewportProps, {
        zoom: m
      })), E = y.getMapCenterByLngLatPosition({
        lngLat: u,
        pos: n
      }), P = gs(E, 2), L = P[0], U = P[1];
      return this._getUpdatedMapState({
        zoom: m,
        longitude: L,
        latitude: U
      });
    }
  }, {
    key: "zoomEnd",
    value: function() {
      return this._getUpdatedMapState({
        startZoomLngLat: null,
        startZoom: null
      });
    }
  }, {
    key: "_getUpdatedMapState",
    value: function(t) {
      return new r(Object.assign({}, this._viewportProps, this._state, t));
    }
  }, {
    key: "_applyConstraints",
    value: function(t) {
      var n = t.maxZoom, i = t.minZoom, s = t.zoom;
      t.zoom = Og(s, i, n);
      var o = t.maxPitch, l = t.minPitch, u = t.pitch;
      return t.pitch = Og(u, l, o), Object.assign(t, bee(t)), t;
    }
  }, {
    key: "_unproject",
    value: function(t) {
      var n = new oc(this._viewportProps);
      return t && n.unproject(t);
    }
  }, {
    key: "_calculateNewLngLat",
    value: function(t) {
      var n = t.startPanLngLat, i = t.pos, s = new oc(this._viewportProps);
      return s.getMapCenterByLngLatPosition({
        lngLat: n,
        pos: i
      });
    }
  }, {
    key: "_calculateNewZoom",
    value: function(t) {
      var n = t.scale, i = t.startZoom, s = this._viewportProps, o = s.maxZoom, l = s.minZoom, u = i + Math.log2(n);
      return Og(u, l, o);
    }
  }, {
    key: "_calculateNewPitchAndBearing",
    value: function(t) {
      var n = t.deltaScaleX, i = t.deltaScaleY, s = t.startBearing, o = t.startPitch;
      i = Og(i, -1, 1);
      var l = this._viewportProps, u = l.minPitch, m = l.maxPitch, y = s + 180 * n, E = o;
      return i > 0 ? E = o + i * (m - o) : i < 0 && (E = o - i * (u - o)), {
        pitch: E,
        bearing: y
      };
    }
  }, {
    key: "_getRotationParams",
    value: function(t, n) {
      var i = t[0] - n[0], s = t[1] - n[1], o = t[1], l = n[1], u = this._viewportProps, m = u.width, y = u.height, E = i / m, P = 0;
      return s > 0 ? Math.abs(y - l) > QS && (P = s / (l - y) * Dee) : s < 0 && l > QS && (P = 1 - o / l), P = Math.min(1, Math.max(-1, P)), {
        deltaScaleX: E,
        deltaScaleY: P
      };
    }
  }]), r;
})();
function Lee(r) {
  return r[0].toLowerCase() + r.slice(1);
}
function kee(r) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : qf;
  for (var t in e) {
    var n = t.slice(0, 3), i = Lee(t.slice(3));
    if (n === "min" && r[i] < e[t] || n === "max" && r[i] > e[t])
      return !1;
  }
  return !0;
}
function JS(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function eI(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? JS(Object(t), !0).forEach(function(n) {
      Br(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : JS(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
var _h = Dt.createContext({
  viewport: null,
  map: null,
  container: null,
  onViewportChange: null,
  onViewStateChange: null,
  eventManager: null
}), uw = _h.Provider;
function Fee(r) {
  var e = r.value, t = r.children, n = Dt.useState(null), i = gs(n, 2), s = i[0], o = i[1], l = Dt.useContext(_h);
  return e = eI(eI({
    setMap: o
  }, l), {}, {
    map: l && l.map || s
  }, e), Dt.createElement(uw, {
    value: e
  }, t);
}
_h.Provider = Fee;
var u2 = typeof window < "u" ? Dt.useLayoutEffect : Dt.useEffect;
function tI(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function al(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? tI(Object(t), !0).forEach(function(n) {
      Br(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : tI(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
var Nee = "https://visgl.github.io/react-map-gl/docs/get-started/mapbox-tokens", yD = "A valid API access token is required to use Mapbox data";
function Uee() {
}
function vD(r) {
  var e = r.props, t = r.width, n = r.height;
  return new oc(al(al(al({}, e), e.viewState), {}, {
    width: t,
    height: n
  }));
}
var zee = 401, rI = {
  position: "absolute",
  width: "100%",
  height: "100%",
  overflow: "hidden"
}, Vee = Object.assign({}, mh.propTypes, {
  width: vt.oneOfType([vt.number, vt.string]),
  height: vt.oneOfType([vt.number, vt.string]),
  onResize: vt.func,
  disableTokenWarning: vt.bool,
  visible: vt.bool,
  className: vt.string,
  style: vt.object,
  visibilityConstraints: vt.object
}), jee = Object.assign({}, mh.defaultProps, {
  disableTokenWarning: !1,
  visible: !0,
  onResize: Uee,
  className: "",
  style: null,
  visibilityConstraints: qf
});
function Hee() {
  var r = {
    position: "absolute",
    left: 0,
    top: 0
  };
  return Dt.createElement("div", {
    key: "warning",
    id: "no-token-warning",
    style: r
  }, Dt.createElement("h3", {
    key: "header"
  }, yD), Dt.createElement("div", {
    key: "text"
  }, "For information on setting up your basemap, read"), Dt.createElement("a", {
    key: "link",
    href: Nee
  }, "Note on Map Tokens"));
}
function Gee(r) {
  return {
    getMap: function() {
      return r.current && r.current.getMap();
    },
    queryRenderedFeatures: function(t) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = r.current && r.current.getMap();
      return i && i.queryRenderedFeatures(t, n);
    }
  };
}
var nu = Dt.forwardRef(function(r, e) {
  var t = Dt.useState(!0), n = gs(t, 2), i = n[0], s = n[1], o = Dt.useState({
    width: 0,
    height: 0
  }), l = gs(o, 2), u = l[0], m = l[1], y = Dt.useRef(null), E = Dt.useRef(null), P = Dt.useRef(null), L = Dt.useRef(null), U = Dt.useContext(_h);
  u2(function() {
    if (nu.supported()) {
      var ve = new mh(al(al(al({}, r), u), {}, {
        mapboxgl: cc,
        container: E.current,
        onError: function(re) {
          var Me = re.error && re.error.status || re.status;
          Me === zee && i && (console.error(yD), s(!1)), r.onError(re);
        }
      }));
      y.current = ve, U && U.setMap && U.setMap(ve.getMap());
      var me = new CN(function(X) {
        if (X[0].contentRect) {
          var re = X[0].contentRect, Me = re.width, ot = re.height;
          m({
            width: Me,
            height: ot
          }), r.onResize({
            width: Me,
            height: ot
          });
        }
      });
      return me.observe(P.current), function() {
        ve.finalize(), y.current = null, me.disconnect();
      };
    }
  }, []), u2(function() {
    y.current && y.current.setProps(al(al({}, r), u));
  });
  var V = y.current && y.current.getMap();
  Dt.useImperativeHandle(e, function() {
    return Gee(y);
  }, []);
  var q = Dt.useCallback(function(ve) {
    var me = ve.target;
    me === L.current && me.scrollTo(0, 0);
  }, []), j = V && Dt.createElement(uw, {
    value: al(al({}, U), {}, {
      viewport: U.viewport || vD(al({
        map: V,
        props: r
      }, u)),
      map: V,
      container: U.container || P.current
    })
  }, Dt.createElement("div", {
    key: "map-overlays",
    className: "overlays",
    ref: L,
    style: rI,
    onScroll: q
  }, r.children)), K = r.className, Y = r.width, de = r.height, ne = r.style, ae = r.visibilityConstraints, De = Object.assign({
    position: "relative"
  }, ne, {
    width: Y,
    height: de
  }), Ge = r.visible && kee(r.viewState || r, ae), fe = Object.assign({}, rI, {
    visibility: Ge ? "inherit" : "hidden"
  });
  return Dt.createElement("div", {
    key: "map-container",
    ref: P,
    style: De
  }, Dt.createElement("div", {
    key: "map-mapbox",
    ref: E,
    style: fe,
    className: K
  }), j, !i && !r.disableTokenWarning && Dt.createElement(Hee, null));
});
nu.supported = function() {
  return cc && cc.supported();
};
nu.propTypes = Vee;
nu.defaultProps = jee;
function Wee(r, e) {
  var t;
  if (typeof Symbol > "u" || r[Symbol.iterator] == null) {
    if (Array.isArray(r) || (t = $ee(r)) || e) {
      t && (r = t);
      var n = 0, i = function() {
      };
      return { s: i, n: function() {
        return n >= r.length ? { done: !0 } : { done: !1, value: r[n++] };
      }, e: function(m) {
        throw m;
      }, f: i };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var s = !0, o = !1, l;
  return { s: function() {
    t = r[Symbol.iterator]();
  }, n: function() {
    var m = t.next();
    return s = m.done, m;
  }, e: function(m) {
    o = !0, l = m;
  }, f: function() {
    try {
      !s && t.return != null && t.return();
    } finally {
      if (o) throw l;
    }
  } };
}
function $ee(r, e) {
  if (r) {
    if (typeof r == "string") return nI(r, e);
    var t = Object.prototype.toString.call(r).slice(8, -1);
    if (t === "Object" && r.constructor && (t = r.constructor.name), t === "Map" || t === "Set") return Array.from(r);
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)) return nI(r, e);
  }
}
function nI(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var t = 0, n = new Array(e); t < e; t++)
    n[t] = r[t];
  return n;
}
var bD = (function() {
  function r() {
    ef(this, r), Br(this, "propNames", []);
  }
  return Ju(r, [{
    key: "arePropsEqual",
    value: function(t, n) {
      var i = Wee(this.propNames || []), s;
      try {
        for (i.s(); !(s = i.n()).done; ) {
          var o = s.value;
          if (!_D(t[o], n[o]))
            return !1;
        }
      } catch (l) {
        i.e(l);
      } finally {
        i.f();
      }
      return !0;
    }
  }, {
    key: "initializeProps",
    value: function(t, n) {
      return {
        start: t,
        end: n
      };
    }
  }, {
    key: "interpolateProps",
    value: function(t, n, i) {
      ll(!1, "interpolateProps is not implemented");
    }
  }, {
    key: "getDuration",
    value: function(t, n) {
      return n.transitionDuration;
    }
  }]), r;
})(), qee = {
  longitude: 1,
  bearing: 1
};
function d_(r) {
  return Number.isFinite(r) || Array.isArray(r);
}
function Xee(r) {
  return r in qee;
}
function f2(r, e, t) {
  return Xee(r) && Math.abs(t - e) > 180 && (t = t < 0 ? t + 360 : t - 360), t;
}
function s1(r, e) {
  var t;
  if (typeof Symbol > "u" || r[Symbol.iterator] == null) {
    if (Array.isArray(r) || (t = Zee(r)) || e) {
      t && (r = t);
      var n = 0, i = function() {
      };
      return { s: i, n: function() {
        return n >= r.length ? { done: !0 } : { done: !1, value: r[n++] };
      }, e: function(m) {
        throw m;
      }, f: i };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var s = !0, o = !1, l;
  return { s: function() {
    t = r[Symbol.iterator]();
  }, n: function() {
    var m = t.next();
    return s = m.done, m;
  }, e: function(m) {
    o = !0, l = m;
  }, f: function() {
    try {
      !s && t.return != null && t.return();
    } finally {
      if (o) throw l;
    }
  } };
}
function Zee(r, e) {
  if (r) {
    if (typeof r == "string") return iI(r, e);
    var t = Object.prototype.toString.call(r).slice(8, -1);
    if (t === "Object" && r.constructor && (t = r.constructor.name), t === "Map" || t === "Set") return Array.from(r);
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)) return iI(r, e);
  }
}
function iI(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var t = 0, n = new Array(e); t < e; t++)
    n[t] = r[t];
  return n;
}
function Yee(r) {
  var e = Kee();
  return function() {
    var n = gp(r), i;
    if (e) {
      var s = gp(this).constructor;
      i = Reflect.construct(n, arguments, s);
    } else
      i = n.apply(this, arguments);
    return Z2(this, i);
  };
}
function Kee() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
  if (typeof Proxy == "function") return !0;
  try {
    return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
var Qee = ["longitude", "latitude", "zoom", "bearing", "pitch"], Jee = ["latitude", "longitude", "zoom", "width", "height"], sI = ["bearing", "pitch"], ete = {
  speed: 1.2,
  curve: 1.414
};
(function(r) {
  X2(t, r);
  var e = Yee(t);
  function t() {
    var n, i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return ef(this, t), n = e.call(this), Br(Uu(n), "propNames", Qee), n.props = Object.assign({}, ete, i), n;
  }
  return Ju(t, [{
    key: "initializeProps",
    value: function(i, s) {
      var o = {}, l = {}, u = s1(Jee), m;
      try {
        for (u.s(); !(m = u.n()).done; ) {
          var y = m.value, E = i[y], P = s[y];
          ll(d_(E) && d_(P), "".concat(y, " must be supplied for transition")), o[y] = E, l[y] = f2(y, E, P);
        }
      } catch (K) {
        u.e(K);
      } finally {
        u.f();
      }
      var L = s1(sI), U;
      try {
        for (L.s(); !(U = L.n()).done; ) {
          var V = U.value, q = i[V] || 0, j = s[V] || 0;
          o[V] = q, l[V] = f2(V, q, j);
        }
      } catch (K) {
        L.e(K);
      } finally {
        L.f();
      }
      return {
        start: o,
        end: l
      };
    }
  }, {
    key: "interpolateProps",
    value: function(i, s, o) {
      var l = wee(i, s, o, this.props), u = s1(sI), m;
      try {
        for (u.s(); !(m = u.n()).done; ) {
          var y = m.value;
          l[y] = h_(i[y], s[y], o);
        }
      } catch (E) {
        u.e(E);
      } finally {
        u.f();
      }
      return l;
    }
  }, {
    key: "getDuration",
    value: function(i, s) {
      var o = s.transitionDuration;
      return o === "auto" && (o = Tee(i, s, this.props)), o;
    }
  }]), t;
})(bD);
function oI(r, e) {
  var t;
  if (typeof Symbol > "u" || r[Symbol.iterator] == null) {
    if (Array.isArray(r) || (t = tte(r)) || e) {
      t && (r = t);
      var n = 0, i = function() {
      };
      return { s: i, n: function() {
        return n >= r.length ? { done: !0 } : { done: !1, value: r[n++] };
      }, e: function(m) {
        throw m;
      }, f: i };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var s = !0, o = !1, l;
  return { s: function() {
    t = r[Symbol.iterator]();
  }, n: function() {
    var m = t.next();
    return s = m.done, m;
  }, e: function(m) {
    o = !0, l = m;
  }, f: function() {
    try {
      !s && t.return != null && t.return();
    } finally {
      if (o) throw l;
    }
  } };
}
function tte(r, e) {
  if (r) {
    if (typeof r == "string") return aI(r, e);
    var t = Object.prototype.toString.call(r).slice(8, -1);
    if (t === "Object" && r.constructor && (t = r.constructor.name), t === "Map" || t === "Set") return Array.from(r);
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)) return aI(r, e);
  }
}
function aI(r, e) {
  (e == null || e > r.length) && (e = r.length);
  for (var t = 0, n = new Array(e); t < e; t++)
    n[t] = r[t];
  return n;
}
function rte(r) {
  var e = nte();
  return function() {
    var n = gp(r), i;
    if (e) {
      var s = gp(this).constructor;
      i = Reflect.construct(n, arguments, s);
    } else
      i = n.apply(this, arguments);
    return Z2(this, i);
  };
}
function nte() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
  if (typeof Proxy == "function") return !0;
  try {
    return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
var ite = ["longitude", "latitude", "zoom", "bearing", "pitch"], qA = (function(r) {
  X2(t, r);
  var e = rte(t);
  function t() {
    var n, i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return ef(this, t), n = e.call(this), Array.isArray(i) && (i = {
      transitionProps: i
    }), n.propNames = i.transitionProps || ite, i.around && (n.around = i.around), n;
  }
  return Ju(t, [{
    key: "initializeProps",
    value: function(i, s) {
      var o = {}, l = {};
      if (this.around) {
        o.around = this.around;
        var u = new oc(i).unproject(this.around);
        Object.assign(l, s, {
          around: new oc(s).project(u),
          aroundLngLat: u
        });
      }
      var m = oI(this.propNames), y;
      try {
        for (m.s(); !(y = m.n()).done; ) {
          var E = y.value, P = i[E], L = s[E];
          ll(d_(P) && d_(L), "".concat(E, " must be supplied for transition")), o[E] = P, l[E] = f2(E, P, L);
        }
      } catch (U) {
        m.e(U);
      } finally {
        m.f();
      }
      return {
        start: o,
        end: l
      };
    }
  }, {
    key: "interpolateProps",
    value: function(i, s, o) {
      var l = {}, u = oI(this.propNames), m;
      try {
        for (u.s(); !(m = u.n()).done; ) {
          var y = m.value;
          l[y] = h_(i[y], s[y], o);
        }
      } catch (V) {
        u.e(V);
      } finally {
        u.f();
      }
      if (s.around) {
        var E = new oc(Object.assign({}, s, l)).getMapCenterByLngLatPosition({
          lngLat: s.aroundLngLat,
          pos: h_(i.around, s.around, o)
        }), P = gs(E, 2), L = P[0], U = P[1];
        l.longitude = L, l.latitude = U;
      }
      return l;
    }
  }]), t;
})(bD), XA = function() {
};
function ste(r, e) {
  var t = r(e);
  return function(n) {
    return 1 / (1 - t) * (r(n * (1 - e) + e) - t);
  };
}
var ZA = {
  BREAK: 1,
  SNAP_TO_END: 2,
  IGNORE: 3,
  UPDATE: 4
}, ote = {
  transitionDuration: 0,
  transitionEasing: function(e) {
    return e;
  },
  transitionInterpolator: new qA(),
  transitionInterruption: ZA.BREAK,
  onTransitionStart: XA,
  onTransitionInterrupt: XA,
  onTransitionEnd: XA
}, fw = (function() {
  function r() {
    var e = this, t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    ef(this, r), Br(this, "_animationFrame", null), Br(this, "_onTransitionFrame", function() {
      e._animationFrame = requestAnimationFrame(e._onTransitionFrame), e._updateViewport();
    }), this.props = null, this.onViewportChange = t.onViewportChange || XA, this.onStateChange = t.onStateChange || XA, this.time = t.getTime || Date.now;
  }
  return Ju(r, [{
    key: "getViewportInTransition",
    value: function() {
      return this._animationFrame ? this.state.propsInTransition : null;
    }
  }, {
    key: "processViewportChange",
    value: function(t) {
      var n = this.props;
      if (this.props = t, !n || this._shouldIgnoreViewportChange(n, t))
        return !1;
      if (this._isTransitionEnabled(t)) {
        var i = Object.assign({}, n), s = Object.assign({}, t);
        if (this._isTransitionInProgress() && (n.onTransitionInterrupt(), this.state.interruption === ZA.SNAP_TO_END ? Object.assign(i, this.state.endProps) : Object.assign(i, this.state.propsInTransition), this.state.interruption === ZA.UPDATE)) {
          var o = this.time(), l = (o - this.state.startTime) / this.state.duration;
          s.transitionDuration = this.state.duration - (o - this.state.startTime), s.transitionEasing = ste(this.state.easing, l), s.transitionInterpolator = i.transitionInterpolator;
        }
        return s.onTransitionStart(), this._triggerTransition(i, s), !0;
      }
      return this._isTransitionInProgress() && (n.onTransitionInterrupt(), this._endTransition()), !1;
    }
  }, {
    key: "_isTransitionInProgress",
    value: function() {
      return !!this._animationFrame;
    }
  }, {
    key: "_isTransitionEnabled",
    value: function(t) {
      var n = t.transitionDuration, i = t.transitionInterpolator;
      return (n > 0 || n === "auto") && !!i;
    }
  }, {
    key: "_isUpdateDueToCurrentTransition",
    value: function(t) {
      return this.state.propsInTransition ? this.state.interpolator.arePropsEqual(t, this.state.propsInTransition) : !1;
    }
  }, {
    key: "_shouldIgnoreViewportChange",
    value: function(t, n) {
      return t ? this._isTransitionInProgress() ? this.state.interruption === ZA.IGNORE || this._isUpdateDueToCurrentTransition(n) : this._isTransitionEnabled(n) ? n.transitionInterpolator.arePropsEqual(t, n) : !0 : !0;
    }
  }, {
    key: "_triggerTransition",
    value: function(t, n) {
      ll(this._isTransitionEnabled(n)), this._animationFrame && cancelAnimationFrame(this._animationFrame);
      var i = n.transitionInterpolator, s = i.getDuration ? i.getDuration(t, n) : n.transitionDuration;
      if (s !== 0) {
        var o = n.transitionInterpolator.initializeProps(t, n), l = {
          inTransition: !0,
          isZooming: t.zoom !== n.zoom,
          isPanning: t.longitude !== n.longitude || t.latitude !== n.latitude,
          isRotating: t.bearing !== n.bearing || t.pitch !== n.pitch
        };
        this.state = {
          duration: s,
          easing: n.transitionEasing,
          interpolator: n.transitionInterpolator,
          interruption: n.transitionInterruption,
          startTime: this.time(),
          startProps: o.start,
          endProps: o.end,
          animation: null,
          propsInTransition: {}
        }, this._onTransitionFrame(), this.onStateChange(l);
      }
    }
  }, {
    key: "_endTransition",
    value: function() {
      this._animationFrame && (cancelAnimationFrame(this._animationFrame), this._animationFrame = null), this.onStateChange({
        inTransition: !1,
        isZooming: !1,
        isPanning: !1,
        isRotating: !1
      });
    }
  }, {
    key: "_updateViewport",
    value: function() {
      var t = this.time(), n = this.state, i = n.startTime, s = n.duration, o = n.easing, l = n.interpolator, u = n.startProps, m = n.endProps, y = !1, E = (t - i) / s;
      E >= 1 && (E = 1, y = !0), E = o(E);
      var P = l.interpolateProps(u, m, E), L = new up(Object.assign({}, this.props, P));
      this.state.propsInTransition = L.getViewportProps(), this.onViewportChange(this.state.propsInTransition, this.props), y && (this._endTransition(), this.props.onTransitionEnd());
    }
  }]), r;
})();
Br(fw, "defaultProps", ote);
var o1 = { exports: {} };
var lI;
function ate() {
  return lI || (lI = 1, (function(r) {
    (function(e, t, n, i) {
      var s = ["", "webkit", "Moz", "MS", "ms", "o"], o = t.createElement("div"), l = "function", u = Math.round, m = Math.abs, y = Date.now;
      function E(Ee, ke, Ke) {
        return setTimeout(Y(Ee, Ke), ke);
      }
      function P(Ee, ke, Ke) {
        return Array.isArray(Ee) ? (L(Ee, Ke[ke], Ke), !0) : !1;
      }
      function L(Ee, ke, Ke) {
        var bt;
        if (Ee)
          if (Ee.forEach)
            Ee.forEach(ke, Ke);
          else if (Ee.length !== i)
            for (bt = 0; bt < Ee.length; )
              ke.call(Ke, Ee[bt], bt, Ee), bt++;
          else
            for (bt in Ee)
              Ee.hasOwnProperty(bt) && ke.call(Ke, Ee[bt], bt, Ee);
      }
      function U(Ee, ke, Ke) {
        var bt = "DEPRECATED METHOD: " + ke + `
` + Ke + ` AT 
`;
        return function() {
          var Qt = new Error("get-stack-trace"), Tr = Qt && Qt.stack ? Qt.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace", Tn = e.console && (e.console.warn || e.console.log);
          return Tn && Tn.call(e.console, bt, Tr), Ee.apply(this, arguments);
        };
      }
      var V;
      typeof Object.assign != "function" ? V = function(ke) {
        if (ke === i || ke === null)
          throw new TypeError("Cannot convert undefined or null to object");
        for (var Ke = Object(ke), bt = 1; bt < arguments.length; bt++) {
          var Qt = arguments[bt];
          if (Qt !== i && Qt !== null)
            for (var Tr in Qt)
              Qt.hasOwnProperty(Tr) && (Ke[Tr] = Qt[Tr]);
        }
        return Ke;
      } : V = Object.assign;
      var q = U(function(ke, Ke, bt) {
        for (var Qt = Object.keys(Ke), Tr = 0; Tr < Qt.length; )
          (!bt || bt && ke[Qt[Tr]] === i) && (ke[Qt[Tr]] = Ke[Qt[Tr]]), Tr++;
        return ke;
      }, "extend", "Use `assign`."), j = U(function(ke, Ke) {
        return q(ke, Ke, !0);
      }, "merge", "Use `assign`.");
      function K(Ee, ke, Ke) {
        var bt = ke.prototype, Qt;
        Qt = Ee.prototype = Object.create(bt), Qt.constructor = Ee, Qt._super = bt, Ke && V(Qt, Ke);
      }
      function Y(Ee, ke) {
        return function() {
          return Ee.apply(ke, arguments);
        };
      }
      function de(Ee, ke) {
        return typeof Ee == l ? Ee.apply(ke && ke[0] || i, ke) : Ee;
      }
      function ne(Ee, ke) {
        return Ee === i ? ke : Ee;
      }
      function ae(Ee, ke, Ke) {
        L(ve(ke), function(bt) {
          Ee.addEventListener(bt, Ke, !1);
        });
      }
      function De(Ee, ke, Ke) {
        L(ve(ke), function(bt) {
          Ee.removeEventListener(bt, Ke, !1);
        });
      }
      function Ge(Ee, ke) {
        for (; Ee; ) {
          if (Ee == ke)
            return !0;
          Ee = Ee.parentNode;
        }
        return !1;
      }
      function fe(Ee, ke) {
        return Ee.indexOf(ke) > -1;
      }
      function ve(Ee) {
        return Ee.trim().split(/\s+/g);
      }
      function me(Ee, ke, Ke) {
        if (Ee.indexOf && !Ke)
          return Ee.indexOf(ke);
        for (var bt = 0; bt < Ee.length; ) {
          if (Ke && Ee[bt][Ke] == ke || !Ke && Ee[bt] === ke)
            return bt;
          bt++;
        }
        return -1;
      }
      function X(Ee) {
        return Array.prototype.slice.call(Ee, 0);
      }
      function re(Ee, ke, Ke) {
        for (var bt = [], Qt = [], Tr = 0; Tr < Ee.length; ) {
          var Tn = Ee[Tr][ke];
          me(Qt, Tn) < 0 && bt.push(Ee[Tr]), Qt[Tr] = Tn, Tr++;
        }
        return bt = bt.sort(function(mn, Di) {
          return mn[ke] > Di[ke];
        }), bt;
      }
      function Me(Ee, ke) {
        for (var Ke, bt, Qt = ke[0].toUpperCase() + ke.slice(1), Tr = 0; Tr < s.length; ) {
          if (Ke = s[Tr], bt = Ke ? Ke + Qt : ke, bt in Ee)
            return bt;
          Tr++;
        }
        return i;
      }
      var ot = 1;
      function be() {
        return ot++;
      }
      function Ue(Ee) {
        var ke = Ee.ownerDocument || Ee;
        return ke.defaultView || ke.parentWindow || e;
      }
      var Xe = /mobile|tablet|ip(ad|hone|od)|android/i, lt = "ontouchstart" in e, at = Me(e, "PointerEvent") !== i, ct = lt && Xe.test(navigator.userAgent), gt = "touch", St = "pen", Ot = "mouse", dt = "kinect", _r = 25, sr = 1, tr = 2, Wt = 4, yr = 8, An = 1, Fr = 2, Pr = 4, $n = 8, xr = 16, wr = Fr | Pr, gn = $n | xr, zr = wr | gn, ci = ["x", "y"], Jn = ["clientX", "clientY"];
      function wn(Ee, ke) {
        var Ke = this;
        this.manager = Ee, this.callback = ke, this.element = Ee.element, this.target = Ee.options.inputTarget, this.domHandler = function(bt) {
          de(Ee.options.enable, [Ee]) && Ke.handler(bt);
        }, this.init();
      }
      wn.prototype = {
        /**
         * should handle the inputEvent data and trigger the callback
         * @virtual
         */
        handler: function() {
        },
        /**
         * bind the events
         */
        init: function() {
          this.evEl && ae(this.element, this.evEl, this.domHandler), this.evTarget && ae(this.target, this.evTarget, this.domHandler), this.evWin && ae(Ue(this.element), this.evWin, this.domHandler);
        },
        /**
         * unbind the events
         */
        destroy: function() {
          this.evEl && De(this.element, this.evEl, this.domHandler), this.evTarget && De(this.target, this.evTarget, this.domHandler), this.evWin && De(Ue(this.element), this.evWin, this.domHandler);
        }
      };
      function ii(Ee) {
        var ke, Ke = Ee.options.inputClass;
        return Ke ? ke = Ke : at ? ke = Pe : ct ? ke = pe : lt ? ke = d : ke = Xt, new ke(Ee, qn);
      }
      function qn(Ee, ke, Ke) {
        var bt = Ke.pointers.length, Qt = Ke.changedPointers.length, Tr = ke & sr && bt - Qt === 0, Tn = ke & (Wt | yr) && bt - Qt === 0;
        Ke.isFirst = !!Tr, Ke.isFinal = !!Tn, Tr && (Ee.session = {}), Ke.eventType = ke, Rn(Ee, Ke), Ee.emit("hammer.input", Ke), Ee.recognize(Ke), Ee.session.prevInput = Ke;
      }
      function Rn(Ee, ke) {
        var Ke = Ee.session, bt = ke.pointers, Qt = bt.length;
        Ke.firstInput || (Ke.firstInput = br(ke)), Qt > 1 && !Ke.firstMultiple ? Ke.firstMultiple = br(ke) : Qt === 1 && (Ke.firstMultiple = !1);
        var Tr = Ke.firstInput, Tn = Ke.firstMultiple, bi = Tn ? Tn.center : Tr.center, mn = ke.center = Nr(bt);
        ke.timeStamp = y(), ke.deltaTime = ke.timeStamp - Tr.timeStamp, ke.angle = Gt(bi, mn), ke.distance = Le(bi, mn), ei(Ke, ke), ke.offsetDirection = pi(ke.deltaX, ke.deltaY);
        var Di = on(ke.deltaTime, ke.deltaX, ke.deltaY);
        ke.overallVelocityX = Di.x, ke.overallVelocityY = Di.y, ke.overallVelocity = m(Di.x) > m(Di.y) ? Di.x : Di.y, ke.scale = Tn ? pr(Tn.pointers, bt) : 1, ke.rotation = Tn ? Jt(Tn.pointers, bt) : 0, ke.maxPointers = Ke.prevInput ? ke.pointers.length > Ke.prevInput.maxPointers ? ke.pointers.length : Ke.prevInput.maxPointers : ke.pointers.length, Zt(Ke, ke);
        var qs = Ee.element;
        Ge(ke.srcEvent.target, qs) && (qs = ke.srcEvent.target), ke.target = qs;
      }
      function ei(Ee, ke) {
        var Ke = ke.center, bt = Ee.offsetDelta || {}, Qt = Ee.prevDelta || {}, Tr = Ee.prevInput || {};
        (ke.eventType === sr || Tr.eventType === Wt) && (Qt = Ee.prevDelta = {
          x: Tr.deltaX || 0,
          y: Tr.deltaY || 0
        }, bt = Ee.offsetDelta = {
          x: Ke.x,
          y: Ke.y
        }), ke.deltaX = Qt.x + (Ke.x - bt.x), ke.deltaY = Qt.y + (Ke.y - bt.y);
      }
      function Zt(Ee, ke) {
        var Ke = Ee.lastInterval || ke, bt = ke.timeStamp - Ke.timeStamp, Qt, Tr, Tn, bi;
        if (ke.eventType != yr && (bt > _r || Ke.velocity === i)) {
          var mn = ke.deltaX - Ke.deltaX, Di = ke.deltaY - Ke.deltaY, qs = on(bt, mn, Di);
          Tr = qs.x, Tn = qs.y, Qt = m(qs.x) > m(qs.y) ? qs.x : qs.y, bi = pi(mn, Di), Ee.lastInterval = ke;
        } else
          Qt = Ke.velocity, Tr = Ke.velocityX, Tn = Ke.velocityY, bi = Ke.direction;
        ke.velocity = Qt, ke.velocityX = Tr, ke.velocityY = Tn, ke.direction = bi;
      }
      function br(Ee) {
        for (var ke = [], Ke = 0; Ke < Ee.pointers.length; )
          ke[Ke] = {
            clientX: u(Ee.pointers[Ke].clientX),
            clientY: u(Ee.pointers[Ke].clientY)
          }, Ke++;
        return {
          timeStamp: y(),
          pointers: ke,
          center: Nr(ke),
          deltaX: Ee.deltaX,
          deltaY: Ee.deltaY
        };
      }
      function Nr(Ee) {
        var ke = Ee.length;
        if (ke === 1)
          return {
            x: u(Ee[0].clientX),
            y: u(Ee[0].clientY)
          };
        for (var Ke = 0, bt = 0, Qt = 0; Qt < ke; )
          Ke += Ee[Qt].clientX, bt += Ee[Qt].clientY, Qt++;
        return {
          x: u(Ke / ke),
          y: u(bt / ke)
        };
      }
      function on(Ee, ke, Ke) {
        return {
          x: ke / Ee || 0,
          y: Ke / Ee || 0
        };
      }
      function pi(Ee, ke) {
        return Ee === ke ? An : m(Ee) >= m(ke) ? Ee < 0 ? Fr : Pr : ke < 0 ? $n : xr;
      }
      function Le(Ee, ke, Ke) {
        Ke || (Ke = ci);
        var bt = ke[Ke[0]] - Ee[Ke[0]], Qt = ke[Ke[1]] - Ee[Ke[1]];
        return Math.sqrt(bt * bt + Qt * Qt);
      }
      function Gt(Ee, ke, Ke) {
        Ke || (Ke = ci);
        var bt = ke[Ke[0]] - Ee[Ke[0]], Qt = ke[Ke[1]] - Ee[Ke[1]];
        return Math.atan2(Qt, bt) * 180 / Math.PI;
      }
      function Jt(Ee, ke) {
        return Gt(ke[1], ke[0], Jn) + Gt(Ee[1], Ee[0], Jn);
      }
      function pr(Ee, ke) {
        return Le(ke[0], ke[1], Jn) / Le(Ee[0], Ee[1], Jn);
      }
      var st = {
        mousedown: sr,
        mousemove: tr,
        mouseup: Wt
      }, Ft = "mousedown", _e = "mousemove mouseup";
      function Xt() {
        this.evEl = Ft, this.evWin = _e, this.pressed = !1, wn.apply(this, arguments);
      }
      K(Xt, wn, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function(ke) {
          var Ke = st[ke.type];
          Ke & sr && ke.button === 0 && (this.pressed = !0), Ke & tr && ke.which !== 1 && (Ke = Wt), this.pressed && (Ke & Wt && (this.pressed = !1), this.callback(this.manager, Ke, {
            pointers: [ke],
            changedPointers: [ke],
            pointerType: Ot,
            srcEvent: ke
          }));
        }
      });
      var Ct = {
        pointerdown: sr,
        pointermove: tr,
        pointerup: Wt,
        pointercancel: yr,
        pointerout: yr
      }, $ = {
        2: gt,
        3: St,
        4: Ot,
        5: dt
        // see https://twitter.com/jacobrossi/status/480596438489890816
      }, Et = "pointerdown", Rt = "pointermove pointerup pointercancel";
      e.MSPointerEvent && !e.PointerEvent && (Et = "MSPointerDown", Rt = "MSPointerMove MSPointerUp MSPointerCancel");
      function Pe() {
        this.evEl = Et, this.evWin = Rt, wn.apply(this, arguments), this.store = this.manager.session.pointerEvents = [];
      }
      K(Pe, wn, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function(ke) {
          var Ke = this.store, bt = !1, Qt = ke.type.toLowerCase().replace("ms", ""), Tr = Ct[Qt], Tn = $[ke.pointerType] || ke.pointerType, bi = Tn == gt, mn = me(Ke, ke.pointerId, "pointerId");
          Tr & sr && (ke.button === 0 || bi) ? mn < 0 && (Ke.push(ke), mn = Ke.length - 1) : Tr & (Wt | yr) && (bt = !0), !(mn < 0) && (Ke[mn] = ke, this.callback(this.manager, Tr, {
            pointers: Ke,
            changedPointers: [ke],
            pointerType: Tn,
            srcEvent: ke
          }), bt && Ke.splice(mn, 1));
        }
      });
      var tt = {
        touchstart: sr,
        touchmove: tr,
        touchend: Wt,
        touchcancel: yr
      }, At = "touchstart", Q = "touchstart touchmove touchend touchcancel";
      function ie() {
        this.evTarget = At, this.evWin = Q, this.started = !1, wn.apply(this, arguments);
      }
      K(ie, wn, {
        handler: function(ke) {
          var Ke = tt[ke.type];
          if (Ke === sr && (this.started = !0), !!this.started) {
            var bt = ce.call(this, ke, Ke);
            Ke & (Wt | yr) && bt[0].length - bt[1].length === 0 && (this.started = !1), this.callback(this.manager, Ke, {
              pointers: bt[0],
              changedPointers: bt[1],
              pointerType: gt,
              srcEvent: ke
            });
          }
        }
      });
      function ce(Ee, ke) {
        var Ke = X(Ee.touches), bt = X(Ee.changedTouches);
        return ke & (Wt | yr) && (Ke = re(Ke.concat(bt), "identifier")), [Ke, bt];
      }
      var we = {
        touchstart: sr,
        touchmove: tr,
        touchend: Wt,
        touchcancel: yr
      }, Ne = "touchstart touchmove touchend touchcancel";
      function pe() {
        this.evTarget = Ne, this.targetIds = {}, wn.apply(this, arguments);
      }
      K(pe, wn, {
        handler: function(ke) {
          var Ke = we[ke.type], bt = Te.call(this, ke, Ke);
          bt && this.callback(this.manager, Ke, {
            pointers: bt[0],
            changedPointers: bt[1],
            pointerType: gt,
            srcEvent: ke
          });
        }
      });
      function Te(Ee, ke) {
        var Ke = X(Ee.touches), bt = this.targetIds;
        if (ke & (sr | tr) && Ke.length === 1)
          return bt[Ke[0].identifier] = !0, [Ke, Ke];
        var Qt, Tr, Tn = X(Ee.changedTouches), bi = [], mn = this.target;
        if (Tr = Ke.filter(function(Di) {
          return Ge(Di.target, mn);
        }), ke === sr)
          for (Qt = 0; Qt < Tr.length; )
            bt[Tr[Qt].identifier] = !0, Qt++;
        for (Qt = 0; Qt < Tn.length; )
          bt[Tn[Qt].identifier] && bi.push(Tn[Qt]), ke & (Wt | yr) && delete bt[Tn[Qt].identifier], Qt++;
        if (bi.length)
          return [
            // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
            re(Tr.concat(bi), "identifier"),
            bi
          ];
      }
      var le = 2500, ge = 25;
      function d() {
        wn.apply(this, arguments);
        var Ee = Y(this.handler, this);
        this.touch = new pe(this.manager, Ee), this.mouse = new Xt(this.manager, Ee), this.primaryTouch = null, this.lastTouches = [];
      }
      K(d, wn, {
        /**
         * handle mouse and touch events
         * @param {Hammer} manager
         * @param {String} inputEvent
         * @param {Object} inputData
         */
        handler: function(ke, Ke, bt) {
          var Qt = bt.pointerType == gt, Tr = bt.pointerType == Ot;
          if (!(Tr && bt.sourceCapabilities && bt.sourceCapabilities.firesTouchEvents)) {
            if (Qt)
              ee.call(this, Ke, bt);
            else if (Tr && nt.call(this, bt))
              return;
            this.callback(ke, Ke, bt);
          }
        },
        /**
         * remove the event listeners
         */
        destroy: function() {
          this.touch.destroy(), this.mouse.destroy();
        }
      });
      function ee(Ee, ke) {
        Ee & sr ? (this.primaryTouch = ke.changedPointers[0].identifier, It.call(this, ke)) : Ee & (Wt | yr) && It.call(this, ke);
      }
      function It(Ee) {
        var ke = Ee.changedPointers[0];
        if (ke.identifier === this.primaryTouch) {
          var Ke = { x: ke.clientX, y: ke.clientY };
          this.lastTouches.push(Ke);
          var bt = this.lastTouches, Qt = function() {
            var Tr = bt.indexOf(Ke);
            Tr > -1 && bt.splice(Tr, 1);
          };
          setTimeout(Qt, le);
        }
      }
      function nt(Ee) {
        for (var ke = Ee.srcEvent.clientX, Ke = Ee.srcEvent.clientY, bt = 0; bt < this.lastTouches.length; bt++) {
          var Qt = this.lastTouches[bt], Tr = Math.abs(ke - Qt.x), Tn = Math.abs(Ke - Qt.y);
          if (Tr <= ge && Tn <= ge)
            return !0;
        }
        return !1;
      }
      var Mt = Me(o.style, "touchAction"), kt = Mt !== i, zt = "compute", _t = "auto", Vt = "manipulation", Lt = "none", Yt = "pan-x", Hr = "pan-y", ir = Yr();
      function nn(Ee, ke) {
        this.manager = Ee, this.set(ke);
      }
      nn.prototype = {
        /**
         * set the touchAction value on the element or enable the polyfill
         * @param {String} value
         */
        set: function(Ee) {
          Ee == zt && (Ee = this.compute()), kt && this.manager.element.style && ir[Ee] && (this.manager.element.style[Mt] = Ee), this.actions = Ee.toLowerCase().trim();
        },
        /**
         * just re-set the touchAction value
         */
        update: function() {
          this.set(this.manager.options.touchAction);
        },
        /**
         * compute the value for the touchAction property based on the recognizer's settings
         * @returns {String} value
         */
        compute: function() {
          var Ee = [];
          return L(this.manager.recognizers, function(ke) {
            de(ke.options.enable, [ke]) && (Ee = Ee.concat(ke.getTouchAction()));
          }), un(Ee.join(" "));
        },
        /**
         * this method is called on each input cycle and provides the preventing of the browser behavior
         * @param {Object} input
         */
        preventDefaults: function(Ee) {
          var ke = Ee.srcEvent, Ke = Ee.offsetDirection;
          if (this.manager.session.prevented) {
            ke.preventDefault();
            return;
          }
          var bt = this.actions, Qt = fe(bt, Lt) && !ir[Lt], Tr = fe(bt, Hr) && !ir[Hr], Tn = fe(bt, Yt) && !ir[Yt];
          if (Qt) {
            var bi = Ee.pointers.length === 1, mn = Ee.distance < 2, Di = Ee.deltaTime < 250;
            if (bi && mn && Di)
              return;
          }
          if (!(Tn && Tr) && (Qt || Tr && Ke & wr || Tn && Ke & gn))
            return this.preventSrc(ke);
        },
        /**
         * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
         * @param {Object} srcEvent
         */
        preventSrc: function(Ee) {
          this.manager.session.prevented = !0, Ee.preventDefault();
        }
      };
      function un(Ee) {
        if (fe(Ee, Lt))
          return Lt;
        var ke = fe(Ee, Yt), Ke = fe(Ee, Hr);
        return ke && Ke ? Lt : ke || Ke ? ke ? Yt : Hr : fe(Ee, Vt) ? Vt : _t;
      }
      function Yr() {
        if (!kt)
          return !1;
        var Ee = {}, ke = e.CSS && e.CSS.supports;
        return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(Ke) {
          Ee[Ke] = ke ? e.CSS.supports("touch-action", Ke) : !0;
        }), Ee;
      }
      var Qr = 1, $r = 2, Ai = 4, Kr = 8, hr = Kr, ye = 16, er = 32;
      function sn(Ee) {
        this.options = V({}, this.defaults, Ee || {}), this.id = be(), this.manager = null, this.options.enable = ne(this.options.enable, !0), this.state = Qr, this.simultaneous = {}, this.requireFail = [];
      }
      sn.prototype = {
        /**
         * @virtual
         * @type {Object}
         */
        defaults: {},
        /**
         * set options
         * @param {Object} options
         * @return {Recognizer}
         */
        set: function(Ee) {
          return V(this.options, Ee), this.manager && this.manager.touchAction.update(), this;
        },
        /**
         * recognize simultaneous with an other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        recognizeWith: function(Ee) {
          if (P(Ee, "recognizeWith", this))
            return this;
          var ke = this.simultaneous;
          return Ee = ui(Ee, this), ke[Ee.id] || (ke[Ee.id] = Ee, Ee.recognizeWith(this)), this;
        },
        /**
         * drop the simultaneous link. it doesnt remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRecognizeWith: function(Ee) {
          return P(Ee, "dropRecognizeWith", this) ? this : (Ee = ui(Ee, this), delete this.simultaneous[Ee.id], this);
        },
        /**
         * recognizer can only run when an other is failing
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        requireFailure: function(Ee) {
          if (P(Ee, "requireFailure", this))
            return this;
          var ke = this.requireFail;
          return Ee = ui(Ee, this), me(ke, Ee) === -1 && (ke.push(Ee), Ee.requireFailure(this)), this;
        },
        /**
         * drop the requireFailure link. it does not remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRequireFailure: function(Ee) {
          if (P(Ee, "dropRequireFailure", this))
            return this;
          Ee = ui(Ee, this);
          var ke = me(this.requireFail, Ee);
          return ke > -1 && this.requireFail.splice(ke, 1), this;
        },
        /**
         * has require failures boolean
         * @returns {boolean}
         */
        hasRequireFailures: function() {
          return this.requireFail.length > 0;
        },
        /**
         * if the recognizer can recognize simultaneous with an other recognizer
         * @param {Recognizer} otherRecognizer
         * @returns {Boolean}
         */
        canRecognizeWith: function(Ee) {
          return !!this.simultaneous[Ee.id];
        },
        /**
         * You should use `tryEmit` instead of `emit` directly to check
         * that all the needed recognizers has failed before emitting.
         * @param {Object} input
         */
        emit: function(Ee) {
          var ke = this, Ke = this.state;
          function bt(Qt) {
            ke.manager.emit(Qt, Ee);
          }
          Ke < Kr && bt(ke.options.event + Wi(Ke)), bt(ke.options.event), Ee.additionalEvent && bt(Ee.additionalEvent), Ke >= Kr && bt(ke.options.event + Wi(Ke));
        },
        /**
         * Check that all the require failure recognizers has failed,
         * if true, it emits a gesture event,
         * otherwise, setup the state to FAILED.
         * @param {Object} input
         */
        tryEmit: function(Ee) {
          if (this.canEmit())
            return this.emit(Ee);
          this.state = er;
        },
        /**
         * can we emit?
         * @returns {boolean}
         */
        canEmit: function() {
          for (var Ee = 0; Ee < this.requireFail.length; ) {
            if (!(this.requireFail[Ee].state & (er | Qr)))
              return !1;
            Ee++;
          }
          return !0;
        },
        /**
         * update the recognizer
         * @param {Object} inputData
         */
        recognize: function(Ee) {
          var ke = V({}, Ee);
          if (!de(this.options.enable, [this, ke])) {
            this.reset(), this.state = er;
            return;
          }
          this.state & (hr | ye | er) && (this.state = Qr), this.state = this.process(ke), this.state & ($r | Ai | Kr | ye) && this.tryEmit(ke);
        },
        /**
         * return the state of the recognizer
         * the actual recognizing happens in this method
         * @virtual
         * @param {Object} inputData
         * @returns {Const} STATE
         */
        process: function(Ee) {
        },
        // jshint ignore:line
        /**
         * return the preferred touch-action
         * @virtual
         * @returns {Array}
         */
        getTouchAction: function() {
        },
        /**
         * called when the gesture isn't allowed to recognize
         * like when another is being recognized or it is disabled
         * @virtual
         */
        reset: function() {
        }
      };
      function Wi(Ee) {
        return Ee & ye ? "cancel" : Ee & Kr ? "end" : Ee & Ai ? "move" : Ee & $r ? "start" : "";
      }
      function ma(Ee) {
        return Ee == xr ? "down" : Ee == $n ? "up" : Ee == Fr ? "left" : Ee == Pr ? "right" : "";
      }
      function ui(Ee, ke) {
        var Ke = ke.manager;
        return Ke ? Ke.get(Ee) : Ee;
      }
      function Xn() {
        sn.apply(this, arguments);
      }
      K(Xn, sn, {
        /**
         * @namespace
         * @memberof AttrRecognizer
         */
        defaults: {
          /**
           * @type {Number}
           * @default 1
           */
          pointers: 1
        },
        /**
         * Used to check if it the recognizer receives valid input, like input.distance > 10.
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {Boolean} recognized
         */
        attrTest: function(Ee) {
          var ke = this.options.pointers;
          return ke === 0 || Ee.pointers.length === ke;
        },
        /**
         * Process the input and return the state for the recognizer
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {*} State
         */
        process: function(Ee) {
          var ke = this.state, Ke = Ee.eventType, bt = ke & ($r | Ai), Qt = this.attrTest(Ee);
          return bt && (Ke & yr || !Qt) ? ke | ye : bt || Qt ? Ke & Wt ? ke | Kr : ke & $r ? ke | Ai : $r : er;
        }
      });
      function Ae() {
        Xn.apply(this, arguments), this.pX = null, this.pY = null;
      }
      K(Ae, Xn, {
        /**
         * @namespace
         * @memberof PanRecognizer
         */
        defaults: {
          event: "pan",
          threshold: 10,
          pointers: 1,
          direction: zr
        },
        getTouchAction: function() {
          var Ee = this.options.direction, ke = [];
          return Ee & wr && ke.push(Hr), Ee & gn && ke.push(Yt), ke;
        },
        directionTest: function(Ee) {
          var ke = this.options, Ke = !0, bt = Ee.distance, Qt = Ee.direction, Tr = Ee.deltaX, Tn = Ee.deltaY;
          return Qt & ke.direction || (ke.direction & wr ? (Qt = Tr === 0 ? An : Tr < 0 ? Fr : Pr, Ke = Tr != this.pX, bt = Math.abs(Ee.deltaX)) : (Qt = Tn === 0 ? An : Tn < 0 ? $n : xr, Ke = Tn != this.pY, bt = Math.abs(Ee.deltaY))), Ee.direction = Qt, Ke && bt > ke.threshold && Qt & ke.direction;
        },
        attrTest: function(Ee) {
          return Xn.prototype.attrTest.call(this, Ee) && (this.state & $r || !(this.state & $r) && this.directionTest(Ee));
        },
        emit: function(Ee) {
          this.pX = Ee.deltaX, this.pY = Ee.deltaY;
          var ke = ma(Ee.direction);
          ke && (Ee.additionalEvent = this.options.event + ke), this._super.emit.call(this, Ee);
        }
      });
      function Ko() {
        Xn.apply(this, arguments);
      }
      K(Ko, Xn, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
          event: "pinch",
          threshold: 0,
          pointers: 2
        },
        getTouchAction: function() {
          return [Lt];
        },
        attrTest: function(Ee) {
          return this._super.attrTest.call(this, Ee) && (Math.abs(Ee.scale - 1) > this.options.threshold || this.state & $r);
        },
        emit: function(Ee) {
          if (Ee.scale !== 1) {
            var ke = Ee.scale < 1 ? "in" : "out";
            Ee.additionalEvent = this.options.event + ke;
          }
          this._super.emit.call(this, Ee);
        }
      });
      function Zn() {
        sn.apply(this, arguments), this._timer = null, this._input = null;
      }
      K(Zn, sn, {
        /**
         * @namespace
         * @memberof PressRecognizer
         */
        defaults: {
          event: "press",
          pointers: 1,
          time: 251,
          // minimal time of the pointer to be pressed
          threshold: 9
          // a minimal movement is ok, but keep it low
        },
        getTouchAction: function() {
          return [_t];
        },
        process: function(Ee) {
          var ke = this.options, Ke = Ee.pointers.length === ke.pointers, bt = Ee.distance < ke.threshold, Qt = Ee.deltaTime > ke.time;
          if (this._input = Ee, !bt || !Ke || Ee.eventType & (Wt | yr) && !Qt)
            this.reset();
          else if (Ee.eventType & sr)
            this.reset(), this._timer = E(function() {
              this.state = hr, this.tryEmit();
            }, ke.time, this);
          else if (Ee.eventType & Wt)
            return hr;
          return er;
        },
        reset: function() {
          clearTimeout(this._timer);
        },
        emit: function(Ee) {
          this.state === hr && (Ee && Ee.eventType & Wt ? this.manager.emit(this.options.event + "up", Ee) : (this._input.timeStamp = y(), this.manager.emit(this.options.event, this._input)));
        }
      });
      function Qo() {
        Xn.apply(this, arguments);
      }
      K(Qo, Xn, {
        /**
         * @namespace
         * @memberof RotateRecognizer
         */
        defaults: {
          event: "rotate",
          threshold: 0,
          pointers: 2
        },
        getTouchAction: function() {
          return [Lt];
        },
        attrTest: function(Ee) {
          return this._super.attrTest.call(this, Ee) && (Math.abs(Ee.rotation) > this.options.threshold || this.state & $r);
        }
      });
      function Oi() {
        Xn.apply(this, arguments);
      }
      K(Oi, Xn, {
        /**
         * @namespace
         * @memberof SwipeRecognizer
         */
        defaults: {
          event: "swipe",
          threshold: 10,
          velocity: 0.3,
          direction: wr | gn,
          pointers: 1
        },
        getTouchAction: function() {
          return Ae.prototype.getTouchAction.call(this);
        },
        attrTest: function(Ee) {
          var ke = this.options.direction, Ke;
          return ke & (wr | gn) ? Ke = Ee.overallVelocity : ke & wr ? Ke = Ee.overallVelocityX : ke & gn && (Ke = Ee.overallVelocityY), this._super.attrTest.call(this, Ee) && ke & Ee.offsetDirection && Ee.distance > this.options.threshold && Ee.maxPointers == this.options.pointers && m(Ke) > this.options.velocity && Ee.eventType & Wt;
        },
        emit: function(Ee) {
          var ke = ma(Ee.offsetDirection);
          ke && this.manager.emit(this.options.event + ke, Ee), this.manager.emit(this.options.event, Ee);
        }
      });
      function fi() {
        sn.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0;
      }
      K(fi, sn, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
          event: "tap",
          pointers: 1,
          taps: 1,
          interval: 300,
          // max time between the multi-tap taps
          time: 250,
          // max time of the pointer to be down (like finger on the screen)
          threshold: 9,
          // a minimal movement is ok, but keep it low
          posThreshold: 10
          // a multi-tap can be a bit off the initial position
        },
        getTouchAction: function() {
          return [Vt];
        },
        process: function(Ee) {
          var ke = this.options, Ke = Ee.pointers.length === ke.pointers, bt = Ee.distance < ke.threshold, Qt = Ee.deltaTime < ke.time;
          if (this.reset(), Ee.eventType & sr && this.count === 0)
            return this.failTimeout();
          if (bt && Qt && Ke) {
            if (Ee.eventType != Wt)
              return this.failTimeout();
            var Tr = this.pTime ? Ee.timeStamp - this.pTime < ke.interval : !0, Tn = !this.pCenter || Le(this.pCenter, Ee.center) < ke.posThreshold;
            this.pTime = Ee.timeStamp, this.pCenter = Ee.center, !Tn || !Tr ? this.count = 1 : this.count += 1, this._input = Ee;
            var bi = this.count % ke.taps;
            if (bi === 0)
              return this.hasRequireFailures() ? (this._timer = E(function() {
                this.state = hr, this.tryEmit();
              }, ke.interval, this), $r) : hr;
          }
          return er;
        },
        failTimeout: function() {
          return this._timer = E(function() {
            this.state = er;
          }, this.options.interval, this), er;
        },
        reset: function() {
          clearTimeout(this._timer);
        },
        emit: function() {
          this.state == hr && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input));
        }
      });
      function Ci(Ee, ke) {
        return ke = ke || {}, ke.recognizers = ne(ke.recognizers, Ci.defaults.preset), new $i(Ee, ke);
      }
      Ci.VERSION = "2.0.7", Ci.defaults = {
        /**
         * set if DOM events are being triggered.
         * But this is slower and unused by simple implementations, so disabled by default.
         * @type {Boolean}
         * @default false
         */
        domEvents: !1,
        /**
         * The value for the touchAction property/fallback.
         * When set to `compute` it will magically set the correct value based on the added recognizers.
         * @type {String}
         * @default compute
         */
        touchAction: zt,
        /**
         * @type {Boolean}
         * @default true
         */
        enable: !0,
        /**
         * EXPERIMENTAL FEATURE -- can be removed/changed
         * Change the parent input target element.
         * If Null, then it is being set the to main element.
         * @type {Null|EventTarget}
         * @default null
         */
        inputTarget: null,
        /**
         * force an input class
         * @type {Null|Function}
         * @default null
         */
        inputClass: null,
        /**
         * Default recognizer setup when calling `Hammer()`
         * When creating a new Manager these will be skipped.
         * @type {Array}
         */
        preset: [
          // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
          [Qo, { enable: !1 }],
          [Ko, { enable: !1 }, ["rotate"]],
          [Oi, { direction: wr }],
          [Ae, { direction: wr }, ["swipe"]],
          [fi],
          [fi, { event: "doubletap", taps: 2 }, ["tap"]],
          [Zn]
        ],
        /**
         * Some CSS properties can be used to improve the working of Hammer.
         * Add them to this method and they will be set when creating a new Manager.
         * @namespace
         */
        cssProps: {
          /**
           * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userSelect: "none",
          /**
           * Disable the Windows Phone grippers when pressing an element.
           * @type {String}
           * @default 'none'
           */
          touchSelect: "none",
          /**
           * Disables the default callout shown when you touch and hold a touch target.
           * On iOS, when you touch and hold a touch target such as a link, Safari displays
           * a callout containing information about the link. This property allows you to disable that callout.
           * @type {String}
           * @default 'none'
           */
          touchCallout: "none",
          /**
           * Specifies whether zooming is enabled. Used by IE10>
           * @type {String}
           * @default 'none'
           */
          contentZooming: "none",
          /**
           * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userDrag: "none",
          /**
           * Overrides the highlight color shown when the user taps a link or a JavaScript
           * clickable element in iOS. This property obeys the alpha value, if specified.
           * @type {String}
           * @default 'rgba(0,0,0,0)'
           */
          tapHighlightColor: "rgba(0,0,0,0)"
        }
      };
      var Fn = 1, ms = 2;
      function $i(Ee, ke) {
        this.options = V({}, Ci.defaults, ke || {}), this.options.inputTarget = this.options.inputTarget || Ee, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = Ee, this.input = ii(this), this.touchAction = new nn(this, this.options.touchAction), Ms(this, !0), L(this.options.recognizers, function(Ke) {
          var bt = this.add(new Ke[0](Ke[1]));
          Ke[2] && bt.recognizeWith(Ke[2]), Ke[3] && bt.requireFailure(Ke[3]);
        }, this);
      }
      $i.prototype = {
        /**
         * set options
         * @param {Object} options
         * @returns {Manager}
         */
        set: function(Ee) {
          return V(this.options, Ee), Ee.touchAction && this.touchAction.update(), Ee.inputTarget && (this.input.destroy(), this.input.target = Ee.inputTarget, this.input.init()), this;
        },
        /**
         * stop recognizing for this session.
         * This session will be discarded, when a new [input]start event is fired.
         * When forced, the recognizer cycle is stopped immediately.
         * @param {Boolean} [force]
         */
        stop: function(Ee) {
          this.session.stopped = Ee ? ms : Fn;
        },
        /**
         * run the recognizers!
         * called by the inputHandler function on every movement of the pointers (touches)
         * it walks through all the recognizers and tries to detect the gesture that is being made
         * @param {Object} inputData
         */
        recognize: function(Ee) {
          var ke = this.session;
          if (!ke.stopped) {
            this.touchAction.preventDefaults(Ee);
            var Ke, bt = this.recognizers, Qt = ke.curRecognizer;
            (!Qt || Qt && Qt.state & hr) && (Qt = ke.curRecognizer = null);
            for (var Tr = 0; Tr < bt.length; )
              Ke = bt[Tr], ke.stopped !== ms && // 1
              (!Qt || Ke == Qt || // 2
              Ke.canRecognizeWith(Qt)) ? Ke.recognize(Ee) : Ke.reset(), !Qt && Ke.state & ($r | Ai | Kr) && (Qt = ke.curRecognizer = Ke), Tr++;
          }
        },
        /**
         * get a recognizer by its event name.
         * @param {Recognizer|String} recognizer
         * @returns {Recognizer|Null}
         */
        get: function(Ee) {
          if (Ee instanceof sn)
            return Ee;
          for (var ke = this.recognizers, Ke = 0; Ke < ke.length; Ke++)
            if (ke[Ke].options.event == Ee)
              return ke[Ke];
          return null;
        },
        /**
         * add a recognizer to the manager
         * existing recognizers with the same event name will be removed
         * @param {Recognizer} recognizer
         * @returns {Recognizer|Manager}
         */
        add: function(Ee) {
          if (P(Ee, "add", this))
            return this;
          var ke = this.get(Ee.options.event);
          return ke && this.remove(ke), this.recognizers.push(Ee), Ee.manager = this, this.touchAction.update(), Ee;
        },
        /**
         * remove a recognizer by name or instance
         * @param {Recognizer|String} recognizer
         * @returns {Manager}
         */
        remove: function(Ee) {
          if (P(Ee, "remove", this))
            return this;
          if (Ee = this.get(Ee), Ee) {
            var ke = this.recognizers, Ke = me(ke, Ee);
            Ke !== -1 && (ke.splice(Ke, 1), this.touchAction.update());
          }
          return this;
        },
        /**
         * bind event
         * @param {String} events
         * @param {Function} handler
         * @returns {EventEmitter} this
         */
        on: function(Ee, ke) {
          if (Ee !== i && ke !== i) {
            var Ke = this.handlers;
            return L(ve(Ee), function(bt) {
              Ke[bt] = Ke[bt] || [], Ke[bt].push(ke);
            }), this;
          }
        },
        /**
         * unbind event, leave emit blank to remove all handlers
         * @param {String} events
         * @param {Function} [handler]
         * @returns {EventEmitter} this
         */
        off: function(Ee, ke) {
          if (Ee !== i) {
            var Ke = this.handlers;
            return L(ve(Ee), function(bt) {
              ke ? Ke[bt] && Ke[bt].splice(me(Ke[bt], ke), 1) : delete Ke[bt];
            }), this;
          }
        },
        /**
         * emit event to the listeners
         * @param {String} event
         * @param {Object} data
         */
        emit: function(Ee, ke) {
          this.options.domEvents && On(Ee, ke);
          var Ke = this.handlers[Ee] && this.handlers[Ee].slice();
          if (!(!Ke || !Ke.length)) {
            ke.type = Ee, ke.preventDefault = function() {
              ke.srcEvent.preventDefault();
            };
            for (var bt = 0; bt < Ke.length; )
              Ke[bt](ke), bt++;
          }
        },
        /**
         * destroy the manager and unbinds all events
         * it doesn't unbind dom events, that is the user own responsibility
         */
        destroy: function() {
          this.element && Ms(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null;
        }
      };
      function Ms(Ee, ke) {
        var Ke = Ee.element;
        if (Ke.style) {
          var bt;
          L(Ee.options.cssProps, function(Qt, Tr) {
            bt = Me(Ke.style, Tr), ke ? (Ee.oldCssProps[bt] = Ke.style[bt], Ke.style[bt] = Qt) : Ke.style[bt] = Ee.oldCssProps[bt] || "";
          }), ke || (Ee.oldCssProps = {});
        }
      }
      function On(Ee, ke) {
        var Ke = t.createEvent("Event");
        Ke.initEvent(Ee, !0, !0), Ke.gesture = ke, ke.target.dispatchEvent(Ke);
      }
      V(Ci, {
        INPUT_START: sr,
        INPUT_MOVE: tr,
        INPUT_END: Wt,
        INPUT_CANCEL: yr,
        STATE_POSSIBLE: Qr,
        STATE_BEGAN: $r,
        STATE_CHANGED: Ai,
        STATE_ENDED: Kr,
        STATE_RECOGNIZED: hr,
        STATE_CANCELLED: ye,
        STATE_FAILED: er,
        DIRECTION_NONE: An,
        DIRECTION_LEFT: Fr,
        DIRECTION_RIGHT: Pr,
        DIRECTION_UP: $n,
        DIRECTION_DOWN: xr,
        DIRECTION_HORIZONTAL: wr,
        DIRECTION_VERTICAL: gn,
        DIRECTION_ALL: zr,
        Manager: $i,
        Input: wn,
        TouchAction: nn,
        TouchInput: pe,
        MouseInput: Xt,
        PointerEventInput: Pe,
        TouchMouseInput: d,
        SingleTouchInput: ie,
        Recognizer: sn,
        AttrRecognizer: Xn,
        Tap: fi,
        Pan: Ae,
        Swipe: Oi,
        Pinch: Ko,
        Rotate: Qo,
        Press: Zn,
        on: ae,
        off: De,
        each: L,
        merge: j,
        extend: q,
        assign: V,
        inherit: K,
        bindFn: Y,
        prefixed: Me
      });
      var lf = typeof e < "u" ? e : typeof self < "u" ? self : {};
      lf.Hammer = Ci, r.exports ? r.exports = Ci : e[n] = Ci;
    })(window, document, "Hammer");
  })(o1)), o1.exports;
}
var b0 = ate();
const lte = /* @__PURE__ */ dh(b0), Kl = /* @__PURE__ */ UN({
  __proto__: null,
  default: lte
}, [b0]), xD = 1, wD = 2, h2 = 4, cte = {
  mousedown: xD,
  mousemove: wD,
  mouseup: h2
};
function ute(r, e) {
  for (let t = 0; t < r.length; t++)
    if (e(r[t]))
      return !0;
  return !1;
}
function fte(r) {
  const e = r.prototype.handler;
  r.prototype.handler = function(n) {
    const i = this.store;
    n.button > 0 && n.type === "pointerdown" && (ute(i, (s) => s.pointerId === n.pointerId) || i.push(n)), e.call(this, n);
  };
}
function hte(r) {
  r.prototype.handler = function(t) {
    let n = cte[t.type];
    n & xD && t.button >= 0 && (this.pressed = !0), n & wD && t.buttons === 0 && (n = h2), this.pressed && (n & h2 && (this.pressed = !1), this.callback(this.manager, n, {
      pointers: [t],
      changedPointers: [t],
      pointerType: "mouse",
      srcEvent: t
    }));
  };
}
fte(b0.PointerEventInput);
hte(b0.MouseInput);
const dte = b0.Manager;
class Y_ {
  constructor(e, t, n) {
    this.element = e, this.callback = t, this.options = { enable: !0, ...n };
  }
}
const pte = Kl ? [
  [Kl.Pan, { event: "tripan", pointers: 3, threshold: 0, enable: !1 }],
  [Kl.Rotate, { enable: !1 }],
  [Kl.Pinch, { enable: !1 }],
  [Kl.Swipe, { enable: !1 }],
  [Kl.Pan, { threshold: 0, enable: !1 }],
  [Kl.Press, { enable: !1 }],
  [Kl.Tap, { event: "doubletap", taps: 2, enable: !1 }],
  // TODO - rename to 'tap' and 'singletap' in the next major release
  [Kl.Tap, { event: "anytap", enable: !1 }],
  [Kl.Tap, { enable: !1 }]
] : null, cI = {
  tripan: ["rotate", "pinch", "pan"],
  rotate: ["pinch"],
  pinch: ["pan"],
  pan: ["press", "doubletap", "anytap", "tap"],
  doubletap: ["anytap"],
  anytap: ["tap"]
}, Ate = {
  doubletap: ["tap"]
}, gte = {
  pointerdown: "pointerdown",
  pointermove: "pointermove",
  pointerup: "pointerup",
  touchstart: "pointerdown",
  touchmove: "pointermove",
  touchend: "pointerup",
  mousedown: "pointerdown",
  mousemove: "pointermove",
  mouseup: "pointerup"
}, hw = {
  KEY_EVENTS: ["keydown", "keyup"],
  MOUSE_EVENTS: ["mousedown", "mousemove", "mouseup", "mouseover", "mouseout", "mouseleave"],
  WHEEL_EVENTS: [
    // Chrome, Safari
    "wheel",
    // IE
    "mousewheel"
  ]
}, mte = {
  tap: "tap",
  anytap: "anytap",
  doubletap: "doubletap",
  press: "press",
  pinch: "pinch",
  pinchin: "pinch",
  pinchout: "pinch",
  pinchstart: "pinch",
  pinchmove: "pinch",
  pinchend: "pinch",
  pinchcancel: "pinch",
  rotate: "rotate",
  rotatestart: "rotate",
  rotatemove: "rotate",
  rotateend: "rotate",
  rotatecancel: "rotate",
  tripan: "tripan",
  tripanstart: "tripan",
  tripanmove: "tripan",
  tripanup: "tripan",
  tripandown: "tripan",
  tripanleft: "tripan",
  tripanright: "tripan",
  tripanend: "tripan",
  tripancancel: "tripan",
  pan: "pan",
  panstart: "pan",
  panmove: "pan",
  panup: "pan",
  pandown: "pan",
  panleft: "pan",
  panright: "pan",
  panend: "pan",
  pancancel: "pan",
  swipe: "swipe",
  swipeleft: "swipe",
  swiperight: "swipe",
  swipeup: "swipe",
  swipedown: "swipe"
}, uI = {
  click: "tap",
  anyclick: "anytap",
  dblclick: "doubletap",
  mousedown: "pointerdown",
  mousemove: "pointermove",
  mouseup: "pointerup",
  mouseover: "pointerover",
  mouseout: "pointerout",
  mouseleave: "pointerleave"
}, _te = typeof navigator < "u" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "", Qd = typeof window < "u" ? window : global;
let d2 = !1;
try {
  const r = {
    // This function will be called when the browser
    // attempts to access the passive property.
    get passive() {
      return d2 = !0, !0;
    }
  };
  Qd.addEventListener("test", null, r), Qd.removeEventListener("test", null);
} catch {
  d2 = !1;
}
const yte = _te.indexOf("firefox") !== -1, { WHEEL_EVENTS: vte } = hw, fI = "wheel", hI = 4.000244140625, bte = 40, xte = 0.25;
class wte extends Y_ {
  constructor(e, t, n) {
    super(e, t, n), this.handleEvent = (i) => {
      if (!this.options.enable)
        return;
      let s = i.deltaY;
      Qd.WheelEvent && (yte && i.deltaMode === Qd.WheelEvent.DOM_DELTA_PIXEL && (s /= Qd.devicePixelRatio), i.deltaMode === Qd.WheelEvent.DOM_DELTA_LINE && (s *= bte)), s !== 0 && s % hI === 0 && (s = Math.floor(s / hI)), i.shiftKey && s && (s = s * xte), this.callback({
        type: fI,
        center: {
          x: i.clientX,
          y: i.clientY
        },
        delta: -s,
        srcEvent: i,
        pointerType: "mouse",
        target: i.target
      });
    }, this.events = (this.options.events || []).concat(vte), this.events.forEach((i) => e.addEventListener(i, this.handleEvent, d2 ? { passive: !1 } : !1));
  }
  destroy() {
    this.events.forEach((e) => this.element.removeEventListener(e, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, t) {
    e === fI && (this.options.enable = t);
  }
}
const { MOUSE_EVENTS: Tte } = hw, dI = "pointermove", pI = "pointerover", AI = "pointerout", gI = "pointerenter", mI = "pointerleave";
class Ete extends Y_ {
  constructor(e, t, n) {
    super(e, t, n), this.handleEvent = (s) => {
      this.handleOverEvent(s), this.handleOutEvent(s), this.handleEnterEvent(s), this.handleLeaveEvent(s), this.handleMoveEvent(s);
    }, this.pressed = !1;
    const { enable: i } = this.options;
    this.enableMoveEvent = i, this.enableLeaveEvent = i, this.enableEnterEvent = i, this.enableOutEvent = i, this.enableOverEvent = i, this.events = (this.options.events || []).concat(Tte), this.events.forEach((s) => e.addEventListener(s, this.handleEvent));
  }
  destroy() {
    this.events.forEach((e) => this.element.removeEventListener(e, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, t) {
    e === dI && (this.enableMoveEvent = t), e === pI && (this.enableOverEvent = t), e === AI && (this.enableOutEvent = t), e === gI && (this.enableEnterEvent = t), e === mI && (this.enableLeaveEvent = t);
  }
  handleOverEvent(e) {
    this.enableOverEvent && e.type === "mouseover" && this._emit(pI, e);
  }
  handleOutEvent(e) {
    this.enableOutEvent && e.type === "mouseout" && this._emit(AI, e);
  }
  handleEnterEvent(e) {
    this.enableEnterEvent && e.type === "mouseenter" && this._emit(gI, e);
  }
  handleLeaveEvent(e) {
    this.enableLeaveEvent && e.type === "mouseleave" && this._emit(mI, e);
  }
  handleMoveEvent(e) {
    if (this.enableMoveEvent)
      switch (e.type) {
        case "mousedown":
          e.button >= 0 && (this.pressed = !0);
          break;
        case "mousemove":
          e.buttons === 0 && (this.pressed = !1), this.pressed || this._emit(dI, e);
          break;
        case "mouseup":
          this.pressed = !1;
          break;
      }
  }
  _emit(e, t) {
    this.callback({
      type: e,
      center: {
        x: t.clientX,
        y: t.clientY
      },
      srcEvent: t,
      pointerType: "mouse",
      target: t.target
    });
  }
}
const { KEY_EVENTS: Cte } = hw, _I = "keydown", yI = "keyup";
class Ste extends Y_ {
  constructor(e, t, n) {
    super(e, t, n), this.handleEvent = (i) => {
      const s = i.target || i.srcElement;
      s.tagName === "INPUT" && s.type === "text" || s.tagName === "TEXTAREA" || (this.enableDownEvent && i.type === "keydown" && this.callback({
        type: _I,
        srcEvent: i,
        key: i.key,
        target: i.target
      }), this.enableUpEvent && i.type === "keyup" && this.callback({
        type: yI,
        srcEvent: i,
        key: i.key,
        target: i.target
      }));
    }, this.enableDownEvent = this.options.enable, this.enableUpEvent = this.options.enable, this.events = (this.options.events || []).concat(Cte), e.tabIndex = this.options.tabIndex || 0, e.style.outline = "none", this.events.forEach((i) => e.addEventListener(i, this.handleEvent));
  }
  destroy() {
    this.events.forEach((e) => this.element.removeEventListener(e, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, t) {
    e === _I && (this.enableDownEvent = t), e === yI && (this.enableUpEvent = t);
  }
}
const vI = "contextmenu";
class Ite extends Y_ {
  constructor(e, t, n) {
    super(e, t, n), this.handleEvent = (i) => {
      this.options.enable && this.callback({
        type: vI,
        center: {
          x: i.clientX,
          y: i.clientY
        },
        srcEvent: i,
        pointerType: "mouse",
        target: i.target
      });
    }, e.addEventListener("contextmenu", this.handleEvent);
  }
  destroy() {
    this.element.removeEventListener("contextmenu", this.handleEvent);
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, t) {
    e === vI && (this.options.enable = t);
  }
}
const bI = 1, p2 = 2, xI = 4, Pte = {
  pointerdown: bI,
  pointermove: p2,
  pointerup: xI,
  mousedown: bI,
  mousemove: p2,
  mouseup: xI
}, Mte = 0, Rte = 1, Bte = 2, Ote = 1, Dte = 2, Lte = 4;
function kte(r) {
  const e = Pte[r.srcEvent.type];
  if (!e)
    return null;
  const { buttons: t, button: n } = r.srcEvent;
  let i = !1, s = !1, o = !1;
  return e === p2 ? (i = !!(t & Ote), s = !!(t & Lte), o = !!(t & Dte)) : (i = n === Mte, s = n === Rte, o = n === Bte), { leftButton: i, middleButton: s, rightButton: o };
}
function Fte(r, e) {
  const t = r.center;
  if (!t)
    return null;
  const n = e.getBoundingClientRect(), i = n.width / e.offsetWidth || 1, s = n.height / e.offsetHeight || 1, o = {
    x: (t.x - n.left - e.clientLeft) / i,
    y: (t.y - n.top - e.clientTop) / s
  };
  return { center: t, offsetCenter: o };
}
const a1 = {
  srcElement: "root",
  priority: 0
};
class Nte {
  constructor(e) {
    this.handleEvent = (t) => {
      if (this.isEmpty())
        return;
      const n = this._normalizeEvent(t);
      let i = t.srcEvent.target;
      for (; i && i !== n.rootElement; ) {
        if (this._emit(n, i), n.handled)
          return;
        i = i.parentNode;
      }
      this._emit(n, "root");
    }, this.eventManager = e, this.handlers = [], this.handlersByElement = /* @__PURE__ */ new Map(), this._active = !1;
  }
  // Returns true if there are no non-passive handlers
  isEmpty() {
    return !this._active;
  }
  add(e, t, n, i = !1, s = !1) {
    const { handlers: o, handlersByElement: l } = this;
    let u = a1;
    typeof n == "string" || n && n.addEventListener ? u = { ...a1, srcElement: n } : n && (u = { ...a1, ...n });
    let m = l.get(u.srcElement);
    m || (m = [], l.set(u.srcElement, m));
    const y = {
      type: e,
      handler: t,
      srcElement: u.srcElement,
      priority: u.priority
    };
    i && (y.once = !0), s && (y.passive = !0), o.push(y), this._active = this._active || !y.passive;
    let E = m.length - 1;
    for (; E >= 0 && !(m[E].priority >= y.priority); )
      E--;
    m.splice(E + 1, 0, y);
  }
  remove(e, t) {
    const { handlers: n, handlersByElement: i } = this;
    for (let s = n.length - 1; s >= 0; s--) {
      const o = n[s];
      if (o.type === e && o.handler === t) {
        n.splice(s, 1);
        const l = i.get(o.srcElement);
        l.splice(l.indexOf(o), 1), l.length === 0 && i.delete(o.srcElement);
      }
    }
    this._active = n.some((s) => !s.passive);
  }
  /**
   * Invoke handlers on a particular element
   */
  _emit(e, t) {
    const n = this.handlersByElement.get(t);
    if (n) {
      let i = !1;
      const s = () => {
        e.handled = !0;
      }, o = () => {
        e.handled = !0, i = !0;
      }, l = [];
      for (let u = 0; u < n.length; u++) {
        const { type: m, handler: y, once: E } = n[u];
        if (y({
          ...e,
          // @ts-ignore
          type: m,
          stopPropagation: s,
          stopImmediatePropagation: o
        }), E && l.push(n[u]), i)
          break;
      }
      for (let u = 0; u < l.length; u++) {
        const { type: m, handler: y } = l[u];
        this.remove(m, y);
      }
    }
  }
  /**
   * Normalizes hammerjs and custom events to have predictable fields.
   */
  _normalizeEvent(e) {
    const t = this.eventManager.getElement();
    return {
      ...e,
      ...kte(e),
      ...Fte(e, t),
      preventDefault: () => {
        e.srcEvent.preventDefault();
      },
      stopImmediatePropagation: null,
      stopPropagation: null,
      handled: !1,
      rootElement: t
    };
  }
}
const Ute = {
  // event handlers
  events: null,
  // custom recognizers
  recognizers: null,
  recognizerOptions: {},
  // Manager class
  Manager: dte,
  // allow browser default touch action
  // https://github.com/uber/react-map-gl/issues/506
  touchAction: "none",
  tabIndex: 0
};
class zte {
  constructor(e = null, t) {
    this._onBasicInput = (i) => {
      const { srcEvent: s } = i, o = gte[s.type];
      o && this.manager.emit(o, i);
    }, this._onOtherEvent = (i) => {
      this.manager.emit(i.type, i);
    }, this.options = { ...Ute, ...t }, this.events = /* @__PURE__ */ new Map(), this.setElement(e);
    const { events: n } = this.options;
    n && this.on(n);
  }
  getElement() {
    return this.element;
  }
  setElement(e) {
    if (this.element && this.destroy(), this.element = e, !e)
      return;
    const { options: t } = this, n = t.Manager;
    this.manager = new n(e, {
      touchAction: t.touchAction,
      recognizers: t.recognizers || pte
    }).on("hammer.input", this._onBasicInput), t.recognizers || Object.keys(cI).forEach((i) => {
      const s = this.manager.get(i);
      s && cI[i].forEach((o) => {
        s.recognizeWith(o);
      });
    });
    for (const i in t.recognizerOptions) {
      const s = this.manager.get(i);
      if (s) {
        const o = t.recognizerOptions[i];
        delete o.enable, s.set(o);
      }
    }
    this.wheelInput = new wte(e, this._onOtherEvent, {
      enable: !1
    }), this.moveInput = new Ete(e, this._onOtherEvent, {
      enable: !1
    }), this.keyInput = new Ste(e, this._onOtherEvent, {
      enable: !1,
      tabIndex: t.tabIndex
    }), this.contextmenuInput = new Ite(e, this._onOtherEvent, {
      enable: !1
    });
    for (const [i, s] of this.events)
      s.isEmpty() || (this._toggleRecognizer(s.recognizerName, !0), this.manager.on(i, s.handleEvent));
  }
  // Tear down internal event management implementations.
  destroy() {
    this.element && (this.wheelInput.destroy(), this.moveInput.destroy(), this.keyInput.destroy(), this.contextmenuInput.destroy(), this.manager.destroy(), this.wheelInput = null, this.moveInput = null, this.keyInput = null, this.contextmenuInput = null, this.manager = null, this.element = null);
  }
  /** Register an event handler function to be called on `event` */
  on(e, t, n) {
    this._addEventHandler(e, t, n, !1);
  }
  once(e, t, n) {
    this._addEventHandler(e, t, n, !0);
  }
  watch(e, t, n) {
    this._addEventHandler(e, t, n, !1, !0);
  }
  off(e, t) {
    this._removeEventHandler(e, t);
  }
  /*
   * Enable/disable recognizer for the given event
   */
  _toggleRecognizer(e, t) {
    const { manager: n } = this;
    if (!n)
      return;
    const i = n.get(e);
    if (i && i.options.enable !== t) {
      i.set({ enable: t });
      const s = Ate[e];
      s && !this.options.recognizers && s.forEach((o) => {
        const l = n.get(o);
        t ? (l.requireFailure(e), i.dropRequireFailure(o)) : l.dropRequireFailure(e);
      });
    }
    this.wheelInput.enableEventType(e, t), this.moveInput.enableEventType(e, t), this.keyInput.enableEventType(e, t), this.contextmenuInput.enableEventType(e, t);
  }
  /**
   * Process the event registration for a single event + handler.
   */
  _addEventHandler(e, t, n, i, s) {
    if (typeof e != "string") {
      n = t;
      for (const y in e)
        this._addEventHandler(y, e[y], n, i, s);
      return;
    }
    const { manager: o, events: l } = this, u = uI[e] || e;
    let m = l.get(u);
    m || (m = new Nte(this), l.set(u, m), m.recognizerName = mte[u] || u, o && o.on(u, m.handleEvent)), m.add(e, t, n, i, s), m.isEmpty() || this._toggleRecognizer(m.recognizerName, !0);
  }
  /**
   * Process the event deregistration for a single event + handler.
   */
  _removeEventHandler(e, t) {
    if (typeof e != "string") {
      for (const o in e)
        this._removeEventHandler(o, e[o]);
      return;
    }
    const { events: n } = this, i = uI[e] || e, s = n.get(i);
    if (s && (s.remove(e, t), s.isEmpty())) {
      const { recognizerName: o } = s;
      let l = !1;
      for (const u of n.values())
        if (u.recognizerName === o && !u.isEmpty()) {
          l = !0;
          break;
        }
      l || this._toggleRecognizer(o, !1);
    }
  }
}
function wI(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function Do(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? wI(Object(t), !0).forEach(function(n) {
      Br(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : wI(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
var kf = {
  transitionDuration: 0
}, Vc = {
  transitionDuration: 300,
  transitionEasing: function(e) {
    return e;
  },
  transitionInterpolator: new qA(),
  transitionInterruption: ZA.BREAK
}, Dg = 300, Lg = function(e) {
  return 1 - (1 - e) * (1 - e);
}, wd = {
  WHEEL: ["wheel"],
  PAN: ["panstart", "panmove", "panend"],
  PINCH: ["pinchstart", "pinchmove", "pinchend"],
  TRIPLE_PAN: ["tripanstart", "tripanmove", "tripanend"],
  DOUBLE_TAP: ["doubletap"],
  KEYBOARD: ["keydown"]
}, TD = (function() {
  function r() {
    var e = this;
    ef(this, r), Br(this, "events", []), Br(this, "scrollZoom", !0), Br(this, "dragPan", !0), Br(this, "dragRotate", !0), Br(this, "doubleClickZoom", !0), Br(this, "touchZoom", !0), Br(this, "touchRotate", !1), Br(this, "keyboard", !0), Br(this, "_interactionState", {
      isDragging: !1
    }), Br(this, "_events", {}), Br(this, "_setInteractionState", function(t) {
      Object.assign(e._interactionState, t), e.onStateChange && e.onStateChange(e._interactionState);
    }), Br(this, "_onTransition", function(t, n) {
      e.onViewportChange(t, e._interactionState, n);
    }), this.handleEvent = this.handleEvent.bind(this), this._transitionManager = new fw({
      onViewportChange: this._onTransition,
      onStateChange: this._setInteractionState
    });
  }
  return Ju(r, [{
    key: "handleEvent",
    value: function(t) {
      this.mapState = this.getMapState();
      var n = this._eventStartBlocked;
      switch (t.type) {
        case "panstart":
          return n ? !1 : this._onPanStart(t);
        case "panmove":
          return this._onPan(t);
        case "panend":
          return this._onPanEnd(t);
        case "pinchstart":
          return n ? !1 : this._onPinchStart(t);
        case "pinchmove":
          return this._onPinch(t);
        case "pinchend":
          return this._onPinchEnd(t);
        case "tripanstart":
          return n ? !1 : this._onTriplePanStart(t);
        case "tripanmove":
          return this._onTriplePan(t);
        case "tripanend":
          return this._onTriplePanEnd(t);
        case "doubletap":
          return this._onDoubleTap(t);
        case "wheel":
          return this._onWheel(t);
        case "keydown":
          return this._onKeyDown(t);
        default:
          return !1;
      }
    }
  }, {
    key: "getCenter",
    value: function(t) {
      var n = t.offsetCenter, i = n.x, s = n.y;
      return [i, s];
    }
  }, {
    key: "isFunctionKeyPressed",
    value: function(t) {
      var n = t.srcEvent;
      return !!(n.metaKey || n.altKey || n.ctrlKey || n.shiftKey);
    }
  }, {
    key: "blockEvents",
    value: function(t) {
      var n = this, i = setTimeout(function() {
        n._eventStartBlocked === i && (n._eventStartBlocked = null);
      }, t);
      this._eventStartBlocked = i;
    }
  }, {
    key: "updateViewport",
    value: function(t, n, i) {
      var s = this.mapState instanceof up ? this.mapState.getViewportProps() : this.mapState, o = Do(Do({}, t.getViewportProps()), n), l = Object.keys(o).some(function(u) {
        return s[u] !== o[u];
      });
      this._state = t.getState(), this._setInteractionState(i), l && this.onViewportChange(o, this._interactionState, s);
    }
  }, {
    key: "getMapState",
    value: function(t) {
      return new up(Do(Do(Do({}, this.mapStateProps), this._state), t));
    }
  }, {
    key: "isDragging",
    value: function() {
      return this._interactionState.isDragging;
    }
  }, {
    key: "setOptions",
    value: function(t) {
      var n = t.onViewportChange, i = t.onStateChange, s = t.eventManager, o = s === void 0 ? this.eventManager : s, l = t.isInteractive, u = l === void 0 ? !0 : l, m = t.scrollZoom, y = m === void 0 ? this.scrollZoom : m, E = t.dragPan, P = E === void 0 ? this.dragPan : E, L = t.dragRotate, U = L === void 0 ? this.dragRotate : L, V = t.doubleClickZoom, q = V === void 0 ? this.doubleClickZoom : V, j = t.touchZoom, K = j === void 0 ? this.touchZoom : j, Y = t.touchRotate, de = Y === void 0 ? this.touchRotate : Y, ne = t.keyboard, ae = ne === void 0 ? this.keyboard : ne;
      this.onViewportChange = n, this.onStateChange = i;
      var De = this.mapStateProps || {}, Ge = De.height !== t.height || De.width !== t.width;
      this.mapStateProps = t, Ge && (this.mapState = De, this.updateViewport(new up(t))), this._transitionManager.processViewportChange(t), this.eventManager !== o && (this.eventManager = o, this._events = {}, this.toggleEvents(this.events, !0)), this.toggleEvents(wd.WHEEL, u && !!y), this.toggleEvents(wd.PAN, u && !!(P || U)), this.toggleEvents(wd.PINCH, u && !!(K || de)), this.toggleEvents(wd.TRIPLE_PAN, u && !!de), this.toggleEvents(wd.DOUBLE_TAP, u && !!q), this.toggleEvents(wd.KEYBOARD, u && !!ae), this.scrollZoom = y, this.dragPan = P, this.dragRotate = U, this.doubleClickZoom = q, this.touchZoom = K, this.touchRotate = de, this.keyboard = ae;
    }
  }, {
    key: "toggleEvents",
    value: function(t, n) {
      var i = this;
      this.eventManager && t.forEach(function(s) {
        i._events[s] !== n && (i._events[s] = n, n ? i.eventManager.on(s, i.handleEvent) : i.eventManager.off(s, i.handleEvent));
      });
    }
  }, {
    key: "_onPanStart",
    value: function(t) {
      var n = this.getCenter(t);
      this._panRotate = this.isFunctionKeyPressed(t) || t.rightButton;
      var i = this._panRotate ? this.mapState.rotateStart({
        pos: n
      }) : this.mapState.panStart({
        pos: n
      });
      return this.updateViewport(i, kf, {
        isDragging: !0
      }), !0;
    }
  }, {
    key: "_onPan",
    value: function(t) {
      return this.isDragging() ? this._panRotate ? this._onPanRotate(t) : this._onPanMove(t) : !1;
    }
  }, {
    key: "_onPanEnd",
    value: function(t) {
      return this.isDragging() ? this._panRotate ? this._onPanRotateEnd(t) : this._onPanMoveEnd(t) : !1;
    }
  }, {
    key: "_onPanMove",
    value: function(t) {
      if (!this.dragPan)
        return !1;
      var n = this.getCenter(t), i = this.mapState.pan({
        pos: n
      });
      return this.updateViewport(i, kf, {
        isPanning: !0
      }), !0;
    }
  }, {
    key: "_onPanMoveEnd",
    value: function(t) {
      if (this.dragPan) {
        var n = this.dragPan.inertia, i = n === void 0 ? Dg : n;
        if (i && t.velocity) {
          var s = this.getCenter(t), o = [s[0] + t.velocityX * i / 2, s[1] + t.velocityY * i / 2], l = this.mapState.pan({
            pos: o
          }).panEnd();
          return this.updateViewport(l, Do(Do({}, Vc), {}, {
            transitionDuration: i,
            transitionEasing: Lg
          }), {
            isDragging: !1,
            isPanning: !0
          }), !0;
        }
      }
      var u = this.mapState.panEnd();
      return this.updateViewport(u, null, {
        isDragging: !1,
        isPanning: !1
      }), !0;
    }
  }, {
    key: "_onPanRotate",
    value: function(t) {
      if (!this.dragRotate)
        return !1;
      var n = this.getCenter(t), i = this.mapState.rotate({
        pos: n
      });
      return this.updateViewport(i, kf, {
        isRotating: !0
      }), !0;
    }
  }, {
    key: "_onPanRotateEnd",
    value: function(t) {
      if (this.dragRotate) {
        var n = this.dragRotate.inertia, i = n === void 0 ? Dg : n;
        if (i && t.velocity) {
          var s = this.getCenter(t), o = [s[0] + t.velocityX * i / 2, s[1] + t.velocityY * i / 2], l = this.mapState.rotate({
            pos: o
          }).rotateEnd();
          return this.updateViewport(l, Do(Do({}, Vc), {}, {
            transitionDuration: i,
            transitionEasing: Lg
          }), {
            isDragging: !1,
            isRotating: !0
          }), !0;
        }
      }
      var u = this.mapState.panEnd();
      return this.updateViewport(u, null, {
        isDragging: !1,
        isRotating: !1
      }), !0;
    }
  }, {
    key: "_onWheel",
    value: function(t) {
      if (!this.scrollZoom)
        return !1;
      var n = this.scrollZoom, i = n.speed, s = i === void 0 ? 0.01 : i, o = n.smooth, l = o === void 0 ? !1 : o;
      t.preventDefault();
      var u = this.getCenter(t), m = t.delta, y = 2 / (1 + Math.exp(-Math.abs(m * s)));
      m < 0 && y !== 0 && (y = 1 / y);
      var E = this.mapState.zoom({
        pos: u,
        scale: y
      });
      return E.getViewportProps().zoom === this.mapStateProps.zoom ? !1 : (this.updateViewport(E, Do(Do({}, Vc), {}, {
        transitionInterpolator: new qA({
          around: u
        }),
        transitionDuration: l ? 250 : 1
      }), {
        isPanning: !0,
        isZooming: !0
      }), !0);
    }
  }, {
    key: "_onPinchStart",
    value: function(t) {
      var n = this.getCenter(t), i = this.mapState.zoomStart({
        pos: n
      }).rotateStart({
        pos: n
      });
      return this._startPinchRotation = t.rotation, this._lastPinchEvent = t, this.updateViewport(i, kf, {
        isDragging: !0
      }), !0;
    }
  }, {
    key: "_onPinch",
    value: function(t) {
      if (!this.isDragging() || !this.touchZoom && !this.touchRotate)
        return !1;
      var n = this.mapState;
      if (this.touchZoom) {
        var i = t.scale, s = this.getCenter(t);
        n = n.zoom({
          pos: s,
          scale: i
        });
      }
      if (this.touchRotate) {
        var o = t.rotation;
        n = n.rotate({
          deltaAngleX: this._startPinchRotation - o
        });
      }
      return this.updateViewport(n, kf, {
        isDragging: !0,
        isPanning: !!this.touchZoom,
        isZooming: !!this.touchZoom,
        isRotating: !!this.touchRotate
      }), this._lastPinchEvent = t, !0;
    }
  }, {
    key: "_onPinchEnd",
    value: function(t) {
      if (!this.isDragging())
        return !1;
      if (this.touchZoom) {
        var n = this.touchZoom.inertia, i = n === void 0 ? Dg : n, s = this._lastPinchEvent;
        if (i && s && t.scale !== s.scale) {
          var o = this.getCenter(t), l = this.mapState.rotateEnd(), u = Math.log2(t.scale), m = (u - Math.log2(s.scale)) / (t.deltaTime - s.deltaTime), y = Math.pow(2, u + m * i / 2);
          return l = l.zoom({
            pos: o,
            scale: y
          }).zoomEnd(), this.updateViewport(l, Do(Do({}, Vc), {}, {
            transitionInterpolator: new qA({
              around: o
            }),
            transitionDuration: i,
            transitionEasing: Lg
          }), {
            isDragging: !1,
            isPanning: !!this.touchZoom,
            isZooming: !!this.touchZoom,
            isRotating: !1
          }), this.blockEvents(i), !0;
        }
      }
      var E = this.mapState.zoomEnd().rotateEnd();
      return this._state.startPinchRotation = 0, this.updateViewport(E, null, {
        isDragging: !1,
        isPanning: !1,
        isZooming: !1,
        isRotating: !1
      }), this._startPinchRotation = null, this._lastPinchEvent = null, !0;
    }
  }, {
    key: "_onTriplePanStart",
    value: function(t) {
      var n = this.getCenter(t), i = this.mapState.rotateStart({
        pos: n
      });
      return this.updateViewport(i, kf, {
        isDragging: !0
      }), !0;
    }
  }, {
    key: "_onTriplePan",
    value: function(t) {
      if (!this.isDragging() || !this.touchRotate)
        return !1;
      var n = this.getCenter(t);
      n[0] -= t.deltaX;
      var i = this.mapState.rotate({
        pos: n
      });
      return this.updateViewport(i, kf, {
        isRotating: !0
      }), !0;
    }
  }, {
    key: "_onTriplePanEnd",
    value: function(t) {
      if (!this.isDragging())
        return !1;
      if (this.touchRotate) {
        var n = this.touchRotate.inertia, i = n === void 0 ? Dg : n;
        if (i && t.velocityY) {
          var s = this.getCenter(t), o = [s[0], s[1] += t.velocityY * i / 2], l = this.mapState.rotate({
            pos: o
          });
          return this.updateViewport(l, Do(Do({}, Vc), {}, {
            transitionDuration: i,
            transitionEasing: Lg
          }), {
            isDragging: !1,
            isRotating: !0
          }), this.blockEvents(i), !1;
        }
      }
      var u = this.mapState.rotateEnd();
      return this.updateViewport(u, null, {
        isDragging: !1,
        isRotating: !1
      }), !0;
    }
  }, {
    key: "_onDoubleTap",
    value: function(t) {
      if (!this.doubleClickZoom)
        return !1;
      var n = this.getCenter(t), i = this.isFunctionKeyPressed(t), s = this.mapState.zoom({
        pos: n,
        scale: i ? 0.5 : 2
      });
      return this.updateViewport(s, Object.assign({}, Vc, {
        transitionInterpolator: new qA({
          around: n
        })
      }), {
        isZooming: !0
      }), !0;
    }
  }, {
    key: "_onKeyDown",
    value: function(t) {
      if (!this.keyboard)
        return !1;
      var n = this.isFunctionKeyPressed(t), i = this.keyboard, s = i.zoomSpeed, o = s === void 0 ? 2 : s, l = i.moveSpeed, u = l === void 0 ? 100 : l, m = i.rotateSpeedX, y = m === void 0 ? 15 : m, E = i.rotateSpeedY, P = E === void 0 ? 10 : E, L = this.mapStateProps, U;
      switch (t.srcEvent.keyCode) {
        case 189:
          n ? U = this.getMapState({
            zoom: L.zoom - Math.log2(o) - 1
          }) : U = this.getMapState({
            zoom: L.zoom - Math.log2(o)
          });
          break;
        case 187:
          n ? U = this.getMapState({
            zoom: L.zoom + Math.log2(o) + 1
          }) : U = this.getMapState({
            zoom: L.zoom + Math.log2(o)
          });
          break;
        case 37:
          n ? U = this.getMapState({
            bearing: L.bearing - y
          }) : U = this.mapState.pan({
            pos: [u, 0],
            startPos: [0, 0]
          });
          break;
        case 39:
          n ? U = this.getMapState({
            bearing: L.bearing + y
          }) : U = this.mapState.pan({
            pos: [-u, 0],
            startPos: [0, 0]
          });
          break;
        case 38:
          n ? U = this.getMapState({
            pitch: L.pitch + P
          }) : U = this.mapState.pan({
            pos: [0, u],
            startPos: [0, 0]
          });
          break;
        case 40:
          n ? U = this.getMapState({
            pitch: L.pitch - P
          }) : U = this.mapState.pan({
            pos: [0, -u],
            startPos: [0, 0]
          });
          break;
        default:
          return !1;
      }
      return this.updateViewport(U, Vc);
    }
  }]), r;
})();
function TI(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function Uc(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? TI(Object(t), !0).forEach(function(n) {
      Br(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : TI(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
var Vte = Object.assign({}, nu.propTypes, {
  maxZoom: vt.number,
  minZoom: vt.number,
  maxPitch: vt.number,
  minPitch: vt.number,
  onViewStateChange: vt.func,
  onViewportChange: vt.func,
  onInteractionStateChange: vt.func,
  transitionDuration: vt.oneOfType([vt.number, vt.string]),
  transitionInterpolator: vt.object,
  transitionInterruption: vt.number,
  transitionEasing: vt.func,
  onTransitionStart: vt.func,
  onTransitionInterrupt: vt.func,
  onTransitionEnd: vt.func,
  scrollZoom: vt.oneOfType([vt.bool, vt.object]),
  dragPan: vt.oneOfType([vt.bool, vt.object]),
  dragRotate: vt.oneOfType([vt.bool, vt.object]),
  doubleClickZoom: vt.bool,
  touchZoom: vt.oneOfType([vt.bool, vt.object]),
  touchRotate: vt.oneOfType([vt.bool, vt.object]),
  keyboard: vt.oneOfType([vt.bool, vt.object]),
  onHover: vt.func,
  onClick: vt.func,
  onDblClick: vt.func,
  onContextMenu: vt.func,
  onMouseDown: vt.func,
  onMouseMove: vt.func,
  onMouseUp: vt.func,
  onTouchStart: vt.func,
  onTouchMove: vt.func,
  onTouchEnd: vt.func,
  onMouseEnter: vt.func,
  onMouseLeave: vt.func,
  onMouseOut: vt.func,
  onWheel: vt.func,
  touchAction: vt.string,
  eventRecognizerOptions: vt.object,
  clickRadius: vt.number,
  interactiveLayerIds: vt.array,
  getCursor: vt.func,
  controller: vt.instanceOf(TD)
}), jte = function(e) {
  var t = e.isDragging, n = e.isHovering;
  return t ? "grabbing" : n ? "pointer" : "grab";
}, Hte = Object.assign({}, nu.defaultProps, qf, fw.defaultProps, {
  onViewStateChange: null,
  onViewportChange: null,
  onClick: null,
  onNativeClick: null,
  onHover: null,
  onContextMenu: function(e) {
    return e.preventDefault();
  },
  scrollZoom: !0,
  dragPan: !0,
  dragRotate: !0,
  doubleClickZoom: !0,
  touchZoom: !0,
  touchRotate: !1,
  keyboard: !0,
  touchAction: "none",
  eventRecognizerOptions: {},
  clickRadius: 0,
  getCursor: jte
});
function dw(r) {
  if (r.lngLat || !r.offsetCenter)
    return r;
  var e = r.offsetCenter, t = e.x, n = e.y;
  if (!Number.isFinite(t) || !Number.isFinite(n))
    return r;
  var i = [t, n];
  return r.point = i, r.lngLat = this.viewport.unproject(i), r;
}
function ED(r) {
  var e = this.map;
  if (!e || !r)
    return null;
  var t = {}, n = this.props.clickRadius;
  this.props.interactiveLayerIds && (t.layers = this.props.interactiveLayerIds);
  try {
    return e.queryRenderedFeatures(n ? [[r[0] - n, r[1] + n], [r[0] + n, r[1] - n]] : r, t);
  } catch {
    return null;
  }
}
function qc(r, e) {
  var t = this.props[r];
  t && t(dw.call(this, e));
}
function Gte(r) {
  qc.call(this, r.pointerType === "touch" ? "onTouchStart" : "onMouseDown", r);
}
function Wte(r) {
  qc.call(this, r.pointerType === "touch" ? "onTouchEnd" : "onMouseUp", r);
}
function $te(r) {
  if (qc.call(this, r.pointerType === "touch" ? "onTouchMove" : "onMouseMove", r), !this.state.isDragging) {
    var e = this.props, t = e.onHover, n = e.interactiveLayerIds, i;
    r = dw.call(this, r), (n || t) && (i = ED.call(this, r.point));
    var s = !!(n && i && i.length > 0), o = s && !this.state.isHovering, l = !s && this.state.isHovering;
    (t || o) && (r.features = i, t && t(r)), o && qc.call(this, "onMouseEnter", r), l && qc.call(this, "onMouseLeave", r), (o || l) && this.setState({
      isHovering: s
    });
  }
}
function EI(r) {
  var e = this.props, t = e.onClick, n = e.onNativeClick, i = e.onDblClick, s = e.doubleClickZoom, o = [], l = i || s;
  switch (r.type) {
    case "anyclick":
      o.push(n), l || o.push(t);
      break;
    case "click":
      l && o.push(t);
      break;
  }
  o = o.filter(Boolean), o.length && (r = dw.call(this, r), r.features = ED.call(this, r.point), o.forEach(function(u) {
    return u(r);
  }));
}
function qte(r) {
  return {
    getMap: r.current && r.current.getMap,
    queryRenderedFeatures: r.current && r.current.queryRenderedFeatures
  };
}
var pw = Dt.forwardRef(function(r, e) {
  var t = Dt.useContext(_h), n = Dt.useMemo(function() {
    return r.controller || new TD();
  }, []), i = Dt.useMemo(function() {
    return new zte(null, {
      touchAction: r.touchAction,
      recognizerOptions: r.eventRecognizerOptions
    });
  }, []), s = Dt.useRef(null), o = Dt.useRef(null), l = Dt.useRef({
    width: 0,
    height: 0,
    state: {
      isHovering: !1,
      isDragging: !1
    }
  }), u = l.current;
  u.props = r, u.map = o.current && o.current.getMap(), u.setState = function(ae) {
    u.state = Uc(Uc({}, u.state), ae), s.current.style.cursor = r.getCursor(u.state);
  };
  var m = !0, y, E, P = function(De, Ge, fe) {
    if (m) {
      y = [De, Ge, fe];
      return;
    }
    var ve = u.props, me = ve.onViewStateChange, X = ve.onViewportChange;
    me && me({
      viewState: De,
      interactionState: Ge,
      oldViewState: fe
    }), X && X(De, Ge, fe);
  };
  Dt.useImperativeHandle(e, function() {
    return qte(o);
  }, []);
  var L = Dt.useMemo(function() {
    return Uc(Uc({}, t), {}, {
      eventManager: i,
      container: t.container || s.current
    });
  }, [t, s.current]);
  L.onViewportChange = P, L.viewport = t.viewport || vD(u), u.viewport = L.viewport;
  var U = function(De) {
    var Ge = De.isDragging, fe = Ge === void 0 ? !1 : Ge;
    if (fe !== u.state.isDragging && u.setState({
      isDragging: fe
    }), m) {
      E = De;
      return;
    }
    var ve = u.props.onInteractionStateChange;
    ve && ve(De);
  }, V = function() {
    u.width && u.height && n.setOptions(Uc(Uc(Uc({}, u.props), u.props.viewState), {}, {
      isInteractive: !!(u.props.onViewStateChange || u.props.onViewportChange),
      onViewportChange: P,
      onStateChange: U,
      eventManager: i,
      width: u.width,
      height: u.height
    }));
  }, q = function(De) {
    var Ge = De.width, fe = De.height;
    u.width = Ge, u.height = fe, V(), u.props.onResize({
      width: Ge,
      height: fe
    });
  };
  Dt.useEffect(function() {
    return i.setElement(s.current), i.on({
      pointerdown: Gte.bind(u),
      pointermove: $te.bind(u),
      pointerup: Wte.bind(u),
      pointerleave: qc.bind(u, "onMouseOut"),
      click: EI.bind(u),
      anyclick: EI.bind(u),
      dblclick: qc.bind(u, "onDblClick"),
      wheel: qc.bind(u, "onWheel"),
      contextmenu: qc.bind(u, "onContextMenu")
    }), function() {
      i.destroy();
    };
  }, []), u2(function() {
    y && P.apply(void 0, SN(y)), E && U(E);
  }), V();
  var j = r.width, K = r.height, Y = r.style, de = r.getCursor, ne = Dt.useMemo(function() {
    return Uc(Uc({
      position: "relative"
    }, Y), {}, {
      width: j,
      height: K,
      cursor: de(u.state)
    });
  }, [Y, j, K, de, u.state]);
  return (!y || !u._child) && (u._child = Dt.createElement(uw, {
    value: L
  }, Dt.createElement("div", {
    key: "event-canvas",
    ref: s,
    style: ne
  }, Dt.createElement(nu, q4({}, r, {
    width: "100%",
    height: "100%",
    style: null,
    onResize: q,
    ref: o
  }))))), m = !1, u._child;
});
pw.supported = nu.supported;
pw.propTypes = Vte;
pw.defaultProps = Hte;
vt.string.isRequired;
var Xte = ["fill", "line", "symbol", "circle", "fill-extrusion", "raster", "background", "heatmap", "hillshade"];
vt.oneOf(Xte).isRequired;
var tf = {
  captureScroll: !1,
  captureDrag: !0,
  captureClick: !0,
  captureDoubleClick: !0,
  capturePointerMove: !1
}, wl = {
  captureScroll: vt.bool,
  captureDrag: vt.bool,
  captureClick: vt.bool,
  captureDoubleClick: vt.bool,
  capturePointerMove: vt.bool
};
function Zte(r) {
  var e = r.containerRef.current, t = r.context.eventManager;
  if (!(!e || !t)) {
    var n = {
      wheel: function(s) {
        var o = r.props;
        o.captureScroll && s.stopPropagation(), o.onScroll && o.onScroll(s, r);
      },
      panstart: function(s) {
        var o = r.props;
        o.captureDrag && s.stopPropagation(), o.onDragStart && o.onDragStart(s, r);
      },
      anyclick: function(s) {
        var o = r.props;
        o.captureClick && s.stopPropagation(), o.onNativeClick && o.onNativeClick(s, r);
      },
      click: function(s) {
        var o = r.props;
        o.captureClick && s.stopPropagation(), o.onClick && o.onClick(s, r);
      },
      dblclick: function(s) {
        var o = r.props;
        o.captureDoubleClick && s.stopPropagation(), o.onDoubleClick && o.onDoubleClick(s, r);
      },
      pointermove: function(s) {
        var o = r.props;
        o.capturePointerMove && s.stopPropagation(), o.onPointerMove && o.onPointerMove(s, r);
      }
    };
    return t.watch(n, e), function() {
      t.off(n);
    };
  }
}
function rf() {
  var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = Dt.useContext(_h), t = Dt.useRef(null), n = Dt.useRef({
    props: r,
    state: {},
    context: e,
    containerRef: t
  }), i = n.current;
  return i.props = r, i.context = e, Dt.useEffect(function() {
    return Zte(i);
  }, [e.eventManager]), i;
}
function Yte(r) {
  var e = Kte();
  return function() {
    var n = gp(r), i;
    if (e) {
      var s = gp(this).constructor;
      i = Reflect.construct(n, arguments, s);
    } else
      i = n.apply(this, arguments);
    return Z2(this, i);
  };
}
function Kte() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
  if (typeof Proxy == "function") return !0;
  try {
    return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Qte(r) {
  var e = r.instance, t = rf(r), n = t.context, i = t.containerRef;
  return e._context = n, e._containerRef = i, e._render();
}
var CD = (function(r) {
  X2(t, r);
  var e = Yte(t);
  function t() {
    var n;
    ef(this, t);
    for (var i = arguments.length, s = new Array(i), o = 0; o < i; o++)
      s[o] = arguments[o];
    return n = e.call.apply(e, [this].concat(s)), Br(Uu(n), "_context", {}), Br(Uu(n), "_containerRef", Dt.createRef()), Br(Uu(n), "_onScroll", function(l) {
    }), Br(Uu(n), "_onDragStart", function(l) {
    }), Br(Uu(n), "_onDblClick", function(l) {
    }), Br(Uu(n), "_onClick", function(l) {
    }), Br(Uu(n), "_onPointerMove", function(l) {
    }), n;
  }
  return Ju(t, [{
    key: "_render",
    value: function() {
      throw new Error("_render() not implemented");
    }
  }, {
    key: "render",
    value: function() {
      return Dt.createElement(Qte, q4({
        instance: this
      }, this.props, {
        onScroll: this._onScroll,
        onDragStart: this._onDragStart,
        onDblClick: this._onDblClick,
        onClick: this._onClick,
        onPointerMove: this._onPointerMove
      }));
    }
  }]), t;
})(Dt.PureComponent);
Br(CD, "propTypes", wl);
Br(CD, "defaultProps", tf);
function CI(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function SI(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? CI(Object(t), !0).forEach(function(n) {
      Br(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : CI(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
var Jte = Object.assign({}, wl, {
  draggable: vt.bool,
  onDrag: vt.func,
  onDragEnd: vt.func,
  onDragStart: vt.func,
  offsetLeft: vt.number,
  offsetTop: vt.number
}), ere = Object.assign({}, tf, {
  draggable: !1,
  offsetLeft: 0,
  offsetTop: 0
});
function SD(r) {
  var e = r.offsetCenter, t = e.x, n = e.y;
  return [t, n];
}
function tre(r, e) {
  var t = r.center, n = t.x, i = t.y;
  if (e) {
    var s = e.getBoundingClientRect();
    return [s.left - n, s.top - i];
  }
  return null;
}
function Aw(r, e, t, n) {
  var i = r[0] + e[0] - t.offsetLeft, s = r[1] + e[1] - t.offsetTop;
  return n.viewport.unproject([i, s]);
}
function rre(r, e) {
  var t = e.props, n = e.callbacks, i = e.state, s = e.context, o = e.containerRef, l = t.draggable;
  if (l) {
    r.stopPropagation();
    var u = SD(r), m = tre(r, o.current);
    if (i.setDragPos(u), i.setDragOffset(m), n.onDragStart && m) {
      var y = Object.assign({}, r);
      y.lngLat = Aw(u, m, t, s), n.onDragStart(y);
    }
  }
}
function nre(r, e) {
  var t = e.props, n = e.callbacks, i = e.state, s = e.context;
  r.stopPropagation();
  var o = SD(r);
  i.setDragPos(o);
  var l = i.dragOffset;
  if (n.onDrag && l) {
    var u = Object.assign({}, r);
    u.lngLat = Aw(o, l, t, s), n.onDrag(u);
  }
}
function ire(r, e) {
  var t = e.props, n = e.callbacks, i = e.state, s = e.context;
  r.stopPropagation();
  var o = i.dragPos, l = i.dragOffset;
  if (i.setDragPos(null), i.setDragOffset(null), n.onDragEnd && o && l) {
    var u = Object.assign({}, r);
    u.lngLat = Aw(o, l, t, s), n.onDragEnd(u);
  }
}
function sre(r, e) {
  var t = e.state;
  r.stopPropagation(), t.setDragPos(null), t.setDragOffset(null);
}
function ore(r) {
  var e = r.context.eventManager;
  if (!(!e || !r.state.dragPos)) {
    var t = {
      panmove: function(i) {
        return nre(i, r);
      },
      panend: function(i) {
        return ire(i, r);
      },
      pancancel: function(i) {
        return sre(i, r);
      }
    };
    return e.watch(t), function() {
      e.off(t);
    };
  }
}
function are(r) {
  var e = Dt.useState(null), t = gs(e, 2), n = t[0], i = t[1], s = Dt.useState(null), o = gs(s, 2), l = o[0], u = o[1], m = rf(SI(SI({}, r), {}, {
    onDragStart: rre
  }));
  return m.callbacks = r, m.state.dragPos = n, m.state.setDragPos = i, m.state.dragOffset = l, m.state.setDragOffset = u, Dt.useEffect(function() {
    return ore(m);
  }, [m.context.eventManager, !!n]), m;
}
var II = typeof window < "u" && window.devicePixelRatio || 1, u0 = function(e) {
  return Math.round(e * II) / II;
}, PI = function(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "x";
  if (e === null)
    return t;
  var i = n === "x" ? e.offsetWidth : e.offsetHeight;
  return u0(t / 100 * i) / i * 100;
};
function MI(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function lre(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? MI(Object(t), !0).forEach(function(n) {
      Br(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : MI(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
var cre = Object.assign({}, Jte, {
  className: vt.string,
  longitude: vt.number.isRequired,
  latitude: vt.number.isRequired,
  style: vt.object
}), ure = Object.assign({}, ere, {
  className: ""
});
function fre(r) {
  var e = r.props, t = r.state, n = r.context, i = e.longitude, s = e.latitude, o = e.offsetLeft, l = e.offsetTop, u = t.dragPos, m = t.dragOffset;
  if (u && m)
    return [u[0] + m[0], u[1] + m[1]];
  var y = n.viewport.project([i, s]), E = gs(y, 2), P = E[0], L = E[1];
  return P += o, L += l, [P, L];
}
function gw(r) {
  var e = are(r), t = e.state, n = e.containerRef, i = r.children, s = r.className, o = r.draggable, l = r.style, u = t.dragPos, m = fre(e), y = gs(m, 2), E = y[0], P = y[1], L = "translate(".concat(u0(E), "px, ").concat(u0(P), "px)"), U = o ? u ? "grabbing" : "grab" : "auto", V = Dt.useMemo(function() {
    var j = lre({
      position: "absolute",
      left: 0,
      top: 0,
      transform: L,
      cursor: U
    }, l);
    return Dt.createElement("div", {
      className: "mapboxgl-marker ".concat(s),
      ref: e.containerRef,
      style: j
    }, i);
  }, [i, s]), q = n.current;
  return q && (q.style.transform = L, q.style.cursor = U), V;
}
gw.defaultProps = ure;
gw.propTypes = cre;
Dt.memo(gw);
var f0 = {
  top: {
    x: 0.5,
    y: 0
  },
  "top-left": {
    x: 0,
    y: 0
  },
  "top-right": {
    x: 1,
    y: 0
  },
  bottom: {
    x: 0.5,
    y: 1
  },
  "bottom-left": {
    x: 0,
    y: 1
  },
  "bottom-right": {
    x: 1,
    y: 1
  },
  left: {
    x: 0,
    y: 0.5
  },
  right: {
    x: 1,
    y: 0.5
  }
}, hre = Object.keys(f0);
function dre(r) {
  var e = r.x, t = r.y, n = r.width, i = r.height, s = r.selfWidth, o = r.selfHeight, l = r.anchor, u = r.padding, m = u === void 0 ? 0 : u, y = f0[l], E = y.x, P = y.y, L = t - P * o, U = L + o, V = Math.max(0, m - L) + Math.max(0, U - i + m);
  if (V > 0) {
    var q = P, j = V;
    for (P = 0; P <= 1; P += 0.5)
      L = t - P * o, U = L + o, V = Math.max(0, m - L) + Math.max(0, U - i + m), V < j && (j = V, q = P);
    P = q;
  }
  var K = 0.5;
  P === 0.5 && (E = Math.floor(E), K = 1);
  var Y = e - E * s, de = Y + s, ne = Math.max(0, m - Y) + Math.max(0, de - n + m);
  if (ne > 0) {
    var ae = E, De = ne;
    for (E = 0; E <= 1; E += K)
      Y = e - E * s, de = Y + s, ne = Math.max(0, m - Y) + Math.max(0, de - n + m), ne < De && (De = ne, ae = E);
    E = ae;
  }
  return hre.find(function(Ge) {
    var fe = f0[Ge];
    return fe.x === E && fe.y === P;
  }) || l;
}
var pre = Object.assign({}, wl, {
  className: vt.string,
  longitude: vt.number.isRequired,
  latitude: vt.number.isRequired,
  altitude: vt.number,
  offsetLeft: vt.number,
  offsetTop: vt.number,
  tipSize: vt.number,
  closeButton: vt.bool,
  closeOnClick: vt.bool,
  anchor: vt.oneOf(Object.keys(f0)),
  dynamicPosition: vt.bool,
  sortByDepth: vt.bool,
  onClose: vt.func
}), Are = Object.assign({}, tf, {
  className: "",
  altitude: 0,
  offsetLeft: 0,
  offsetTop: 0,
  tipSize: 10,
  anchor: "bottom",
  dynamicPosition: !0,
  sortByDepth: !1,
  closeButton: !0,
  closeOnClick: !0,
  onClose: function() {
  }
});
function gre(r, e, t, n) {
  var i = gs(n, 2), s = i[0], o = i[1], l = r.anchor, u = r.dynamicPosition, m = r.tipSize;
  return t && u ? dre({
    x: s,
    y: o,
    anchor: l,
    padding: m,
    width: e.width,
    height: e.height,
    selfWidth: t.clientWidth,
    selfHeight: t.clientHeight
  }) : l;
}
function mre(r, e, t, n, i) {
  var s = gs(n, 3), o = s[0], l = s[1], u = s[2], m = r.offsetLeft, y = r.offsetTop, E = r.sortByDepth, P = f0[i], L = o + m, U = l + y, V = PI(t, -P.x * 100), q = PI(t, -P.y * 100, "y"), j = {
    position: "absolute",
    transform: `
      translate(`.concat(V, "%, ").concat(q, `%)
      translate(`).concat(u0(L), "px, ").concat(u0(U), `px)
    `),
    display: void 0,
    zIndex: void 0
  };
  return E && (u > 1 || u < -1 || o < 0 || o > e.width || l < 0 || l > e.height ? j.display = "none" : j.zIndex = Math.floor((1 - u) / 2 * 1e5)), j;
}
function mw(r) {
  var e = Dt.useRef(null), t = rf(r), n = t.context, i = t.containerRef, s = Dt.useState(!1), o = gs(s, 2), l = o[1];
  Dt.useEffect(function() {
    l(!0);
  }, [e.current]), Dt.useEffect(function() {
    if (n.eventManager && r.closeOnClick) {
      var de = function() {
        return t.props.onClose();
      };
      return n.eventManager.on("anyclick", de), function() {
        n.eventManager.off("anyclick", de);
      };
    }
  }, [n.eventManager, r.closeOnClick]);
  var u = n.viewport, m = r.className, y = r.longitude, E = r.latitude, P = r.altitude, L = r.tipSize, U = r.closeButton, V = r.children, q = u.project([y, E, P]), j = gre(r, u, e.current, q), K = mre(r, u, i.current, q, j), Y = Dt.useCallback(function(de) {
    t.props.onClose();
    var ne = t.context.eventManager;
    ne && ne.once("click", function(ae) {
      return ae.stopPropagation();
    }, de.target);
  }, []);
  return Dt.createElement("div", {
    className: "mapboxgl-popup mapboxgl-popup-anchor-".concat(j, " ").concat(m),
    style: K,
    ref: i
  }, Dt.createElement("div", {
    key: "tip",
    className: "mapboxgl-popup-tip",
    style: {
      borderWidth: L
    }
  }), Dt.createElement("div", {
    key: "content",
    ref: e,
    className: "mapboxgl-popup-content"
  }, U && Dt.createElement("button", {
    key: "close-button",
    className: "mapboxgl-popup-close-button",
    type: "button",
    onClick: Y
  }, ""), V));
}
mw.propTypes = pre;
mw.defaultProps = Are;
Dt.memo(mw);
function RI(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function _re(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? RI(Object(t), !0).forEach(function(n) {
      Br(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : RI(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
var yre = Object.assign({}, wl, {
  toggleLabel: vt.string,
  className: vt.string,
  style: vt.object,
  compact: vt.bool,
  customAttribution: vt.oneOfType([vt.string, vt.arrayOf(vt.string)])
}), vre = Object.assign({}, tf, {
  className: "",
  toggleLabel: "Toggle Attribution"
});
function bre(r, e, t, n) {
  var i = new cc.AttributionControl(r);
  return i._map = e, i._container = t, i._innerContainer = n, i._updateAttributions(), i._updateEditLink(), e.on("styledata", i._updateData), e.on("sourcedata", i._updateData), i;
}
function xre(r) {
  r._map.off("styledata", r._updateData), r._map.off("sourcedata", r._updateData);
}
function _w(r) {
  var e = rf(r), t = e.context, n = e.containerRef, i = Dt.useRef(null), s = Dt.useState(!1), o = gs(s, 2), l = o[0], u = o[1];
  Dt.useEffect(function() {
    var P;
    return t.map && (P = bre({
      customAttribution: r.customAttribution
    }, t.map, n.current, i.current)), function() {
      return P && xre(P);
    };
  }, [t.map]);
  var m = r.compact === void 0 ? t.viewport.width <= 640 : r.compact;
  Dt.useEffect(function() {
    !m && l && u(!1);
  }, [m]);
  var y = Dt.useCallback(function() {
    return u(function(P) {
      return !P;
    });
  }, []), E = Dt.useMemo(function() {
    return _re({
      position: "absolute"
    }, r.style);
  }, [r.style]);
  return Dt.createElement("div", {
    style: E,
    className: r.className
  }, Dt.createElement("div", {
    ref: n,
    "aria-pressed": l,
    className: "mapboxgl-ctrl mapboxgl-ctrl-attrib ".concat(m ? "mapboxgl-compact" : "", " ").concat(l ? "mapboxgl-compact-show" : "")
  }, Dt.createElement("button", {
    type: "button",
    className: "mapboxgl-ctrl-attrib-button",
    title: r.toggleLabel,
    onClick: y
  }), Dt.createElement("div", {
    ref: i,
    className: "mapboxgl-ctrl-attrib-inner",
    role: "list"
  })));
}
_w.propTypes = yre;
_w.defaultProps = vre;
Dt.memo(_w);
function BI(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function wre(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? BI(Object(t), !0).forEach(function(n) {
      Br(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : BI(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
var Tre = Object.assign({}, wl, {
  className: vt.string,
  style: vt.object,
  container: vt.object,
  label: vt.string
}), Ere = Object.assign({}, tf, {
  className: "",
  container: null,
  label: "Toggle fullscreen"
});
function yw(r) {
  var e = rf(r), t = e.context, n = e.containerRef, i = Dt.useState(!1), s = gs(i, 2), o = s[0], l = s[1], u = Dt.useState(!1), m = gs(u, 2), y = m[0], E = m[1], P = Dt.useState(null), L = gs(P, 2), U = L[0], V = L[1];
  Dt.useEffect(function() {
    var ne = new cc.FullscreenControl();
    V(ne), E(ne._checkFullscreenSupport());
    var ae = function() {
      var Ge = !ne._fullscreen;
      ne._fullscreen = Ge, l(Ge);
    };
    return Wc.addEventListener(ne._fullscreenchange, ae), function() {
      Wc.removeEventListener(ne._fullscreenchange, ae);
    };
  }, []);
  var q = function() {
    U && (U._container = r.container || t.container, U._onClickFullscreen());
  }, j = Dt.useMemo(function() {
    return wre({
      position: "absolute"
    }, r.style);
  }, [r.style]);
  if (!y)
    return null;
  var K = r.className, Y = r.label, de = o ? "shrink" : "fullscreen";
  return Dt.createElement("div", {
    style: j,
    className: K
  }, Dt.createElement("div", {
    className: "mapboxgl-ctrl mapboxgl-ctrl-group",
    ref: n
  }, Dt.createElement("button", {
    key: de,
    className: "mapboxgl-ctrl-icon mapboxgl-ctrl-".concat(de),
    type: "button",
    title: Y,
    onClick: q
  }, Dt.createElement("span", {
    className: "mapboxgl-ctrl-icon",
    "aria-hidden": "true"
  }))));
}
yw.propTypes = Tre;
yw.defaultProps = Ere;
Dt.memo(yw);
var Td;
function Cre() {
  return Td !== void 0 ? Promise.resolve(Td) : window.navigator.permissions !== void 0 ? window.navigator.permissions.query({
    name: "geolocation"
  }).then(function(r) {
    return Td = r.state !== "denied", Td;
  }) : (Td = !!window.navigator.geolocation, Promise.resolve(Td));
}
function OI(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function Sre(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? OI(Object(t), !0).forEach(function(n) {
      Br(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : OI(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
var DI = function() {
}, Ire = Object.assign({}, wl, {
  className: vt.string,
  style: vt.object,
  label: vt.string,
  disabledLabel: vt.string,
  auto: vt.bool,
  positionOptions: vt.object,
  fitBoundsOptions: vt.object,
  trackUserLocation: vt.bool,
  showUserLocation: vt.bool,
  showAccuracyCircle: vt.bool,
  showUserHeading: vt.bool,
  onViewStateChange: vt.func,
  onViewportChange: vt.func,
  onGeolocate: vt.func
}), Pre = Object.assign({}, tf, {
  className: "",
  label: "Find My Location",
  disabledLabel: "Location Not Available",
  auto: !1,
  positionOptions: {
    enableHighAccuracy: !1,
    timeout: 6e3
  },
  fitBoundsOptions: {
    maxZoom: 15
  },
  trackUserLocation: !1,
  showUserLocation: !0,
  showUserHeading: !1,
  showAccuracyCircle: !0,
  onGeolocate: function() {
  }
});
function Mre(r) {
  var e = new cc.LngLat(r.coords.longitude, r.coords.latitude), t = r.coords.accuracy, n = e.toBounds(t);
  return [[n._ne.lng, n._ne.lat], [n._sw.lng, n._sw.lat]];
}
function Rre(r, e, t) {
  var n = new cc.GeolocateControl(e);
  n._container = Wc.createElement("div"), n._map = {
    on: function() {
    },
    _getUIString: function() {
      return "";
    }
  }, n._setupUI(!0), n._map = r.map, n._geolocateButton = t;
  var i = r.eventManager;
  return n.options.trackUserLocation && i && i.on("panstart", function() {
    n._watchState === "ACTIVE_LOCK" && (n._watchState = "BACKGROUND", t.classList.add("mapboxgl-ctrl-geolocate-background"), t.classList.remove("mapboxgl-ctrl-geolocate-active"));
  }), n.on("geolocate", e.onGeolocate), n;
}
function Bre(r, e) {
  var t = e.context, n = e.props, i = Mre(r), s = t.viewport.fitBounds(i, n.fitBoundsOptions), o = s.longitude, l = s.latitude, u = s.zoom, m = Object.assign({}, t.viewport, {
    longitude: o,
    latitude: l,
    zoom: u
  }), y = new up(m), E = Object.assign({}, y.getViewportProps(), Vc), P = n.onViewportChange || t.onViewportChange || DI, L = n.onViewStateChange || t.onViewStateChange || DI;
  L({
    viewState: E
  }), P(E);
}
function vw(r) {
  var e = rf(r), t = e.context, n = e.containerRef, i = Dt.useRef(null), s = Dt.useState(null), o = gs(s, 2), l = o[0], u = o[1], m = Dt.useState(!1), y = gs(m, 2), E = y[0], P = y[1];
  Dt.useEffect(function() {
    var Y;
    return t.map && Cre().then(function(de) {
      P(de), i.current && (Y = Rre(t, r, i.current), Y._updateCamera = function(ne) {
        return Bre(ne, e);
      }, u(Y));
    }), function() {
      Y && Y._clearWatch();
    };
  }, [t.map]);
  var L = Dt.useCallback(function() {
    l && (l.options = e.props, l.trigger());
  }, [l]);
  Dt.useEffect(function() {
    r.auto && L();
  }, [l, r.auto]), Dt.useEffect(function() {
    l && l._onZoom();
  }, [t.viewport.zoom]);
  var U = r.className, V = r.label, q = r.disabledLabel, j = r.trackUserLocation, K = Dt.useMemo(function() {
    return Sre({
      position: "absolute"
    }, r.style);
  }, [r.style]);
  return Dt.createElement("div", {
    style: K,
    className: U
  }, Dt.createElement("div", {
    key: "geolocate-control",
    className: "mapboxgl-ctrl mapboxgl-ctrl-group",
    ref: n
  }, Dt.createElement("button", {
    key: "geolocate",
    className: "mapboxgl-ctrl-icon mapboxgl-ctrl-geolocate",
    ref: i,
    disabled: !E,
    "aria-pressed": !j,
    type: "button",
    title: E ? V : q,
    "aria-label": E ? V : q,
    onClick: L
  }, Dt.createElement("span", {
    className: "mapboxgl-ctrl-icon",
    "aria-hidden": "true"
  }))));
}
vw.propTypes = Ire;
vw.defaultProps = Pre;
Dt.memo(vw);
function Ore(r, e) {
  for (var t = (r || "").split(".").map(Number), n = e.split(".").map(Number), i = 0; i < 3; i++) {
    var s = t[i] || 0, o = n[i] || 0;
    if (s < o)
      return -1;
    if (s > o)
      return 1;
  }
  return 0;
}
function LI(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function Dre(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? LI(Object(t), !0).forEach(function(n) {
      Br(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : LI(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
var kI = function() {
}, Lre = Object.assign({}, wl, {
  className: vt.string,
  style: vt.object,
  onViewStateChange: vt.func,
  onViewportChange: vt.func,
  showCompass: vt.bool,
  showZoom: vt.bool,
  zoomInLabel: vt.string,
  zoomOutLabel: vt.string,
  compassLabel: vt.string
}), kre = Object.assign({}, tf, {
  className: "",
  showCompass: !0,
  showZoom: !0,
  zoomInLabel: "Zoom In",
  zoomOutLabel: "Zoom Out",
  compassLabel: "Reset North"
}), Fre = 1, A2 = 2;
function Nre(r) {
  return Ore(r, "1.6.0") >= 0 ? A2 : Fre;
}
function l1(r, e, t) {
  var n = r.viewport, i = new up(Object.assign({}, n, t)), s = Object.assign({}, i.getViewportProps(), Vc), o = e.onViewportChange || r.onViewportChange || kI, l = e.onViewStateChange || r.onViewStateChange || kI;
  l({
    viewState: s
  }), o(s);
}
function c1(r, e, t, n) {
  return Dt.createElement("button", {
    key: r,
    className: "mapboxgl-ctrl-icon mapboxgl-ctrl-".concat(r),
    type: "button",
    title: e,
    onClick: t
  }, n || Dt.createElement("span", {
    className: "mapboxgl-ctrl-icon",
    "aria-hidden": "true"
  }));
}
function Ure(r) {
  var e = Dt.useMemo(function() {
    return r.map ? Nre(r.map.version) : A2;
  }, [r.map]), t = r.viewport.bearing, n = {
    transform: "rotate(".concat(-t, "deg)")
  };
  return e === A2 ? Dt.createElement("span", {
    className: "mapboxgl-ctrl-icon",
    "aria-hidden": "true",
    style: n
  }) : Dt.createElement("span", {
    className: "mapboxgl-ctrl-compass-arrow",
    style: n
  });
}
function bw(r) {
  var e = rf(r), t = e.context, n = e.containerRef, i = function() {
    l1(t, r, {
      zoom: t.viewport.zoom + 1
    });
  }, s = function() {
    l1(t, r, {
      zoom: t.viewport.zoom - 1
    });
  }, o = function() {
    l1(t, r, {
      bearing: 0,
      pitch: 0
    });
  }, l = r.className, u = r.showCompass, m = r.showZoom, y = r.zoomInLabel, E = r.zoomOutLabel, P = r.compassLabel, L = Dt.useMemo(function() {
    return Dre({
      position: "absolute"
    }, r.style);
  }, [r.style]);
  return Dt.createElement("div", {
    style: L,
    className: l
  }, Dt.createElement("div", {
    className: "mapboxgl-ctrl mapboxgl-ctrl-group",
    ref: n
  }, m && c1("zoom-in", y, i), m && c1("zoom-out", E, s), u && c1("compass", P, o, Ure(t))));
}
bw.propTypes = Lre;
bw.defaultProps = kre;
const zre = Dt.memo(bw);
function FI(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function Vre(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? FI(Object(t), !0).forEach(function(n) {
      Br(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : FI(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
var jre = Object.assign({}, wl, {
  className: vt.string,
  style: vt.object,
  maxWidth: vt.number,
  unit: vt.oneOf(["imperial", "metric", "nautical"])
}), Hre = Object.assign({}, tf, {
  className: "",
  maxWidth: 100,
  unit: "metric"
});
function xw(r) {
  var e = rf(r), t = e.context, n = e.containerRef, i = Dt.useState(null), s = gs(i, 2), o = s[0], l = s[1];
  Dt.useEffect(function() {
    if (t.map) {
      var m = new cc.ScaleControl();
      m._map = t.map, m._container = n.current, l(m);
    }
  }, [t.map]), o && (o.options = r, o._onMove && o._onMove());
  var u = Dt.useMemo(function() {
    return Vre({
      position: "absolute"
    }, r.style);
  }, [r.style]);
  return Dt.createElement("div", {
    style: u,
    className: r.className
  }, Dt.createElement("div", {
    ref: n,
    className: "mapboxgl-ctrl mapboxgl-ctrl-scale"
  }));
}
xw.propTypes = jre;
xw.defaultProps = Hre;
Dt.memo(xw);
Object.assign({}, wl, {
  redraw: vt.func.isRequired
});
Object.assign({}, wl, {
  redraw: vt.func.isRequired,
  style: vt.object
});
Object.assign({}, wl, {
  redraw: vt.func.isRequired,
  style: vt.object
});
cc && cc.setRTLTextPlugin;
const Gre = () => /* @__PURE__ */ Jl.jsx(Jl.Fragment, {}), NI = /* @__PURE__ */ X4("div", {
  target: "e1az0zs51"
})(({
  height: r
}) => ({
  position: "relative",
  height: r,
  width: "100%"
}), ""), Wre = /* @__PURE__ */ X4("div", {
  target: "e1az0zs50"
})(({
  theme: r
}) => ({
  position: "absolute",
  right: "2.625rem",
  top: r.spacing.md,
  zIndex: r.zIndices.priority,
  ".mapboxgl-ctrl.mapboxgl-ctrl-group": {
    // Ensures that the border-radius of the zoom buttons is visible
    overflow: "hidden",
    background: r.colors.bgColor
  },
  // Update zoom buttons based on the active theme
  "button:not(:disabled)": {
    background: r.colors.bgColor,
    width: r.iconSizes.twoXL,
    height: r.iconSizes.twoXL,
    // Add a separator between buttons
    "& + button": {
      borderTopColor: r.colors.borderColor
    },
    ".mapboxgl-ctrl-icon": {
      backgroundSize: r.iconSizes.twoXL,
      "&:hover": {
        backgroundColor: r.colors.darkenedBgMix25
      }
    },
    // On dark backgrounds, invert the color for the + and - symbols
    "& span": {
      filter: Z4(r) ? "" : "invert(100%)"
    }
  }
}), ""), $re = ({
  container: r,
  element: e,
  heightFallback: t = "auto",
  isFullScreen: n,
  shouldUseContainerWidth: i,
  widthFallback: s = "auto"
}) => {
  const o = Dt.useMemo(() => i || n ? "100%" : e.width || r.width || s, [r.width, e.width, n, i, s]), l = Dt.useMemo(() => n && r.height ? r.height : e.height || r.height || t, [n, e.height, r.height, t]);
  return {
    width: o,
    height: l
  };
}, UI = `uniform arcUniforms {
  bool greatCircle;
  bool useShortestPath;
  float numSegments;
  float widthScale;
  float widthMinPixels;
  float widthMaxPixels;
  highp int widthUnits;
} arc;
`, qre = {
  name: "arc",
  vs: UI,
  fs: UI,
  uniformTypes: {
    greatCircle: "f32",
    useShortestPath: "f32",
    numSegments: "f32",
    widthScale: "f32",
    widthMinPixels: "f32",
    widthMaxPixels: "f32",
    widthUnits: "i32"
  }
}, Xre = `#version 300 es
#define SHADER_NAME arc-layer-vertex-shader
in vec4 instanceSourceColors;
in vec4 instanceTargetColors;
in vec3 instanceSourcePositions;
in vec3 instanceSourcePositions64Low;
in vec3 instanceTargetPositions;
in vec3 instanceTargetPositions64Low;
in vec3 instancePickingColors;
in float instanceWidths;
in float instanceHeights;
in float instanceTilts;
out vec4 vColor;
out vec2 uv;
out float isValid;
float paraboloid(float distance, float sourceZ, float targetZ, float ratio) {
float deltaZ = targetZ - sourceZ;
float dh = distance * instanceHeights;
if (dh == 0.0) {
return sourceZ + deltaZ * ratio;
}
float unitZ = deltaZ / dh;
float p2 = unitZ * unitZ + 1.0;
float dir = step(deltaZ, 0.0);
float z0 = mix(sourceZ, targetZ, dir);
float r = mix(ratio, 1.0 - ratio, dir);
return sqrt(r * (p2 - r)) * dh + z0;
}
vec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {
vec2 dir_screenspace = normalize(line_clipspace * project.viewportSize);
dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);
return dir_screenspace * offset_direction * width / 2.0;
}
float getSegmentRatio(float index) {
return smoothstep(0.0, 1.0, index / (arc.numSegments - 1.0));
}
vec3 interpolateFlat(vec3 source, vec3 target, float segmentRatio) {
float distance = length(source.xy - target.xy);
float z = paraboloid(distance, source.z, target.z, segmentRatio);
float tiltAngle = radians(instanceTilts);
vec2 tiltDirection = normalize(target.xy - source.xy);
vec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * z * sin(tiltAngle);
return vec3(
mix(source.xy, target.xy, segmentRatio) + tilt,
z * cos(tiltAngle)
);
}
float getAngularDist (vec2 source, vec2 target) {
vec2 sourceRadians = radians(source);
vec2 targetRadians = radians(target);
vec2 sin_half_delta = sin((sourceRadians - targetRadians) / 2.0);
vec2 shd_sq = sin_half_delta * sin_half_delta;
float a = shd_sq.y + cos(sourceRadians.y) * cos(targetRadians.y) * shd_sq.x;
return 2.0 * asin(sqrt(a));
}
vec3 interpolateGreatCircle(vec3 source, vec3 target, vec3 source3D, vec3 target3D, float angularDist, float t) {
vec2 lngLat;
if(abs(angularDist - PI) < 0.001) {
lngLat = (1.0 - t) * source.xy + t * target.xy;
} else {
float a = sin((1.0 - t) * angularDist);
float b = sin(t * angularDist);
vec3 p = source3D.yxz * a + target3D.yxz * b;
lngLat = degrees(vec2(atan(p.y, -p.x), atan(p.z, length(p.xy))));
}
float z = paraboloid(angularDist * EARTH_RADIUS, source.z, target.z, t);
return vec3(lngLat, z);
}
void main(void) {
geometry.worldPosition = instanceSourcePositions;
geometry.worldPositionAlt = instanceTargetPositions;
float segmentIndex = float(gl_VertexID / 2);
float segmentSide = mod(float(gl_VertexID), 2.) == 0. ? -1. : 1.;
float segmentRatio = getSegmentRatio(segmentIndex);
float prevSegmentRatio = getSegmentRatio(max(0.0, segmentIndex - 1.0));
float nextSegmentRatio = getSegmentRatio(min(arc.numSegments - 1.0, segmentIndex + 1.0));
float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));
isValid = 1.0;
uv = vec2(segmentRatio, segmentSide);
geometry.uv = uv;
geometry.pickingColor = instancePickingColors;
vec4 curr;
vec4 next;
vec3 source;
vec3 target;
if ((arc.greatCircle || project.projectionMode == PROJECTION_MODE_GLOBE) && project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
source = project_globe_(vec3(instanceSourcePositions.xy, 0.0));
target = project_globe_(vec3(instanceTargetPositions.xy, 0.0));
float angularDist = getAngularDist(instanceSourcePositions.xy, instanceTargetPositions.xy);
vec3 prevPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, prevSegmentRatio);
vec3 currPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, segmentRatio);
vec3 nextPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, nextSegmentRatio);
if (abs(currPos.x - prevPos.x) > 180.0) {
indexDir = -1.0;
isValid = 0.0;
} else if (abs(currPos.x - nextPos.x) > 180.0) {
indexDir = 1.0;
isValid = 0.0;
}
nextPos = indexDir < 0.0 ? prevPos : nextPos;
nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;
if (isValid == 0.0) {
nextPos.x += nextPos.x > 0.0 ? -360.0 : 360.0;
float t = ((currPos.x > 0.0 ? 180.0 : -180.0) - currPos.x) / (nextPos.x - currPos.x);
currPos = mix(currPos, nextPos, t);
segmentRatio = mix(segmentRatio, nextSegmentRatio, t);
}
vec3 currPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, segmentRatio);
vec3 nextPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, nextSegmentRatio);
curr = project_position_to_clipspace(currPos, currPos64Low, vec3(0.0), geometry.position);
next = project_position_to_clipspace(nextPos, nextPos64Low, vec3(0.0));
} else {
vec3 source_world = instanceSourcePositions;
vec3 target_world = instanceTargetPositions;
if (arc.useShortestPath) {
source_world.x = mod(source_world.x + 180., 360.0) - 180.;
target_world.x = mod(target_world.x + 180., 360.0) - 180.;
float deltaLng = target_world.x - source_world.x;
if (deltaLng > 180.) target_world.x -= 360.;
if (deltaLng < -180.) source_world.x -= 360.;
}
source = project_position(source_world, instanceSourcePositions64Low);
target = project_position(target_world, instanceTargetPositions64Low);
float antiMeridianX = 0.0;
if (arc.useShortestPath) {
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
antiMeridianX = -(project.coordinateOrigin.x + 180.) / 360. * TILE_SIZE;
}
float thresholdRatio = (antiMeridianX - source.x) / (target.x - source.x);
if (prevSegmentRatio <= thresholdRatio && nextSegmentRatio > thresholdRatio) {
isValid = 0.0;
indexDir = sign(segmentRatio - thresholdRatio);
segmentRatio = thresholdRatio;
}
}
nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;
vec3 currPos = interpolateFlat(source, target, segmentRatio);
vec3 nextPos = interpolateFlat(source, target, nextSegmentRatio);
if (arc.useShortestPath) {
if (nextPos.x < antiMeridianX) {
currPos.x += TILE_SIZE;
nextPos.x += TILE_SIZE;
}
}
curr = project_common_position_to_clipspace(vec4(currPos, 1.0));
next = project_common_position_to_clipspace(vec4(nextPos, 1.0));
geometry.position = vec4(currPos, 1.0);
}
float widthPixels = clamp(
project_size_to_pixel(instanceWidths * arc.widthScale, arc.widthUnits),
arc.widthMinPixels, arc.widthMaxPixels
);
vec3 offset = vec3(
getExtrusionOffset((next.xy - curr.xy) * indexDir, segmentSide, widthPixels),
0.0);
DECKGL_FILTER_SIZE(offset, geometry);
DECKGL_FILTER_GL_POSITION(curr, geometry);
gl_Position = curr + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);
vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio);
vColor = vec4(color.rgb, color.a * layer.opacity);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, Zre = `#version 300 es
#define SHADER_NAME arc-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 uv;
in float isValid;
out vec4 fragColor;
void main(void) {
if (isValid == 0.0) {
discard;
}
fragColor = vColor;
geometry.uv = uv;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`, p_ = [0, 0, 0, 255], Yre = {
  getSourcePosition: { type: "accessor", value: (r) => r.sourcePosition },
  getTargetPosition: { type: "accessor", value: (r) => r.targetPosition },
  getSourceColor: { type: "accessor", value: p_ },
  getTargetColor: { type: "accessor", value: p_ },
  getWidth: { type: "accessor", value: 1 },
  getHeight: { type: "accessor", value: 1 },
  getTilt: { type: "accessor", value: 0 },
  greatCircle: !1,
  numSegments: { type: "number", value: 50, min: 1 },
  widthUnits: "pixels",
  widthScale: { type: "number", value: 1, min: 0 },
  widthMinPixels: { type: "number", value: 0, min: 0 },
  widthMaxPixels: { type: "number", value: Number.MAX_SAFE_INTEGER, min: 0 }
};
class x0 extends Is {
  getBounds() {
    return this.getAttributeManager()?.getBounds([
      "instanceSourcePositions",
      "instanceTargetPositions"
    ]);
  }
  getShaders() {
    return super.getShaders({ vs: Xre, fs: Zre, modules: [Ws, ga, qre] });
  }
  // This layer has its own wrapLongitude logic
  get wrapLongitude() {
    return !1;
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instanceSourcePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: !0,
        accessor: "getSourcePosition"
      },
      instanceTargetPositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: !0,
        accessor: "getTargetPosition"
      },
      instanceSourceColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: !0,
        accessor: "getSourceColor",
        defaultValue: p_
      },
      instanceTargetColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: !0,
        accessor: "getTargetColor",
        defaultValue: p_
      },
      instanceWidths: {
        size: 1,
        transition: !0,
        accessor: "getWidth",
        defaultValue: 1
      },
      instanceHeights: {
        size: 1,
        transition: !0,
        accessor: "getHeight",
        defaultValue: 1
      },
      instanceTilts: {
        size: 1,
        transition: !0,
        accessor: "getTilt",
        defaultValue: 0
      }
    });
  }
  updateState(e) {
    super.updateState(e), e.changeFlags.extensionsChanged && (this.state.model?.destroy(), this.state.model = this._getModel(), this.getAttributeManager().invalidateAll());
  }
  draw({ uniforms: e }) {
    const { widthUnits: t, widthScale: n, widthMinPixels: i, widthMaxPixels: s, greatCircle: o, wrapLongitude: l, numSegments: u } = this.props, m = {
      numSegments: u,
      widthUnits: ko[t],
      widthScale: n,
      widthMinPixels: i,
      widthMaxPixels: s,
      greatCircle: o,
      useShortestPath: l
    }, y = this.state.model;
    y.shaderInputs.setProps({ arc: m }), y.setVertexCount(u * 2), y.draw(this.context.renderPass);
  }
  _getModel() {
    return new Bi(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      topology: "triangle-strip",
      isInstanced: !0
    });
  }
}
x0.layerName = "ArcLayer";
x0.defaultProps = Yre;
const Kre = new Uint32Array([0, 2, 1, 0, 3, 2]), Qre = new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]);
function Jre(r, e) {
  if (!e)
    return ene(r);
  const t = Math.max(Math.abs(r[0][0] - r[3][0]), Math.abs(r[1][0] - r[2][0])), n = Math.max(Math.abs(r[1][1] - r[0][1]), Math.abs(r[2][1] - r[3][1])), i = Math.ceil(t / e) + 1, s = Math.ceil(n / e) + 1, o = (i - 1) * (s - 1) * 6, l = new Uint32Array(o), u = new Float32Array(i * s * 2), m = new Float64Array(i * s * 3);
  let y = 0, E = 0;
  for (let P = 0; P < i; P++) {
    const L = P / (i - 1);
    for (let U = 0; U < s; U++) {
      const V = U / (s - 1), q = tne(r, L, V);
      m[y * 3 + 0] = q[0], m[y * 3 + 1] = q[1], m[y * 3 + 2] = q[2] || 0, u[y * 2 + 0] = L, u[y * 2 + 1] = 1 - V, P > 0 && U > 0 && (l[E++] = y - s, l[E++] = y - s - 1, l[E++] = y - 1, l[E++] = y - s, l[E++] = y - 1, l[E++] = y), y++;
    }
  }
  return {
    vertexCount: o,
    positions: m,
    indices: l,
    texCoords: u
  };
}
function ene(r) {
  const e = new Float64Array(12);
  for (let t = 0; t < r.length; t++)
    e[t * 3 + 0] = r[t][0], e[t * 3 + 1] = r[t][1], e[t * 3 + 2] = r[t][2] || 0;
  return {
    vertexCount: 6,
    positions: e,
    indices: Kre,
    texCoords: Qre
  };
}
function tne(r, e, t) {
  return ml(ml(r[0], r[1], t), ml(r[3], r[2], t), e);
}
const zI = `uniform bitmapUniforms {
  vec4 bounds;
  float coordinateConversion;
  float desaturate;
  vec3 tintColor;
  vec4 transparentColor;
} bitmap;
`, rne = {
  name: "bitmap",
  vs: zI,
  fs: zI,
  uniformTypes: {
    bounds: "vec4<f32>",
    coordinateConversion: "f32",
    desaturate: "f32",
    tintColor: "vec3<f32>",
    transparentColor: "vec4<f32>"
  }
}, nne = `#version 300 es
#define SHADER_NAME bitmap-layer-vertex-shader

in vec2 texCoords;
in vec3 positions;
in vec3 positions64Low;

out vec2 vTexCoord;
out vec2 vTexPos;

const vec3 pickingColor = vec3(1.0, 0.0, 0.0);

void main(void) {
  geometry.worldPosition = positions;
  geometry.uv = texCoords;
  geometry.pickingColor = pickingColor;

  gl_Position = project_position_to_clipspace(positions, positions64Low, vec3(0.0), geometry.position);
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  vTexCoord = texCoords;

  if (bitmap.coordinateConversion < -0.5) {
    vTexPos = geometry.position.xy + project.commonOrigin.xy;
  } else if (bitmap.coordinateConversion > 0.5) {
    vTexPos = geometry.worldPosition.xy;
  }

  vec4 color = vec4(0.0);
  DECKGL_FILTER_COLOR(color, geometry);
}
`, ine = `
vec3 packUVsIntoRGB(vec2 uv) {
  // Extract the top 8 bits. We want values to be truncated down so we can add a fraction
  vec2 uv8bit = floor(uv * 256.);

  // Calculate the normalized remainders of u and v parts that do not fit into 8 bits
  // Scale and clamp to 0-1 range
  vec2 uvFraction = fract(uv * 256.);
  vec2 uvFraction4bit = floor(uvFraction * 16.);

  // Remainder can be encoded in blue channel, encode as 4 bits for pixel coordinates
  float fractions = uvFraction4bit.x + uvFraction4bit.y * 16.;

  return vec3(uv8bit, fractions) / 255.;
}
`, sne = `#version 300 es
#define SHADER_NAME bitmap-layer-fragment-shader

#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D bitmapTexture;

in vec2 vTexCoord;
in vec2 vTexPos;

out vec4 fragColor;

/* projection utils */
const float TILE_SIZE = 512.0;
const float PI = 3.1415926536;
const float WORLD_SCALE = TILE_SIZE / PI / 2.0;

// from degrees to Web Mercator
vec2 lnglat_to_mercator(vec2 lnglat) {
  float x = lnglat.x;
  float y = clamp(lnglat.y, -89.9, 89.9);
  return vec2(
    radians(x) + PI,
    PI + log(tan(PI * 0.25 + radians(y) * 0.5))
  ) * WORLD_SCALE;
}

// from Web Mercator to degrees
vec2 mercator_to_lnglat(vec2 xy) {
  xy /= WORLD_SCALE;
  return degrees(vec2(
    xy.x - PI,
    atan(exp(xy.y - PI)) * 2.0 - PI * 0.5
  ));
}
/* End projection utils */

// apply desaturation
vec3 color_desaturate(vec3 color) {
  float luminance = (color.r + color.g + color.b) * 0.333333333;
  return mix(color, vec3(luminance), bitmap.desaturate);
}

// apply tint
vec3 color_tint(vec3 color) {
  return color * bitmap.tintColor;
}

// blend with background color
vec4 apply_opacity(vec3 color, float alpha) {
  if (bitmap.transparentColor.a == 0.0) {
    return vec4(color, alpha);
  }
  float blendedAlpha = alpha + bitmap.transparentColor.a * (1.0 - alpha);
  float highLightRatio = alpha / blendedAlpha;
  vec3 blendedRGB = mix(bitmap.transparentColor.rgb, color, highLightRatio);
  return vec4(blendedRGB, blendedAlpha);
}

vec2 getUV(vec2 pos) {
  return vec2(
    (pos.x - bitmap.bounds[0]) / (bitmap.bounds[2] - bitmap.bounds[0]),
    (pos.y - bitmap.bounds[3]) / (bitmap.bounds[1] - bitmap.bounds[3])
  );
}

${ine}

void main(void) {
  vec2 uv = vTexCoord;
  if (bitmap.coordinateConversion < -0.5) {
    vec2 lnglat = mercator_to_lnglat(vTexPos);
    uv = getUV(lnglat);
  } else if (bitmap.coordinateConversion > 0.5) {
    vec2 commonPos = lnglat_to_mercator(vTexPos);
    uv = getUV(commonPos);
  }
  vec4 bitmapColor = texture(bitmapTexture, uv);

  fragColor = apply_opacity(color_tint(color_desaturate(bitmapColor.rgb)), bitmapColor.a * layer.opacity);

  geometry.uv = uv;
  DECKGL_FILTER_COLOR(fragColor, geometry);

  if (bool(picking.isActive) && !bool(picking.isAttribute)) {
    // Since instance information is not used, we can use picking color for pixel index
    fragColor.rgb = packUVsIntoRGB(uv);
  }
}
`, one = {
  image: { type: "image", value: null, async: !0 },
  bounds: { type: "array", value: [1, 0, 0, 1], compare: !0 },
  _imageCoordinateSystem: rn.DEFAULT,
  desaturate: { type: "number", min: 0, max: 1, value: 0 },
  // More context: because of the blending mode we're using for ground imagery,
  // alpha is not effective when blending the bitmap layers with the base map.
  // Instead we need to manually dim/blend rgb values with a background color.
  transparentColor: { type: "color", value: [0, 0, 0, 0] },
  tintColor: { type: "color", value: [255, 255, 255] },
  textureParameters: { type: "object", ignore: !0, value: null }
};
class K_ extends Is {
  getShaders() {
    return super.getShaders({ vs: nne, fs: sne, modules: [Ws, ga, rne] });
  }
  initializeState() {
    const e = this.getAttributeManager();
    e.remove(["instancePickingColors"]);
    const t = !0;
    e.add({
      indices: {
        size: 1,
        isIndexed: !0,
        update: (n) => n.value = this.state.mesh.indices,
        noAlloc: t
      },
      positions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        update: (n) => n.value = this.state.mesh.positions,
        noAlloc: t
      },
      texCoords: {
        size: 2,
        update: (n) => n.value = this.state.mesh.texCoords,
        noAlloc: t
      }
    });
  }
  updateState({ props: e, oldProps: t, changeFlags: n }) {
    const i = this.getAttributeManager();
    if (n.extensionsChanged && (this.state.model?.destroy(), this.state.model = this._getModel(), i.invalidateAll()), e.bounds !== t.bounds) {
      const s = this.state.mesh, o = this._createMesh();
      this.state.model.setVertexCount(o.vertexCount);
      for (const l in o)
        s && s[l] !== o[l] && i.invalidate(l);
      this.setState({ mesh: o, ...this._getCoordinateUniforms() });
    } else e._imageCoordinateSystem !== t._imageCoordinateSystem && this.setState(this._getCoordinateUniforms());
  }
  getPickingInfo(e) {
    const { image: t } = this.props, n = e.info;
    if (!n.color || !t)
      return n.bitmap = null, n;
    const { width: i, height: s } = t;
    n.index = 0;
    const o = ane(n.color);
    return n.bitmap = {
      size: { width: i, height: s },
      uv: o,
      pixel: [Math.floor(o[0] * i), Math.floor(o[1] * s)]
    }, n;
  }
  // Override base Layer multi-depth picking logic
  disablePickingIndex() {
    this.setState({ disablePicking: !0 });
  }
  restorePickingColors() {
    this.setState({ disablePicking: !1 });
  }
  _updateAutoHighlight(e) {
    super._updateAutoHighlight({
      ...e,
      color: this.encodePickingColor(0)
    });
  }
  _createMesh() {
    const { bounds: e } = this.props;
    let t = e;
    return VI(e) && (t = [
      [e[0], e[1]],
      [e[0], e[3]],
      [e[2], e[3]],
      [e[2], e[1]]
    ]), Jre(t, this.context.viewport.resolution);
  }
  _getModel() {
    return new Bi(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      topology: "triangle-list",
      isInstanced: !1
    });
  }
  draw(e) {
    const { shaderModuleProps: t } = e, { model: n, coordinateConversion: i, bounds: s, disablePicking: o } = this.state, { image: l, desaturate: u, transparentColor: m, tintColor: y } = this.props;
    if (!(t.picking.isActive && o) && l && n) {
      const E = {
        bitmapTexture: l,
        bounds: s,
        coordinateConversion: i,
        desaturate: u,
        tintColor: y.slice(0, 3).map((P) => P / 255),
        transparentColor: m.map((P) => P / 255)
      };
      n.shaderInputs.setProps({ bitmap: E }), n.draw(this.context.renderPass);
    }
  }
  _getCoordinateUniforms() {
    const { LNGLAT: e, CARTESIAN: t, DEFAULT: n } = rn;
    let { _imageCoordinateSystem: i } = this.props;
    if (i !== n) {
      const { bounds: s } = this.props;
      if (!VI(s))
        throw new Error("_imageCoordinateSystem only supports rectangular bounds");
      const o = this.context.viewport.resolution ? e : t;
      if (i = i === e ? e : t, i === e && o === t)
        return { coordinateConversion: -1, bounds: s };
      if (i === t && o === e) {
        const l = Jc([s[0], s[1]]), u = Jc([s[2], s[3]]);
        return {
          coordinateConversion: 1,
          bounds: [l[0], l[1], u[0], u[1]]
        };
      }
    }
    return {
      coordinateConversion: 0,
      bounds: [0, 0, 0, 0]
    };
  }
}
K_.layerName = "BitmapLayer";
K_.defaultProps = one;
function ane(r) {
  const [e, t, n] = r, i = (n & 240) / 256, s = (n & 15) / 16;
  return [(e + s) / 256, (t + i) / 256];
}
function VI(r) {
  return Number.isFinite(r[0]);
}
const jI = `uniform iconUniforms {
  float sizeScale;
  vec2 iconsTextureDim;
  float sizeBasis;
  float sizeMinPixels;
  float sizeMaxPixels;
  bool billboard;
  highp int sizeUnits;
  float alphaCutoff;
} icon;
`, lne = {
  name: "icon",
  vs: jI,
  fs: jI,
  uniformTypes: {
    sizeScale: "f32",
    iconsTextureDim: "vec2<f32>",
    sizeBasis: "f32",
    sizeMinPixels: "f32",
    sizeMaxPixels: "f32",
    billboard: "f32",
    sizeUnits: "i32",
    alphaCutoff: "f32"
  }
}, cne = `#version 300 es
#define SHADER_NAME icon-layer-vertex-shader
in vec2 positions;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in float instanceSizes;
in float instanceAngles;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec4 instanceIconFrames;
in float instanceColorModes;
in vec2 instanceOffsets;
in vec2 instancePixelOffset;
out float vColorMode;
out vec4 vColor;
out vec2 vTextureCoords;
out vec2 uv;
vec2 rotate_by_angle(vec2 vertex, float angle) {
float angle_radian = angle * PI / 180.0;
float cos_angle = cos(angle_radian);
float sin_angle = sin(angle_radian);
mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);
return rotationMatrix * vertex;
}
void main(void) {
geometry.worldPosition = instancePositions;
geometry.uv = positions;
geometry.pickingColor = instancePickingColors;
uv = positions;
vec2 iconSize = instanceIconFrames.zw;
float sizePixels = clamp(
project_size_to_pixel(instanceSizes * icon.sizeScale, icon.sizeUnits),
icon.sizeMinPixels, icon.sizeMaxPixels
);
float iconConstraint = icon.sizeBasis == 0.0 ? iconSize.x : iconSize.y;
float instanceScale = iconConstraint == 0.0 ? 0.0 : sizePixels / iconConstraint;
vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;
pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;
pixelOffset += instancePixelOffset;
pixelOffset.y *= -1.0;
if (icon.billboard)  {
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vec3 offset = vec3(pixelOffset, 0.0);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
} else {
vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);
DECKGL_FILTER_SIZE(offset_common, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
vTextureCoords = mix(
instanceIconFrames.xy,
instanceIconFrames.xy + iconSize,
(positions.xy + 1.0) / 2.0
) / icon.iconsTextureDim;
vColor = instanceColors;
DECKGL_FILTER_COLOR(vColor, geometry);
vColorMode = instanceColorModes;
}
`, une = `#version 300 es
#define SHADER_NAME icon-layer-fragment-shader
precision highp float;
uniform sampler2D iconsTexture;
in float vColorMode;
in vec4 vColor;
in vec2 vTextureCoords;
in vec2 uv;
out vec4 fragColor;
void main(void) {
geometry.uv = uv;
vec4 texColor = texture(iconsTexture, vTextureCoords);
vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);
float a = texColor.a * layer.opacity * vColor.a;
if (a < icon.alphaCutoff) {
discard;
}
fragColor = vec4(color, a);
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`, fne = 1024, hne = 4, HI = () => {
}, GI = {
  minFilter: "linear",
  mipmapFilter: "linear",
  // LINEAR is the default value but explicitly set it here
  magFilter: "linear",
  // minimize texture boundary artifacts
  addressModeU: "clamp-to-edge",
  addressModeV: "clamp-to-edge"
}, dne = {
  x: 0,
  y: 0,
  width: 0,
  height: 0
};
function pne(r) {
  return Math.pow(2, Math.ceil(Math.log2(r)));
}
function Ane(r, e, t, n) {
  const i = Math.min(t / e.width, n / e.height), s = Math.floor(e.width * i), o = Math.floor(e.height * i);
  return i === 1 ? { image: e, width: s, height: o } : (r.canvas.height = o, r.canvas.width = s, r.clearRect(0, 0, s, o), r.drawImage(e, 0, 0, e.width, e.height, 0, 0, s, o), { image: r.canvas, width: s, height: o });
}
function h0(r) {
  return r && (r.id || r.url);
}
function gne(r, e, t, n) {
  const { width: i, height: s, device: o } = r, l = o.createTexture({
    format: "rgba8unorm",
    width: e,
    height: t,
    sampler: n,
    mipLevels: o.getMipLevelCount(e, t)
  }), u = o.createCommandEncoder();
  return u.copyTextureToTexture({
    sourceTexture: r,
    destinationTexture: l,
    width: i,
    height: s
  }), u.finish(), l.generateMipmapsWebGL(), r.destroy(), l;
}
function WI(r, e, t) {
  for (let n = 0; n < e.length; n++) {
    const { icon: i, xOffset: s } = e[n], o = h0(i);
    r[o] = {
      ...i,
      x: s,
      y: t
    };
  }
}
function mne({ icons: r, buffer: e, mapping: t = {}, xOffset: n = 0, yOffset: i = 0, rowHeight: s = 0, canvasWidth: o }) {
  let l = [];
  for (let u = 0; u < r.length; u++) {
    const m = r[u], y = h0(m);
    if (!t[y]) {
      const { height: E, width: P } = m;
      n + P + e > o && (WI(t, l, i), n = 0, i = s + i + e, s = 0, l = []), l.push({
        icon: m,
        xOffset: n
      }), n = n + P + e, s = Math.max(s, E);
    }
  }
  return l.length > 0 && WI(t, l, i), {
    mapping: t,
    rowHeight: s,
    xOffset: n,
    yOffset: i,
    canvasWidth: o,
    canvasHeight: pne(s + i + e)
  };
}
function _ne(r, e, t) {
  if (!r || !e)
    return null;
  t = t || {};
  const n = {}, { iterable: i, objectInfo: s } = hc(r);
  for (const o of i) {
    s.index++;
    const l = e(o, s), u = h0(l);
    if (!l)
      throw new Error("Icon is missing.");
    if (!l.url)
      throw new Error("Icon url is missing.");
    !n[u] && (!t[u] || l.url !== t[u].url) && (n[u] = { ...l, source: o, sourceIndex: s.index });
  }
  return n;
}
class yne {
  constructor(e, { onUpdate: t = HI, onError: n = HI }) {
    this._loadOptions = null, this._texture = null, this._externalTexture = null, this._mapping = {}, this._samplerParameters = null, this._pendingCount = 0, this._autoPacking = !1, this._xOffset = 0, this._yOffset = 0, this._rowHeight = 0, this._buffer = hne, this._canvasWidth = fne, this._canvasHeight = 0, this._canvas = null, this.device = e, this.onUpdate = t, this.onError = n;
  }
  finalize() {
    this._texture?.delete();
  }
  getTexture() {
    return this._texture || this._externalTexture;
  }
  getIconMapping(e) {
    const t = this._autoPacking ? h0(e) : e;
    return this._mapping[t] || dne;
  }
  setProps({ loadOptions: e, autoPacking: t, iconAtlas: n, iconMapping: i, textureParameters: s }) {
    e && (this._loadOptions = e), t !== void 0 && (this._autoPacking = t), i && (this._mapping = i), n && (this._texture?.delete(), this._texture = null, this._externalTexture = n), s && (this._samplerParameters = s);
  }
  get isLoaded() {
    return this._pendingCount === 0;
  }
  packIcons(e, t) {
    if (!this._autoPacking || typeof document > "u")
      return;
    const n = Object.values(_ne(e, t, this._mapping) || {});
    if (n.length > 0) {
      const { mapping: i, xOffset: s, yOffset: o, rowHeight: l, canvasHeight: u } = mne({
        icons: n,
        buffer: this._buffer,
        canvasWidth: this._canvasWidth,
        mapping: this._mapping,
        rowHeight: this._rowHeight,
        xOffset: this._xOffset,
        yOffset: this._yOffset
      });
      this._rowHeight = l, this._mapping = i, this._xOffset = s, this._yOffset = o, this._canvasHeight = u, this._texture || (this._texture = this.device.createTexture({
        format: "rgba8unorm",
        data: null,
        width: this._canvasWidth,
        height: this._canvasHeight,
        sampler: this._samplerParameters || GI,
        mipLevels: this.device.getMipLevelCount(this._canvasWidth, this._canvasHeight)
      })), this._texture.height !== this._canvasHeight && (this._texture = gne(this._texture, this._canvasWidth, this._canvasHeight, this._samplerParameters || GI)), this.onUpdate(), this._canvas = this._canvas || document.createElement("canvas"), this._loadIcons(n), this._texture?.generateMipmapsWebGL();
    }
  }
  _loadIcons(e) {
    const t = this._canvas.getContext("2d", {
      willReadFrequently: !0
    });
    for (const n of e)
      this._pendingCount++, Kc(n.url, this._loadOptions).then((i) => {
        const s = h0(n), o = this._mapping[s], { x: l, y: u, width: m, height: y } = o, { image: E, width: P, height: L } = Ane(t, i, m, y);
        this._texture?.copyExternalImage({
          image: E,
          x: l + (m - P) / 2,
          y: u + (y - L) / 2,
          width: P,
          height: L
        }), o.width = P, o.height = L, this._texture?.generateMipmapsWebGL(), this.onUpdate();
      }).catch((i) => {
        this.onError({
          url: n.url,
          source: n.source,
          sourceIndex: n.sourceIndex,
          loadOptions: this._loadOptions,
          error: i
        });
      }).finally(() => {
        this._pendingCount--;
      });
  }
}
const ID = [0, 0, 0, 255], vne = {
  iconAtlas: { type: "image", value: null, async: !0 },
  iconMapping: { type: "object", value: {}, async: !0 },
  sizeScale: { type: "number", value: 1, min: 0 },
  billboard: !0,
  sizeUnits: "pixels",
  sizeBasis: "height",
  sizeMinPixels: { type: "number", min: 0, value: 0 },
  //  min point radius in pixels
  sizeMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
  // max point radius in pixels
  alphaCutoff: { type: "number", value: 0.05, min: 0, max: 1 },
  getPosition: { type: "accessor", value: (r) => r.position },
  getIcon: { type: "accessor", value: (r) => r.icon },
  getColor: { type: "accessor", value: ID },
  getSize: { type: "accessor", value: 1 },
  getAngle: { type: "accessor", value: 0 },
  getPixelOffset: { type: "accessor", value: [0, 0] },
  onIconError: { type: "function", value: null, optional: !0 },
  textureParameters: { type: "object", ignore: !0, value: null }
};
class Fp extends Is {
  getShaders() {
    return super.getShaders({ vs: cne, fs: une, modules: [Ws, ga, lne] });
  }
  initializeState() {
    this.state = {
      iconManager: new yne(this.context.device, {
        onUpdate: this._onUpdate.bind(this),
        onError: this._onError.bind(this)
      })
    }, this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: !0,
        accessor: "getPosition"
      },
      instanceSizes: {
        size: 1,
        transition: !0,
        accessor: "getSize",
        defaultValue: 1
      },
      instanceOffsets: {
        size: 2,
        accessor: "getIcon",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        transform: this.getInstanceOffset
      },
      instanceIconFrames: {
        size: 4,
        accessor: "getIcon",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        transform: this.getInstanceIconFrame
      },
      instanceColorModes: {
        size: 1,
        type: "uint8",
        accessor: "getIcon",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        transform: this.getInstanceColorMode
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: !0,
        accessor: "getColor",
        defaultValue: ID
      },
      instanceAngles: {
        size: 1,
        transition: !0,
        accessor: "getAngle"
      },
      instancePixelOffset: {
        size: 2,
        transition: !0,
        accessor: "getPixelOffset"
      }
    });
  }
  /* eslint-disable max-statements, complexity */
  updateState(e) {
    super.updateState(e);
    const { props: t, oldProps: n, changeFlags: i } = e, s = this.getAttributeManager(), { iconAtlas: o, iconMapping: l, data: u, getIcon: m, textureParameters: y } = t, { iconManager: E } = this.state;
    if (typeof o == "string")
      return;
    const P = o || this.internalState.isAsyncPropLoading("iconAtlas");
    E.setProps({
      loadOptions: t.loadOptions,
      autoPacking: !P,
      iconAtlas: o,
      iconMapping: P ? l : null,
      textureParameters: y
    }), P ? n.iconMapping !== t.iconMapping && s.invalidate("getIcon") : (i.dataChanged || i.updateTriggersChanged && (i.updateTriggersChanged.all || i.updateTriggersChanged.getIcon)) && E.packIcons(u, m), i.extensionsChanged && (this.state.model?.destroy(), this.state.model = this._getModel(), s.invalidateAll());
  }
  /* eslint-enable max-statements, complexity */
  get isLoaded() {
    return super.isLoaded && this.state.iconManager.isLoaded;
  }
  finalizeState(e) {
    super.finalizeState(e), this.state.iconManager.finalize();
  }
  draw({ uniforms: e }) {
    const { sizeScale: t, sizeBasis: n, sizeMinPixels: i, sizeMaxPixels: s, sizeUnits: o, billboard: l, alphaCutoff: u } = this.props, { iconManager: m } = this.state, y = m.getTexture();
    if (y) {
      const E = this.state.model, P = {
        iconsTexture: y,
        iconsTextureDim: [y.width, y.height],
        sizeUnits: ko[o],
        sizeScale: t,
        sizeBasis: n === "height" ? 1 : 0,
        sizeMinPixels: i,
        sizeMaxPixels: s,
        billboard: l,
        alphaCutoff: u
      };
      E.shaderInputs.setProps({ icon: P }), E.draw(this.context.renderPass);
    }
  }
  _getModel() {
    const e = [-1, -1, 1, -1, -1, 1, 1, 1];
    return new Bi(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new no({
        topology: "triangle-strip",
        attributes: {
          // The size must be explicitly passed here otherwise luma.gl
          // will default to assuming that positions are 3D (x,y,z)
          positions: {
            size: 2,
            value: new Float32Array(e)
          }
        }
      }),
      isInstanced: !0
    });
  }
  _onUpdate() {
    this.setNeedsRedraw();
  }
  _onError(e) {
    const t = this.getCurrentLayer()?.props.onIconError;
    t ? t(e) : Jr.error(e.error.message)();
  }
  getInstanceOffset(e) {
    const { width: t, height: n, anchorX: i = t / 2, anchorY: s = n / 2 } = this.state.iconManager.getIconMapping(e);
    return [t / 2 - i, n / 2 - s];
  }
  getInstanceColorMode(e) {
    return this.state.iconManager.getIconMapping(e).mask ? 1 : 0;
  }
  getInstanceIconFrame(e) {
    const { x: t, y: n, width: i, height: s } = this.state.iconManager.getIconMapping(e);
    return [t, n, i, s];
  }
}
Fp.defaultProps = vne;
Fp.layerName = "IconLayer";
const bne = (
  /* wgsl */
  `struct LineUniforms {
  widthScale: f32,
  widthMinPixels: f32,
  widthMaxPixels: f32,
  useShortestPath: f32,
  widthUnits: i32,
};

@group(0) @binding(1)
var<uniform> line: LineUniforms;
`
), $I = (
  /* glsl */
  `uniform lineUniforms {
  float widthScale;
  float widthMinPixels;
  float widthMaxPixels;
  float useShortestPath;
  highp int widthUnits;
} line;
`
), xne = {
  name: "line",
  source: bne,
  vs: $I,
  fs: $I,
  uniformTypes: {
    widthScale: "f32",
    widthMinPixels: "f32",
    widthMaxPixels: "f32",
    useShortestPath: "f32",
    widthUnits: "i32"
  }
}, wne = (
  /* wgsl */
  `// ---------- Helper Structures & Functions ----------

// Placeholder filter functions.
fn deckgl_filter_size(offset: vec3<f32>, geometry: Geometry) -> vec3<f32> {
  return offset;
}
fn deckgl_filter_gl_position(p: vec4<f32>, geometry: Geometry) -> vec4<f32> {
  return p;
}
fn deckgl_filter_color(color: vec4<f32>, geometry: Geometry) -> vec4<f32> {
  return color;
}

// Compute an extrusion offset given a line direction (in clipspace),
// an offset direction (-1 or 1), and a width in pixels.
// Assumes a uniform "project" with a viewportSize field is available.
fn getExtrusionOffset(line_clipspace: vec2<f32>, offset_direction: f32, width: f32) -> vec2<f32> {
  // project.viewportSize should be provided as a uniform (not shown here)
  let dir_screenspace = normalize(line_clipspace * project.viewportSize);
  // Rotate by 90: (x,y) becomes (-y,x)
  let rotated = vec2<f32>(-dir_screenspace.y, dir_screenspace.x);
  return rotated * offset_direction * width / 2.0;
}

// Splits the line between two points at a given x coordinate.
// Interpolates the y and z components.
fn splitLine(a: vec3<f32>, b: vec3<f32>, x: f32) -> vec3<f32> {
  let t: f32 = (x - a.x) / (b.x - a.x);
  return vec3<f32>(x, a.yz + t * (b.yz - a.yz));
}

// ---------- Uniforms & Global Structures ----------

// Uniforms for line, color, and project are assumed to be defined elsewhere.
// For example:
//
// @group(0) @binding(0)
// var<uniform> line: LineUniform;
//
// struct ColorUniform {
//   opacity: f32,
// };
// @group(0) @binding(1)
// var<uniform> color: ColorUniform;
//
// struct ProjectUniform {
//   viewportSize: vec2<f32>,
// };
// @group(0) @binding(2)
// var<uniform> project: ProjectUniform;



// ---------- Vertex Output Structure ----------

struct Varyings {
  @builtin(position) gl_Position: vec4<f32>,
  @location(0) vColor: vec4<f32>,
  @location(1) uv: vec2<f32>,
};

// ---------- Vertex Shader Entry Point ----------

@vertex
fn vertexMain(
  @location(0) positions: vec3<f32>,
  @location(1) instanceSourcePositions: vec3<f32>,
  @location(2) instanceTargetPositions: vec3<f32>,
  @location(3) instanceSourcePositions64Low: vec3<f32>,
  @location(4) instanceTargetPositions64Low: vec3<f32>,
  @location(5) instanceColors: vec4<f32>,
  @location(6) instancePickingColors: vec3<f32>,
  @location(7) instanceWidths: f32
) -> Varyings {
  var geometry: Geometry;
  geometry.worldPosition = instanceSourcePositions;
  geometry.worldPositionAlt = instanceTargetPositions;

  var source_world: vec3<f32> = instanceSourcePositions;
  var target_world: vec3<f32> = instanceTargetPositions;
  var source_world_64low: vec3<f32> = instanceSourcePositions64Low;
  var target_world_64low: vec3<f32> = instanceTargetPositions64Low;

  // Apply shortest-path adjustments if needed.
  if (line.useShortestPath > 0.5 || line.useShortestPath < -0.5) {
    source_world.x = (source_world.x + 180.0 % 360.0) - 180.0;
    target_world.x = (target_world.x + 180.0 % 360.0) - 180.0;
    let deltaLng: f32 = target_world.x - source_world.x;

    if (deltaLng * line.useShortestPath > 180.0) {
      source_world.x = source_world.x + 360.0 * line.useShortestPath;
      source_world = splitLine(source_world, target_world, 180.0 * line.useShortestPath);
      source_world_64low = vec3<f32>(0.0, 0.0, 0.0);
    } else if (deltaLng * line.useShortestPath < -180.0) {
      target_world.x = target_world.x + 360.0 * line.useShortestPath;
      target_world = splitLine(source_world, target_world, 180.0 * line.useShortestPath);
      target_world_64low = vec3<f32>(0.0, 0.0, 0.0);
    } else if (line.useShortestPath < 0.0) {
      var abortOut: Varyings;
      abortOut.gl_Position = vec4<f32>(0.0);
      abortOut.vColor = vec4<f32>(0.0);
      abortOut.uv = vec2<f32>(0.0);
      return abortOut;
    }
  }

  // Project Pos and target positions to clip space.
  let sourceResult = project_position_to_clipspace_and_commonspace(source_world, source_world_64low, vec3<f32>(0.0));
  let targetResult = project_position_to_clipspace_and_commonspace(target_world, target_world_64low, vec3<f32>(0.0));
  let sourcePos: vec4<f32> = sourceResult.clipPosition;
  let targetPos: vec4<f32> = targetResult.clipPosition;
  let source_commonspace: vec4<f32> = sourceResult.commonPosition;
  let target_commonspace: vec4<f32> = targetResult.commonPosition;

  // Interpolate along the line segment.
  let segmentIndex: f32 = positions.x;
  let p: vec4<f32> = sourcePos + segmentIndex * (targetPos - sourcePos);
  geometry.position = source_commonspace + segmentIndex * (target_commonspace - source_commonspace);
  let uv: vec2<f32> = positions.xy;
  geometry.uv = uv;
  geometry.pickingColor = instancePickingColors;

  // Determine width in pixels.
  let widthPixels: f32 = clamp(
    project_unit_size_to_pixel(instanceWidths * line.widthScale, line.widthUnits),
    line.widthMinPixels, line.widthMaxPixels
  );

  // Compute extrusion offset.
  let extrusion: vec2<f32> = getExtrusionOffset(targetPos.xy - sourcePos.xy, positions.y, widthPixels);
  let offset: vec3<f32> = vec3<f32>(extrusion, 0.0);

  // Apply deck.gl filter functions.
  let filteredOffset = deckgl_filter_size(offset, geometry);
  let filteredP = deckgl_filter_gl_position(p, geometry);

  let clipOffset: vec2<f32> = project_pixel_size_to_clipspace(filteredOffset.xy);
  let finalPosition: vec4<f32> = filteredP + vec4<f32>(clipOffset, 0.0, 0.0);

  // Compute color.
  var vColor: vec4<f32> = vec4<f32>(instanceColors.rgb, instanceColors.a * color.opacity);
  // vColor = deckgl_filter_color(vColor, geometry);

  var output: Varyings;
  output.gl_Position = finalPosition;
  output.vColor = vColor;
  output.uv = uv;
  return output;
}

@fragment
fn fragmentMain(
  @location(0) vColor: vec4<f32>,
  @location(1) uv: vec2<f32>
) -> @location(0) vec4<f32> {
  // Create and initialize geometry with the provided uv.
  var geometry: Geometry;
  geometry.uv = uv;

  // Start with the input color.
  var fragColor: vec4<f32> = vColor;

  // Apply the deck.gl filter to the color.
  fragColor = deckgl_filter_color(fragColor, geometry);

  // Apply premultiplied alpha as required by transparent canvas
  fragColor = deckgl_premultiplied_alpha(fragColor);

  return fragColor;
}
`
), Tne = `#version 300 es
#define SHADER_NAME line-layer-vertex-shader
in vec3 positions;
in vec3 instanceSourcePositions;
in vec3 instanceTargetPositions;
in vec3 instanceSourcePositions64Low;
in vec3 instanceTargetPositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in float instanceWidths;
out vec4 vColor;
out vec2 uv;
vec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {
vec2 dir_screenspace = normalize(line_clipspace * project.viewportSize);
dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);
return dir_screenspace * offset_direction * width / 2.0;
}
vec3 splitLine(vec3 a, vec3 b, float x) {
float t = (x - a.x) / (b.x - a.x);
return vec3(x, mix(a.yz, b.yz, t));
}
void main(void) {
geometry.worldPosition = instanceSourcePositions;
geometry.worldPositionAlt = instanceTargetPositions;
vec3 source_world = instanceSourcePositions;
vec3 target_world = instanceTargetPositions;
vec3 source_world_64low = instanceSourcePositions64Low;
vec3 target_world_64low = instanceTargetPositions64Low;
if (line.useShortestPath > 0.5 || line.useShortestPath < -0.5) {
source_world.x = mod(source_world.x + 180., 360.0) - 180.;
target_world.x = mod(target_world.x + 180., 360.0) - 180.;
float deltaLng = target_world.x - source_world.x;
if (deltaLng * line.useShortestPath > 180.) {
source_world.x += 360. * line.useShortestPath;
source_world = splitLine(source_world, target_world, 180. * line.useShortestPath);
source_world_64low = vec3(0.0);
} else if (deltaLng * line.useShortestPath < -180.) {
target_world.x += 360. * line.useShortestPath;
target_world = splitLine(source_world, target_world, 180. * line.useShortestPath);
target_world_64low = vec3(0.0);
} else if (line.useShortestPath < 0.) {
gl_Position = vec4(0.);
return;
}
}
vec4 source_commonspace;
vec4 target_commonspace;
vec4 source = project_position_to_clipspace(source_world, source_world_64low, vec3(0.), source_commonspace);
vec4 target = project_position_to_clipspace(target_world, target_world_64low, vec3(0.), target_commonspace);
float segmentIndex = positions.x;
vec4 p = mix(source, target, segmentIndex);
geometry.position = mix(source_commonspace, target_commonspace, segmentIndex);
uv = positions.xy;
geometry.uv = uv;
geometry.pickingColor = instancePickingColors;
float widthPixels = clamp(
project_size_to_pixel(instanceWidths * line.widthScale, line.widthUnits),
line.widthMinPixels, line.widthMaxPixels
);
vec3 offset = vec3(
getExtrusionOffset(target.xy - source.xy, positions.y, widthPixels),
0.0);
DECKGL_FILTER_SIZE(offset, geometry);
DECKGL_FILTER_GL_POSITION(p, geometry);
gl_Position = p + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);
vColor = vec4(instanceColors.rgb, instanceColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, Ene = `#version 300 es
#define SHADER_NAME line-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 uv;
out vec4 fragColor;
void main(void) {
geometry.uv = uv;
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`, Cne = [0, 0, 0, 255], Sne = {
  getSourcePosition: { type: "accessor", value: (r) => r.sourcePosition },
  getTargetPosition: { type: "accessor", value: (r) => r.targetPosition },
  getColor: { type: "accessor", value: Cne },
  getWidth: { type: "accessor", value: 1 },
  widthUnits: "pixels",
  widthScale: { type: "number", value: 1, min: 0 },
  widthMinPixels: { type: "number", value: 0, min: 0 },
  widthMaxPixels: { type: "number", value: Number.MAX_SAFE_INTEGER, min: 0 }
};
class Q_ extends Is {
  getBounds() {
    return this.getAttributeManager()?.getBounds([
      "instanceSourcePositions",
      "instanceTargetPositions"
    ]);
  }
  getShaders() {
    return super.getShaders({ vs: Tne, fs: Ene, source: wne, modules: [Ws, Nx, ga, xne] });
  }
  // This layer has its own wrapLongitude logic
  get wrapLongitude() {
    return !1;
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instanceSourcePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: !0,
        accessor: "getSourcePosition"
      },
      instanceTargetPositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: !0,
        accessor: "getTargetPosition"
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: !0,
        accessor: "getColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceWidths: {
        size: 1,
        transition: !0,
        accessor: "getWidth",
        defaultValue: 1
      }
    });
  }
  updateState(e) {
    super.updateState(e), e.changeFlags.extensionsChanged && (this.state.model?.destroy(), this.state.model = this._getModel(), this.getAttributeManager().invalidateAll());
  }
  draw({ uniforms: e }) {
    const { widthUnits: t, widthScale: n, widthMinPixels: i, widthMaxPixels: s, wrapLongitude: o } = this.props, l = this.state.model, u = {
      widthUnits: ko[t],
      widthScale: n,
      widthMinPixels: i,
      widthMaxPixels: s,
      useShortestPath: o ? 1 : 0
    };
    l.shaderInputs.setProps({ line: u }), l.draw(this.context.renderPass), o && (l.shaderInputs.setProps({ line: { ...u, useShortestPath: -1 } }), l.draw(this.context.renderPass));
  }
  _getModel() {
    const e = this.context.device.type === "webgpu" ? {
      depthWriteEnabled: !0,
      depthCompare: "less-equal"
    } : void 0, t = [0, -1, 0, 0, 1, 0, 1, -1, 0, 1, 1, 0];
    return new Bi(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new no({
        topology: "triangle-strip",
        attributes: {
          positions: { size: 3, value: new Float32Array(t) }
        }
      }),
      parameters: e,
      isInstanced: !0
    });
  }
}
Q_.layerName = "LineLayer";
Q_.defaultProps = Sne;
const Ine = (
  /* wgsl */
  `struct PointCloudUniforms {
  radiusPixels: f32,
  sizeUnits: i32,
};

@group(0) @binding(3)
var<uniform> pointCloud: PointCloudUniforms;
`
), qI = `uniform pointCloudUniforms {
  float radiusPixels;
  highp int sizeUnits;
} pointCloud;
`, Pne = {
  name: "pointCloud",
  source: Ine,
  vs: qI,
  fs: qI,
  uniformTypes: {
    radiusPixels: "f32",
    sizeUnits: "i32"
  }
}, Mne = `#version 300 es
#define SHADER_NAME point-cloud-layer-vertex-shader
in vec3 positions;
in vec3 instanceNormals;
in vec4 instanceColors;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec3 instancePickingColors;
out vec4 vColor;
out vec2 unitPosition;
void main(void) {
geometry.worldPosition = instancePositions;
geometry.normal = project_normal(instanceNormals);
unitPosition = positions.xy;
geometry.uv = unitPosition;
geometry.pickingColor = instancePickingColors;
vec3 offset = vec3(positions.xy * project_size_to_pixel(pointCloud.radiusPixels, pointCloud.sizeUnits), 0.0);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
vec3 lightColor = lighting_getLightColor(instanceColors.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, instanceColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, Rne = `#version 300 es
#define SHADER_NAME point-cloud-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 unitPosition;
out vec4 fragColor;
void main(void) {
geometry.uv = unitPosition.xy;
float distToCenter = length(unitPosition);
if (distToCenter > 1.0) {
discard;
}
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`, Bne = (
  /* wgsl */
  `struct ConstantAttributes {
  instanceNormals: vec3<f32>,
  instanceColors: vec4<f32>,
  instancePositions: vec3<f32>,
  instancePositions64Low: vec3<f32>,
  instancePickingColors: vec3<f32>
};

const constants = ConstantAttributes(
  vec3<f32>(1.0, 0.0, 0.0),
  vec4<f32>(0.0, 0.0, 0.0, 1.0),
  vec3<f32>(0.0),
  vec3<f32>(0.0),
  vec3<f32>(0.0)
);

struct Attributes {
  @builtin(instance_index) instanceIndex : u32,
  @builtin(vertex_index) vertexIndex : u32,
  @location(0) positions: vec3<f32>,
  @location(1) instancePositions: vec3<f32>,
  @location(2) instancePositions64Low: vec3<f32>,
  @location(3) instanceNormals: vec3<f32>,
  @location(4) instanceColors: vec4<f32>,
  @location(5) instancePickingColors: vec3<f32>
};

struct Varyings {
  @builtin(position) position: vec4<f32>,
  @location(0) vColor: vec4<f32>,
  @location(1) unitPosition: vec2<f32>,
};

@vertex
fn vertexMain(attributes: Attributes) -> Varyings {
  var varyings: Varyings;
  
  // var geometry: Geometry;
  // geometry.worldPosition = instancePositions;
  // geometry.normal = project_normal(instanceNormals);

  // position on the containing square in [-1, 1] space
  varyings.unitPosition = attributes.positions.xy;
  geometry.uv = varyings.unitPosition;
  geometry.pickingColor = attributes.instancePickingColors;

  // Find the center of the point and add the current vertex
  let offset = vec3<f32>(attributes.positions.xy * project_unit_size_to_pixel(pointCloud.radiusPixels, pointCloud.sizeUnits), 0.0);
  // DECKGL_FILTER_SIZE(offset, geometry);

  varyings.position = project_position_to_clipspace(attributes.instancePositions, attributes.instancePositions64Low, vec3<f32>(0.0)); // TODO , geometry.position);
  // DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
  let clipPixels = project_pixel_size_to_clipspace(offset.xy);
  varyings.position.x += clipPixels.x;
  varyings.position.y += clipPixels.y;

  // Apply lighting
  let lightColor = lighting_getLightColor2(attributes.instanceColors.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);

  // Apply opacity to instance color, or return instance picking color
  varyings.vColor = vec4(lightColor, attributes.instanceColors.a * color.opacity);
  // DECKGL_FILTER_COLOR(vColor, geometry);

  return varyings;
}

@fragment
fn fragmentMain(varyings: Varyings) -> @location(0) vec4<f32> {
  // var geometry: Geometry;
  // geometry.uv = unitPosition.xy;

  let distToCenter = length(varyings.unitPosition);
  if (distToCenter > 1.0) {
    discard;
  }

  var fragColor: vec4<f32>;

  fragColor = varyings.vColor;
  // DECKGL_FILTER_COLOR(fragColor, geometry);

  // Apply premultiplied alpha as required by transparent canvas
  fragColor = deckgl_premultiplied_alpha(fragColor);

  return fragColor;
}
`
), PD = [0, 0, 0, 255], MD = [0, 0, 1], One = {
  sizeUnits: "pixels",
  pointSize: { type: "number", min: 0, value: 10 },
  //  point radius in pixels
  getPosition: { type: "accessor", value: (r) => r.position },
  getNormal: { type: "accessor", value: MD },
  getColor: { type: "accessor", value: PD },
  material: !0,
  // Depreated
  radiusPixels: { deprecatedFor: "pointSize" }
};
function Dne(r) {
  const { header: e, attributes: t } = r;
  if (!(!e || !t) && (r.length = e.vertexCount, t.POSITION && (t.instancePositions = t.POSITION), t.NORMAL && (t.instanceNormals = t.NORMAL), t.COLOR_0)) {
    const { size: n, value: i } = t.COLOR_0;
    t.instanceColors = { size: n, type: "unorm8", value: i };
  }
}
class w0 extends Is {
  getShaders() {
    return super.getShaders({
      vs: Mne,
      fs: Rne,
      source: Bne,
      modules: [Ws, Nx, k_, ga, Pne]
    });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: !0,
        accessor: "getPosition"
      },
      instanceNormals: {
        size: 3,
        transition: !0,
        accessor: "getNormal",
        defaultValue: MD
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: !0,
        accessor: "getColor",
        defaultValue: PD
      }
    });
  }
  updateState(e) {
    const { changeFlags: t, props: n } = e;
    super.updateState(e), t.extensionsChanged && (this.state.model?.destroy(), this.state.model = this._getModel(), this.getAttributeManager().invalidateAll()), t.dataChanged && Dne(n.data);
  }
  draw({ uniforms: e }) {
    const { pointSize: t, sizeUnits: n } = this.props, i = this.state.model, s = {
      sizeUnits: ko[n],
      radiusPixels: t
    };
    i.shaderInputs.setProps({ pointCloud: s }), this.context.device.type === "webgpu" && (i.instanceCount = this.props.data.length), i.draw(this.context.renderPass);
  }
  _getModel() {
    const e = this.context.device.type === "webgpu" ? {
      depthWriteEnabled: !0,
      depthCompare: "less-equal"
    } : void 0, t = [];
    for (let n = 0; n < 3; n++) {
      const i = n / 3 * Math.PI * 2;
      t.push(Math.cos(i) * 2, Math.sin(i) * 2, 0);
    }
    return new Bi(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new no({
        topology: "triangle-list",
        attributes: {
          positions: new Float32Array(t)
        }
      }),
      parameters: e,
      isInstanced: !0
    });
  }
}
w0.layerName = "PointCloudLayer";
w0.defaultProps = One;
const XI = `uniform scatterplotUniforms {
  float radiusScale;
  float radiusMinPixels;
  float radiusMaxPixels;
  float lineWidthScale;
  float lineWidthMinPixels;
  float lineWidthMaxPixels;
  float stroked;
  float filled;
  bool antialiasing;
  bool billboard;
  highp int radiusUnits;
  highp int lineWidthUnits;
} scatterplot;
`, Lne = {
  name: "scatterplot",
  vs: XI,
  fs: XI,
  source: "",
  uniformTypes: {
    radiusScale: "f32",
    radiusMinPixels: "f32",
    radiusMaxPixels: "f32",
    lineWidthScale: "f32",
    lineWidthMinPixels: "f32",
    lineWidthMaxPixels: "f32",
    stroked: "f32",
    filled: "f32",
    antialiasing: "f32",
    billboard: "f32",
    radiusUnits: "i32",
    lineWidthUnits: "i32"
  }
}, kne = (
  /* glsl */
  `#version 300 es
#define SHADER_NAME scatterplot-layer-vertex-shader
in vec3 positions;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in float instanceRadius;
in float instanceLineWidths;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in vec3 instancePickingColors;
out vec4 vFillColor;
out vec4 vLineColor;
out vec2 unitPosition;
out float innerUnitRadius;
out float outerRadiusPixels;
void main(void) {
geometry.worldPosition = instancePositions;
outerRadiusPixels = clamp(
project_size_to_pixel(scatterplot.radiusScale * instanceRadius, scatterplot.radiusUnits),
scatterplot.radiusMinPixels, scatterplot.radiusMaxPixels
);
float lineWidthPixels = clamp(
project_size_to_pixel(scatterplot.lineWidthScale * instanceLineWidths, scatterplot.lineWidthUnits),
scatterplot.lineWidthMinPixels, scatterplot.lineWidthMaxPixels
);
outerRadiusPixels += scatterplot.stroked * lineWidthPixels / 2.0;
float edgePadding = scatterplot.antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;
unitPosition = edgePadding * positions.xy;
geometry.uv = unitPosition;
geometry.pickingColor = instancePickingColors;
innerUnitRadius = 1.0 - scatterplot.stroked * lineWidthPixels / outerRadiusPixels;
if (scatterplot.billboard) {
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vec3 offset = edgePadding * positions * outerRadiusPixels;
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
} else {
vec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vFillColor, geometry);
vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vLineColor, geometry);
}
`
), Fne = (
  /* glsl */
  `#version 300 es
#define SHADER_NAME scatterplot-layer-fragment-shader
precision highp float;
in vec4 vFillColor;
in vec4 vLineColor;
in vec2 unitPosition;
in float innerUnitRadius;
in float outerRadiusPixels;
out vec4 fragColor;
void main(void) {
geometry.uv = unitPosition;
float distToCenter = length(unitPosition) * outerRadiusPixels;
float inCircle = scatterplot.antialiasing ?
smoothedge(distToCenter, outerRadiusPixels) :
step(distToCenter, outerRadiusPixels);
if (inCircle == 0.0) {
discard;
}
if (scatterplot.stroked > 0.5) {
float isLine = scatterplot.antialiasing ?
smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :
step(innerUnitRadius * outerRadiusPixels, distToCenter);
if (scatterplot.filled > 0.5) {
fragColor = mix(vFillColor, vLineColor, isLine);
} else {
if (isLine == 0.0) {
discard;
}
fragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);
}
} else if (scatterplot.filled < 0.5) {
discard;
} else {
fragColor = vFillColor;
}
fragColor.a *= inCircle;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`
), Nne = (
  /* wgsl */
  `// Main shaders

struct ScatterplotUniforms {
  radiusScale: f32,
  radiusMinPixels: f32,
  radiusMaxPixels: f32,
  lineWidthScale: f32,
  lineWidthMinPixels: f32,
  lineWidthMaxPixels: f32,
  stroked: f32,
  filled: i32,
  antialiasing: i32,
  billboard: i32,
  radiusUnits: i32,
  lineWidthUnits: i32,
};

struct ConstantAttributeUniforms {
 instancePositions: vec3<f32>,
 instancePositions64Low: vec3<f32>,
 instanceRadius: f32,
 instanceLineWidths: f32,
 instanceFillColors: vec4<f32>,
 instanceLineColors: vec4<f32>,
 instancePickingColors: vec3<f32>,

 instancePositionsConstant: i32,
 instancePositions64LowConstant: i32,
 instanceRadiusConstant: i32,
 instanceLineWidthsConstant: i32,
 instanceFillColorsConstant: i32,
 instanceLineColorsConstant: i32,
 instancePickingColorsConstant: i32
};

@group(0) @binding(2) var<uniform> scatterplot: ScatterplotUniforms;

struct ConstantAttributes {
  instancePositions: vec3<f32>,
  instancePositions64Low: vec3<f32>,
  instanceRadius: f32,
  instanceLineWidths: f32,
  instanceFillColors: vec4<f32>,
  instanceLineColors: vec4<f32>,
  instancePickingColors: vec3<f32>
};

const constants = ConstantAttributes(
  vec3<f32>(0.0),
  vec3<f32>(0.0),
  0.0,
  0.0,
  vec4<f32>(0.0, 0.0, 0.0, 1.0),
  vec4<f32>(0.0, 0.0, 0.0, 1.0),
  vec3<f32>(0.0)
);

struct Attributes {
  @builtin(instance_index) instanceIndex : u32,
  @builtin(vertex_index) vertexIndex : u32,
  @location(0) positions: vec3<f32>,
  @location(1) instancePositions: vec3<f32>,
  @location(2) instancePositions64Low: vec3<f32>,
  @location(3) instanceRadius: f32,
  @location(4) instanceLineWidths: f32,
  @location(5) instanceFillColors: vec4<f32>,
  @location(6) instanceLineColors: vec4<f32>,
  @location(7) instancePickingColors: vec3<f32>
};

struct Varyings {
  @builtin(position) position: vec4<f32>,
  @location(0) vFillColor: vec4<f32>,
  @location(1) vLineColor: vec4<f32>,
  @location(2) unitPosition: vec2<f32>,
  @location(3) innerUnitRadius: f32,
  @location(4) outerRadiusPixels: f32,
};

@vertex
fn vertexMain(attributes: Attributes) -> Varyings {
  var varyings: Varyings;

  // Draw an inline geometry constant array clip space triangle to verify that rendering works.
  // var positions = array<vec2<f32>, 3>(vec2(0.0, 0.5), vec2(-0.5, -0.5), vec2(0.5, -0.5));
  // if (attributes.instanceIndex == 0) {
  //   varyings.position = vec4<f32>(positions[attributes.vertexIndex], 0.0, 1.0);
  //   return varyings;
  // }

  // var geometry: Geometry;
  // geometry.worldPosition = instancePositions;

  // Multiply out radius and clamp to limits
  varyings.outerRadiusPixels = clamp(
    project_unit_size_to_pixel(scatterplot.radiusScale * attributes.instanceRadius, scatterplot.radiusUnits),
    scatterplot.radiusMinPixels, scatterplot.radiusMaxPixels
  );

  // Multiply out line width and clamp to limits
  let lineWidthPixels = clamp(
    project_unit_size_to_pixel(scatterplot.lineWidthScale * attributes.instanceLineWidths, scatterplot.lineWidthUnits),
    scatterplot.lineWidthMinPixels, scatterplot.lineWidthMaxPixels
  );

  // outer radius needs to offset by half stroke width
  varyings.outerRadiusPixels += scatterplot.stroked * lineWidthPixels / 2.0;
  // Expand geometry to accommodate edge smoothing
  let edgePadding = select(
    (varyings.outerRadiusPixels + SMOOTH_EDGE_RADIUS) / varyings.outerRadiusPixels,
    1.0,
    scatterplot.antialiasing != 0
  );

  // position on the containing square in [-1, 1] space
  varyings.unitPosition = edgePadding * attributes.positions.xy;
  geometry.uv = varyings.unitPosition;
  geometry.pickingColor = attributes.instancePickingColors;

  varyings.innerUnitRadius = 1.0 - scatterplot.stroked * lineWidthPixels / varyings.outerRadiusPixels;

  if (scatterplot.billboard != 0) {
    varyings.position = project_position_to_clipspace(attributes.instancePositions, attributes.instancePositions64Low, vec3<f32>(0.0)); // TODO , geometry.position);
    // DECKGL_FILTER_GL_POSITION(varyings.position, geometry);
    let offset = attributes.positions; // * edgePadding * varyings.outerRadiusPixels;
    // DECKGL_FILTER_SIZE(offset, geometry);
    let clipPixels = project_pixel_size_to_clipspace(offset.xy);
    varyings.position.x = clipPixels.x;
    varyings.position.y = clipPixels.y;
  } else {
    let offset = edgePadding * attributes.positions * project_pixel_size_float(varyings.outerRadiusPixels);
    // DECKGL_FILTER_SIZE(offset, geometry);
    varyings.position = project_position_to_clipspace(attributes.instancePositions, attributes.instancePositions64Low, offset); // TODO , geometry.position);
    // DECKGL_FILTER_GL_POSITION(varyings.position, geometry);
  }

  // Apply opacity to instance color, or return instance picking color
  varyings.vFillColor = vec4<f32>(attributes.instanceFillColors.rgb, attributes.instanceFillColors.a * color.opacity);
  // DECKGL_FILTER_COLOR(varyings.vFillColor, geometry);
  varyings.vLineColor = vec4<f32>(attributes.instanceLineColors.rgb, attributes.instanceLineColors.a * color.opacity);
  // DECKGL_FILTER_COLOR(varyings.vLineColor, geometry);

  return varyings;
}

@fragment
fn fragmentMain(varyings: Varyings) -> @location(0) vec4<f32> {
  // var geometry: Geometry;
  // geometry.uv = unitPosition;

  let distToCenter = length(varyings.unitPosition) * varyings.outerRadiusPixels;
  let inCircle = select(
    smoothedge(distToCenter, varyings.outerRadiusPixels),
    step(distToCenter, varyings.outerRadiusPixels),
    scatterplot.antialiasing != 0
  );

  if (inCircle == 0.0) {
    discard;
  }

  var fragColor: vec4<f32>;

  if (scatterplot.stroked != 0) {
    let isLine = select(
      smoothedge(varyings.innerUnitRadius * varyings.outerRadiusPixels, distToCenter),
      step(varyings.innerUnitRadius * varyings.outerRadiusPixels, distToCenter),
      scatterplot.antialiasing != 0
    );

    if (scatterplot.filled != 0) {
      fragColor = mix(varyings.vFillColor, varyings.vLineColor, isLine);
    } else {
      if (isLine == 0.0) {
        discard;
      }
      fragColor = vec4<f32>(varyings.vLineColor.rgb, varyings.vLineColor.a * isLine);
    }
  } else if (scatterplot.filled == 0) {
    discard;
  } else {
    fragColor = varyings.vFillColor;
  }

  fragColor.a *= inCircle;
  // DECKGL_FILTER_COLOR(fragColor, geometry);

  // Apply premultiplied alpha as required by transparent canvas
  fragColor = deckgl_premultiplied_alpha(fragColor);

  return fragColor;
  // return vec4<f32>(0, 0, 1, 1);
}
`
), ZI = [0, 0, 0, 255], Une = {
  radiusUnits: "meters",
  radiusScale: { type: "number", min: 0, value: 1 },
  radiusMinPixels: { type: "number", min: 0, value: 0 },
  //  min point radius in pixels
  radiusMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
  // max point radius in pixels
  lineWidthUnits: "meters",
  lineWidthScale: { type: "number", min: 0, value: 1 },
  lineWidthMinPixels: { type: "number", min: 0, value: 0 },
  lineWidthMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
  stroked: !1,
  filled: !0,
  billboard: !1,
  antialiasing: !0,
  getPosition: { type: "accessor", value: (r) => r.position },
  getRadius: { type: "accessor", value: 1 },
  getFillColor: { type: "accessor", value: ZI },
  getLineColor: { type: "accessor", value: ZI },
  getLineWidth: { type: "accessor", value: 1 },
  // deprecated
  strokeWidth: { deprecatedFor: "getLineWidth" },
  outline: { deprecatedFor: "stroked" },
  getColor: { deprecatedFor: ["getFillColor", "getLineColor"] }
};
class T0 extends Is {
  getShaders() {
    return super.getShaders({
      vs: kne,
      fs: Fne,
      source: Nne,
      modules: [Ws, Nx, ga, Lne]
    });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: !0,
        accessor: "getPosition"
      },
      instanceRadius: {
        size: 1,
        transition: !0,
        accessor: "getRadius",
        defaultValue: 1
      },
      instanceFillColors: {
        size: this.props.colorFormat.length,
        transition: !0,
        type: "unorm8",
        accessor: "getFillColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineColors: {
        size: this.props.colorFormat.length,
        transition: !0,
        type: "unorm8",
        accessor: "getLineColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineWidths: {
        size: 1,
        transition: !0,
        accessor: "getLineWidth",
        defaultValue: 1
      }
    });
  }
  updateState(e) {
    super.updateState(e), e.changeFlags.extensionsChanged && (this.state.model?.destroy(), this.state.model = this._getModel(), this.getAttributeManager().invalidateAll());
  }
  draw({ uniforms: e }) {
    const { radiusUnits: t, radiusScale: n, radiusMinPixels: i, radiusMaxPixels: s, stroked: o, filled: l, billboard: u, antialiasing: m, lineWidthUnits: y, lineWidthScale: E, lineWidthMinPixels: P, lineWidthMaxPixels: L } = this.props, U = {
      stroked: o,
      filled: l,
      billboard: u,
      antialiasing: m,
      radiusUnits: ko[t],
      radiusScale: n,
      radiusMinPixels: i,
      radiusMaxPixels: s,
      lineWidthUnits: ko[y],
      lineWidthScale: E,
      lineWidthMinPixels: P,
      lineWidthMaxPixels: L
    }, V = this.state.model;
    V.shaderInputs.setProps({ scatterplot: U }), this.context.device.type === "webgpu" && (V.instanceCount = this.props.data.length), V.draw(this.context.renderPass);
  }
  _getModel() {
    const e = this.context.device.type === "webgpu" ? {
      depthWriteEnabled: !0,
      depthCompare: "less-equal"
    } : void 0, t = [-1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0];
    return new Bi(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new no({
        topology: "triangle-strip",
        attributes: {
          positions: { size: 3, value: new Float32Array(t) }
        }
      }),
      isInstanced: !0,
      parameters: e
    });
  }
}
T0.defaultProps = Une;
T0.layerName = "ScatterplotLayer";
const ww = {
  CLOCKWISE: 1,
  COUNTER_CLOCKWISE: -1
};
function Tw(r, e, t = {}) {
  return zne(r, t) !== e ? (jne(r, t), !0) : !1;
}
function zne(r, e = {}) {
  return Math.sign(Vne(r, e));
}
const YI = {
  x: 0,
  y: 1,
  z: 2
};
function Vne(r, e = {}) {
  const { start: t = 0, end: n = r.length, plane: i = "xy" } = e, s = e.size || 2;
  let o = 0;
  const l = YI[i[0]], u = YI[i[1]];
  for (let m = t, y = n - s; m < n; m += s)
    o += (r[m + l] - r[y + l]) * (r[m + u] + r[y + u]), y = m;
  return o / 2;
}
function jne(r, e) {
  const { start: t = 0, end: n = r.length, size: i = 2 } = e, s = (n - t) / i, o = Math.floor(s / 2);
  for (let l = 0; l < o; ++l) {
    const u = t + l * i, m = t + (s - 1 - l) * i;
    for (let y = 0; y < i; ++y) {
      const E = r[u + y];
      r[u + y] = r[m + y], r[m + y] = E;
    }
  }
}
function Al(r, e) {
  const t = e.length, n = r.length;
  if (n > 0) {
    let i = !0;
    for (let s = 0; s < t; s++)
      if (r[n - t + s] !== e[s]) {
        i = !1;
        break;
      }
    if (i)
      return !1;
  }
  for (let i = 0; i < t; i++)
    r[n + i] = e[i];
  return !0;
}
function g2(r, e) {
  const t = e.length;
  for (let n = 0; n < t; n++)
    r[n] = e[n];
}
function d0(r, e, t, n, i = []) {
  const s = n + e * t;
  for (let o = 0; o < t; o++)
    i[o] = r[s + o];
  return i;
}
function m2(r, e, t, n, i = []) {
  let s, o;
  if (t & 8)
    s = (n[3] - r[1]) / (e[1] - r[1]), o = 3;
  else if (t & 4)
    s = (n[1] - r[1]) / (e[1] - r[1]), o = 1;
  else if (t & 2)
    s = (n[2] - r[0]) / (e[0] - r[0]), o = 2;
  else if (t & 1)
    s = (n[0] - r[0]) / (e[0] - r[0]), o = 0;
  else
    return null;
  for (let l = 0; l < r.length; l++)
    i[l] = (o & 1) === l ? n[o] : s * (e[l] - r[l]) + r[l];
  return i;
}
function Pm(r, e) {
  let t = 0;
  return r[0] < e[0] ? t |= 1 : r[0] > e[2] && (t |= 2), r[1] < e[1] ? t |= 4 : r[1] > e[3] && (t |= 8), t;
}
function RD(r, e) {
  const { size: t = 2, broken: n = !1, gridResolution: i = 10, gridOffset: s = [0, 0], startIndex: o = 0, endIndex: l = r.length } = e || {}, u = (l - o) / t;
  let m = [];
  const y = [m], E = d0(r, 0, t, o);
  let P, L;
  const U = OD(E, i, s, []), V = [];
  Al(m, E);
  for (let q = 1; q < u; q++) {
    for (P = d0(r, q, t, o, P), L = Pm(P, U); L; ) {
      m2(E, P, L, U, V);
      const j = Pm(V, U);
      j && (m2(E, V, j, U, V), L = j), Al(m, V), g2(E, V), Gne(U, i, L), n && m.length > t && (m = [], y.push(m), Al(m, E)), L = Pm(P, U);
    }
    Al(m, P), g2(E, P);
  }
  return n ? y : y[0];
}
const KI = 0, Hne = 1;
function BD(r, e = null, t) {
  if (!r.length)
    return [];
  const { size: n = 2, gridResolution: i = 10, gridOffset: s = [0, 0], edgeTypes: o = !1 } = t || {}, l = [], u = [
    {
      pos: r,
      types: o ? new Array(r.length / n).fill(Hne) : null,
      holes: e || []
    }
  ], m = [[], []];
  let y = [];
  for (; u.length; ) {
    const { pos: E, types: P, holes: L } = u.shift();
    Wne(E, n, L[0] || E.length, m), y = OD(m[0], i, s, y);
    const U = Pm(m[1], y);
    if (U) {
      let V = QI(E, P, n, 0, L[0] || E.length, y, U);
      const q = { pos: V[0].pos, types: V[0].types, holes: [] }, j = { pos: V[1].pos, types: V[1].types, holes: [] };
      u.push(q, j);
      for (let K = 0; K < L.length; K++)
        V = QI(E, P, n, L[K], L[K + 1] || E.length, y, U), V[0] && (q.holes.push(q.pos.length), q.pos = kg(q.pos, V[0].pos), o && (q.types = kg(q.types, V[0].types))), V[1] && (j.holes.push(j.pos.length), j.pos = kg(j.pos, V[1].pos), o && (j.types = kg(j.types, V[1].types)));
    } else {
      const V = { positions: E };
      o && (V.edgeTypes = P), L.length && (V.holeIndices = L), l.push(V);
    }
  }
  return l;
}
function QI(r, e, t, n, i, s, o) {
  const l = (i - n) / t, u = [], m = [], y = [], E = [], P = [];
  let L, U, V;
  const q = d0(r, l - 1, t, n);
  let j = Math.sign(o & 8 ? q[1] - s[3] : q[0] - s[2]), K = e && e[l - 1], Y = 0, de = 0;
  for (let ne = 0; ne < l; ne++)
    L = d0(r, ne, t, n, L), U = Math.sign(o & 8 ? L[1] - s[3] : L[0] - s[2]), V = e && e[n / t + ne], U && j && j !== U && (m2(q, L, o, s, P), Al(u, P) && y.push(K), Al(m, P) && E.push(K)), U <= 0 ? (Al(u, L) && y.push(V), Y -= U) : y.length && (y[y.length - 1] = KI), U >= 0 ? (Al(m, L) && E.push(V), de += U) : E.length && (E[E.length - 1] = KI), g2(q, L), j = U, K = V;
  return [
    Y ? { pos: u, types: e && y } : null,
    de ? { pos: m, types: e && E } : null
  ];
}
function OD(r, e, t, n) {
  const i = Math.floor((r[0] - t[0]) / e) * e + t[0], s = Math.floor((r[1] - t[1]) / e) * e + t[1];
  return n[0] = i, n[1] = s, n[2] = i + e, n[3] = s + e, n;
}
function Gne(r, e, t) {
  t & 8 ? (r[1] += e, r[3] += e) : t & 4 ? (r[1] -= e, r[3] -= e) : t & 2 ? (r[0] += e, r[2] += e) : t & 1 && (r[0] -= e, r[2] -= e);
}
function Wne(r, e, t, n) {
  let i = 1 / 0, s = -1 / 0, o = 1 / 0, l = -1 / 0;
  for (let u = 0; u < t; u += e) {
    const m = r[u], y = r[u + 1];
    i = m < i ? m : i, s = m > s ? m : s, o = y < o ? y : o, l = y > l ? y : l;
  }
  return n[0][0] = i, n[0][1] = o, n[1][0] = s, n[1][1] = l, n;
}
function kg(r, e) {
  for (let t = 0; t < e.length; t++)
    r.push(e[t]);
  return r;
}
const $ne = 85.051129;
function qne(r, e) {
  const { size: t = 2, startIndex: n = 0, endIndex: i = r.length, normalize: s = !0 } = e || {}, o = r.slice(n, i);
  DD(o, t, 0, i - n);
  const l = RD(o, {
    size: t,
    broken: !0,
    gridResolution: 360,
    gridOffset: [-180, -180]
  });
  if (s)
    for (const u of l)
      LD(u, t);
  return l;
}
function Xne(r, e = null, t) {
  const { size: n = 2, normalize: i = !0, edgeTypes: s = !1 } = t || {};
  e = e || [];
  const o = [], l = [];
  let u = 0, m = 0;
  for (let E = 0; E <= e.length; E++) {
    const P = e[E] || r.length, L = m, U = Zne(r, n, u, P);
    for (let V = U; V < P; V++)
      o[m++] = r[V];
    for (let V = u; V < U; V++)
      o[m++] = r[V];
    DD(o, n, L, m), Yne(o, n, L, m, t?.maxLatitude), u = P, l[E] = m;
  }
  l.pop();
  const y = BD(o, l, {
    size: n,
    gridResolution: 360,
    gridOffset: [-180, -180],
    edgeTypes: s
  });
  if (i)
    for (const E of y)
      LD(E.positions, n);
  return y;
}
function Zne(r, e, t, n) {
  let i = -1, s = -1;
  for (let o = t + 1; o < n; o += e) {
    const l = Math.abs(r[o]);
    l > i && (i = l, s = o - 1);
  }
  return s;
}
function Yne(r, e, t, n, i = $ne) {
  const s = r[t], o = r[n - e];
  if (Math.abs(s - o) > 180) {
    const l = d0(r, 0, e, t);
    l[0] += Math.round((o - s) / 360) * 360, Al(r, l), l[1] = Math.sign(l[1]) * i, Al(r, l), l[0] = s, Al(r, l);
  }
}
function DD(r, e, t, n) {
  let i = r[0], s;
  for (let o = t; o < n; o += e) {
    s = r[o];
    const l = s - i;
    (l > 180 || l < -180) && (s -= Math.round(l / 360) * 360), r[o] = i = s;
  }
}
function LD(r, e) {
  let t;
  const n = r.length / e;
  for (let s = 0; s < n && (t = r[s * e], (t + 180) % 360 === 0); s++)
    ;
  const i = -Math.round(t / 360) * 360;
  if (i !== 0)
    for (let s = 0; s < n; s++)
      r[s * e] += i;
}
class Kne extends no {
  constructor(e) {
    const { indices: t, attributes: n } = Qne(e);
    super({
      ...e,
      indices: t,
      // @ts-expect-error
      attributes: n
    });
  }
}
function Qne(r) {
  const { radius: e, height: t = 1, nradial: n = 10 } = r;
  let { vertices: i } = r;
  i && (Jr.assert(i.length >= n), i = i.flatMap((L) => [L[0], L[1]]), Tw(i, ww.COUNTER_CLOCKWISE));
  const s = t > 0, o = n + 1, l = s ? o * 3 + 1 : n, u = Math.PI * 2 / n, m = new Uint16Array(s ? n * 3 * 2 : 0), y = new Float32Array(l * 3), E = new Float32Array(l * 3);
  let P = 0;
  if (s) {
    for (let L = 0; L < o; L++) {
      const U = L * u, V = L % n, q = Math.sin(U), j = Math.cos(U);
      for (let K = 0; K < 2; K++)
        y[P + 0] = i ? i[V * 2] : j * e, y[P + 1] = i ? i[V * 2 + 1] : q * e, y[P + 2] = (1 / 2 - K) * t, E[P + 0] = i ? i[V * 2] : j, E[P + 1] = i ? i[V * 2 + 1] : q, P += 3;
    }
    y[P + 0] = y[P - 3], y[P + 1] = y[P - 2], y[P + 2] = y[P - 1], P += 3;
  }
  for (let L = s ? 0 : 1; L < o; L++) {
    const U = Math.floor(L / 2) * Math.sign(0.5 - L % 2), V = U * u, q = (U + n) % n, j = Math.sin(V), K = Math.cos(V);
    y[P + 0] = i ? i[q * 2] : K * e, y[P + 1] = i ? i[q * 2 + 1] : j * e, y[P + 2] = t / 2, E[P + 2] = 1, P += 3;
  }
  if (s) {
    let L = 0;
    for (let U = 0; U < n; U++)
      m[L++] = U * 2 + 0, m[L++] = U * 2 + 2, m[L++] = U * 2 + 0, m[L++] = U * 2 + 1, m[L++] = U * 2 + 1, m[L++] = U * 2 + 3;
  }
  return {
    indices: m,
    attributes: {
      POSITION: { size: 3, value: y },
      NORMAL: { size: 3, value: E }
    }
  };
}
const JI = `uniform columnUniforms {
  float radius;
  float angle;
  vec2 offset;
  bool extruded;
  bool stroked;
  bool isStroke;
  float coverage;
  float elevationScale;
  float edgeDistance;
  float widthScale;
  float widthMinPixels;
  float widthMaxPixels;
  highp int radiusUnits;
  highp int widthUnits;
} column;
`, Jne = {
  name: "column",
  vs: JI,
  fs: JI,
  uniformTypes: {
    radius: "f32",
    angle: "f32",
    offset: "vec2<f32>",
    extruded: "f32",
    stroked: "f32",
    isStroke: "f32",
    coverage: "f32",
    elevationScale: "f32",
    edgeDistance: "f32",
    widthScale: "f32",
    widthMinPixels: "f32",
    widthMaxPixels: "f32",
    radiusUnits: "i32",
    widthUnits: "i32"
  }
}, eie = `#version 300 es
#define SHADER_NAME column-layer-vertex-shader
in vec3 positions;
in vec3 normals;
in vec3 instancePositions;
in float instanceElevations;
in vec3 instancePositions64Low;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in float instanceStrokeWidths;
in vec3 instancePickingColors;
out vec4 vColor;
#ifdef FLAT_SHADING
out vec3 cameraPosition;
out vec4 position_commonspace;
#endif
void main(void) {
geometry.worldPosition = instancePositions;
vec4 color = column.isStroke ? instanceLineColors : instanceFillColors;
mat2 rotationMatrix = mat2(cos(column.angle), sin(column.angle), -sin(column.angle), cos(column.angle));
float elevation = 0.0;
float strokeOffsetRatio = 1.0;
if (column.extruded) {
elevation = instanceElevations * (positions.z + 1.0) / 2.0 * column.elevationScale;
} else if (column.stroked) {
float widthPixels = clamp(
project_size_to_pixel(instanceStrokeWidths * column.widthScale, column.widthUnits),
column.widthMinPixels, column.widthMaxPixels) / 2.0;
float halfOffset = project_pixel_size(widthPixels) / project_size(column.edgeDistance * column.coverage * column.radius);
if (column.isStroke) {
strokeOffsetRatio -= sign(positions.z) * halfOffset;
} else {
strokeOffsetRatio -= halfOffset;
}
}
float shouldRender = float(color.a > 0.0 && instanceElevations >= 0.0);
float dotRadius = column.radius * column.coverage * shouldRender;
geometry.pickingColor = instancePickingColors;
vec3 centroidPosition = vec3(instancePositions.xy, instancePositions.z + elevation);
vec3 centroidPosition64Low = instancePositions64Low;
vec2 offset = (rotationMatrix * positions.xy * strokeOffsetRatio + column.offset) * dotRadius;
if (column.radiusUnits == UNIT_METERS) {
offset = project_size(offset);
}
vec3 pos = vec3(offset, 0.);
DECKGL_FILTER_SIZE(pos, geometry);
gl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, geometry.position);
geometry.normal = project_normal(vec3(rotationMatrix * normals.xy, normals.z));
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
if (column.extruded && !column.isStroke) {
#ifdef FLAT_SHADING
cameraPosition = project.cameraPosition;
position_commonspace = geometry.position;
vColor = vec4(color.rgb, color.a * layer.opacity);
#else
vec3 lightColor = lighting_getLightColor(color.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, color.a * layer.opacity);
#endif
} else {
vColor = vec4(color.rgb, color.a * layer.opacity);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, tie = `#version 300 es
#define SHADER_NAME column-layer-fragment-shader
precision highp float;
out vec4 fragColor;
in vec4 vColor;
#ifdef FLAT_SHADING
in vec3 cameraPosition;
in vec4 position_commonspace;
#endif
void main(void) {
fragColor = vColor;
geometry.uv = vec2(0.);
#ifdef FLAT_SHADING
if (column.extruded && !column.isStroke && !bool(picking.isActive)) {
vec3 normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
fragColor.rgb = lighting_getLightColor(vColor.rgb, cameraPosition, position_commonspace.xyz, normal);
}
#endif
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`, A_ = [0, 0, 0, 255], rie = {
  diskResolution: { type: "number", min: 4, value: 20 },
  vertices: null,
  radius: { type: "number", min: 0, value: 1e3 },
  angle: { type: "number", value: 0 },
  offset: { type: "array", value: [0, 0] },
  coverage: { type: "number", min: 0, max: 1, value: 1 },
  elevationScale: { type: "number", min: 0, value: 1 },
  radiusUnits: "meters",
  lineWidthUnits: "meters",
  lineWidthScale: 1,
  lineWidthMinPixels: 0,
  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
  extruded: !0,
  wireframe: !1,
  filled: !0,
  stroked: !1,
  flatShading: !1,
  getPosition: { type: "accessor", value: (r) => r.position },
  getFillColor: { type: "accessor", value: A_ },
  getLineColor: { type: "accessor", value: A_ },
  getLineWidth: { type: "accessor", value: 1 },
  getElevation: { type: "accessor", value: 1e3 },
  material: !0,
  getColor: { deprecatedFor: ["getFillColor", "getLineColor"] }
};
class dc extends Is {
  getShaders() {
    const e = {}, { flatShading: t } = this.props;
    return t && (e.FLAT_SHADING = 1), super.getShaders({
      vs: eie,
      fs: tie,
      defines: e,
      modules: [Ws, t ? kx : k_, ga, Jne]
    });
  }
  /**
   * DeckGL calls initializeState when GL context is available
   * Essentially a deferred constructor
   */
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: !0,
        accessor: "getPosition"
      },
      instanceElevations: {
        size: 1,
        transition: !0,
        accessor: "getElevation"
      },
      instanceFillColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: !0,
        accessor: "getFillColor",
        defaultValue: A_
      },
      instanceLineColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: !0,
        accessor: "getLineColor",
        defaultValue: A_
      },
      instanceStrokeWidths: {
        size: 1,
        accessor: "getLineWidth",
        transition: !0
      }
    });
  }
  updateState(e) {
    super.updateState(e);
    const { props: t, oldProps: n, changeFlags: i } = e, s = i.extensionsChanged || t.flatShading !== n.flatShading;
    s && (this.state.models?.forEach((l) => l.destroy()), this.setState(this._getModels()), this.getAttributeManager().invalidateAll());
    const o = this.getNumInstances();
    this.state.fillModel.setInstanceCount(o), this.state.wireframeModel.setInstanceCount(o), (s || t.diskResolution !== n.diskResolution || t.vertices !== n.vertices || (t.extruded || t.stroked) !== (n.extruded || n.stroked)) && this._updateGeometry(t);
  }
  getGeometry(e, t, n) {
    const i = new Kne({
      radius: 1,
      height: n ? 2 : 0,
      vertices: t,
      nradial: e
    });
    let s = 0;
    if (t)
      for (let o = 0; o < e; o++) {
        const l = t[o], u = Math.sqrt(l[0] * l[0] + l[1] * l[1]);
        s += u / e;
      }
    else
      s = 1;
    return this.setState({
      edgeDistance: Math.cos(Math.PI / e) * s
    }), i;
  }
  _getModels() {
    const e = this.getShaders(), t = this.getAttributeManager().getBufferLayouts(), n = new Bi(this.context.device, {
      ...e,
      id: `${this.props.id}-fill`,
      bufferLayout: t,
      isInstanced: !0
    }), i = new Bi(this.context.device, {
      ...e,
      id: `${this.props.id}-wireframe`,
      bufferLayout: t,
      isInstanced: !0
    });
    return {
      fillModel: n,
      wireframeModel: i,
      models: [i, n]
    };
  }
  _updateGeometry({ diskResolution: e, vertices: t, extruded: n, stroked: i }) {
    const s = this.getGeometry(e, t, n || i);
    this.setState({
      fillVertexCount: s.attributes.POSITION.value.length / 3
    });
    const o = this.state.fillModel, l = this.state.wireframeModel;
    o.setGeometry(s), o.setTopology("triangle-strip"), o.setIndexBuffer(null), l.setGeometry(s), l.setTopology("line-list");
  }
  draw({ uniforms: e }) {
    const { lineWidthUnits: t, lineWidthScale: n, lineWidthMinPixels: i, lineWidthMaxPixels: s, radiusUnits: o, elevationScale: l, extruded: u, filled: m, stroked: y, wireframe: E, offset: P, coverage: L, radius: U, angle: V } = this.props, q = this.state.fillModel, j = this.state.wireframeModel, { fillVertexCount: K, edgeDistance: Y } = this.state, de = {
      radius: U,
      angle: V / 180 * Math.PI,
      offset: P,
      extruded: u,
      stroked: y,
      coverage: L,
      elevationScale: l,
      edgeDistance: Y,
      radiusUnits: ko[o],
      widthUnits: ko[t],
      widthScale: n,
      widthMinPixels: i,
      widthMaxPixels: s
    };
    u && E && (j.shaderInputs.setProps({
      column: {
        ...de,
        isStroke: !0
      }
    }), j.draw(this.context.renderPass)), m && (q.setVertexCount(K), q.shaderInputs.setProps({
      column: {
        ...de,
        isStroke: !1
      }
    }), q.draw(this.context.renderPass)), !u && y && (q.setVertexCount(K * 2 / 3), q.shaderInputs.setProps({
      column: {
        ...de,
        isStroke: !0
      }
    }), q.draw(this.context.renderPass));
  }
}
dc.layerName = "ColumnLayer";
dc.defaultProps = rie;
const nie = {
  cellSize: { type: "number", min: 0, value: 1e3 },
  offset: { type: "array", value: [1, 1] }
};
let Ew = class extends dc {
  _updateGeometry() {
    const e = new n6();
    this.state.fillModel.setGeometry(e);
  }
  draw({ uniforms: e }) {
    const { elevationScale: t, extruded: n, offset: i, coverage: s, cellSize: o, angle: l, radiusUnits: u } = this.props, m = this.state.fillModel, y = {
      radius: o / 2,
      radiusUnits: ko[u],
      angle: l,
      offset: i,
      extruded: n,
      stroked: !1,
      coverage: s,
      elevationScale: t,
      edgeDistance: 1,
      isStroke: !1,
      widthUnits: 0,
      widthScale: 0,
      widthMinPixels: 0,
      widthMaxPixels: 0
    };
    m.shaderInputs.setProps({ column: y }), m.draw(this.context.renderPass);
  }
};
Ew.layerName = "GridCellLayer";
Ew.defaultProps = nie;
function iie(r, e, t, n) {
  let i;
  if (Array.isArray(r[0])) {
    const s = r.length * e;
    i = new Array(s);
    for (let o = 0; o < r.length; o++)
      for (let l = 0; l < e; l++)
        i[o * e + l] = r[o][l] || 0;
  } else
    i = r;
  return t ? RD(i, { size: e, gridResolution: t }) : n ? qne(i, { size: e }) : i;
}
const sie = 1, oie = 2, u1 = 4;
class aie extends D6 {
  constructor(e) {
    super({
      ...e,
      attributes: {
        // Padding covers shaderAttributes for last segment in largest case fp64
        // additional vertex + hi & low parts, 3 * 6
        positions: {
          size: 3,
          padding: 18,
          initialize: !0,
          type: e.fp64 ? Float64Array : Float32Array
        },
        segmentTypes: { size: 1, type: Uint8ClampedArray }
      }
    });
  }
  /** Get packed attribute by name */
  get(e) {
    return this.attributes[e];
  }
  /* Implement base Tesselator interface */
  getGeometryFromBuffer(e) {
    return this.normalize ? super.getGeometryFromBuffer(e) : null;
  }
  /* Implement base Tesselator interface */
  normalizeGeometry(e) {
    return this.normalize ? iie(e, this.positionSize, this.opts.resolution, this.opts.wrapLongitude) : e;
  }
  /* Implement base Tesselator interface */
  getGeometrySize(e) {
    if (eP(e)) {
      let n = 0;
      for (const i of e)
        n += this.getGeometrySize(i);
      return n;
    }
    const t = this.getPathLength(e);
    return t < 2 ? 0 : this.isClosed(e) ? t < 3 ? 0 : t + 2 : t;
  }
  /* Implement base Tesselator interface */
  updateGeometryAttributes(e, t) {
    if (t.geometrySize !== 0)
      if (e && eP(e))
        for (const n of e) {
          const i = this.getGeometrySize(n);
          t.geometrySize = i, this.updateGeometryAttributes(n, t), t.vertexStart += i;
        }
      else
        this._updateSegmentTypes(e, t), this._updatePositions(e, t);
  }
  _updateSegmentTypes(e, t) {
    const n = this.attributes.segmentTypes, i = e ? this.isClosed(e) : !1, { vertexStart: s, geometrySize: o } = t;
    n.fill(0, s, s + o), i ? (n[s] = u1, n[s + o - 2] = u1) : (n[s] += sie, n[s + o - 2] += oie), n[s + o - 1] = u1;
  }
  _updatePositions(e, t) {
    const { positions: n } = this.attributes;
    if (!n || !e)
      return;
    const { vertexStart: i, geometrySize: s } = t, o = new Array(3);
    for (let l = i, u = 0; u < s; l++, u++)
      this.getPointOnPath(e, u, o), n[l * 3] = o[0], n[l * 3 + 1] = o[1], n[l * 3 + 2] = o[2];
  }
  // Utilities
  /** Returns the number of points in the path */
  getPathLength(e) {
    return e.length / this.positionSize;
  }
  /** Returns a point on the path at the specified index */
  getPointOnPath(e, t, n = []) {
    const { positionSize: i } = this;
    t * i >= e.length && (t += 1 - e.length / i);
    const s = t * i;
    return n[0] = e[s], n[1] = e[s + 1], n[2] = i === 3 && e[s + 2] || 0, n;
  }
  // Returns true if the first and last points are identical
  isClosed(e) {
    if (!this.normalize)
      return !!this.opts.loop;
    const { positionSize: t } = this, n = e.length - t;
    return e[0] === e[n] && e[1] === e[n + 1] && (t === 2 || e[2] === e[n + 2]);
  }
}
function eP(r) {
  return Array.isArray(r[0]);
}
const tP = `uniform pathUniforms {
  float widthScale;
  float widthMinPixels;
  float widthMaxPixels;
  float jointType;
  float capType;
  float miterLimit;
  bool billboard;
  highp int widthUnits;
} path;
`, lie = {
  name: "path",
  vs: tP,
  fs: tP,
  uniformTypes: {
    widthScale: "f32",
    widthMinPixels: "f32",
    widthMaxPixels: "f32",
    jointType: "f32",
    capType: "f32",
    miterLimit: "f32",
    billboard: "f32",
    widthUnits: "i32"
  }
}, cie = `#version 300 es
#define SHADER_NAME path-layer-vertex-shader
in vec2 positions;
in float instanceTypes;
in vec3 instanceStartPositions;
in vec3 instanceEndPositions;
in vec3 instanceLeftPositions;
in vec3 instanceRightPositions;
in vec3 instanceLeftPositions64Low;
in vec3 instanceStartPositions64Low;
in vec3 instanceEndPositions64Low;
in vec3 instanceRightPositions64Low;
in float instanceStrokeWidths;
in vec4 instanceColors;
in vec3 instancePickingColors;
uniform float opacity;
out vec4 vColor;
out vec2 vCornerOffset;
out float vMiterLength;
out vec2 vPathPosition;
out float vPathLength;
out float vJointType;
const float EPSILON = 0.001;
const vec3 ZERO_OFFSET = vec3(0.0);
float flipIfTrue(bool flag) {
return -(float(flag) * 2. - 1.);
}
vec3 getLineJoinOffset(
vec3 prevPoint, vec3 currPoint, vec3 nextPoint,
vec2 width
) {
bool isEnd = positions.x > 0.0;
float sideOfPath = positions.y;
float isJoint = float(sideOfPath == 0.0);
vec3 deltaA3 = (currPoint - prevPoint);
vec3 deltaB3 = (nextPoint - currPoint);
mat3 rotationMatrix;
bool needsRotation = !path.billboard && project_needs_rotation(currPoint, rotationMatrix);
if (needsRotation) {
deltaA3 = deltaA3 * rotationMatrix;
deltaB3 = deltaB3 * rotationMatrix;
}
vec2 deltaA = deltaA3.xy / width;
vec2 deltaB = deltaB3.xy / width;
float lenA = length(deltaA);
float lenB = length(deltaB);
vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);
vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);
vec2 perpA = vec2(-dirA.y, dirA.x);
vec2 perpB = vec2(-dirB.y, dirB.x);
vec2 tangent = dirA + dirB;
tangent = length(tangent) > 0. ? normalize(tangent) : perpA;
vec2 miterVec = vec2(-tangent.y, tangent.x);
vec2 dir = isEnd ? dirA : dirB;
vec2 perp = isEnd ? perpA : perpB;
float L = isEnd ? lenA : lenB;
float sinHalfA = abs(dot(miterVec, perp));
float cosHalfA = abs(dot(dirA, miterVec));
float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);
float cornerPosition = sideOfPath * turnDirection;
float miterSize = 1.0 / max(sinHalfA, EPSILON);
miterSize = mix(
min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),
miterSize,
step(0.0, cornerPosition)
);
vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))
* (sideOfPath + isJoint * turnDirection);
bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));
bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));
bool isCap = isStartCap || isEndCap;
if (isCap) {
offsetVec = mix(perp * sideOfPath, dir * path.capType * 4.0 * flipIfTrue(isStartCap), isJoint);
vJointType = path.capType;
} else {
vJointType = path.jointType;
}
vPathLength = L;
vCornerOffset = offsetVec;
vMiterLength = dot(vCornerOffset, miterVec * turnDirection);
vMiterLength = isCap ? isJoint : vMiterLength;
vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);
vPathPosition = vec2(
dot(offsetFromStartOfPath, perp),
dot(offsetFromStartOfPath, dir)
);
geometry.uv = vPathPosition;
float isValid = step(instanceTypes, 3.5);
vec3 offset = vec3(offsetVec * width * isValid, 0.0);
if (needsRotation) {
offset = rotationMatrix * offset;
}
return offset;
}
void clipLine(inout vec4 position, vec4 refPosition) {
if (position.w < EPSILON) {
float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);
position = refPosition + (position - refPosition) * r;
}
}
void main() {
geometry.pickingColor = instancePickingColors;
vColor = vec4(instanceColors.rgb, instanceColors.a * layer.opacity);
float isEnd = positions.x;
vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);
vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);
vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);
vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);
vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);
vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);
geometry.worldPosition = currPosition;
vec2 widthPixels = vec2(clamp(
project_size_to_pixel(instanceStrokeWidths * path.widthScale, path.widthUnits),
path.widthMinPixels, path.widthMaxPixels) / 2.0);
vec3 width;
if (path.billboard) {
vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);
vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);
vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);
clipLine(prevPositionScreen, currPositionScreen);
clipLine(nextPositionScreen, currPositionScreen);
clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));
width = vec3(widthPixels, 0.0);
DECKGL_FILTER_SIZE(width, geometry);
vec3 offset = getLineJoinOffset(
prevPositionScreen.xyz / prevPositionScreen.w,
currPositionScreen.xyz / currPositionScreen.w,
nextPositionScreen.xyz / nextPositionScreen.w,
project_pixel_size_to_clipspace(width.xy)
);
DECKGL_FILTER_GL_POSITION(currPositionScreen, geometry);
gl_Position = vec4(currPositionScreen.xyz + offset * currPositionScreen.w, currPositionScreen.w);
} else {
prevPosition = project_position(prevPosition, prevPosition64Low);
currPosition = project_position(currPosition, currPosition64Low);
nextPosition = project_position(nextPosition, nextPosition64Low);
width = vec3(project_pixel_size(widthPixels), 0.0);
DECKGL_FILTER_SIZE(width, geometry);
vec3 offset = getLineJoinOffset(prevPosition, currPosition, nextPosition, width.xy);
geometry.position = vec4(currPosition + offset, 1.0);
gl_Position = project_common_position_to_clipspace(geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, uie = `#version 300 es
#define SHADER_NAME path-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 vCornerOffset;
in float vMiterLength;
in vec2 vPathPosition;
in float vPathLength;
in float vJointType;
out vec4 fragColor;
void main(void) {
geometry.uv = vPathPosition;
if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {
if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {
discard;
}
if (vJointType < 0.5 && vMiterLength > path.miterLimit + 1.0) {
discard;
}
}
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`, kD = [0, 0, 0, 255], fie = {
  widthUnits: "meters",
  widthScale: { type: "number", min: 0, value: 1 },
  widthMinPixels: { type: "number", min: 0, value: 0 },
  widthMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
  jointRounded: !1,
  capRounded: !1,
  miterLimit: { type: "number", min: 0, value: 4 },
  billboard: !1,
  _pathType: null,
  getPath: { type: "accessor", value: (r) => r.path },
  getColor: { type: "accessor", value: kD },
  getWidth: { type: "accessor", value: 1 },
  // deprecated props
  rounded: { deprecatedFor: ["jointRounded", "capRounded"] }
}, f1 = {
  enter: (r, e) => e.length ? e.subarray(e.length - r.length) : r
};
class nf extends Is {
  getShaders() {
    return super.getShaders({ vs: cie, fs: uie, modules: [Ws, ga, lie] });
  }
  get wrapLongitude() {
    return !1;
  }
  getBounds() {
    return this.getAttributeManager()?.getBounds(["vertexPositions"]);
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      vertexPositions: {
        size: 3,
        // Start filling buffer from 1 vertex in
        vertexOffset: 1,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: f1,
        accessor: "getPath",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculatePositions,
        noAlloc: !0,
        shaderAttributes: {
          instanceLeftPositions: {
            vertexOffset: 0
          },
          instanceStartPositions: {
            vertexOffset: 1
          },
          instanceEndPositions: {
            vertexOffset: 2
          },
          instanceRightPositions: {
            vertexOffset: 3
          }
        }
      },
      instanceTypes: {
        size: 1,
        type: "uint8",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculateSegmentTypes,
        noAlloc: !0
      },
      instanceStrokeWidths: {
        size: 1,
        accessor: "getWidth",
        transition: f1,
        defaultValue: 1
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        accessor: "getColor",
        transition: f1,
        defaultValue: kD
      },
      instancePickingColors: {
        size: 4,
        type: "uint8",
        accessor: (n, { index: i, target: s }) => this.encodePickingColor(n && n.__source ? n.__source.index : i, s)
      }
    }), this.setState({
      pathTesselator: new aie({
        fp64: this.use64bitPositions()
      })
    });
  }
  updateState(e) {
    super.updateState(e);
    const { props: t, changeFlags: n } = e, i = this.getAttributeManager();
    if (n.dataChanged || n.updateTriggersChanged && (n.updateTriggersChanged.all || n.updateTriggersChanged.getPath)) {
      const { pathTesselator: o } = this.state, l = t.data.attributes || {};
      o.updateGeometry({
        data: t.data,
        geometryBuffer: l.getPath,
        buffers: l,
        normalize: !t._pathType,
        loop: t._pathType === "loop",
        getGeometry: t.getPath,
        positionFormat: t.positionFormat,
        wrapLongitude: t.wrapLongitude,
        // TODO - move the flag out of the viewport
        resolution: this.context.viewport.resolution,
        dataChanged: n.dataChanged
      }), this.setState({
        numInstances: o.instanceCount,
        startIndices: o.vertexStarts
      }), n.dataChanged || i.invalidateAll();
    }
    n.extensionsChanged && (this.state.model?.destroy(), this.state.model = this._getModel(), i.invalidateAll());
  }
  getPickingInfo(e) {
    const t = super.getPickingInfo(e), { index: n } = t, i = this.props.data;
    return i[0] && i[0].__source && (t.object = i.find((s) => s.__source.index === n)), t;
  }
  /** Override base Layer method */
  disablePickingIndex(e) {
    const t = this.props.data;
    if (t[0] && t[0].__source)
      for (let n = 0; n < t.length; n++)
        t[n].__source.index === e && this._disablePickingIndex(n);
    else
      super.disablePickingIndex(e);
  }
  draw({ uniforms: e }) {
    const { jointRounded: t, capRounded: n, billboard: i, miterLimit: s, widthUnits: o, widthScale: l, widthMinPixels: u, widthMaxPixels: m } = this.props, y = this.state.model, E = {
      jointType: Number(t),
      capType: Number(n),
      billboard: i,
      widthUnits: ko[o],
      widthScale: l,
      miterLimit: s,
      widthMinPixels: u,
      widthMaxPixels: m
    };
    y.shaderInputs.setProps({ path: E }), y.draw(this.context.renderPass);
  }
  _getModel() {
    const e = [
      // start corner
      0,
      1,
      2,
      // body
      1,
      4,
      2,
      1,
      3,
      4,
      // end corner
      3,
      5,
      4
    ], t = [
      // bevel start corner
      0,
      0,
      // start inner corner
      0,
      -1,
      // start outer corner
      0,
      1,
      // end inner corner
      1,
      -1,
      // end outer corner
      1,
      1,
      // bevel end corner
      1,
      0
    ];
    return new Bi(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new no({
        topology: "triangle-list",
        attributes: {
          indices: new Uint16Array(e),
          positions: { value: new Float32Array(t), size: 2 }
        }
      }),
      isInstanced: !0
    });
  }
  calculatePositions(e) {
    const { pathTesselator: t } = this.state;
    e.startIndices = t.vertexStarts, e.value = t.get("positions");
  }
  calculateSegmentTypes(e) {
    const { pathTesselator: t } = this.state;
    e.startIndices = t.vertexStarts, e.value = t.get("segmentTypes");
  }
}
nf.defaultProps = fie;
nf.layerName = "PathLayer";
var Fg = { exports: {} }, rP;
function hie() {
  if (rP) return Fg.exports;
  rP = 1, Fg.exports = r, Fg.exports.default = r;
  function r(be, Ue, Xe) {
    Xe = Xe || 2;
    var lt = Ue && Ue.length, at = lt ? Ue[0] * Xe : be.length, ct = e(be, 0, at, Xe, !0), gt = [];
    if (!ct || ct.next === ct.prev) return gt;
    var St, Ot, dt, _r, sr, tr, Wt;
    if (lt && (ct = u(be, Ue, ct, Xe)), be.length > 80 * Xe) {
      St = dt = be[0], Ot = _r = be[1];
      for (var yr = Xe; yr < at; yr += Xe)
        sr = be[yr], tr = be[yr + 1], sr < St && (St = sr), tr < Ot && (Ot = tr), sr > dt && (dt = sr), tr > _r && (_r = tr);
      Wt = Math.max(dt - St, _r - Ot), Wt = Wt !== 0 ? 32767 / Wt : 0;
    }
    return n(ct, gt, Xe, St, Ot, Wt, 0), gt;
  }
  function e(be, Ue, Xe, lt, at) {
    var ct, gt;
    if (at === ot(be, Ue, Xe, lt) > 0)
      for (ct = Ue; ct < Xe; ct += lt) gt = X(ct, be[ct], be[ct + 1], gt);
    else
      for (ct = Xe - lt; ct >= Ue; ct -= lt) gt = X(ct, be[ct], be[ct + 1], gt);
    return gt && de(gt, gt.next) && (re(gt), gt = gt.next), gt;
  }
  function t(be, Ue) {
    if (!be) return be;
    Ue || (Ue = be);
    var Xe = be, lt;
    do
      if (lt = !1, !Xe.steiner && (de(Xe, Xe.next) || Y(Xe.prev, Xe, Xe.next) === 0)) {
        if (re(Xe), Xe = Ue = Xe.prev, Xe === Xe.next) break;
        lt = !0;
      } else
        Xe = Xe.next;
    while (lt || Xe !== Ue);
    return Ue;
  }
  function n(be, Ue, Xe, lt, at, ct, gt) {
    if (be) {
      !gt && ct && L(be, lt, at, ct);
      for (var St = be, Ot, dt; be.prev !== be.next; ) {
        if (Ot = be.prev, dt = be.next, ct ? s(be, lt, at, ct) : i(be)) {
          Ue.push(Ot.i / Xe | 0), Ue.push(be.i / Xe | 0), Ue.push(dt.i / Xe | 0), re(be), be = dt.next, St = dt.next;
          continue;
        }
        if (be = dt, be === St) {
          gt ? gt === 1 ? (be = o(t(be), Ue, Xe), n(be, Ue, Xe, lt, at, ct, 2)) : gt === 2 && l(be, Ue, Xe, lt, at, ct) : n(t(be), Ue, Xe, lt, at, ct, 1);
          break;
        }
      }
    }
  }
  function i(be) {
    var Ue = be.prev, Xe = be, lt = be.next;
    if (Y(Ue, Xe, lt) >= 0) return !1;
    for (var at = Ue.x, ct = Xe.x, gt = lt.x, St = Ue.y, Ot = Xe.y, dt = lt.y, _r = at < ct ? at < gt ? at : gt : ct < gt ? ct : gt, sr = St < Ot ? St < dt ? St : dt : Ot < dt ? Ot : dt, tr = at > ct ? at > gt ? at : gt : ct > gt ? ct : gt, Wt = St > Ot ? St > dt ? St : dt : Ot > dt ? Ot : dt, yr = lt.next; yr !== Ue; ) {
      if (yr.x >= _r && yr.x <= tr && yr.y >= sr && yr.y <= Wt && j(at, St, ct, Ot, gt, dt, yr.x, yr.y) && Y(yr.prev, yr, yr.next) >= 0) return !1;
      yr = yr.next;
    }
    return !0;
  }
  function s(be, Ue, Xe, lt) {
    var at = be.prev, ct = be, gt = be.next;
    if (Y(at, ct, gt) >= 0) return !1;
    for (var St = at.x, Ot = ct.x, dt = gt.x, _r = at.y, sr = ct.y, tr = gt.y, Wt = St < Ot ? St < dt ? St : dt : Ot < dt ? Ot : dt, yr = _r < sr ? _r < tr ? _r : tr : sr < tr ? sr : tr, An = St > Ot ? St > dt ? St : dt : Ot > dt ? Ot : dt, Fr = _r > sr ? _r > tr ? _r : tr : sr > tr ? sr : tr, Pr = V(Wt, yr, Ue, Xe, lt), $n = V(An, Fr, Ue, Xe, lt), xr = be.prevZ, wr = be.nextZ; xr && xr.z >= Pr && wr && wr.z <= $n; ) {
      if (xr.x >= Wt && xr.x <= An && xr.y >= yr && xr.y <= Fr && xr !== at && xr !== gt && j(St, _r, Ot, sr, dt, tr, xr.x, xr.y) && Y(xr.prev, xr, xr.next) >= 0 || (xr = xr.prevZ, wr.x >= Wt && wr.x <= An && wr.y >= yr && wr.y <= Fr && wr !== at && wr !== gt && j(St, _r, Ot, sr, dt, tr, wr.x, wr.y) && Y(wr.prev, wr, wr.next) >= 0)) return !1;
      wr = wr.nextZ;
    }
    for (; xr && xr.z >= Pr; ) {
      if (xr.x >= Wt && xr.x <= An && xr.y >= yr && xr.y <= Fr && xr !== at && xr !== gt && j(St, _r, Ot, sr, dt, tr, xr.x, xr.y) && Y(xr.prev, xr, xr.next) >= 0) return !1;
      xr = xr.prevZ;
    }
    for (; wr && wr.z <= $n; ) {
      if (wr.x >= Wt && wr.x <= An && wr.y >= yr && wr.y <= Fr && wr !== at && wr !== gt && j(St, _r, Ot, sr, dt, tr, wr.x, wr.y) && Y(wr.prev, wr, wr.next) >= 0) return !1;
      wr = wr.nextZ;
    }
    return !0;
  }
  function o(be, Ue, Xe) {
    var lt = be;
    do {
      var at = lt.prev, ct = lt.next.next;
      !de(at, ct) && ne(at, lt, lt.next, ct) && fe(at, ct) && fe(ct, at) && (Ue.push(at.i / Xe | 0), Ue.push(lt.i / Xe | 0), Ue.push(ct.i / Xe | 0), re(lt), re(lt.next), lt = be = ct), lt = lt.next;
    } while (lt !== be);
    return t(lt);
  }
  function l(be, Ue, Xe, lt, at, ct) {
    var gt = be;
    do {
      for (var St = gt.next.next; St !== gt.prev; ) {
        if (gt.i !== St.i && K(gt, St)) {
          var Ot = me(gt, St);
          gt = t(gt, gt.next), Ot = t(Ot, Ot.next), n(gt, Ue, Xe, lt, at, ct, 0), n(Ot, Ue, Xe, lt, at, ct, 0);
          return;
        }
        St = St.next;
      }
      gt = gt.next;
    } while (gt !== be);
  }
  function u(be, Ue, Xe, lt) {
    var at = [], ct, gt, St, Ot, dt;
    for (ct = 0, gt = Ue.length; ct < gt; ct++)
      St = Ue[ct] * lt, Ot = ct < gt - 1 ? Ue[ct + 1] * lt : be.length, dt = e(be, St, Ot, lt, !1), dt === dt.next && (dt.steiner = !0), at.push(q(dt));
    for (at.sort(m), ct = 0; ct < at.length; ct++)
      Xe = y(at[ct], Xe);
    return Xe;
  }
  function m(be, Ue) {
    return be.x - Ue.x;
  }
  function y(be, Ue) {
    var Xe = E(be, Ue);
    if (!Xe)
      return Ue;
    var lt = me(Xe, be);
    return t(lt, lt.next), t(Xe, Xe.next);
  }
  function E(be, Ue) {
    var Xe = Ue, lt = be.x, at = be.y, ct = -1 / 0, gt;
    do {
      if (at <= Xe.y && at >= Xe.next.y && Xe.next.y !== Xe.y) {
        var St = Xe.x + (at - Xe.y) * (Xe.next.x - Xe.x) / (Xe.next.y - Xe.y);
        if (St <= lt && St > ct && (ct = St, gt = Xe.x < Xe.next.x ? Xe : Xe.next, St === lt))
          return gt;
      }
      Xe = Xe.next;
    } while (Xe !== Ue);
    if (!gt) return null;
    var Ot = gt, dt = gt.x, _r = gt.y, sr = 1 / 0, tr;
    Xe = gt;
    do
      lt >= Xe.x && Xe.x >= dt && lt !== Xe.x && j(at < _r ? lt : ct, at, dt, _r, at < _r ? ct : lt, at, Xe.x, Xe.y) && (tr = Math.abs(at - Xe.y) / (lt - Xe.x), fe(Xe, be) && (tr < sr || tr === sr && (Xe.x > gt.x || Xe.x === gt.x && P(gt, Xe))) && (gt = Xe, sr = tr)), Xe = Xe.next;
    while (Xe !== Ot);
    return gt;
  }
  function P(be, Ue) {
    return Y(be.prev, be, Ue.prev) < 0 && Y(Ue.next, be, be.next) < 0;
  }
  function L(be, Ue, Xe, lt) {
    var at = be;
    do
      at.z === 0 && (at.z = V(at.x, at.y, Ue, Xe, lt)), at.prevZ = at.prev, at.nextZ = at.next, at = at.next;
    while (at !== be);
    at.prevZ.nextZ = null, at.prevZ = null, U(at);
  }
  function U(be) {
    var Ue, Xe, lt, at, ct, gt, St, Ot, dt = 1;
    do {
      for (Xe = be, be = null, ct = null, gt = 0; Xe; ) {
        for (gt++, lt = Xe, St = 0, Ue = 0; Ue < dt && (St++, lt = lt.nextZ, !!lt); Ue++)
          ;
        for (Ot = dt; St > 0 || Ot > 0 && lt; )
          St !== 0 && (Ot === 0 || !lt || Xe.z <= lt.z) ? (at = Xe, Xe = Xe.nextZ, St--) : (at = lt, lt = lt.nextZ, Ot--), ct ? ct.nextZ = at : be = at, at.prevZ = ct, ct = at;
        Xe = lt;
      }
      ct.nextZ = null, dt *= 2;
    } while (gt > 1);
    return be;
  }
  function V(be, Ue, Xe, lt, at) {
    return be = (be - Xe) * at | 0, Ue = (Ue - lt) * at | 0, be = (be | be << 8) & 16711935, be = (be | be << 4) & 252645135, be = (be | be << 2) & 858993459, be = (be | be << 1) & 1431655765, Ue = (Ue | Ue << 8) & 16711935, Ue = (Ue | Ue << 4) & 252645135, Ue = (Ue | Ue << 2) & 858993459, Ue = (Ue | Ue << 1) & 1431655765, be | Ue << 1;
  }
  function q(be) {
    var Ue = be, Xe = be;
    do
      (Ue.x < Xe.x || Ue.x === Xe.x && Ue.y < Xe.y) && (Xe = Ue), Ue = Ue.next;
    while (Ue !== be);
    return Xe;
  }
  function j(be, Ue, Xe, lt, at, ct, gt, St) {
    return (at - gt) * (Ue - St) >= (be - gt) * (ct - St) && (be - gt) * (lt - St) >= (Xe - gt) * (Ue - St) && (Xe - gt) * (ct - St) >= (at - gt) * (lt - St);
  }
  function K(be, Ue) {
    return be.next.i !== Ue.i && be.prev.i !== Ue.i && !Ge(be, Ue) && // dones't intersect other edges
    (fe(be, Ue) && fe(Ue, be) && ve(be, Ue) && // locally visible
    (Y(be.prev, be, Ue.prev) || Y(be, Ue.prev, Ue)) || // does not create opposite-facing sectors
    de(be, Ue) && Y(be.prev, be, be.next) > 0 && Y(Ue.prev, Ue, Ue.next) > 0);
  }
  function Y(be, Ue, Xe) {
    return (Ue.y - be.y) * (Xe.x - Ue.x) - (Ue.x - be.x) * (Xe.y - Ue.y);
  }
  function de(be, Ue) {
    return be.x === Ue.x && be.y === Ue.y;
  }
  function ne(be, Ue, Xe, lt) {
    var at = De(Y(be, Ue, Xe)), ct = De(Y(be, Ue, lt)), gt = De(Y(Xe, lt, be)), St = De(Y(Xe, lt, Ue));
    return !!(at !== ct && gt !== St || at === 0 && ae(be, Xe, Ue) || ct === 0 && ae(be, lt, Ue) || gt === 0 && ae(Xe, be, lt) || St === 0 && ae(Xe, Ue, lt));
  }
  function ae(be, Ue, Xe) {
    return Ue.x <= Math.max(be.x, Xe.x) && Ue.x >= Math.min(be.x, Xe.x) && Ue.y <= Math.max(be.y, Xe.y) && Ue.y >= Math.min(be.y, Xe.y);
  }
  function De(be) {
    return be > 0 ? 1 : be < 0 ? -1 : 0;
  }
  function Ge(be, Ue) {
    var Xe = be;
    do {
      if (Xe.i !== be.i && Xe.next.i !== be.i && Xe.i !== Ue.i && Xe.next.i !== Ue.i && ne(Xe, Xe.next, be, Ue)) return !0;
      Xe = Xe.next;
    } while (Xe !== be);
    return !1;
  }
  function fe(be, Ue) {
    return Y(be.prev, be, be.next) < 0 ? Y(be, Ue, be.next) >= 0 && Y(be, be.prev, Ue) >= 0 : Y(be, Ue, be.prev) < 0 || Y(be, be.next, Ue) < 0;
  }
  function ve(be, Ue) {
    var Xe = be, lt = !1, at = (be.x + Ue.x) / 2, ct = (be.y + Ue.y) / 2;
    do
      Xe.y > ct != Xe.next.y > ct && Xe.next.y !== Xe.y && at < (Xe.next.x - Xe.x) * (ct - Xe.y) / (Xe.next.y - Xe.y) + Xe.x && (lt = !lt), Xe = Xe.next;
    while (Xe !== be);
    return lt;
  }
  function me(be, Ue) {
    var Xe = new Me(be.i, be.x, be.y), lt = new Me(Ue.i, Ue.x, Ue.y), at = be.next, ct = Ue.prev;
    return be.next = Ue, Ue.prev = be, Xe.next = at, at.prev = Xe, lt.next = Xe, Xe.prev = lt, ct.next = lt, lt.prev = ct, lt;
  }
  function X(be, Ue, Xe, lt) {
    var at = new Me(be, Ue, Xe);
    return lt ? (at.next = lt.next, at.prev = lt, lt.next.prev = at, lt.next = at) : (at.prev = at, at.next = at), at;
  }
  function re(be) {
    be.next.prev = be.prev, be.prev.next = be.next, be.prevZ && (be.prevZ.nextZ = be.nextZ), be.nextZ && (be.nextZ.prevZ = be.prevZ);
  }
  function Me(be, Ue, Xe) {
    this.i = be, this.x = Ue, this.y = Xe, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
  }
  r.deviation = function(be, Ue, Xe, lt) {
    var at = Ue && Ue.length, ct = at ? Ue[0] * Xe : be.length, gt = Math.abs(ot(be, 0, ct, Xe));
    if (at)
      for (var St = 0, Ot = Ue.length; St < Ot; St++) {
        var dt = Ue[St] * Xe, _r = St < Ot - 1 ? Ue[St + 1] * Xe : be.length;
        gt -= Math.abs(ot(be, dt, _r, Xe));
      }
    var sr = 0;
    for (St = 0; St < lt.length; St += 3) {
      var tr = lt[St] * Xe, Wt = lt[St + 1] * Xe, yr = lt[St + 2] * Xe;
      sr += Math.abs(
        (be[tr] - be[yr]) * (be[Wt + 1] - be[tr + 1]) - (be[tr] - be[Wt]) * (be[yr + 1] - be[tr + 1])
      );
    }
    return gt === 0 && sr === 0 ? 0 : Math.abs((sr - gt) / gt);
  };
  function ot(be, Ue, Xe, lt) {
    for (var at = 0, ct = Ue, gt = Xe - lt; ct < Xe; ct += lt)
      at += (be[gt] - be[ct]) * (be[ct + 1] + be[gt + 1]), gt = ct;
    return at;
  }
  return r.flatten = function(be) {
    for (var Ue = be[0][0].length, Xe = { vertices: [], holes: [], dimensions: Ue }, lt = 0, at = 0; at < be.length; at++) {
      for (var ct = 0; ct < be[at].length; ct++)
        for (var gt = 0; gt < Ue; gt++) Xe.vertices.push(be[at][ct][gt]);
      at > 0 && (lt += be[at - 1].length, Xe.holes.push(lt));
    }
    return Xe;
  }, Fg.exports;
}
var die = hie();
const FD = /* @__PURE__ */ dh(die), Ng = ww.CLOCKWISE, nP = ww.COUNTER_CLOCKWISE, Wu = {};
function pie(r) {
  if (r = r && r.positions || r, !Array.isArray(r) && !ArrayBuffer.isView(r))
    throw new Error("invalid polygon");
}
function LA(r) {
  return "positions" in r ? r.positions : r;
}
function Mm(r) {
  return "holeIndices" in r ? r.holeIndices : null;
}
function Aie(r) {
  return Array.isArray(r[0]);
}
function gie(r) {
  return r.length >= 1 && r[0].length >= 2 && Number.isFinite(r[0][0]);
}
function mie(r) {
  const e = r[0], t = r[r.length - 1];
  return e[0] === t[0] && e[1] === t[1] && e[2] === t[2];
}
function _ie(r, e, t, n) {
  for (let i = 0; i < e; i++)
    if (r[t + i] !== r[n - e + i])
      return !1;
  return !0;
}
function iP(r, e, t, n, i) {
  let s = e;
  const o = t.length;
  for (let l = 0; l < o; l++)
    for (let u = 0; u < n; u++)
      r[s++] = t[l][u] || 0;
  if (!mie(t))
    for (let l = 0; l < n; l++)
      r[s++] = t[0][l] || 0;
  return Wu.start = e, Wu.end = s, Wu.size = n, Tw(r, i, Wu), s;
}
function sP(r, e, t, n, i = 0, s, o) {
  s = s || t.length;
  const l = s - i;
  if (l <= 0)
    return e;
  let u = e;
  for (let m = 0; m < l; m++)
    r[u++] = t[i + m];
  if (!_ie(t, n, i, s))
    for (let m = 0; m < n; m++)
      r[u++] = t[i + m];
  return Wu.start = e, Wu.end = u, Wu.size = n, Tw(r, o, Wu), u;
}
function ND(r, e) {
  pie(r);
  const t = [], n = [];
  if ("positions" in r) {
    const { positions: i, holeIndices: s } = r;
    if (s) {
      let o = 0;
      for (let l = 0; l <= s.length; l++)
        o = sP(t, o, i, e, s[l - 1], s[l], l === 0 ? Ng : nP), n.push(o);
      return n.pop(), { positions: t, holeIndices: n };
    }
    r = i;
  }
  if (!Aie(r))
    return sP(t, 0, r, e, 0, t.length, Ng), t;
  if (!gie(r)) {
    let i = 0;
    for (const [s, o] of r.entries())
      i = iP(t, i, o, e, s === 0 ? Ng : nP), n.push(i);
    return n.pop(), { positions: t, holeIndices: n };
  }
  return iP(t, 0, r, e, Ng), t;
}
function h1(r, e, t) {
  const n = r.length / 3;
  let i = 0;
  for (let s = 0; s < n; s++) {
    const o = (s + 1) % n;
    i += r[s * 3 + e] * r[o * 3 + t], i -= r[o * 3 + e] * r[s * 3 + t];
  }
  return Math.abs(i / 2);
}
function oP(r, e, t, n) {
  const i = r.length / 3;
  for (let s = 0; s < i; s++) {
    const o = s * 3, l = r[o + 0], u = r[o + 1], m = r[o + 2];
    r[o + e] = l, r[o + t] = u, r[o + n] = m;
  }
}
function yie(r, e, t, n) {
  let i = Mm(r);
  i && (i = i.map((l) => l / e));
  let s = LA(r);
  const o = n && e === 3;
  if (t) {
    const l = s.length;
    s = s.slice();
    const u = [];
    for (let m = 0; m < l; m += e) {
      u[0] = s[m], u[1] = s[m + 1], o && (u[2] = s[m + 2]);
      const y = t(u);
      s[m] = y[0], s[m + 1] = y[1], o && (s[m + 2] = y[2]);
    }
  }
  if (o) {
    const l = h1(s, 0, 1), u = h1(s, 0, 2), m = h1(s, 1, 2);
    if (!l && !u && !m)
      return [];
    l > u && l > m || (u > m ? (t || (s = s.slice()), oP(s, 0, 2, 1)) : (t || (s = s.slice()), oP(s, 2, 0, 1)));
  }
  return FD(s, i, e);
}
class vie extends D6 {
  constructor(e) {
    const { fp64: t, IndexType: n = Uint32Array } = e;
    super({
      ...e,
      attributes: {
        positions: { size: 3, type: t ? Float64Array : Float32Array },
        vertexValid: { type: Uint16Array, size: 1 },
        indices: { type: n, size: 1 }
      }
    });
  }
  /** Get attribute by name */
  get(e) {
    const { attributes: t } = this;
    return e === "indices" ? t.indices && t.indices.subarray(0, this.vertexCount) : t[e];
  }
  /** Override base Tesselator method */
  updateGeometry(e) {
    super.updateGeometry(e);
    const t = this.buffers.indices;
    if (t)
      this.vertexCount = (t.value || t).length;
    else if (this.data && !this.getGeometry)
      throw new Error("missing indices buffer");
  }
  /** Implement base Tesselator interface */
  normalizeGeometry(e) {
    if (this.normalize) {
      const t = ND(e, this.positionSize);
      return this.opts.resolution ? BD(LA(t), Mm(t), {
        size: this.positionSize,
        gridResolution: this.opts.resolution,
        edgeTypes: !0
      }) : this.opts.wrapLongitude ? Xne(LA(t), Mm(t), {
        size: this.positionSize,
        maxLatitude: 86,
        edgeTypes: !0
      }) : t;
    }
    return e;
  }
  /** Implement base Tesselator interface */
  getGeometrySize(e) {
    if (aP(e)) {
      let t = 0;
      for (const n of e)
        t += this.getGeometrySize(n);
      return t;
    }
    return LA(e).length / this.positionSize;
  }
  /** Override base Tesselator method */
  getGeometryFromBuffer(e) {
    return this.normalize || !this.buffers.indices ? super.getGeometryFromBuffer(e) : null;
  }
  /** Implement base Tesselator interface */
  updateGeometryAttributes(e, t) {
    if (e && aP(e))
      for (const n of e) {
        const i = this.getGeometrySize(n);
        t.geometrySize = i, this.updateGeometryAttributes(n, t), t.vertexStart += i, t.indexStart = this.indexStarts[t.geometryIndex + 1];
      }
    else {
      const n = e;
      this._updateIndices(n, t), this._updatePositions(n, t), this._updateVertexValid(n, t);
    }
  }
  // Flatten the indices array
  _updateIndices(e, { geometryIndex: t, vertexStart: n, indexStart: i }) {
    const { attributes: s, indexStarts: o, typedArrayManager: l } = this;
    let u = s.indices;
    if (!u || !e)
      return;
    let m = i;
    const y = yie(e, this.positionSize, this.opts.preproject, this.opts.full3d);
    u = l.allocate(u, i + y.length, {
      copy: !0
    });
    for (let E = 0; E < y.length; E++)
      u[m++] = y[E] + n;
    o[t + 1] = i + y.length, s.indices = u;
  }
  // Flatten out all the vertices of all the sub subPolygons
  _updatePositions(e, { vertexStart: t, geometrySize: n }) {
    const { attributes: { positions: i }, positionSize: s } = this;
    if (!i || !e)
      return;
    const o = LA(e);
    for (let l = t, u = 0; u < n; l++, u++) {
      const m = o[u * s], y = o[u * s + 1], E = s > 2 ? o[u * s + 2] : 0;
      i[l * 3] = m, i[l * 3 + 1] = y, i[l * 3 + 2] = E;
    }
  }
  _updateVertexValid(e, { vertexStart: t, geometrySize: n }) {
    const { positionSize: i } = this, s = this.attributes.vertexValid, o = e && Mm(e);
    if (e && e.edgeTypes ? s.set(e.edgeTypes, t) : s.fill(1, t, t + n), o)
      for (let l = 0; l < o.length; l++)
        s[t + o[l] / i - 1] = 0;
    s[t + n - 1] = 0;
  }
}
function aP(r) {
  return Array.isArray(r) && r.length > 0 && !Number.isFinite(r[0]);
}
const lP = `uniform solidPolygonUniforms {
  bool extruded;
  bool isWireframe;
  float elevationScale;
} solidPolygon;
`, bie = {
  name: "solidPolygon",
  vs: lP,
  fs: lP,
  uniformTypes: {
    extruded: "f32",
    isWireframe: "f32",
    elevationScale: "f32"
  }
}, UD = `in vec4 fillColors;
in vec4 lineColors;
in vec3 pickingColors;
out vec4 vColor;
struct PolygonProps {
vec3 positions;
vec3 positions64Low;
vec3 normal;
float elevations;
};
vec3 project_offset_normal(vec3 vector) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {
return normalize(vector * project.commonUnitsPerWorldUnit);
}
return project_normal(vector);
}
void calculatePosition(PolygonProps props) {
vec3 pos = props.positions;
vec3 pos64Low = props.positions64Low;
vec3 normal = props.normal;
vec4 colors = solidPolygon.isWireframe ? lineColors : fillColors;
geometry.worldPosition = props.positions;
geometry.pickingColor = pickingColors;
if (solidPolygon.extruded) {
pos.z += props.elevations * solidPolygon.elevationScale;
}
gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
if (solidPolygon.extruded) {
#ifdef IS_SIDE_VERTEX
normal = project_offset_normal(normal);
#else
normal = project_normal(normal);
#endif
geometry.normal = normal;
vec3 lightColor = lighting_getLightColor(colors.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, colors.a * layer.opacity);
} else {
vColor = vec4(colors.rgb, colors.a * layer.opacity);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, xie = `#version 300 es
#define SHADER_NAME solid-polygon-layer-vertex-shader
in vec3 vertexPositions;
in vec3 vertexPositions64Low;
in float elevations;
${UD}
void main(void) {
PolygonProps props;
props.positions = vertexPositions;
props.positions64Low = vertexPositions64Low;
props.elevations = elevations;
props.normal = vec3(0.0, 0.0, 1.0);
calculatePosition(props);
}
`, wie = `#version 300 es
#define SHADER_NAME solid-polygon-layer-vertex-shader-side
#define IS_SIDE_VERTEX
in vec2 positions;
in vec3 vertexPositions;
in vec3 nextVertexPositions;
in vec3 vertexPositions64Low;
in vec3 nextVertexPositions64Low;
in float elevations;
in float instanceVertexValid;
${UD}
void main(void) {
if(instanceVertexValid < 0.5){
gl_Position = vec4(0.);
return;
}
PolygonProps props;
vec3 pos;
vec3 pos64Low;
vec3 nextPos;
vec3 nextPos64Low;
#if RING_WINDING_ORDER_CW == 1
pos = vertexPositions;
pos64Low = vertexPositions64Low;
nextPos = nextVertexPositions;
nextPos64Low = nextVertexPositions64Low;
#else
pos = nextVertexPositions;
pos64Low = nextVertexPositions64Low;
nextPos = vertexPositions;
nextPos64Low = vertexPositions64Low;
#endif
props.positions = mix(pos, nextPos, positions.x);
props.positions64Low = mix(pos64Low, nextPos64Low, positions.x);
props.normal = vec3(
pos.y - nextPos.y + (pos64Low.y - nextPos64Low.y),
nextPos.x - pos.x + (nextPos64Low.x - pos64Low.x),
0.0);
props.elevations = elevations * positions.y;
calculatePosition(props);
}
`, Tie = `#version 300 es
#define SHADER_NAME solid-polygon-layer-fragment-shader
precision highp float;
in vec4 vColor;
out vec4 fragColor;
void main(void) {
fragColor = vColor;
geometry.uv = vec2(0.);
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`, g_ = [0, 0, 0, 255], Eie = {
  filled: !0,
  extruded: !1,
  wireframe: !1,
  _normalize: !0,
  _windingOrder: "CW",
  _full3d: !1,
  elevationScale: { type: "number", min: 0, value: 1 },
  getPolygon: { type: "accessor", value: (r) => r.polygon },
  getElevation: { type: "accessor", value: 1e3 },
  getFillColor: { type: "accessor", value: g_ },
  getLineColor: { type: "accessor", value: g_ },
  material: !0
}, Ug = {
  enter: (r, e) => e.length ? e.subarray(e.length - r.length) : r
};
class sf extends Is {
  getShaders(e) {
    return super.getShaders({
      vs: e === "top" ? xie : wie,
      fs: Tie,
      defines: {
        RING_WINDING_ORDER_CW: !this.props._normalize && this.props._windingOrder === "CCW" ? 0 : 1
      },
      modules: [Ws, k_, ga, bie]
    });
  }
  get wrapLongitude() {
    return !1;
  }
  getBounds() {
    return this.getAttributeManager()?.getBounds(["vertexPositions"]);
  }
  initializeState() {
    const { viewport: e } = this.context;
    let { coordinateSystem: t } = this.props;
    const { _full3d: n } = this.props;
    e.isGeospatial && t === rn.DEFAULT && (t = rn.LNGLAT);
    let i;
    t === rn.LNGLAT && (n ? i = e.projectPosition.bind(e) : i = e.projectFlat.bind(e)), this.setState({
      numInstances: 0,
      polygonTesselator: new vie({
        // Lnglat coordinates are usually projected non-linearly, which affects tesselation results
        // Provide a preproject function if the coordinates are in lnglat
        preproject: i,
        fp64: this.use64bitPositions(),
        IndexType: Uint32Array
      })
    });
    const s = this.getAttributeManager(), o = !0;
    s.remove(["instancePickingColors"]), s.add({
      indices: {
        size: 1,
        isIndexed: !0,
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculateIndices,
        noAlloc: o
      },
      vertexPositions: {
        size: 3,
        type: "float64",
        stepMode: "dynamic",
        fp64: this.use64bitPositions(),
        transition: Ug,
        accessor: "getPolygon",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculatePositions,
        noAlloc: o,
        shaderAttributes: {
          nextVertexPositions: {
            vertexOffset: 1
          }
        }
      },
      instanceVertexValid: {
        size: 1,
        type: "uint16",
        stepMode: "instance",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculateVertexValid,
        noAlloc: o
      },
      elevations: {
        size: 1,
        stepMode: "dynamic",
        transition: Ug,
        accessor: "getElevation"
      },
      fillColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        stepMode: "dynamic",
        transition: Ug,
        accessor: "getFillColor",
        defaultValue: g_
      },
      lineColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        stepMode: "dynamic",
        transition: Ug,
        accessor: "getLineColor",
        defaultValue: g_
      },
      pickingColors: {
        size: 4,
        type: "uint8",
        stepMode: "dynamic",
        accessor: (l, { index: u, target: m }) => this.encodePickingColor(l && l.__source ? l.__source.index : u, m)
      }
    });
  }
  getPickingInfo(e) {
    const t = super.getPickingInfo(e), { index: n } = t, i = this.props.data;
    return i[0] && i[0].__source && (t.object = i.find((s) => s.__source.index === n)), t;
  }
  disablePickingIndex(e) {
    const t = this.props.data;
    if (t[0] && t[0].__source)
      for (let n = 0; n < t.length; n++)
        t[n].__source.index === e && this._disablePickingIndex(n);
    else
      super.disablePickingIndex(e);
  }
  draw({ uniforms: e }) {
    const { extruded: t, filled: n, wireframe: i, elevationScale: s } = this.props, { topModel: o, sideModel: l, wireframeModel: u, polygonTesselator: m } = this.state, y = {
      extruded: !!t,
      elevationScale: s,
      isWireframe: !1
    };
    u && i && (u.setInstanceCount(m.instanceCount - 1), u.shaderInputs.setProps({ solidPolygon: { ...y, isWireframe: !0 } }), u.draw(this.context.renderPass)), l && n && (l.setInstanceCount(m.instanceCount - 1), l.shaderInputs.setProps({ solidPolygon: y }), l.draw(this.context.renderPass)), o && n && (o.setVertexCount(m.vertexCount), o.shaderInputs.setProps({ solidPolygon: y }), o.draw(this.context.renderPass));
  }
  updateState(e) {
    super.updateState(e), this.updateGeometry(e);
    const { props: t, oldProps: n, changeFlags: i } = e, s = this.getAttributeManager();
    (i.extensionsChanged || t.filled !== n.filled || t.extruded !== n.extruded) && (this.state.models?.forEach((l) => l.destroy()), this.setState(this._getModels()), s.invalidateAll());
  }
  updateGeometry({ props: e, oldProps: t, changeFlags: n }) {
    if (n.dataChanged || n.updateTriggersChanged && (n.updateTriggersChanged.all || n.updateTriggersChanged.getPolygon)) {
      const { polygonTesselator: s } = this.state, o = e.data.attributes || {};
      s.updateGeometry({
        data: e.data,
        normalize: e._normalize,
        geometryBuffer: o.getPolygon,
        buffers: o,
        getGeometry: e.getPolygon,
        positionFormat: e.positionFormat,
        wrapLongitude: e.wrapLongitude,
        // TODO - move the flag out of the viewport
        resolution: this.context.viewport.resolution,
        fp64: this.use64bitPositions(),
        dataChanged: n.dataChanged,
        full3d: e._full3d
      }), this.setState({
        numInstances: s.instanceCount,
        startIndices: s.vertexStarts
      }), n.dataChanged || this.getAttributeManager().invalidateAll();
    }
  }
  _getModels() {
    const { id: e, filled: t, extruded: n } = this.props;
    let i, s, o;
    if (t) {
      const l = this.getShaders("top");
      l.defines.NON_INSTANCED_MODEL = 1;
      const u = this.getAttributeManager().getBufferLayouts({ isInstanced: !1 });
      i = new Bi(this.context.device, {
        ...l,
        id: `${e}-top`,
        topology: "triangle-list",
        bufferLayout: u,
        isIndexed: !0,
        userData: {
          excludeAttributes: { instanceVertexValid: !0 }
        }
      });
    }
    if (n) {
      const l = this.getAttributeManager().getBufferLayouts({ isInstanced: !0 });
      s = new Bi(this.context.device, {
        ...this.getShaders("side"),
        id: `${e}-side`,
        bufferLayout: l,
        geometry: new no({
          topology: "triangle-strip",
          attributes: {
            // top right - top left - bottom right - bottom left
            positions: {
              size: 2,
              value: new Float32Array([1, 0, 0, 0, 1, 1, 0, 1])
            }
          }
        }),
        isInstanced: !0,
        userData: {
          excludeAttributes: { indices: !0 }
        }
      }), o = new Bi(this.context.device, {
        ...this.getShaders("side"),
        id: `${e}-wireframe`,
        bufferLayout: l,
        geometry: new no({
          topology: "line-strip",
          attributes: {
            // top right - top left - bottom left - bottom right
            positions: {
              size: 2,
              value: new Float32Array([1, 0, 0, 0, 0, 1, 1, 1])
            }
          }
        }),
        isInstanced: !0,
        userData: {
          excludeAttributes: { indices: !0 }
        }
      });
    }
    return {
      models: [s, o, i].filter(Boolean),
      topModel: i,
      sideModel: s,
      wireframeModel: o
    };
  }
  calculateIndices(e) {
    const { polygonTesselator: t } = this.state;
    e.startIndices = t.indexStarts, e.value = t.get("indices");
  }
  calculatePositions(e) {
    const { polygonTesselator: t } = this.state;
    e.startIndices = t.vertexStarts, e.value = t.get("positions");
  }
  calculateVertexValid(e) {
    e.value = this.state.polygonTesselator.get("vertexValid");
  }
}
sf.defaultProps = Eie;
sf.layerName = "SolidPolygonLayer";
function zD({ data: r, getIndex: e, dataRange: t, replace: n }) {
  const { startRow: i = 0, endRow: s = 1 / 0 } = t, o = r.length;
  let l = o, u = o;
  for (let P = 0; P < o; P++) {
    const L = e(r[P]);
    if (l > P && L >= i && (l = P), L >= s) {
      u = P;
      break;
    }
  }
  let m = l;
  const E = u - l !== n.length ? r.slice(u) : void 0;
  for (let P = 0; P < n.length; P++)
    r[m++] = n[P];
  if (E) {
    for (let P = 0; P < E.length; P++)
      r[m++] = E[P];
    r.length = m;
  }
  return {
    startRow: l,
    endRow: l + n.length
  };
}
const VD = [0, 0, 0, 255], Cie = [0, 0, 0, 255], Sie = {
  stroked: !0,
  filled: !0,
  extruded: !1,
  elevationScale: 1,
  wireframe: !1,
  _normalize: !0,
  _windingOrder: "CW",
  lineWidthUnits: "meters",
  lineWidthScale: 1,
  lineWidthMinPixels: 0,
  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
  lineJointRounded: !1,
  lineMiterLimit: 4,
  getPolygon: { type: "accessor", value: (r) => r.polygon },
  // Polygon fill color
  getFillColor: { type: "accessor", value: Cie },
  // Point, line and polygon outline color
  getLineColor: { type: "accessor", value: VD },
  // Line and polygon outline accessors
  getLineWidth: { type: "accessor", value: 1 },
  // Polygon extrusion accessor
  getElevation: { type: "accessor", value: 1e3 },
  // Optional material for 'lighting' shader module
  material: !0
};
class of extends Ps {
  initializeState() {
    this.state = {
      paths: [],
      pathsDiff: null
    }, this.props.getLineDashArray && Jr.removed("getLineDashArray", "PathStyleExtension")();
  }
  updateState({ changeFlags: e }) {
    const t = e.dataChanged || e.updateTriggersChanged && (e.updateTriggersChanged.all || e.updateTriggersChanged.getPolygon);
    if (t && Array.isArray(e.dataChanged)) {
      const n = this.state.paths.slice(), i = e.dataChanged.map((s) => zD({
        data: n,
        getIndex: (o) => o.__source.index,
        dataRange: s,
        replace: this._getPaths(s)
      }));
      this.setState({ paths: n, pathsDiff: i });
    } else t && this.setState({
      paths: this._getPaths(),
      pathsDiff: null
    });
  }
  _getPaths(e = {}) {
    const { data: t, getPolygon: n, positionFormat: i, _normalize: s } = this.props, o = [], l = i === "XY" ? 2 : 3, { startRow: u, endRow: m } = e, { iterable: y, objectInfo: E } = hc(t, u, m);
    for (const P of y) {
      E.index++;
      let L = n(P, E);
      s && (L = ND(L, l));
      const { holeIndices: U } = L, V = L.positions || L;
      if (U)
        for (let q = 0; q <= U.length; q++) {
          const j = V.slice(U[q - 1] || 0, U[q] || V.length);
          o.push(this.getSubLayerRow({ path: j }, P, E.index));
        }
      else
        o.push(this.getSubLayerRow({ path: V }, P, E.index));
    }
    return o;
  }
  /* eslint-disable complexity */
  renderLayers() {
    const { data: e, _dataDiff: t, stroked: n, filled: i, extruded: s, wireframe: o, _normalize: l, _windingOrder: u, elevationScale: m, transitions: y, positionFormat: E } = this.props, { lineWidthUnits: P, lineWidthScale: L, lineWidthMinPixels: U, lineWidthMaxPixels: V, lineJointRounded: q, lineMiterLimit: j, lineDashJustified: K } = this.props, { getFillColor: Y, getLineColor: de, getLineWidth: ne, getLineDashArray: ae, getElevation: De, getPolygon: Ge, updateTriggers: fe, material: ve } = this.props, { paths: me, pathsDiff: X } = this.state, re = this.getSubLayerClass("fill", sf), Me = this.getSubLayerClass("stroke", nf), ot = this.shouldRenderSubLayer("fill", me) && new re({
      _dataDiff: t,
      extruded: s,
      elevationScale: m,
      filled: i,
      wireframe: o,
      _normalize: l,
      _windingOrder: u,
      getElevation: De,
      getFillColor: Y,
      getLineColor: s && o ? de : VD,
      material: ve,
      transitions: y
    }, this.getSubLayerProps({
      id: "fill",
      updateTriggers: fe && {
        getPolygon: fe.getPolygon,
        getElevation: fe.getElevation,
        getFillColor: fe.getFillColor,
        // using a legacy API to invalid lineColor attributes
        // if (extruded && wireframe) has changed
        lineColors: s && o,
        getLineColor: fe.getLineColor
      }
    }), {
      data: e,
      positionFormat: E,
      getPolygon: Ge
    }), be = !s && n && this.shouldRenderSubLayer("stroke", me) && new Me({
      _dataDiff: X && (() => X),
      widthUnits: P,
      widthScale: L,
      widthMinPixels: U,
      widthMaxPixels: V,
      jointRounded: q,
      miterLimit: j,
      dashJustified: K,
      // Already normalized
      _pathType: "loop",
      transitions: y && {
        getWidth: y.getLineWidth,
        getColor: y.getLineColor,
        getPath: y.getPolygon
      },
      getColor: this.getSubLayerAccessor(de),
      getWidth: this.getSubLayerAccessor(ne),
      getDashArray: this.getSubLayerAccessor(ae)
    }, this.getSubLayerProps({
      id: "stroke",
      updateTriggers: fe && {
        getWidth: fe.getLineWidth,
        getColor: fe.getLineColor,
        getDashArray: fe.getLineDashArray
      }
    }), {
      data: me,
      positionFormat: E,
      getPath: (Ue) => Ue.path
    });
    return [
      // If not extruded: flat fill layer is drawn below outlines
      !s && ot,
      be,
      // If extruded: draw fill layer last for correct blending behavior
      s && ot
    ];
  }
}
of.layerName = "PolygonLayer";
of.defaultProps = Sie;
function Iie(r, e) {
  if (!r)
    return null;
  const t = "startIndices" in r ? r.startIndices[e] : e, n = r.featureIds.value[t];
  return t !== -1 ? Pie(r, n, t) : null;
}
function Pie(r, e, t) {
  const n = {
    properties: { ...r.properties[e] }
  };
  for (const i in r.numericProps)
    n.properties[i] = r.numericProps[i].value[t];
  return n;
}
function Mie(r, e) {
  const t = {
    points: null,
    lines: null,
    polygons: null
  };
  for (const n in t) {
    const i = r[n].globalFeatureIds.value;
    t[n] = new Uint8ClampedArray(i.length * 4);
    const s = [];
    for (let o = 0; o < i.length; o++)
      e(i[o], s), t[n][o * 4 + 0] = s[0], t[n][o * 4 + 1] = s[1], t[n][o * 4 + 2] = s[2], t[n][o * 4 + 3] = 255;
  }
  return t;
}
const cP = `uniform sdfUniforms {
  float gamma;
  bool enabled;
  float buffer;
  float outlineBuffer;
  vec4 outlineColor;
} sdf;
`, Rie = {
  name: "sdf",
  vs: cP,
  fs: cP,
  uniformTypes: {
    gamma: "f32",
    enabled: "f32",
    buffer: "f32",
    outlineBuffer: "f32",
    outlineColor: "vec4<f32>"
  }
}, Bie = `#version 300 es
#define SHADER_NAME multi-icon-layer-fragment-shader
precision highp float;
uniform sampler2D iconsTexture;
in vec4 vColor;
in vec2 vTextureCoords;
in vec2 uv;
out vec4 fragColor;
void main(void) {
geometry.uv = uv;
if (!bool(picking.isActive)) {
float alpha = texture(iconsTexture, vTextureCoords).a;
vec4 color = vColor;
if (sdf.enabled) {
float distance = alpha;
alpha = smoothstep(sdf.buffer - sdf.gamma, sdf.buffer + sdf.gamma, distance);
if (sdf.outlineBuffer > 0.0) {
float inFill = alpha;
float inBorder = smoothstep(sdf.outlineBuffer - sdf.gamma, sdf.outlineBuffer + sdf.gamma, distance);
color = mix(sdf.outlineColor, vColor, inFill);
alpha = inBorder;
}
}
float a = alpha * color.a;
if (a < icon.alphaCutoff) {
discard;
}
fragColor = vec4(color.rgb, a * layer.opacity);
}
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`, d1 = 192 / 256, uP = [], Oie = {
  getIconOffsets: { type: "accessor", value: (r) => r.offsets },
  alphaCutoff: 1e-3,
  smoothing: 0.1,
  outlineWidth: 0,
  outlineColor: { type: "color", value: [0, 0, 0, 255] }
};
class J_ extends Fp {
  getShaders() {
    const e = super.getShaders();
    return { ...e, modules: [...e.modules, Rie], fs: Bie };
  }
  initializeState() {
    super.initializeState(), this.getAttributeManager().addInstanced({
      instanceOffsets: {
        size: 2,
        accessor: "getIconOffsets"
      },
      instancePickingColors: {
        type: "uint8",
        size: 3,
        accessor: (t, { index: n, target: i }) => this.encodePickingColor(n, i)
      }
    });
  }
  updateState(e) {
    super.updateState(e);
    const { props: t, oldProps: n } = e;
    let { outlineColor: i } = t;
    i !== n.outlineColor && (i = i.map((s) => s / 255), i[3] = Number.isFinite(i[3]) ? i[3] : 1, this.setState({
      outlineColor: i
    })), !t.sdf && t.outlineWidth && Jr.warn(`${this.id}: fontSettings.sdf is required to render outline`)();
  }
  draw(e) {
    const { sdf: t, smoothing: n, outlineWidth: i } = this.props, { outlineColor: s } = this.state, o = i ? Math.max(n, d1 * (1 - i)) : -1, l = this.state.model, u = {
      buffer: d1,
      outlineBuffer: o,
      gamma: n,
      enabled: !!t,
      outlineColor: s
    };
    if (l.shaderInputs.setProps({ sdf: u }), super.draw(e), t && i) {
      const { iconManager: m } = this.state;
      m.getTexture() && (l.shaderInputs.setProps({ sdf: { ...u, outlineBuffer: d1 } }), l.draw(this.context.renderPass));
    }
  }
  getInstanceOffset(e) {
    return e ? Array.from(e).flatMap((t) => super.getInstanceOffset(t)) : uP;
  }
  getInstanceColorMode(e) {
    return 1;
  }
  getInstanceIconFrame(e) {
    return e ? Array.from(e).flatMap((t) => super.getInstanceIconFrame(t)) : uP;
  }
}
J_.defaultProps = Oie;
J_.layerName = "MultiIconLayer";
const YA = 1e20;
class Die {
  constructor({
    fontSize: e = 24,
    buffer: t = 3,
    radius: n = 8,
    cutoff: i = 0.25,
    fontFamily: s = "sans-serif",
    fontWeight: o = "normal",
    fontStyle: l = "normal",
    lang: u = null
  } = {}) {
    this.buffer = t, this.cutoff = i, this.radius = n, this.lang = u;
    const m = this.size = e + t * 4, y = this._createCanvas(m), E = this.ctx = y.getContext("2d", { willReadFrequently: !0 });
    E.font = `${l} ${o} ${e}px ${s}`, E.textBaseline = "alphabetic", E.textAlign = "left", E.fillStyle = "black", this.gridOuter = new Float64Array(m * m), this.gridInner = new Float64Array(m * m), this.f = new Float64Array(m), this.z = new Float64Array(m + 1), this.v = new Uint16Array(m);
  }
  _createCanvas(e) {
    const t = document.createElement("canvas");
    return t.width = t.height = e, t;
  }
  draw(e) {
    const {
      width: t,
      actualBoundingBoxAscent: n,
      actualBoundingBoxDescent: i,
      actualBoundingBoxLeft: s,
      actualBoundingBoxRight: o
    } = this.ctx.measureText(e), l = Math.ceil(n), u = 0, m = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(o - s))), y = Math.min(this.size - this.buffer, l + Math.ceil(i)), E = m + 2 * this.buffer, P = y + 2 * this.buffer, L = Math.max(E * P, 0), U = new Uint8ClampedArray(L), V = { data: U, width: E, height: P, glyphWidth: m, glyphHeight: y, glyphTop: l, glyphLeft: u, glyphAdvance: t };
    if (m === 0 || y === 0) return V;
    const { ctx: q, buffer: j, gridInner: K, gridOuter: Y } = this;
    this.lang && (q.lang = this.lang), q.clearRect(j, j, m, y), q.fillText(e, j, j + l);
    const de = q.getImageData(j, j, m, y);
    Y.fill(YA, 0, L), K.fill(0, 0, L);
    for (let ne = 0; ne < y; ne++)
      for (let ae = 0; ae < m; ae++) {
        const De = de.data[4 * (ne * m + ae) + 3] / 255;
        if (De === 0) continue;
        const Ge = (ne + j) * E + ae + j;
        if (De === 1)
          Y[Ge] = 0, K[Ge] = YA;
        else {
          const fe = 0.5 - De;
          Y[Ge] = fe > 0 ? fe * fe : 0, K[Ge] = fe < 0 ? fe * fe : 0;
        }
      }
    fP(Y, 0, 0, E, P, E, this.f, this.v, this.z), fP(K, j, j, m, y, E, this.f, this.v, this.z);
    for (let ne = 0; ne < L; ne++) {
      const ae = Math.sqrt(Y[ne]) - Math.sqrt(K[ne]);
      U[ne] = Math.round(255 - 255 * (ae / this.radius + this.cutoff));
    }
    return V;
  }
}
function fP(r, e, t, n, i, s, o, l, u) {
  for (let m = e; m < e + n; m++) hP(r, t * s + m, s, i, o, l, u);
  for (let m = t; m < t + i; m++) hP(r, m * s + e, 1, n, o, l, u);
}
function hP(r, e, t, n, i, s, o) {
  s[0] = 0, o[0] = -YA, o[1] = YA, i[0] = r[e];
  for (let l = 1, u = 0, m = 0; l < n; l++) {
    i[l] = r[e + l * t];
    const y = l * l;
    do {
      const E = s[u];
      m = (i[l] - i[E] + y - E * E) / (l - E) / 2;
    } while (m <= o[u] && --u > -1);
    u++, s[u] = l, o[u] = m, o[u + 1] = YA;
  }
  for (let l = 0, u = 0; l < n; l++) {
    for (; o[u + 1] < l; ) u++;
    const m = s[u], y = l - m;
    r[e + l * t] = i[m] + y * y;
  }
}
const Lie = 32, kie = [];
function Fie(r) {
  return Math.pow(2, Math.ceil(Math.log2(r)));
}
function Nie({ characterSet: r, getFontWidth: e, fontHeight: t, buffer: n, maxCanvasWidth: i, mapping: s = {}, xOffset: o = 0, yOffset: l = 0 }) {
  let u = 0, m = o;
  const y = t + n * 2;
  for (const E of r)
    if (!s[E]) {
      const P = e(E);
      m + P + n * 2 > i && (m = 0, u++), s[E] = {
        x: m + n,
        y: l + u * y + n,
        width: P,
        height: y,
        layoutWidth: P,
        layoutHeight: t
      }, m += P + n * 2;
    }
  return {
    mapping: s,
    xOffset: m,
    yOffset: l + u * y,
    canvasHeight: Fie(l + (u + 1) * y)
  };
}
function jD(r, e, t, n) {
  let i = 0;
  for (let s = e; s < t; s++) {
    const o = r[s];
    i += n[o]?.layoutWidth || 0;
  }
  return i;
}
function HD(r, e, t, n, i, s) {
  let o = e, l = 0;
  for (let u = e; u < t; u++) {
    const m = jD(r, u, u + 1, i);
    l + m > n && (o < u && s.push(u), o = u, l = 0), l += m;
  }
  return l;
}
function Uie(r, e, t, n, i, s) {
  let o = e, l = e, u = e, m = 0;
  for (let y = e; y < t; y++)
    if ((r[y] === " " || r[y + 1] === " " || y + 1 === t) && (u = y + 1), u > l) {
      let E = jD(r, l, u, i);
      m + E > n && (o < l && (s.push(l), o = l, m = 0), E > n && (E = HD(r, l, u, n, i, s), o = s[s.length - 1])), l = u, m += E;
    }
  return m;
}
function zie(r, e, t, n, i = 0, s) {
  s === void 0 && (s = r.length);
  const o = [];
  return e === "break-all" ? HD(r, i, s, t, n, o) : Uie(r, i, s, t, n, o), o;
}
function Vie(r, e, t, n, i, s) {
  let o = 0, l = 0;
  for (let u = e; u < t; u++) {
    const m = r[u], y = n[m];
    y ? (l || (l = y.layoutHeight), i[u] = o + y.layoutWidth / 2, o += y.layoutWidth) : (Jr.warn(`Missing character: ${m} (${m.codePointAt(0)})`)(), i[u] = o, o += Lie);
  }
  s[0] = o, s[1] = l;
}
function jie(r, e, t, n, i) {
  const s = Array.from(r), o = s.length, l = new Array(o), u = new Array(o), m = new Array(o), y = (t === "break-word" || t === "break-all") && isFinite(n) && n > 0, E = [0, 0], P = [0, 0];
  let L = 0, U = 0, V = 0;
  for (let q = 0; q <= o; q++) {
    const j = s[q];
    if ((j === `
` || q === o) && (V = q), V > U) {
      const K = y ? zie(s, t, n, i, U, V) : kie;
      for (let Y = 0; Y <= K.length; Y++) {
        const de = Y === 0 ? U : K[Y - 1], ne = Y < K.length ? K[Y] : V;
        Vie(s, de, ne, i, l, P);
        for (let ae = de; ae < ne; ae++) {
          const De = s[ae], Ge = i[De]?.layoutOffsetY || 0;
          u[ae] = L + P[1] / 2 + Ge, m[ae] = P[0];
        }
        L = L + P[1] * e, E[0] = Math.max(E[0], P[0]);
      }
      U = V;
    }
    j === `
` && (l[U] = 0, u[U] = 0, m[U] = 0, U++);
  }
  return E[1] = L, { x: l, y: u, rowWidth: m, size: E };
}
function Hie({ value: r, length: e, stride: t, offset: n, startIndices: i, characterSet: s }) {
  const o = r.BYTES_PER_ELEMENT, l = t ? t / o : 1, u = n ? n / o : 0, m = i[e] || Math.ceil((r.length - u) / l), y = s && /* @__PURE__ */ new Set(), E = new Array(e);
  let P = r;
  if (l > 1 || u > 0) {
    const L = r.constructor;
    P = new L(m);
    for (let U = 0; U < m; U++)
      P[U] = r[U * l + u];
  }
  for (let L = 0; L < e; L++) {
    const U = i[L], V = i[L + 1] || m, q = P.subarray(U, V);
    E[L] = String.fromCodePoint.apply(null, q), y && q.forEach(y.add, y);
  }
  if (y)
    for (const L of y)
      s.add(String.fromCodePoint(L));
  return { texts: E, characterCount: m };
}
class GD {
  constructor(e = 5) {
    this._cache = {}, this._order = [], this.limit = e;
  }
  get(e) {
    const t = this._cache[e];
    return t && (this._deleteOrder(e), this._appendOrder(e)), t;
  }
  set(e, t) {
    this._cache[e] ? (this.delete(e), this._cache[e] = t, this._appendOrder(e)) : (Object.keys(this._cache).length === this.limit && this.delete(this._order[0]), this._cache[e] = t, this._appendOrder(e));
  }
  delete(e) {
    this._cache[e] && (delete this._cache[e], this._deleteOrder(e));
  }
  _deleteOrder(e) {
    const t = this._order.indexOf(e);
    t >= 0 && this._order.splice(t, 1);
  }
  _appendOrder(e) {
    this._order.push(e);
  }
}
function Gie() {
  const r = [];
  for (let e = 32; e < 128; e++)
    r.push(String.fromCharCode(e));
  return r;
}
const fp = {
  fontFamily: "Monaco, monospace",
  fontWeight: "normal",
  characterSet: Gie(),
  fontSize: 64,
  buffer: 4,
  sdf: !1,
  cutoff: 0.25,
  radius: 12,
  smoothing: 0.1
}, dP = 1024, pP = 0.9, AP = 1.2, WD = 3;
let m_ = new GD(WD);
function Wie(r, e) {
  let t;
  typeof e == "string" ? t = new Set(Array.from(e)) : t = new Set(e);
  const n = m_.get(r);
  if (!n)
    return t;
  for (const i in n.mapping)
    t.has(i) && t.delete(i);
  return t;
}
function $ie(r, e) {
  for (let t = 0; t < r.length; t++)
    e.data[4 * t + 3] = r[t];
}
function gP(r, e, t, n) {
  r.font = `${n} ${t}px ${e}`, r.fillStyle = "#000", r.textBaseline = "alphabetic", r.textAlign = "left";
}
function qie(r) {
  Jr.assert(Number.isFinite(r) && r >= WD, "Invalid cache limit"), m_ = new GD(r);
}
class Xie {
  constructor() {
    this.props = { ...fp };
  }
  get atlas() {
    return this._atlas;
  }
  // TODO - cut during v9 porting as types reveal this is not correct
  // get texture(): Texture | undefined {
  //   return this._atlas;
  // }
  get mapping() {
    return this._atlas && this._atlas.mapping;
  }
  get scale() {
    const { fontSize: e, buffer: t } = this.props;
    return (e * AP + t * 2) / e;
  }
  setProps(e = {}) {
    Object.assign(this.props, e), this._key = this._getKey();
    const t = Wie(this._key, this.props.characterSet), n = m_.get(this._key);
    if (n && t.size === 0) {
      this._atlas !== n && (this._atlas = n);
      return;
    }
    const i = this._generateFontAtlas(t, n);
    this._atlas = i, m_.set(this._key, i);
  }
  // eslint-disable-next-line max-statements
  _generateFontAtlas(e, t) {
    const { fontFamily: n, fontWeight: i, fontSize: s, buffer: o, sdf: l, radius: u, cutoff: m } = this.props;
    let y = t && t.data;
    y || (y = document.createElement("canvas"), y.width = dP);
    const E = y.getContext("2d", { willReadFrequently: !0 });
    gP(E, n, s, i);
    const { mapping: P, canvasHeight: L, xOffset: U, yOffset: V } = Nie({
      getFontWidth: (q) => E.measureText(q).width,
      fontHeight: s * AP,
      buffer: o,
      characterSet: e,
      maxCanvasWidth: dP,
      ...t && {
        mapping: t.mapping,
        xOffset: t.xOffset,
        yOffset: t.yOffset
      }
    });
    if (y.height !== L) {
      const q = E.getImageData(0, 0, y.width, y.height);
      y.height = L, E.putImageData(q, 0, 0);
    }
    if (gP(E, n, s, i), l) {
      const q = new Die({
        fontSize: s,
        buffer: o,
        radius: u,
        cutoff: m,
        fontFamily: n,
        fontWeight: `${i}`
      });
      for (const j of e) {
        const { data: K, width: Y, height: de, glyphTop: ne } = q.draw(j);
        P[j].width = Y, P[j].layoutOffsetY = s * pP - ne;
        const ae = E.createImageData(Y, de);
        $ie(K, ae), E.putImageData(ae, P[j].x, P[j].y);
      }
    } else
      for (const q of e)
        E.fillText(q, P[q].x, P[q].y + o + s * pP);
    return {
      xOffset: U,
      yOffset: V,
      mapping: P,
      data: y,
      width: y.width,
      height: y.height
    };
  }
  _getKey() {
    const { fontFamily: e, fontWeight: t, fontSize: n, buffer: i, sdf: s, radius: o, cutoff: l } = this.props;
    return s ? `${e} ${t} ${n} ${i} ${o} ${l}` : `${e} ${t} ${n} ${i}`;
  }
}
const mP = `uniform textBackgroundUniforms {
  bool billboard;
  float sizeScale;
  float sizeMinPixels;
  float sizeMaxPixels;
  vec4 borderRadius;
  vec4 padding;
  highp int sizeUnits;
  bool stroked;
} textBackground;
`, Zie = {
  name: "textBackground",
  vs: mP,
  fs: mP,
  uniformTypes: {
    billboard: "f32",
    sizeScale: "f32",
    sizeMinPixels: "f32",
    sizeMaxPixels: "f32",
    borderRadius: "vec4<f32>",
    padding: "vec4<f32>",
    sizeUnits: "i32",
    stroked: "f32"
  }
}, Yie = `#version 300 es
#define SHADER_NAME text-background-layer-vertex-shader
in vec2 positions;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceRects;
in float instanceSizes;
in float instanceAngles;
in vec2 instancePixelOffsets;
in float instanceLineWidths;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in vec3 instancePickingColors;
out vec4 vFillColor;
out vec4 vLineColor;
out float vLineWidth;
out vec2 uv;
out vec2 dimensions;
vec2 rotate_by_angle(vec2 vertex, float angle) {
float angle_radian = radians(angle);
float cos_angle = cos(angle_radian);
float sin_angle = sin(angle_radian);
mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);
return rotationMatrix * vertex;
}
void main(void) {
geometry.worldPosition = instancePositions;
geometry.uv = positions;
geometry.pickingColor = instancePickingColors;
uv = positions;
vLineWidth = instanceLineWidths;
float sizePixels = clamp(
project_size_to_pixel(instanceSizes * textBackground.sizeScale, textBackground.sizeUnits),
textBackground.sizeMinPixels, textBackground.sizeMaxPixels
);
dimensions = instanceRects.zw * sizePixels + textBackground.padding.xy + textBackground.padding.zw;
vec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-textBackground.padding.xy, textBackground.padding.zw, positions);
pixelOffset = rotate_by_angle(pixelOffset, instanceAngles);
pixelOffset += instancePixelOffsets;
pixelOffset.y *= -1.0;
if (textBackground.billboard)  {
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vec3 offset = vec3(pixelOffset, 0.0);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
} else {
vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);
DECKGL_FILTER_SIZE(offset_common, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vFillColor, geometry);
vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vLineColor, geometry);
}
`, Kie = `#version 300 es
#define SHADER_NAME text-background-layer-fragment-shader
precision highp float;
in vec4 vFillColor;
in vec4 vLineColor;
in float vLineWidth;
in vec2 uv;
in vec2 dimensions;
out vec4 fragColor;
float round_rect(vec2 p, vec2 size, vec4 radii) {
vec2 pixelPositionCB = (p - 0.5) * size;
vec2 sizeCB = size * 0.5;
float maxBorderRadius = min(size.x, size.y) * 0.5;
vec4 borderRadius = vec4(min(radii, maxBorderRadius));
borderRadius.xy =
(pixelPositionCB.x > 0.0) ? borderRadius.xy : borderRadius.zw;
borderRadius.x = (pixelPositionCB.y > 0.0) ? borderRadius.x : borderRadius.y;
vec2 q = abs(pixelPositionCB) - sizeCB + borderRadius.x;
return -(min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - borderRadius.x);
}
float rect(vec2 p, vec2 size) {
vec2 pixelPosition = p * size;
return min(min(pixelPosition.x, size.x - pixelPosition.x),
min(pixelPosition.y, size.y - pixelPosition.y));
}
vec4 get_stroked_fragColor(float dist) {
float isBorder = smoothedge(dist, vLineWidth);
return mix(vFillColor, vLineColor, isBorder);
}
void main(void) {
geometry.uv = uv;
if (textBackground.borderRadius != vec4(0.0)) {
float distToEdge = round_rect(uv, dimensions, textBackground.borderRadius);
if (textBackground.stroked) {
fragColor = get_stroked_fragColor(distToEdge);
} else {
fragColor = vFillColor;
}
float shapeAlpha = smoothedge(-distToEdge, 0.0);
fragColor.a *= shapeAlpha;
} else {
if (textBackground.stroked) {
float distToEdge = rect(uv, dimensions);
fragColor = get_stroked_fragColor(distToEdge);
} else {
fragColor = vFillColor;
}
}
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`, Qie = {
  billboard: !0,
  sizeScale: 1,
  sizeUnits: "pixels",
  sizeMinPixels: 0,
  sizeMaxPixels: Number.MAX_SAFE_INTEGER,
  borderRadius: { type: "object", value: 0 },
  padding: { type: "array", value: [0, 0, 0, 0] },
  getPosition: { type: "accessor", value: (r) => r.position },
  getSize: { type: "accessor", value: 1 },
  getAngle: { type: "accessor", value: 0 },
  getPixelOffset: { type: "accessor", value: [0, 0] },
  getBoundingRect: { type: "accessor", value: [0, 0, 0, 0] },
  getFillColor: { type: "accessor", value: [0, 0, 0, 255] },
  getLineColor: { type: "accessor", value: [0, 0, 0, 255] },
  getLineWidth: { type: "accessor", value: 1 }
};
class E0 extends Is {
  getShaders() {
    return super.getShaders({ vs: Yie, fs: Kie, modules: [Ws, ga, Zie] });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: !0,
        accessor: "getPosition"
      },
      instanceSizes: {
        size: 1,
        transition: !0,
        accessor: "getSize",
        defaultValue: 1
      },
      instanceAngles: {
        size: 1,
        transition: !0,
        accessor: "getAngle"
      },
      instanceRects: {
        size: 4,
        accessor: "getBoundingRect"
      },
      instancePixelOffsets: {
        size: 2,
        transition: !0,
        accessor: "getPixelOffset"
      },
      instanceFillColors: {
        size: 4,
        transition: !0,
        type: "unorm8",
        accessor: "getFillColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineColors: {
        size: 4,
        transition: !0,
        type: "unorm8",
        accessor: "getLineColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineWidths: {
        size: 1,
        transition: !0,
        accessor: "getLineWidth",
        defaultValue: 1
      }
    });
  }
  updateState(e) {
    super.updateState(e);
    const { changeFlags: t } = e;
    t.extensionsChanged && (this.state.model?.destroy(), this.state.model = this._getModel(), this.getAttributeManager().invalidateAll());
  }
  draw({ uniforms: e }) {
    const { billboard: t, sizeScale: n, sizeUnits: i, sizeMinPixels: s, sizeMaxPixels: o, getLineWidth: l } = this.props;
    let { padding: u, borderRadius: m } = this.props;
    u.length < 4 && (u = [u[0], u[1], u[0], u[1]]), Array.isArray(m) || (m = [m, m, m, m]);
    const y = this.state.model, E = {
      billboard: t,
      stroked: !!l,
      borderRadius: m,
      padding: u,
      sizeUnits: ko[i],
      sizeScale: n,
      sizeMinPixels: s,
      sizeMaxPixels: o
    };
    y.shaderInputs.setProps({ textBackground: E }), y.draw(this.context.renderPass);
  }
  _getModel() {
    const e = [0, 0, 1, 0, 0, 1, 1, 1];
    return new Bi(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new no({
        topology: "triangle-strip",
        vertexCount: 4,
        attributes: {
          positions: { size: 2, value: new Float32Array(e) }
        }
      }),
      isInstanced: !0
    });
  }
}
E0.defaultProps = Qie;
E0.layerName = "TextBackgroundLayer";
const _P = {
  start: 1,
  middle: 0,
  end: -1
}, yP = {
  top: 1,
  center: 0,
  bottom: -1
}, p1 = [0, 0, 0, 255], Jie = 1, ese = {
  billboard: !0,
  sizeScale: 1,
  sizeUnits: "pixels",
  sizeMinPixels: 0,
  sizeMaxPixels: Number.MAX_SAFE_INTEGER,
  background: !1,
  getBackgroundColor: { type: "accessor", value: [255, 255, 255, 255] },
  getBorderColor: { type: "accessor", value: p1 },
  getBorderWidth: { type: "accessor", value: 0 },
  backgroundBorderRadius: { type: "object", value: 0 },
  backgroundPadding: { type: "array", value: [0, 0, 0, 0] },
  characterSet: { type: "object", value: fp.characterSet },
  fontFamily: fp.fontFamily,
  fontWeight: fp.fontWeight,
  lineHeight: Jie,
  outlineWidth: { type: "number", value: 0, min: 0 },
  outlineColor: { type: "color", value: p1 },
  fontSettings: { type: "object", value: {}, compare: 1 },
  // auto wrapping options
  wordBreak: "break-word",
  maxWidth: { type: "number", value: -1 },
  getText: { type: "accessor", value: (r) => r.text },
  getPosition: { type: "accessor", value: (r) => r.position },
  getColor: { type: "accessor", value: p1 },
  getSize: { type: "accessor", value: 32 },
  getAngle: { type: "accessor", value: 0 },
  getTextAnchor: { type: "accessor", value: "middle" },
  getAlignmentBaseline: { type: "accessor", value: "center" },
  getPixelOffset: { type: "accessor", value: [0, 0] },
  // deprecated
  backgroundColor: { deprecatedFor: ["background", "getBackgroundColor"] }
};
class yh extends Ps {
  constructor() {
    super(...arguments), this.getBoundingRect = (e, t) => {
      let { size: [n, i] } = this.transformParagraph(e, t);
      const { fontSize: s } = this.state.fontAtlasManager.props;
      n /= s, i /= s;
      const { getTextAnchor: o, getAlignmentBaseline: l } = this.props, u = _P[typeof o == "function" ? o(e, t) : o], m = yP[typeof l == "function" ? l(e, t) : l];
      return [(u - 1) * n / 2, (m - 1) * i / 2, n, i];
    }, this.getIconOffsets = (e, t) => {
      const { getTextAnchor: n, getAlignmentBaseline: i } = this.props, { x: s, y: o, rowWidth: l, size: [u, m] } = this.transformParagraph(e, t), y = _P[typeof n == "function" ? n(e, t) : n], E = yP[typeof i == "function" ? i(e, t) : i], P = s.length, L = new Array(P * 2);
      let U = 0;
      for (let V = 0; V < P; V++) {
        const q = (1 - y) * (u - l[V]) / 2;
        L[U++] = (y - 1) * u / 2 + q + s[V], L[U++] = (E - 1) * m / 2 + o[V];
      }
      return L;
    };
  }
  initializeState() {
    this.state = {
      styleVersion: 0,
      fontAtlasManager: new Xie()
    }, this.props.maxWidth > 0 && Jr.once(1, "v8.9 breaking change: TextLayer maxWidth is now relative to text size")();
  }
  // eslint-disable-next-line complexity
  updateState(e) {
    const { props: t, oldProps: n, changeFlags: i } = e;
    (i.dataChanged || i.updateTriggersChanged && (i.updateTriggersChanged.all || i.updateTriggersChanged.getText)) && this._updateText(), (this._updateFontAtlas() || t.lineHeight !== n.lineHeight || t.wordBreak !== n.wordBreak || t.maxWidth !== n.maxWidth) && this.setState({
      styleVersion: this.state.styleVersion + 1
    });
  }
  getPickingInfo({ info: e }) {
    return e.object = e.index >= 0 ? this.props.data[e.index] : null, e;
  }
  /** Returns true if font has changed */
  _updateFontAtlas() {
    const { fontSettings: e, fontFamily: t, fontWeight: n } = this.props, { fontAtlasManager: i, characterSet: s } = this.state, o = {
      ...e,
      characterSet: s,
      fontFamily: t,
      fontWeight: n
    };
    if (!i.mapping)
      return i.setProps(o), !0;
    for (const l in o)
      if (o[l] !== i.props[l])
        return i.setProps(o), !0;
    return !1;
  }
  // Text strings are variable width objects
  // Count characters and start offsets
  _updateText() {
    const { data: e, characterSet: t } = this.props, n = e.attributes?.getText;
    let { getText: i } = this.props, s = e.startIndices, o;
    const l = t === "auto" && /* @__PURE__ */ new Set();
    if (n && s) {
      const { texts: u, characterCount: m } = Hie({
        ...ArrayBuffer.isView(n) ? { value: n } : n,
        // @ts-ignore if data.attribute is defined then length is expected
        length: e.length,
        startIndices: s,
        characterSet: l
      });
      o = m, i = (y, { index: E }) => u[E];
    } else {
      const { iterable: u, objectInfo: m } = hc(e);
      s = [0], o = 0;
      for (const y of u) {
        m.index++;
        const E = Array.from(i(y, m) || "");
        l && E.forEach(l.add, l), o += E.length, s.push(o);
      }
    }
    this.setState({
      getText: i,
      startIndices: s,
      numInstances: o,
      characterSet: l || t
    });
  }
  /** There are two size systems in this layer:
  
      + Pixel size: user-specified text size, via getSize, sizeScale, sizeUnits etc.
        The layer roughly matches the output of the layer to CSS pixels, e.g. getSize: 12, sizeScale: 2
        in layer props is roughly equivalent to font-size: 24px in CSS.
      + Texture size: internally, character positions in a text blob are calculated using the sizes of iconMapping,
        which depends on how large each character is drawn into the font atlas. This is controlled by
        fontSettings.fontSize (default 64) and most users do not set it manually.
        These numbers are intended to be used in the vertex shader and never to be exposed to the end user.
  
      All surfaces exposed to the user should either use the pixel size or a multiplier relative to the pixel size. */
  /** Calculate the size and position of each character in a text string.
   * Values are in texture size */
  transformParagraph(e, t) {
    const { fontAtlasManager: n } = this.state, i = n.mapping, s = this.state.getText, { wordBreak: o, lineHeight: l, maxWidth: u } = this.props, m = s(e, t) || "";
    return jie(m, l, o, u * n.props.fontSize, i);
  }
  renderLayers() {
    const { startIndices: e, numInstances: t, getText: n, fontAtlasManager: { scale: i, atlas: s, mapping: o }, styleVersion: l } = this.state, { data: u, _dataDiff: m, getPosition: y, getColor: E, getSize: P, getAngle: L, getPixelOffset: U, getBackgroundColor: V, getBorderColor: q, getBorderWidth: j, backgroundBorderRadius: K, backgroundPadding: Y, background: de, billboard: ne, fontSettings: ae, outlineWidth: De, outlineColor: Ge, sizeScale: fe, sizeUnits: ve, sizeMinPixels: me, sizeMaxPixels: X, transitions: re, updateTriggers: Me } = this.props, ot = this.getSubLayerClass("characters", J_), be = this.getSubLayerClass("background", E0);
    return [
      de && new be({
        // background props
        getFillColor: V,
        getLineColor: q,
        getLineWidth: j,
        borderRadius: K,
        padding: Y,
        // props shared with characters layer
        getPosition: y,
        getSize: P,
        getAngle: L,
        getPixelOffset: U,
        billboard: ne,
        sizeScale: fe,
        sizeUnits: ve,
        sizeMinPixels: me,
        sizeMaxPixels: X,
        transitions: re && {
          getPosition: re.getPosition,
          getAngle: re.getAngle,
          getSize: re.getSize,
          getFillColor: re.getBackgroundColor,
          getLineColor: re.getBorderColor,
          getLineWidth: re.getBorderWidth,
          getPixelOffset: re.getPixelOffset
        }
      }, this.getSubLayerProps({
        id: "background",
        updateTriggers: {
          getPosition: Me.getPosition,
          getAngle: Me.getAngle,
          getSize: Me.getSize,
          getFillColor: Me.getBackgroundColor,
          getLineColor: Me.getBorderColor,
          getLineWidth: Me.getBorderWidth,
          getPixelOffset: Me.getPixelOffset,
          getBoundingRect: {
            getText: Me.getText,
            getTextAnchor: Me.getTextAnchor,
            getAlignmentBaseline: Me.getAlignmentBaseline,
            styleVersion: l
          }
        }
      }), {
        data: (
          // @ts-ignore (2339) attribute is not defined on all data types
          u.attributes && u.attributes.background ? (
            // @ts-ignore (2339) attribute is not defined on all data types
            { length: u.length, attributes: u.attributes.background }
          ) : u
        ),
        _dataDiff: m,
        // Maintain the same background behavior as <=8.3. Remove in v9?
        autoHighlight: !1,
        getBoundingRect: this.getBoundingRect
      }),
      new ot({
        sdf: ae.sdf,
        smoothing: Number.isFinite(ae.smoothing) ? ae.smoothing : fp.smoothing,
        outlineWidth: De / (ae.radius || fp.radius),
        outlineColor: Ge,
        iconAtlas: s,
        iconMapping: o,
        getPosition: y,
        getColor: E,
        getSize: P,
        getAngle: L,
        getPixelOffset: U,
        billboard: ne,
        sizeScale: fe * i,
        sizeUnits: ve,
        sizeMinPixels: me * i,
        sizeMaxPixels: X * i,
        transitions: re && {
          getPosition: re.getPosition,
          getAngle: re.getAngle,
          getColor: re.getColor,
          getSize: re.getSize,
          getPixelOffset: re.getPixelOffset
        }
      }, this.getSubLayerProps({
        id: "characters",
        updateTriggers: {
          all: Me.getText,
          getPosition: Me.getPosition,
          getAngle: Me.getAngle,
          getColor: Me.getColor,
          getSize: Me.getSize,
          getPixelOffset: Me.getPixelOffset,
          getIconOffsets: {
            getTextAnchor: Me.getTextAnchor,
            getAlignmentBaseline: Me.getAlignmentBaseline,
            styleVersion: l
          }
        }
      }), {
        data: u,
        _dataDiff: m,
        startIndices: e,
        numInstances: t,
        getIconOffsets: this.getIconOffsets,
        getIcon: n
      })
    ];
  }
  static set fontAtlasCacheLimit(e) {
    qie(e);
  }
}
yh.defaultProps = ese;
yh.layerName = "TextLayer";
const Rm = {
  circle: {
    type: T0,
    props: {
      filled: "filled",
      stroked: "stroked",
      lineWidthMaxPixels: "lineWidthMaxPixels",
      lineWidthMinPixels: "lineWidthMinPixels",
      lineWidthScale: "lineWidthScale",
      lineWidthUnits: "lineWidthUnits",
      pointRadiusMaxPixels: "radiusMaxPixels",
      pointRadiusMinPixels: "radiusMinPixels",
      pointRadiusScale: "radiusScale",
      pointRadiusUnits: "radiusUnits",
      pointAntialiasing: "antialiasing",
      pointBillboard: "billboard",
      getFillColor: "getFillColor",
      getLineColor: "getLineColor",
      getLineWidth: "getLineWidth",
      getPointRadius: "getRadius"
    }
  },
  icon: {
    type: Fp,
    props: {
      iconAtlas: "iconAtlas",
      iconMapping: "iconMapping",
      iconSizeMaxPixels: "sizeMaxPixels",
      iconSizeMinPixels: "sizeMinPixels",
      iconSizeScale: "sizeScale",
      iconSizeUnits: "sizeUnits",
      iconAlphaCutoff: "alphaCutoff",
      iconBillboard: "billboard",
      getIcon: "getIcon",
      getIconAngle: "getAngle",
      getIconColor: "getColor",
      getIconPixelOffset: "getPixelOffset",
      getIconSize: "getSize"
    }
  },
  text: {
    type: yh,
    props: {
      textSizeMaxPixels: "sizeMaxPixels",
      textSizeMinPixels: "sizeMinPixels",
      textSizeScale: "sizeScale",
      textSizeUnits: "sizeUnits",
      textBackground: "background",
      textBackgroundPadding: "backgroundPadding",
      textFontFamily: "fontFamily",
      textFontWeight: "fontWeight",
      textLineHeight: "lineHeight",
      textMaxWidth: "maxWidth",
      textOutlineColor: "outlineColor",
      textOutlineWidth: "outlineWidth",
      textWordBreak: "wordBreak",
      textCharacterSet: "characterSet",
      textBillboard: "billboard",
      textFontSettings: "fontSettings",
      getText: "getText",
      getTextAngle: "getAngle",
      getTextColor: "getColor",
      getTextPixelOffset: "getPixelOffset",
      getTextSize: "getSize",
      getTextAnchor: "getTextAnchor",
      getTextAlignmentBaseline: "getAlignmentBaseline",
      getTextBackgroundColor: "getBackgroundColor",
      getTextBorderColor: "getBorderColor",
      getTextBorderWidth: "getBorderWidth"
    }
  }
}, Bm = {
  type: nf,
  props: {
    lineWidthUnits: "widthUnits",
    lineWidthScale: "widthScale",
    lineWidthMinPixels: "widthMinPixels",
    lineWidthMaxPixels: "widthMaxPixels",
    lineJointRounded: "jointRounded",
    lineCapRounded: "capRounded",
    lineMiterLimit: "miterLimit",
    lineBillboard: "billboard",
    getLineColor: "getColor",
    getLineWidth: "getWidth"
  }
}, _2 = {
  type: sf,
  props: {
    extruded: "extruded",
    filled: "filled",
    wireframe: "wireframe",
    elevationScale: "elevationScale",
    material: "material",
    _full3d: "_full3d",
    getElevation: "getElevation",
    getFillColor: "getFillColor",
    getLineColor: "getLineColor"
  }
};
function bA({ type: r, props: e }) {
  const t = {};
  for (const n in e)
    t[n] = r.defaultProps[e[n]];
  return t;
}
function A1(r, e) {
  const { transitions: t, updateTriggers: n } = r.props, i = {
    updateTriggers: {},
    transitions: t && {
      getPosition: t.geometry
    }
  };
  for (const s in e) {
    const o = e[s];
    let l = r.props[s];
    s.startsWith("get") && (l = r.getSubLayerAccessor(l), i.updateTriggers[o] = n[s], t && (i.transitions[o] = t[s])), i[o] = l;
  }
  return i;
}
function tse(r) {
  if (Array.isArray(r))
    return r;
  switch (Jr.assert(r.type, "GeoJSON does not have type"), r.type) {
    case "Feature":
      return [r];
    case "FeatureCollection":
      return Jr.assert(Array.isArray(r.features), "GeoJSON does not have features array"), r.features;
    default:
      return [{ geometry: r }];
  }
}
function vP(r, e, t = {}) {
  const n = {
    pointFeatures: [],
    lineFeatures: [],
    polygonFeatures: [],
    polygonOutlineFeatures: []
  }, { startRow: i = 0, endRow: s = r.length } = t;
  for (let o = i; o < s; o++) {
    const l = r[o], { geometry: u } = l;
    if (u)
      if (u.type === "GeometryCollection") {
        Jr.assert(Array.isArray(u.geometries), "GeoJSON does not have geometries array");
        const { geometries: m } = u;
        for (let y = 0; y < m.length; y++) {
          const E = m[y];
          bP(E, n, e, l, o);
        }
      } else
        bP(u, n, e, l, o);
  }
  return n;
}
function bP(r, e, t, n, i) {
  const { type: s, coordinates: o } = r, { pointFeatures: l, lineFeatures: u, polygonFeatures: m, polygonOutlineFeatures: y } = e;
  if (!nse(s, o)) {
    Jr.warn(`${s} coordinates are malformed`)();
    return;
  }
  switch (s) {
    case "Point":
      l.push(t({
        geometry: r
      }, n, i));
      break;
    case "MultiPoint":
      o.forEach((E) => {
        l.push(t({
          geometry: { type: "Point", coordinates: E }
        }, n, i));
      });
      break;
    case "LineString":
      u.push(t({
        geometry: r
      }, n, i));
      break;
    case "MultiLineString":
      o.forEach((E) => {
        u.push(t({
          geometry: { type: "LineString", coordinates: E }
        }, n, i));
      });
      break;
    case "Polygon":
      m.push(t({
        geometry: r
      }, n, i)), o.forEach((E) => {
        y.push(t({
          geometry: { type: "LineString", coordinates: E }
        }, n, i));
      });
      break;
    case "MultiPolygon":
      o.forEach((E) => {
        m.push(t({
          geometry: { type: "Polygon", coordinates: E }
        }, n, i)), E.forEach((P) => {
          y.push(t({
            geometry: { type: "LineString", coordinates: P }
          }, n, i));
        });
      });
      break;
  }
}
const rse = {
  Point: 1,
  MultiPoint: 2,
  LineString: 2,
  MultiLineString: 3,
  Polygon: 3,
  MultiPolygon: 4
};
function nse(r, e) {
  let t = rse[r];
  for (Jr.assert(t, `Unknown GeoJSON type ${r}`); e && --t > 0; )
    e = e[0];
  return e && Number.isFinite(e[0]);
}
function $D() {
  return {
    points: {},
    lines: {},
    polygons: {},
    polygonsOutline: {}
  };
}
function zg(r) {
  return r.geometry.coordinates;
}
function ise(r, e) {
  const t = $D(), { pointFeatures: n, lineFeatures: i, polygonFeatures: s, polygonOutlineFeatures: o } = r;
  return t.points.data = n, t.points._dataDiff = e.pointFeatures && (() => e.pointFeatures), t.points.getPosition = zg, t.lines.data = i, t.lines._dataDiff = e.lineFeatures && (() => e.lineFeatures), t.lines.getPath = zg, t.polygons.data = s, t.polygons._dataDiff = e.polygonFeatures && (() => e.polygonFeatures), t.polygons.getPolygon = zg, t.polygonsOutline.data = o, t.polygonsOutline._dataDiff = e.polygonOutlineFeatures && (() => e.polygonOutlineFeatures), t.polygonsOutline.getPath = zg, t;
}
function sse(r, e) {
  const t = $D(), { points: n, lines: i, polygons: s } = r, o = Mie(r, e);
  t.points.data = {
    length: n.positions.value.length / n.positions.size,
    attributes: {
      ...n.attributes,
      getPosition: n.positions,
      instancePickingColors: {
        size: 4,
        value: o.points
      }
    },
    properties: n.properties,
    numericProps: n.numericProps,
    featureIds: n.featureIds
  }, t.lines.data = {
    length: i.pathIndices.value.length - 1,
    startIndices: i.pathIndices.value,
    attributes: {
      ...i.attributes,
      getPath: i.positions,
      instancePickingColors: {
        size: 4,
        value: o.lines
      }
    },
    properties: i.properties,
    numericProps: i.numericProps,
    featureIds: i.featureIds
  }, t.lines._pathType = "open";
  const l = s.positions.value.length / s.positions.size, u = Array(l).fill(1);
  for (const m of s.primitivePolygonIndices.value)
    u[m - 1] = 0;
  return t.polygons.data = {
    length: s.polygonIndices.value.length - 1,
    startIndices: s.polygonIndices.value,
    attributes: {
      ...s.attributes,
      getPolygon: s.positions,
      instanceVertexValid: {
        size: 1,
        value: new Uint16Array(u)
      },
      pickingColors: {
        size: 4,
        value: o.polygons
      }
    },
    properties: s.properties,
    numericProps: s.numericProps,
    featureIds: s.featureIds
  }, t.polygons._normalize = !1, s.triangles && (t.polygons.data.attributes.indices = s.triangles.value), t.polygonsOutline.data = {
    length: s.primitivePolygonIndices.value.length - 1,
    startIndices: s.primitivePolygonIndices.value,
    attributes: {
      ...s.attributes,
      getPath: s.positions,
      instancePickingColors: {
        size: 4,
        value: o.polygons
      }
    },
    properties: s.properties,
    numericProps: s.numericProps,
    featureIds: s.featureIds
  }, t.polygonsOutline._pathType = "open", t;
}
const ose = ["points", "linestrings", "polygons"], ase = {
  ...bA(Rm.circle),
  ...bA(Rm.icon),
  ...bA(Rm.text),
  ...bA(Bm),
  ...bA(_2),
  // Overwrite sub layer defaults
  stroked: !0,
  filled: !0,
  extruded: !1,
  wireframe: !1,
  _full3d: !1,
  iconAtlas: { type: "object", value: null },
  iconMapping: { type: "object", value: {} },
  getIcon: { type: "accessor", value: (r) => r.properties.icon },
  getText: { type: "accessor", value: (r) => r.properties.text },
  // Self props
  pointType: "circle",
  // TODO: deprecated, remove in v9
  getRadius: { deprecatedFor: "getPointRadius" }
};
class iu extends Ps {
  initializeState() {
    this.state = {
      layerProps: {},
      features: {},
      featuresDiff: {}
    };
  }
  updateState({ props: e, changeFlags: t }) {
    if (!t.dataChanged)
      return;
    const { data: n } = this.props, i = n && "points" in n && "polygons" in n && "lines" in n;
    this.setState({ binary: i }), i ? this._updateStateBinary({ props: e, changeFlags: t }) : this._updateStateJSON({ props: e, changeFlags: t });
  }
  _updateStateBinary({ props: e, changeFlags: t }) {
    const n = sse(e.data, this.encodePickingColor);
    this.setState({ layerProps: n });
  }
  _updateStateJSON({ props: e, changeFlags: t }) {
    const n = tse(e.data), i = this.getSubLayerRow.bind(this);
    let s = {};
    const o = {};
    if (Array.isArray(t.dataChanged)) {
      const u = this.state.features;
      for (const m in u)
        s[m] = u[m].slice(), o[m] = [];
      for (const m of t.dataChanged) {
        const y = vP(n, i, m);
        for (const E in u)
          o[E].push(zD({
            data: s[E],
            getIndex: (P) => P.__source.index,
            dataRange: m,
            replace: y[E]
          }));
      }
    } else
      s = vP(n, i);
    const l = ise(s, o);
    this.setState({
      features: s,
      featuresDiff: o,
      layerProps: l
    });
  }
  getPickingInfo(e) {
    const t = super.getPickingInfo(e), { index: n, sourceLayer: i } = t;
    return t.featureType = ose.find((s) => i.id.startsWith(`${this.id}-${s}-`)), n >= 0 && i.id.startsWith(`${this.id}-points-text`) && this.state.binary && (t.index = this.props.data.points.globalFeatureIds.value[n]), t;
  }
  _updateAutoHighlight(e) {
    const t = `${this.id}-points-`, n = e.featureType === "points";
    for (const i of this.getSubLayers())
      i.id.startsWith(t) === n && i.updateAutoHighlight(e);
  }
  _renderPolygonLayer() {
    const { extruded: e, wireframe: t } = this.props, { layerProps: n } = this.state, i = "polygons-fill", s = this.shouldRenderSubLayer(i, n.polygons?.data) && this.getSubLayerClass(i, _2.type);
    if (s) {
      const o = A1(this, _2.props), l = e && t;
      return l || delete o.getLineColor, o.updateTriggers.lineColors = l, new s(o, this.getSubLayerProps({
        id: i,
        updateTriggers: o.updateTriggers
      }), n.polygons);
    }
    return null;
  }
  _renderLineLayers() {
    const { extruded: e, stroked: t } = this.props, { layerProps: n } = this.state, i = "polygons-stroke", s = "linestrings", o = !e && t && this.shouldRenderSubLayer(i, n.polygonsOutline?.data) && this.getSubLayerClass(i, Bm.type), l = this.shouldRenderSubLayer(s, n.lines?.data) && this.getSubLayerClass(s, Bm.type);
    if (o || l) {
      const u = A1(this, Bm.props);
      return [
        o && new o(u, this.getSubLayerProps({
          id: i,
          updateTriggers: u.updateTriggers
        }), n.polygonsOutline),
        l && new l(u, this.getSubLayerProps({
          id: s,
          updateTriggers: u.updateTriggers
        }), n.lines)
      ];
    }
    return null;
  }
  _renderPointLayers() {
    const { pointType: e } = this.props, { layerProps: t, binary: n } = this.state;
    let { highlightedObjectIndex: i } = this.props;
    !n && Number.isFinite(i) && (i = t.points.data.findIndex((l) => l.__source.index === i));
    const s = new Set(e.split("+")), o = [];
    for (const l of s) {
      const u = `points-${l}`, m = Rm[l], y = m && this.shouldRenderSubLayer(u, t.points?.data) && this.getSubLayerClass(u, m.type);
      if (y) {
        const E = A1(this, m.props);
        let P = t.points;
        if (l === "text" && n) {
          const { instancePickingColors: L, ...U } = P.data.attributes;
          P = {
            ...P,
            // @ts-expect-error TODO - type binary data
            data: { ...P.data, attributes: U }
          };
        }
        o.push(new y(E, this.getSubLayerProps({
          id: u,
          updateTriggers: E.updateTriggers,
          highlightedObjectIndex: i
        }), P));
      }
    }
    return o;
  }
  renderLayers() {
    const { extruded: e } = this.props, t = this._renderPolygonLayer(), n = this._renderLineLayers(), i = this._renderPointLayers();
    return [
      // If not extruded: flat fill layer is drawn below outlines
      !e && t,
      n,
      i,
      // If extruded: draw fill layer last for correct blending behavior
      e && t
    ];
  }
  getSubLayerAccessor(e) {
    const { binary: t } = this.state;
    return !t || typeof e != "function" ? super.getSubLayerAccessor(e) : (n, i) => {
      const { data: s, index: o } = i, l = Iie(s, o);
      return e(l, i);
    };
  }
}
iu.layerName = "GeoJsonLayer";
iu.defaultProps = ase;
const lse = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ArcLayer: x0,
  BitmapLayer: K_,
  ColumnLayer: dc,
  GeoJsonLayer: iu,
  GridCellLayer: Ew,
  IconLayer: Fp,
  LineLayer: Q_,
  PathLayer: nf,
  PointCloudLayer: w0,
  PolygonLayer: of,
  ScatterplotLayer: T0,
  SolidPolygonLayer: sf,
  TextLayer: yh,
  _MultiIconLayer: J_,
  _TextBackgroundLayer: E0
}, Symbol.toStringTag, { value: "Module" })), cse = {
  ...of.defaultProps
};
class su extends Ps {
  /** Implement to generate props to create geometry. */
  indexToBounds() {
    return null;
  }
  renderLayers() {
    const { elevationScale: e, extruded: t, wireframe: n, filled: i, stroked: s, lineWidthUnits: o, lineWidthScale: l, lineWidthMinPixels: u, lineWidthMaxPixels: m, lineJointRounded: y, lineMiterLimit: E, lineDashJustified: P, getElevation: L, getFillColor: U, getLineColor: V, getLineWidth: q } = this.props, { updateTriggers: j, material: K, transitions: Y } = this.props, de = this.getSubLayerClass("cell", of), { updateTriggers: ne, ...ae } = this.indexToBounds() || {};
    return new de({
      filled: i,
      wireframe: n,
      extruded: t,
      elevationScale: e,
      stroked: s,
      lineWidthUnits: o,
      lineWidthScale: l,
      lineWidthMinPixels: u,
      lineWidthMaxPixels: m,
      lineJointRounded: y,
      lineMiterLimit: E,
      lineDashJustified: P,
      material: K,
      transitions: Y,
      getElevation: L,
      getFillColor: U,
      getLineColor: V,
      getLineWidth: q
    }, this.getSubLayerProps({
      id: "cell",
      updateTriggers: j && {
        ...ne,
        getElevation: j.getElevation,
        getFillColor: j.getFillColor,
        getLineColor: j.getLineColor,
        getLineWidth: j.getLineWidth
      }
    }), ae);
  }
}
su.layerName = "GeoCellLayer";
su.defaultProps = cse;
var use = Object.defineProperty, C0 = (r, e) => {
  for (var t in e)
    use(r, t, { get: e[t], enumerable: !0 });
}, Fo = {};
C0(Fo, {
  ARRAY_TYPE: () => ts,
  EPSILON: () => ro,
  RANDOM: () => Jf,
  equals: () => pse,
  setMatrixArrayType: () => fse,
  toRadian: () => dse
});
var ro = 1e-6, ts = typeof Float32Array < "u" ? Float32Array : Array, Jf = Math.random;
function fse(r) {
  ts = r;
}
var hse = Math.PI / 180;
function dse(r) {
  return r * hse;
}
function pse(r, e) {
  return Math.abs(r - e) <= ro * Math.max(1, Math.abs(r), Math.abs(e));
}
Math.hypot || (Math.hypot = function() {
  for (var r = 0, e = arguments.length; e--; )
    r += arguments[e] * arguments[e];
  return Math.sqrt(r);
});
var oh = {};
C0(oh, {
  LDU: () => Rse,
  add: () => Bse,
  adjoint: () => wse,
  clone: () => gse,
  copy: () => mse,
  create: () => Ase,
  determinant: () => Tse,
  equals: () => Dse,
  exactEquals: () => Ose,
  frob: () => Mse,
  fromRotation: () => Sse,
  fromScaling: () => Ise,
  fromValues: () => yse,
  identity: () => _se,
  invert: () => xse,
  mul: () => Fse,
  multiply: () => qD,
  multiplyScalar: () => Lse,
  multiplyScalarAndAdd: () => kse,
  rotate: () => Ese,
  scale: () => Cse,
  set: () => vse,
  str: () => Pse,
  sub: () => Nse,
  subtract: () => XD,
  transpose: () => bse
});
function Ase() {
  var r = new ts(4);
  return ts != Float32Array && (r[1] = 0, r[2] = 0), r[0] = 1, r[3] = 1, r;
}
function gse(r) {
  var e = new ts(4);
  return e[0] = r[0], e[1] = r[1], e[2] = r[2], e[3] = r[3], e;
}
function mse(r, e) {
  return r[0] = e[0], r[1] = e[1], r[2] = e[2], r[3] = e[3], r;
}
function _se(r) {
  return r[0] = 1, r[1] = 0, r[2] = 0, r[3] = 1, r;
}
function yse(r, e, t, n) {
  var i = new ts(4);
  return i[0] = r, i[1] = e, i[2] = t, i[3] = n, i;
}
function vse(r, e, t, n, i) {
  return r[0] = e, r[1] = t, r[2] = n, r[3] = i, r;
}
function bse(r, e) {
  if (r === e) {
    var t = e[1];
    r[1] = e[2], r[2] = t;
  } else
    r[0] = e[0], r[1] = e[2], r[2] = e[1], r[3] = e[3];
  return r;
}
function xse(r, e) {
  var t = e[0], n = e[1], i = e[2], s = e[3], o = t * s - i * n;
  return o ? (o = 1 / o, r[0] = s * o, r[1] = -n * o, r[2] = -i * o, r[3] = t * o, r) : null;
}
function wse(r, e) {
  var t = e[0];
  return r[0] = e[3], r[1] = -e[1], r[2] = -e[2], r[3] = t, r;
}
function Tse(r) {
  return r[0] * r[3] - r[2] * r[1];
}
function qD(r, e, t) {
  var n = e[0], i = e[1], s = e[2], o = e[3], l = t[0], u = t[1], m = t[2], y = t[3];
  return r[0] = n * l + s * u, r[1] = i * l + o * u, r[2] = n * m + s * y, r[3] = i * m + o * y, r;
}
function Ese(r, e, t) {
  var n = e[0], i = e[1], s = e[2], o = e[3], l = Math.sin(t), u = Math.cos(t);
  return r[0] = n * u + s * l, r[1] = i * u + o * l, r[2] = n * -l + s * u, r[3] = i * -l + o * u, r;
}
function Cse(r, e, t) {
  var n = e[0], i = e[1], s = e[2], o = e[3], l = t[0], u = t[1];
  return r[0] = n * l, r[1] = i * l, r[2] = s * u, r[3] = o * u, r;
}
function Sse(r, e) {
  var t = Math.sin(e), n = Math.cos(e);
  return r[0] = n, r[1] = t, r[2] = -t, r[3] = n, r;
}
function Ise(r, e) {
  return r[0] = e[0], r[1] = 0, r[2] = 0, r[3] = e[1], r;
}
function Pse(r) {
  return "mat2(" + r[0] + ", " + r[1] + ", " + r[2] + ", " + r[3] + ")";
}
function Mse(r) {
  return Math.hypot(r[0], r[1], r[2], r[3]);
}
function Rse(r, e, t, n) {
  return r[2] = n[2] / n[0], t[0] = n[0], t[1] = n[1], t[3] = n[3] - r[2] * t[1], [r, e, t];
}
function Bse(r, e, t) {
  return r[0] = e[0] + t[0], r[1] = e[1] + t[1], r[2] = e[2] + t[2], r[3] = e[3] + t[3], r;
}
function XD(r, e, t) {
  return r[0] = e[0] - t[0], r[1] = e[1] - t[1], r[2] = e[2] - t[2], r[3] = e[3] - t[3], r;
}
function Ose(r, e) {
  return r[0] === e[0] && r[1] === e[1] && r[2] === e[2] && r[3] === e[3];
}
function Dse(r, e) {
  var t = r[0], n = r[1], i = r[2], s = r[3], o = e[0], l = e[1], u = e[2], m = e[3];
  return Math.abs(t - o) <= ro * Math.max(1, Math.abs(t), Math.abs(o)) && Math.abs(n - l) <= ro * Math.max(1, Math.abs(n), Math.abs(l)) && Math.abs(i - u) <= ro * Math.max(1, Math.abs(i), Math.abs(u)) && Math.abs(s - m) <= ro * Math.max(1, Math.abs(s), Math.abs(m));
}
function Lse(r, e, t) {
  return r[0] = e[0] * t, r[1] = e[1] * t, r[2] = e[2] * t, r[3] = e[3] * t, r;
}
function kse(r, e, t, n) {
  return r[0] = e[0] + t[0] * n, r[1] = e[1] + t[1] * n, r[2] = e[2] + t[2] * n, r[3] = e[3] + t[3] * n, r;
}
var Fse = qD, Nse = XD;
function Use() {
  var r = new ts(9);
  return ts != Float32Array && (r[1] = 0, r[2] = 0, r[3] = 0, r[5] = 0, r[6] = 0, r[7] = 0), r[0] = 1, r[4] = 1, r[8] = 1, r;
}
var y2 = {};
C0(y2, {
  add: () => Qoe,
  calculateW: () => Voe,
  clone: () => Xoe,
  conjugate: () => Woe,
  copy: () => Yoe,
  create: () => b2,
  dot: () => uL,
  equals: () => iae,
  exactEquals: () => nae,
  exp: () => oL,
  fromEuler: () => $oe,
  fromMat3: () => lL,
  fromValues: () => Zoe,
  getAngle: () => Foe,
  getAxisAngle: () => koe,
  identity: () => Loe,
  invert: () => Goe,
  len: () => tae,
  length: () => fL,
  lerp: () => eae,
  ln: () => aL,
  mul: () => Joe,
  multiply: () => sL,
  normalize: () => Iw,
  pow: () => joe,
  random: () => Hoe,
  rotateX: () => Noe,
  rotateY: () => Uoe,
  rotateZ: () => zoe,
  rotationTo: () => sae,
  scale: () => cL,
  set: () => Koe,
  setAxes: () => aae,
  setAxisAngle: () => iL,
  slerp: () => Dm,
  sqlerp: () => oae,
  sqrLen: () => rae,
  squaredLength: () => hL,
  str: () => qoe
});
var dr = {};
C0(dr, {
  add: () => Hse,
  angle: () => coe,
  bezier: () => toe,
  ceil: () => Gse,
  clone: () => zse,
  copy: () => Vse,
  create: () => Cw,
  cross: () => Om,
  dist: () => moe,
  distance: () => JD,
  div: () => goe,
  divide: () => QD,
  dot: () => Sw,
  equals: () => doe,
  exactEquals: () => hoe,
  floor: () => Wse,
  forEach: () => voe,
  fromValues: () => v2,
  hermite: () => eoe,
  inverse: () => Qse,
  len: () => nL,
  length: () => ZD,
  lerp: () => Jse,
  max: () => qse,
  min: () => $se,
  mul: () => Aoe,
  multiply: () => KD,
  negate: () => Kse,
  normalize: () => rL,
  random: () => roe,
  rotateX: () => ooe,
  rotateY: () => aoe,
  rotateZ: () => loe,
  round: () => Xse,
  scale: () => Zse,
  scaleAndAdd: () => Yse,
  set: () => jse,
  sqrDist: () => _oe,
  sqrLen: () => yoe,
  squaredDistance: () => eL,
  squaredLength: () => tL,
  str: () => foe,
  sub: () => poe,
  subtract: () => YD,
  transformMat3: () => ioe,
  transformMat4: () => noe,
  transformQuat: () => soe,
  zero: () => uoe
});
function Cw() {
  var r = new ts(3);
  return ts != Float32Array && (r[0] = 0, r[1] = 0, r[2] = 0), r;
}
function zse(r) {
  var e = new ts(3);
  return e[0] = r[0], e[1] = r[1], e[2] = r[2], e;
}
function ZD(r) {
  var e = r[0], t = r[1], n = r[2];
  return Math.hypot(e, t, n);
}
function v2(r, e, t) {
  var n = new ts(3);
  return n[0] = r, n[1] = e, n[2] = t, n;
}
function Vse(r, e) {
  return r[0] = e[0], r[1] = e[1], r[2] = e[2], r;
}
function jse(r, e, t, n) {
  return r[0] = e, r[1] = t, r[2] = n, r;
}
function Hse(r, e, t) {
  return r[0] = e[0] + t[0], r[1] = e[1] + t[1], r[2] = e[2] + t[2], r;
}
function YD(r, e, t) {
  return r[0] = e[0] - t[0], r[1] = e[1] - t[1], r[2] = e[2] - t[2], r;
}
function KD(r, e, t) {
  return r[0] = e[0] * t[0], r[1] = e[1] * t[1], r[2] = e[2] * t[2], r;
}
function QD(r, e, t) {
  return r[0] = e[0] / t[0], r[1] = e[1] / t[1], r[2] = e[2] / t[2], r;
}
function Gse(r, e) {
  return r[0] = Math.ceil(e[0]), r[1] = Math.ceil(e[1]), r[2] = Math.ceil(e[2]), r;
}
function Wse(r, e) {
  return r[0] = Math.floor(e[0]), r[1] = Math.floor(e[1]), r[2] = Math.floor(e[2]), r;
}
function $se(r, e, t) {
  return r[0] = Math.min(e[0], t[0]), r[1] = Math.min(e[1], t[1]), r[2] = Math.min(e[2], t[2]), r;
}
function qse(r, e, t) {
  return r[0] = Math.max(e[0], t[0]), r[1] = Math.max(e[1], t[1]), r[2] = Math.max(e[2], t[2]), r;
}
function Xse(r, e) {
  return r[0] = Math.round(e[0]), r[1] = Math.round(e[1]), r[2] = Math.round(e[2]), r;
}
function Zse(r, e, t) {
  return r[0] = e[0] * t, r[1] = e[1] * t, r[2] = e[2] * t, r;
}
function Yse(r, e, t, n) {
  return r[0] = e[0] + t[0] * n, r[1] = e[1] + t[1] * n, r[2] = e[2] + t[2] * n, r;
}
function JD(r, e) {
  var t = e[0] - r[0], n = e[1] - r[1], i = e[2] - r[2];
  return Math.hypot(t, n, i);
}
function eL(r, e) {
  var t = e[0] - r[0], n = e[1] - r[1], i = e[2] - r[2];
  return t * t + n * n + i * i;
}
function tL(r) {
  var e = r[0], t = r[1], n = r[2];
  return e * e + t * t + n * n;
}
function Kse(r, e) {
  return r[0] = -e[0], r[1] = -e[1], r[2] = -e[2], r;
}
function Qse(r, e) {
  return r[0] = 1 / e[0], r[1] = 1 / e[1], r[2] = 1 / e[2], r;
}
function rL(r, e) {
  var t = e[0], n = e[1], i = e[2], s = t * t + n * n + i * i;
  return s > 0 && (s = 1 / Math.sqrt(s)), r[0] = e[0] * s, r[1] = e[1] * s, r[2] = e[2] * s, r;
}
function Sw(r, e) {
  return r[0] * e[0] + r[1] * e[1] + r[2] * e[2];
}
function Om(r, e, t) {
  var n = e[0], i = e[1], s = e[2], o = t[0], l = t[1], u = t[2];
  return r[0] = i * u - s * l, r[1] = s * o - n * u, r[2] = n * l - i * o, r;
}
function Jse(r, e, t, n) {
  var i = e[0], s = e[1], o = e[2];
  return r[0] = i + n * (t[0] - i), r[1] = s + n * (t[1] - s), r[2] = o + n * (t[2] - o), r;
}
function eoe(r, e, t, n, i, s) {
  var o = s * s, l = o * (2 * s - 3) + 1, u = o * (s - 2) + s, m = o * (s - 1), y = o * (3 - 2 * s);
  return r[0] = e[0] * l + t[0] * u + n[0] * m + i[0] * y, r[1] = e[1] * l + t[1] * u + n[1] * m + i[1] * y, r[2] = e[2] * l + t[2] * u + n[2] * m + i[2] * y, r;
}
function toe(r, e, t, n, i, s) {
  var o = 1 - s, l = o * o, u = s * s, m = l * o, y = 3 * s * l, E = 3 * u * o, P = u * s;
  return r[0] = e[0] * m + t[0] * y + n[0] * E + i[0] * P, r[1] = e[1] * m + t[1] * y + n[1] * E + i[1] * P, r[2] = e[2] * m + t[2] * y + n[2] * E + i[2] * P, r;
}
function roe(r, e) {
  e = e || 1;
  var t = Jf() * 2 * Math.PI, n = Jf() * 2 - 1, i = Math.sqrt(1 - n * n) * e;
  return r[0] = Math.cos(t) * i, r[1] = Math.sin(t) * i, r[2] = n * e, r;
}
function noe(r, e, t) {
  var n = e[0], i = e[1], s = e[2], o = t[3] * n + t[7] * i + t[11] * s + t[15];
  return o = o || 1, r[0] = (t[0] * n + t[4] * i + t[8] * s + t[12]) / o, r[1] = (t[1] * n + t[5] * i + t[9] * s + t[13]) / o, r[2] = (t[2] * n + t[6] * i + t[10] * s + t[14]) / o, r;
}
function ioe(r, e, t) {
  var n = e[0], i = e[1], s = e[2];
  return r[0] = n * t[0] + i * t[3] + s * t[6], r[1] = n * t[1] + i * t[4] + s * t[7], r[2] = n * t[2] + i * t[5] + s * t[8], r;
}
function soe(r, e, t) {
  var n = t[0], i = t[1], s = t[2], o = t[3], l = e[0], u = e[1], m = e[2], y = i * m - s * u, E = s * l - n * m, P = n * u - i * l, L = i * P - s * E, U = s * y - n * P, V = n * E - i * y, q = o * 2;
  return y *= q, E *= q, P *= q, L *= 2, U *= 2, V *= 2, r[0] = l + y + L, r[1] = u + E + U, r[2] = m + P + V, r;
}
function ooe(r, e, t, n) {
  var i = [], s = [];
  return i[0] = e[0] - t[0], i[1] = e[1] - t[1], i[2] = e[2] - t[2], s[0] = i[0], s[1] = i[1] * Math.cos(n) - i[2] * Math.sin(n), s[2] = i[1] * Math.sin(n) + i[2] * Math.cos(n), r[0] = s[0] + t[0], r[1] = s[1] + t[1], r[2] = s[2] + t[2], r;
}
function aoe(r, e, t, n) {
  var i = [], s = [];
  return i[0] = e[0] - t[0], i[1] = e[1] - t[1], i[2] = e[2] - t[2], s[0] = i[2] * Math.sin(n) + i[0] * Math.cos(n), s[1] = i[1], s[2] = i[2] * Math.cos(n) - i[0] * Math.sin(n), r[0] = s[0] + t[0], r[1] = s[1] + t[1], r[2] = s[2] + t[2], r;
}
function loe(r, e, t, n) {
  var i = [], s = [];
  return i[0] = e[0] - t[0], i[1] = e[1] - t[1], i[2] = e[2] - t[2], s[0] = i[0] * Math.cos(n) - i[1] * Math.sin(n), s[1] = i[0] * Math.sin(n) + i[1] * Math.cos(n), s[2] = i[2], r[0] = s[0] + t[0], r[1] = s[1] + t[1], r[2] = s[2] + t[2], r;
}
function coe(r, e) {
  var t = r[0], n = r[1], i = r[2], s = e[0], o = e[1], l = e[2], u = Math.sqrt(t * t + n * n + i * i), m = Math.sqrt(s * s + o * o + l * l), y = u * m, E = y && Sw(r, e) / y;
  return Math.acos(Math.min(Math.max(E, -1), 1));
}
function uoe(r) {
  return r[0] = 0, r[1] = 0, r[2] = 0, r;
}
function foe(r) {
  return "vec3(" + r[0] + ", " + r[1] + ", " + r[2] + ")";
}
function hoe(r, e) {
  return r[0] === e[0] && r[1] === e[1] && r[2] === e[2];
}
function doe(r, e) {
  var t = r[0], n = r[1], i = r[2], s = e[0], o = e[1], l = e[2];
  return Math.abs(t - s) <= ro * Math.max(1, Math.abs(t), Math.abs(s)) && Math.abs(n - o) <= ro * Math.max(1, Math.abs(n), Math.abs(o)) && Math.abs(i - l) <= ro * Math.max(1, Math.abs(i), Math.abs(l));
}
var poe = YD, Aoe = KD, goe = QD, moe = JD, _oe = eL, nL = ZD, yoe = tL, voe = (function() {
  var r = Cw();
  return function(e, t, n, i, s, o) {
    var l, u;
    for (t || (t = 3), n || (n = 0), i ? u = Math.min(i * t + n, e.length) : u = e.length, l = n; l < u; l += t)
      r[0] = e[l], r[1] = e[l + 1], r[2] = e[l + 2], s(r, r, o), e[l] = r[0], e[l + 1] = r[1], e[l + 2] = r[2];
    return e;
  };
})();
function boe() {
  var r = new ts(4);
  return ts != Float32Array && (r[0] = 0, r[1] = 0, r[2] = 0, r[3] = 0), r;
}
function xoe(r) {
  var e = new ts(4);
  return e[0] = r[0], e[1] = r[1], e[2] = r[2], e[3] = r[3], e;
}
function woe(r, e, t, n) {
  var i = new ts(4);
  return i[0] = r, i[1] = e, i[2] = t, i[3] = n, i;
}
function Toe(r, e) {
  return r[0] = e[0], r[1] = e[1], r[2] = e[2], r[3] = e[3], r;
}
function Eoe(r, e, t, n, i) {
  return r[0] = e, r[1] = t, r[2] = n, r[3] = i, r;
}
function Coe(r, e, t) {
  return r[0] = e[0] + t[0], r[1] = e[1] + t[1], r[2] = e[2] + t[2], r[3] = e[3] + t[3], r;
}
function Soe(r, e, t) {
  return r[0] = e[0] * t, r[1] = e[1] * t, r[2] = e[2] * t, r[3] = e[3] * t, r;
}
function Ioe(r) {
  var e = r[0], t = r[1], n = r[2], i = r[3];
  return Math.hypot(e, t, n, i);
}
function Poe(r) {
  var e = r[0], t = r[1], n = r[2], i = r[3];
  return e * e + t * t + n * n + i * i;
}
function Moe(r, e) {
  var t = e[0], n = e[1], i = e[2], s = e[3], o = t * t + n * n + i * i + s * s;
  return o > 0 && (o = 1 / Math.sqrt(o)), r[0] = t * o, r[1] = n * o, r[2] = i * o, r[3] = s * o, r;
}
function Roe(r, e) {
  return r[0] * e[0] + r[1] * e[1] + r[2] * e[2] + r[3] * e[3];
}
function Boe(r, e, t, n) {
  var i = e[0], s = e[1], o = e[2], l = e[3];
  return r[0] = i + n * (t[0] - i), r[1] = s + n * (t[1] - s), r[2] = o + n * (t[2] - o), r[3] = l + n * (t[3] - l), r;
}
function Ooe(r, e) {
  return r[0] === e[0] && r[1] === e[1] && r[2] === e[2] && r[3] === e[3];
}
function Doe(r, e) {
  var t = r[0], n = r[1], i = r[2], s = r[3], o = e[0], l = e[1], u = e[2], m = e[3];
  return Math.abs(t - o) <= ro * Math.max(1, Math.abs(t), Math.abs(o)) && Math.abs(n - l) <= ro * Math.max(1, Math.abs(n), Math.abs(l)) && Math.abs(i - u) <= ro * Math.max(1, Math.abs(i), Math.abs(u)) && Math.abs(s - m) <= ro * Math.max(1, Math.abs(s), Math.abs(m));
}
(function() {
  var r = boe();
  return function(e, t, n, i, s, o) {
    var l, u;
    for (t || (t = 4), n || (n = 0), i ? u = Math.min(i * t + n, e.length) : u = e.length, l = n; l < u; l += t)
      r[0] = e[l], r[1] = e[l + 1], r[2] = e[l + 2], r[3] = e[l + 3], s(r, r, o), e[l] = r[0], e[l + 1] = r[1], e[l + 2] = r[2], e[l + 3] = r[3];
    return e;
  };
})();
function b2() {
  var r = new ts(4);
  return ts != Float32Array && (r[0] = 0, r[1] = 0, r[2] = 0), r[3] = 1, r;
}
function Loe(r) {
  return r[0] = 0, r[1] = 0, r[2] = 0, r[3] = 1, r;
}
function iL(r, e, t) {
  t = t * 0.5;
  var n = Math.sin(t);
  return r[0] = n * e[0], r[1] = n * e[1], r[2] = n * e[2], r[3] = Math.cos(t), r;
}
function koe(r, e) {
  var t = Math.acos(e[3]) * 2, n = Math.sin(t / 2);
  return n > ro ? (r[0] = e[0] / n, r[1] = e[1] / n, r[2] = e[2] / n) : (r[0] = 1, r[1] = 0, r[2] = 0), t;
}
function Foe(r, e) {
  var t = uL(r, e);
  return Math.acos(2 * t * t - 1);
}
function sL(r, e, t) {
  var n = e[0], i = e[1], s = e[2], o = e[3], l = t[0], u = t[1], m = t[2], y = t[3];
  return r[0] = n * y + o * l + i * m - s * u, r[1] = i * y + o * u + s * l - n * m, r[2] = s * y + o * m + n * u - i * l, r[3] = o * y - n * l - i * u - s * m, r;
}
function Noe(r, e, t) {
  t *= 0.5;
  var n = e[0], i = e[1], s = e[2], o = e[3], l = Math.sin(t), u = Math.cos(t);
  return r[0] = n * u + o * l, r[1] = i * u + s * l, r[2] = s * u - i * l, r[3] = o * u - n * l, r;
}
function Uoe(r, e, t) {
  t *= 0.5;
  var n = e[0], i = e[1], s = e[2], o = e[3], l = Math.sin(t), u = Math.cos(t);
  return r[0] = n * u - s * l, r[1] = i * u + o * l, r[2] = s * u + n * l, r[3] = o * u - i * l, r;
}
function zoe(r, e, t) {
  t *= 0.5;
  var n = e[0], i = e[1], s = e[2], o = e[3], l = Math.sin(t), u = Math.cos(t);
  return r[0] = n * u + i * l, r[1] = i * u - n * l, r[2] = s * u + o * l, r[3] = o * u - s * l, r;
}
function Voe(r, e) {
  var t = e[0], n = e[1], i = e[2];
  return r[0] = t, r[1] = n, r[2] = i, r[3] = Math.sqrt(Math.abs(1 - t * t - n * n - i * i)), r;
}
function oL(r, e) {
  var t = e[0], n = e[1], i = e[2], s = e[3], o = Math.sqrt(t * t + n * n + i * i), l = Math.exp(s), u = o > 0 ? l * Math.sin(o) / o : 0;
  return r[0] = t * u, r[1] = n * u, r[2] = i * u, r[3] = l * Math.cos(o), r;
}
function aL(r, e) {
  var t = e[0], n = e[1], i = e[2], s = e[3], o = Math.sqrt(t * t + n * n + i * i), l = o > 0 ? Math.atan2(o, s) / o : 0;
  return r[0] = t * l, r[1] = n * l, r[2] = i * l, r[3] = 0.5 * Math.log(t * t + n * n + i * i + s * s), r;
}
function joe(r, e, t) {
  return aL(r, e), cL(r, r, t), oL(r, r), r;
}
function Dm(r, e, t, n) {
  var i = e[0], s = e[1], o = e[2], l = e[3], u = t[0], m = t[1], y = t[2], E = t[3], P, L, U, V, q;
  return L = i * u + s * m + o * y + l * E, L < 0 && (L = -L, u = -u, m = -m, y = -y, E = -E), 1 - L > ro ? (P = Math.acos(L), U = Math.sin(P), V = Math.sin((1 - n) * P) / U, q = Math.sin(n * P) / U) : (V = 1 - n, q = n), r[0] = V * i + q * u, r[1] = V * s + q * m, r[2] = V * o + q * y, r[3] = V * l + q * E, r;
}
function Hoe(r) {
  var e = Jf(), t = Jf(), n = Jf(), i = Math.sqrt(1 - e), s = Math.sqrt(e);
  return r[0] = i * Math.sin(2 * Math.PI * t), r[1] = i * Math.cos(2 * Math.PI * t), r[2] = s * Math.sin(2 * Math.PI * n), r[3] = s * Math.cos(2 * Math.PI * n), r;
}
function Goe(r, e) {
  var t = e[0], n = e[1], i = e[2], s = e[3], o = t * t + n * n + i * i + s * s, l = o ? 1 / o : 0;
  return r[0] = -t * l, r[1] = -n * l, r[2] = -i * l, r[3] = s * l, r;
}
function Woe(r, e) {
  return r[0] = -e[0], r[1] = -e[1], r[2] = -e[2], r[3] = e[3], r;
}
function lL(r, e) {
  var t = e[0] + e[4] + e[8], n;
  if (t > 0)
    n = Math.sqrt(t + 1), r[3] = 0.5 * n, n = 0.5 / n, r[0] = (e[5] - e[7]) * n, r[1] = (e[6] - e[2]) * n, r[2] = (e[1] - e[3]) * n;
  else {
    var i = 0;
    e[4] > e[0] && (i = 1), e[8] > e[i * 3 + i] && (i = 2);
    var s = (i + 1) % 3, o = (i + 2) % 3;
    n = Math.sqrt(e[i * 3 + i] - e[s * 3 + s] - e[o * 3 + o] + 1), r[i] = 0.5 * n, n = 0.5 / n, r[3] = (e[s * 3 + o] - e[o * 3 + s]) * n, r[s] = (e[s * 3 + i] + e[i * 3 + s]) * n, r[o] = (e[o * 3 + i] + e[i * 3 + o]) * n;
  }
  return r;
}
function $oe(r, e, t, n) {
  var i = 0.5 * Math.PI / 180;
  e *= i, t *= i, n *= i;
  var s = Math.sin(e), o = Math.cos(e), l = Math.sin(t), u = Math.cos(t), m = Math.sin(n), y = Math.cos(n);
  return r[0] = s * u * y - o * l * m, r[1] = o * l * y + s * u * m, r[2] = o * u * m - s * l * y, r[3] = o * u * y + s * l * m, r;
}
function qoe(r) {
  return "quat(" + r[0] + ", " + r[1] + ", " + r[2] + ", " + r[3] + ")";
}
var Xoe = xoe, Zoe = woe, Yoe = Toe, Koe = Eoe, Qoe = Coe, Joe = sL, cL = Soe, uL = Roe, eae = Boe, fL = Ioe, tae = fL, hL = Poe, rae = hL, Iw = Moe, nae = Ooe, iae = Doe, sae = (function() {
  var r = Cw(), e = v2(1, 0, 0), t = v2(0, 1, 0);
  return function(n, i, s) {
    var o = Sw(i, s);
    return o < -0.999999 ? (Om(r, e, i), nL(r) < 1e-6 && Om(r, t, i), rL(r, r), iL(n, r, Math.PI), n) : o > 0.999999 ? (n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 1, n) : (Om(r, i, s), n[0] = r[0], n[1] = r[1], n[2] = r[2], n[3] = 1 + o, Iw(n, n));
  };
})(), oae = (function() {
  var r = b2(), e = b2();
  return function(t, n, i, s, o, l) {
    return Dm(r, n, o, l), Dm(e, i, s, l), Dm(t, r, e, 2 * l * (1 - l)), t;
  };
})(), aae = (function() {
  var r = Use();
  return function(e, t, n, i) {
    return r[0] = n[0], r[3] = n[1], r[6] = n[2], r[1] = i[0], r[4] = i[1], r[7] = i[2], r[2] = -t[0], r[5] = -t[1], r[8] = -t[2], Iw(e, lL(e, r));
  };
})(), vn = {};
C0(vn, {
  add: () => hae,
  angle: () => Bae,
  ceil: () => dae,
  clone: () => lae,
  copy: () => uae,
  create: () => dL,
  cross: () => Tae,
  dist: () => Vae,
  distance: () => mL,
  div: () => zae,
  divide: () => gL,
  dot: () => wae,
  equals: () => kae,
  exactEquals: () => Lae,
  floor: () => pae,
  forEach: () => Gae,
  fromValues: () => cae,
  inverse: () => bae,
  len: () => Fae,
  length: () => yL,
  lerp: () => Eae,
  max: () => gae,
  min: () => Aae,
  mul: () => Uae,
  multiply: () => AL,
  negate: () => vae,
  normalize: () => xae,
  random: () => Cae,
  rotate: () => Rae,
  round: () => mae,
  scale: () => _ae,
  scaleAndAdd: () => yae,
  set: () => fae,
  sqrDist: () => jae,
  sqrLen: () => Hae,
  squaredDistance: () => _L,
  squaredLength: () => vL,
  str: () => Dae,
  sub: () => Nae,
  subtract: () => pL,
  transformMat2: () => Sae,
  transformMat2d: () => Iae,
  transformMat3: () => Pae,
  transformMat4: () => Mae,
  zero: () => Oae
});
function dL() {
  var r = new ts(2);
  return ts != Float32Array && (r[0] = 0, r[1] = 0), r;
}
function lae(r) {
  var e = new ts(2);
  return e[0] = r[0], e[1] = r[1], e;
}
function cae(r, e) {
  var t = new ts(2);
  return t[0] = r, t[1] = e, t;
}
function uae(r, e) {
  return r[0] = e[0], r[1] = e[1], r;
}
function fae(r, e, t) {
  return r[0] = e, r[1] = t, r;
}
function hae(r, e, t) {
  return r[0] = e[0] + t[0], r[1] = e[1] + t[1], r;
}
function pL(r, e, t) {
  return r[0] = e[0] - t[0], r[1] = e[1] - t[1], r;
}
function AL(r, e, t) {
  return r[0] = e[0] * t[0], r[1] = e[1] * t[1], r;
}
function gL(r, e, t) {
  return r[0] = e[0] / t[0], r[1] = e[1] / t[1], r;
}
function dae(r, e) {
  return r[0] = Math.ceil(e[0]), r[1] = Math.ceil(e[1]), r;
}
function pae(r, e) {
  return r[0] = Math.floor(e[0]), r[1] = Math.floor(e[1]), r;
}
function Aae(r, e, t) {
  return r[0] = Math.min(e[0], t[0]), r[1] = Math.min(e[1], t[1]), r;
}
function gae(r, e, t) {
  return r[0] = Math.max(e[0], t[0]), r[1] = Math.max(e[1], t[1]), r;
}
function mae(r, e) {
  return r[0] = Math.round(e[0]), r[1] = Math.round(e[1]), r;
}
function _ae(r, e, t) {
  return r[0] = e[0] * t, r[1] = e[1] * t, r;
}
function yae(r, e, t, n) {
  return r[0] = e[0] + t[0] * n, r[1] = e[1] + t[1] * n, r;
}
function mL(r, e) {
  var t = e[0] - r[0], n = e[1] - r[1];
  return Math.hypot(t, n);
}
function _L(r, e) {
  var t = e[0] - r[0], n = e[1] - r[1];
  return t * t + n * n;
}
function yL(r) {
  var e = r[0], t = r[1];
  return Math.hypot(e, t);
}
function vL(r) {
  var e = r[0], t = r[1];
  return e * e + t * t;
}
function vae(r, e) {
  return r[0] = -e[0], r[1] = -e[1], r;
}
function bae(r, e) {
  return r[0] = 1 / e[0], r[1] = 1 / e[1], r;
}
function xae(r, e) {
  var t = e[0], n = e[1], i = t * t + n * n;
  return i > 0 && (i = 1 / Math.sqrt(i)), r[0] = e[0] * i, r[1] = e[1] * i, r;
}
function wae(r, e) {
  return r[0] * e[0] + r[1] * e[1];
}
function Tae(r, e, t) {
  var n = e[0] * t[1] - e[1] * t[0];
  return r[0] = r[1] = 0, r[2] = n, r;
}
function Eae(r, e, t, n) {
  var i = e[0], s = e[1];
  return r[0] = i + n * (t[0] - i), r[1] = s + n * (t[1] - s), r;
}
function Cae(r, e) {
  e = e || 1;
  var t = Jf() * 2 * Math.PI;
  return r[0] = Math.cos(t) * e, r[1] = Math.sin(t) * e, r;
}
function Sae(r, e, t) {
  var n = e[0], i = e[1];
  return r[0] = t[0] * n + t[2] * i, r[1] = t[1] * n + t[3] * i, r;
}
function Iae(r, e, t) {
  var n = e[0], i = e[1];
  return r[0] = t[0] * n + t[2] * i + t[4], r[1] = t[1] * n + t[3] * i + t[5], r;
}
function Pae(r, e, t) {
  var n = e[0], i = e[1];
  return r[0] = t[0] * n + t[3] * i + t[6], r[1] = t[1] * n + t[4] * i + t[7], r;
}
function Mae(r, e, t) {
  var n = e[0], i = e[1];
  return r[0] = t[0] * n + t[4] * i + t[12], r[1] = t[1] * n + t[5] * i + t[13], r;
}
function Rae(r, e, t, n) {
  var i = e[0] - t[0], s = e[1] - t[1], o = Math.sin(n), l = Math.cos(n);
  return r[0] = i * l - s * o + t[0], r[1] = i * o + s * l + t[1], r;
}
function Bae(r, e) {
  var t = r[0], n = r[1], i = e[0], s = e[1], o = Math.sqrt(t * t + n * n) * Math.sqrt(i * i + s * s), l = o && (t * i + n * s) / o;
  return Math.acos(Math.min(Math.max(l, -1), 1));
}
function Oae(r) {
  return r[0] = 0, r[1] = 0, r;
}
function Dae(r) {
  return "vec2(" + r[0] + ", " + r[1] + ")";
}
function Lae(r, e) {
  return r[0] === e[0] && r[1] === e[1];
}
function kae(r, e) {
  var t = r[0], n = r[1], i = e[0], s = e[1];
  return Math.abs(t - i) <= ro * Math.max(1, Math.abs(t), Math.abs(i)) && Math.abs(n - s) <= ro * Math.max(1, Math.abs(n), Math.abs(s));
}
var Fae = yL, Nae = pL, Uae = AL, zae = gL, Vae = mL, jae = _L, Hae = vL, Gae = (function() {
  var r = dL();
  return function(e, t, n, i, s, o) {
    var l, u;
    for (t || (t = 2), n || (n = 0), i ? u = Math.min(i * t + n, e.length) : u = e.length, l = n; l < u; l += t)
      r[0] = e[l], r[1] = e[l + 1], s(r, r, o), e[l] = r[0], e[l + 1] = r[1];
    return e;
  };
})(), Wae = (1 + Math.sqrt(5)) / 2, __ = 2 * Math.PI / 5, ac = Math.PI / 5, xP = Math.PI / 10, $ae = 2 * Math.atan(Wae), x2 = Math.PI - $ae, ey = (Math.sqrt(5) - 1) / 2, qae = 3 - Math.sqrt(5);
Fo.setMatrixArrayType(Float64Array);
var Pw = class w2 {
  constructor(e) {
    this.vertices = e, this.isWindingCorrect() || this.vertices.reverse();
  }
  getArea() {
    let e = 0;
    const t = this.vertices.length;
    for (let n = 0; n < t; n++) {
      const i = (n + 1) % t;
      e += (this.vertices[i][0] - this.vertices[n][0]) * (this.vertices[i][1] + this.vertices[n][1]);
    }
    return e;
  }
  isWindingCorrect() {
    return this.getArea() >= 0;
  }
  getVertices() {
    return this.vertices;
  }
  scale(e) {
    for (const t of this.vertices)
      vn.scale(t, t, e);
    return this;
  }
  /**
   * Rotates the pentagon 180 degrees (equivalent to negating x & y)
   * @returns The rotated pentagon
   */
  rotate180() {
    for (const e of this.vertices)
      vn.negate(e, e);
    return this;
  }
  /**
   * Reflects the pentagon over the x-axis (equivalent to negating y)
   * and reverses the winding order to maintain consistent orientation
   * @returns The reflected pentagon
   */
  reflectY() {
    for (const e of this.vertices)
      e[1] = -e[1];
    return this.vertices.reverse(), this;
  }
  translate(e) {
    for (const t of this.vertices)
      vn.add(t, t, e);
    return this;
  }
  transform(e) {
    for (const t of this.vertices)
      vn.transformMat2(t, t, e);
    return this;
  }
  transform2d(e) {
    for (const t of this.vertices)
      vn.transformMat2d(t, t, e);
    return this;
  }
  clone() {
    return new w2(this.vertices.map((t) => vn.clone(t)));
  }
  getCenter() {
    const e = this.vertices.length;
    return this.vertices.reduce((n, i) => [n[0] + i[0] / e, n[1] + i[1] / e], [0, 0]);
  }
  /**
   * Tests if a point is inside the pentagon by checking if it's on the correct side of all edges.
   * Assumes consistent winding order (counter-clockwise).
   * @param point The point to test
   * @returns 1 if point is inside, otherwise a negative value proportional to the distance from the point to the edge
   */
  containsPoint(e) {
    if (!this.isWindingCorrect())
      throw new Error("Pentagon is not counter-clockwise");
    const t = this.vertices.length;
    let n = 1;
    for (let i = 0; i < t; i++) {
      const s = this.vertices[i], o = this.vertices[(i + 1) % t], l = s[0] - o[0], u = s[1] - o[1], m = e[0] - s[0], y = e[1] - s[1], E = l * y - u * m;
      if (E < 0) {
        const P = Math.sqrt(m * m + y * y);
        n = Math.min(n, E / P);
      }
    }
    return n;
  }
  /**
   * Splits each edge of the pentagon into the specified number of segments
   * @param segments Number of segments to split each edge into
   * @returns A new PentagonShape with more vertices, or the original PentagonShape if segments <= 1
   */
  splitEdges(e) {
    if (e <= 1)
      return this;
    const t = [], n = this.vertices.length;
    for (let i = 0; i < n; i++) {
      const s = this.vertices[i], o = this.vertices[(i + 1) % n];
      t.push(vn.clone(s));
      for (let l = 1; l < e; l++) {
        const u = l / e, m = vn.create();
        vn.lerp(m, s, o, u), t.push(m);
      }
    }
    return new w2(t);
  }
};
Fo.setMatrixArrayType(Float64Array);
var bL = [0, 0], xL = [0, 1], ah = [0.7885966681787006, 1.6149108024237764], wL = [1.6171013659387945, 1.054928690397459], TL = [Math.cos(xP), Math.sin(xP)], Xae = 2 * vn.length(ah) * Math.cos(ac), Zae = ac - Math.atan2(ah[1], ah[0]), Yae = 2 * ey / Xae;
[bL, xL, ah, wL, TL].forEach((r) => {
  vn.scale(r, r, Yae), vn.rotate(r, r, [0, 0], Zae);
});
var Kae = new Pw([bL, xL, ah, wL, TL]), EL = Math.atan2(ah[1], ah[0]) - ac, Qae = [0, 0], y_ = ey / Math.cos(ac), wP = EL + ac, v_ = [y_ * Math.cos(wP), y_ * Math.sin(wP)], TP = EL - ac, p0 = [y_ * Math.cos(TP), y_ * Math.sin(TP)], Jae = new Pw([Qae, v_, p0]), CL = oh.fromValues(v_[0], v_[1], p0[0], p0[1]);
oh.invert(oh.create(), CL);
var ele = new Float64Array([
  -0.0022392098386786394,
  21308606513250217e-22,
  -2559257686421274e-24,
  33701965267802837e-28,
  -4667545312611249e-30,
  667492870384816e-32
]), tle = new Float64Array([
  0.0022392089963541657,
  28831978048607556e-22,
  508622073997266e-23,
  102018123778161e-25,
  21912872306767718e-30,
  49284235482523806e-33
]), rle = class {
  /**
   * Applies coefficients using Clenshaw summation algorithm (order 6)
   * @param phi Angle in radians
   * @param C Array of coefficients
   * @returns Transformed angle in radians
   */
  applyCoefficients(r, e) {
    const t = Math.sin(r), n = Math.cos(r), i = 2 * (n - t) * (n + t);
    let s, o;
    return s = i * e[5] + e[4], o = i * s + e[3], s = i * o - s + e[2], o = i * s - o + e[1], s = i * o - s + e[0], r + 2 * t * n * s;
  }
  /**
   * Converts geodetic latitude to authalic latitude
   * @param phi Geodetic latitude in radians
   * @returns Authalic latitude in radians
   */
  forward(r) {
    return this.applyCoefficients(r, ele);
  }
  /**
   * Converts authalic latitude to geodetic latitude
   * @param phi Authalic latitude in radians
   * @returns Geodetic latitude in radians
   */
  inverse(r) {
    return this.applyCoefficients(r, tle);
  }
};
Fo.setMatrixArrayType(Float64Array);
var SL = new rle();
function EP(r) {
  return r * (Math.PI / 180);
}
function CP(r) {
  return r * (180 / Math.PI);
}
function SP(r) {
  const e = vn.length(r), t = Math.atan2(r[1], r[0]);
  return [e, t];
}
function nle([r, e]) {
  const t = r * Math.cos(e), n = r * Math.sin(e);
  return [t, n];
}
function ile(r, [e, t, n]) {
  const i = [e[0] - n[0], e[1] - n[1]], s = [n[0] - t[0], n[1] - t[1]], o = [r[0] - n[0], r[1] - n[1]], l = s[0] * i[1] - s[1] * i[0], u = (s[0] * o[1] - s[1] * o[0]) / l, m = (i[0] * o[1] - i[1] * o[0]) / l, y = 1 - (u + m);
  return [u, m, y];
}
function sle(r, [e, t, n]) {
  return [
    r[0] * e[0] + r[1] * t[0] + r[2] * n[0],
    r[0] * e[1] + r[1] * t[1] + r[2] * n[1]
  ];
}
function T2(r) {
  const e = Math.atan2(r[1], r[0]), t = Math.sqrt(r[0] * r[0] + r[1] * r[1] + r[2] * r[2]), n = Math.acos(r[2] / t);
  return [e, n];
}
function hp([r, e]) {
  const t = Math.sin(e), n = t * Math.cos(r), i = t * Math.sin(r), s = Math.cos(e);
  return [n, i, s];
}
var IL = 93;
function ole([r, e]) {
  const t = EP(r + IL), n = EP(e), i = SL.forward(n), s = Math.PI / 2 - i;
  return [t, s];
}
function PL([r, e]) {
  const t = CP(r) - IL, n = Math.PI / 2 - e, i = SL.inverse(n), s = CP(i);
  return [t, s];
}
function ale(r) {
  const e = r.map((s) => hp(ole(s))), t = dr.create();
  for (const s of e)
    dr.add(t, t, s);
  dr.normalize(t, t);
  let [n, i] = PL(T2(t));
  return (i > 89.99 || i < -89.99) && (n = r[0][0]), n = ((n + 180) % 360 + 360) % 360 - 180, r.map((s) => {
    let [o, l] = s;
    for (; o - n > 180; ) o = o - 360;
    for (; o - n < -180; ) o = o + 360;
    return [o, l];
  });
}
Fo.setMatrixArrayType(Float64Array);
var ty = Math.sqrt(5), ry = Math.sqrt(0.2), ML = Math.sqrt((1 - ry) / 2), RL = Math.sqrt((1 + ry) / 2), Vg = 0.5, IP = Math.sqrt((2.5 - ty) / 10), PP = Math.sqrt((2.5 + ty) / 10), MP = Math.sqrt((1 + ry) / 8), RP = Math.sqrt((1 - ry) / 8), BP = Math.sqrt((3 - ty) / 8), OP = Math.sqrt((3 + ty) / 8), lle = [
  [0, 0],
  // Doesn't actually matter as rotation is 0
  // First ring: five vertices, CCW, multiplied by sinAlpha
  [ML, 0],
  // [cos0, sin0]
  [IP, Vg],
  // [cos72, sin72]
  [-MP, BP],
  // [-cos36, sin36]
  [-MP, -BP],
  // [-cos36, -sin36]
  [IP, -Vg],
  // [cos72, -sin72]
  // Second ring: the same five vertices but negated (180deg rotation), multiplied by cosAlpha
  [-RL, 0],
  // [-cos0, -sin0]
  [-RP, -OP],
  // [-cos72, -sin72]
  [PP, -Vg],
  // [cos36, -sin36]
  [PP, Vg],
  // [cos36, sin36]
  [-RP, OP],
  // [-cos72, sin72]
  [0, 0]
], cle = lle.map(([r, e]) => [-e, r]), jg = cle.map((r, e) => e === 0 ? [0, 0, 0, 1] : e === 11 ? [0, -1, 0, 0] : [...r, 0, e < 6 ? RL : ML]);
Fo.setMatrixArrayType(Float64Array);
var BL = ["vu", "uw", "vw", "vw", "vw"], kA = ["wu", "uw", "vw", "vu", "uw"], g1 = ["wu", "uv", "wv", "wu", "uw"], Hg = ["vu", "uv", "wv", "wu", "uw"], ule = [
  BL,
  // 0 Arctic
  Hg,
  // 1 North America
  g1,
  // 2 South America
  kA,
  // 3 North Atlantic & Western Europe & Africa
  g1,
  // 4 South Atlantic & Africa
  Hg,
  // 5 Europe, Middle East & CentralAfrica
  g1,
  // 6 Indian Ocean
  kA,
  // 7 Asia
  kA,
  // 8 Australia
  kA,
  // 9 North Pacific
  Hg,
  // 10 South Pacific
  Hg
  // 11 Antarctic
], fle = [4, 2, 3, 2, 0, 4, 3, 2, 2, 0, 3, 0], DP = [0, 1, 2, 4, 3, 5, 7, 8, 6, 11, 10, 9], _l = [];
function hle() {
  Gg([0, 0], 0, jg[0]);
  for (let r = 0; r < 5; r++) {
    const e = r * __, t = e + ac;
    Gg([e, x2], ac, jg[r + 1]), Gg([t, Math.PI - x2], ac, jg[(r + 3) % 5 + 6]);
  }
  Gg([0, Math.PI], 0, jg[11]);
}
var Ed = 0;
function Gg(r, e, t) {
  if (Ed > 11)
    throw new Error(`Too many origins: ${Ed}`);
  const n = y2.create();
  y2.conjugate(n, t);
  const i = {
    id: Ed,
    axis: r,
    quat: t,
    inverseQuat: n,
    angle: e,
    orientation: ule[Ed],
    firstQuintant: fle[Ed]
  };
  _l.push(i), Ed++;
}
hle();
_l.sort((r, e) => DP.indexOf(r.id) - DP.indexOf(e.id));
_l.forEach((r, e) => r.id = e);
function dle(r, e) {
  const t = e.orientation, n = t === BL || t === kA ? -1 : 1, i = (r - e.firstQuintant + 5) % 5, s = t[i];
  return { quintant: (e.firstQuintant + n * i + 5) % 5, orientation: s };
}
var ple = class {
  /**
   * Projects spherical coordinates to polar coordinates using gnomonic projection
   * @param spherical Spherical coordinates [theta, phi]
   * @returns Polar coordinates [rho, gamma]
   */
  forward([r, e]) {
    return [Math.tan(e), r];
  }
  /**
   * Unprojects polar coordinates to spherical coordinates using gnomonic projection
   * @param polar Polar coordinates [rho, gamma]
   * @returns Spherical coordinates [theta, phi]
   */
  inverse([r, e]) {
    return [e, Math.atan(r)];
  }
}, Cd = dr.create(), KA = dr.create(), LP = dr.create(), kP = dr.create();
function m1(r, e) {
  dr.lerp(Cd, r, e, 0.5), dr.normalize(Cd, Cd), dr.cross(Cd, r, Cd);
  const t = dr.length(Cd);
  if (t < 1e-8) {
    const n = dr.subtract(dr.create(), r, e);
    return 0.5 * dr.length(n);
  }
  return t;
}
function Ale(r, e, t) {
  return dr.cross(KA, e, t), dr.dot(r, KA);
}
function gle(r, e, t, n, i) {
  dr.cross(KA, n, i);
  const s = dr.dot(e, KA), o = dr.dot(t, KA);
  return dr.scale(LP, e, o), dr.scale(kP, t, s), dr.sub(r, kP, LP);
}
function E2(r, e, t, n) {
  const i = dr.angle(e, t);
  if (i < 1e-12)
    return dr.lerp(r, e, t, n);
  const s = Math.sin((1 - n) * i) / Math.sin(i), o = Math.sin(n * i) / Math.sin(i), l = dr.scale(dr.create(), e, s), u = dr.scale(dr.create(), t, o);
  return dr.add(r, l, u);
}
Fo.setMatrixArrayType(Float64Array);
var Wg = dr.create(), $g = dr.create(), qg = dr.create(), Sd = dr.create(), mle = class {
  constructor(r) {
    this._area = null, this.vertices = r, Object.freeze(this.vertices);
  }
  /**
   * 
   * @param nSegments Returns a closed boundary of the polygon, with nSegments points per edge
   * @returns SphericalPolygon
   */
  getBoundary(r = 1, e = !0) {
    const t = [], n = this.vertices.length;
    for (let i = 0; i < n * r; i++) {
      const s = i / r;
      t.push(this.slerp(s));
    }
    return e && t.push(t[0]), t;
  }
  /**
   * Interpolates along boundary of polygon. Pass t = 1.5 to get the midpoint between 2nd and 3rd vertices
   * @param t 
   * @returns Cartesian coordinate
   */
  slerp(r) {
    const e = this.vertices.length, t = r % 1, n = Math.floor(r % e), i = (n + 1) % e;
    return E2(dr.create(), this.vertices[n], this.vertices[i], t);
  }
  /**
   * Returns the vertex given by index t, along with the vectors:
   * - VA: Vector from vertex to point A
   * - VB: Vector from vertex to point B
   * @param t 
   * @returns 
   */
  getTransformedVertices(r) {
    const e = this.vertices.length, t = Math.floor(r % e), n = (t + 1) % e, i = (t + e - 1) % e, s = dr.clone(this.vertices[t]), o = dr.clone(this.vertices[n]), l = dr.clone(this.vertices[i]);
    return dr.sub(o, o, s), dr.sub(l, l, s), [s, o, l];
  }
  containsPoint(r) {
    const e = this.vertices.length;
    let t = 1 / 0;
    for (let n = 0; n < e; n++) {
      const [i, s, o] = this.getTransformedVertices(n), l = dr.sub(dr.create(), r, i);
      dr.normalize(l, l), dr.normalize(s, s), dr.normalize(o, o);
      const u = dr.cross(dr.create(), s, l), m = dr.cross(dr.create(), l, o), y = dr.dot(i, u), E = dr.dot(i, m);
      t = Math.min(t, y, E);
    }
    return t;
  }
  /**
   * Calculate the area of a spherical triangle given three vertices
   * @param v1 First vertex
   * @param v2 Second vertex  
   * @param v3 Third vertex
   * @returns Area of the spherical triangle in radians
   */
  getTriangleArea(r, e, t) {
    dr.lerp(Wg, e, t, 0.5), dr.lerp($g, t, r, 0.5), dr.lerp(qg, r, e, 0.5), dr.normalize(Wg, Wg), dr.normalize($g, $g), dr.normalize(qg, qg);
    const n = Ale(Wg, $g, qg), i = Math.max(-1, Math.min(1, n));
    return Math.abs(i) < 1e-8 ? 2 * i : Math.asin(i) * 2;
  }
  /**
   * Calculate the area of the spherical polygon by decomposing it into a fan of triangles
   * @returns The area of the spherical polygon in radians
   */
  getArea() {
    return this._area === null && (this._area = this._getArea()), this._area;
  }
  _getArea() {
    if (this.vertices.length < 3)
      return 0;
    if (this.vertices.length === 3)
      return this._area = this.getTriangleArea(this.vertices[0], this.vertices[1], this.vertices[2]), this._area;
    dr.set(Sd, 0, 0, 0);
    for (const e of this.vertices)
      dr.add(Sd, Sd, e);
    dr.normalize(Sd, Sd);
    let r = 0;
    for (let e = 0; e < this.vertices.length; e++) {
      const t = this.vertices[e], n = this.vertices[(e + 1) % this.vertices.length], i = this.getTriangleArea(Sd, t, n);
      isNaN(i) || (r += i);
    }
    return this._area = r, this._area;
  }
  /**
   * For debugging purposes, check if the winding order is correct
   * In production, should always be correct
   */
  isWindingCorrect() {
    if (!(this.getArea() > 0))
      debugger;
  }
};
Fo.setMatrixArrayType(Float64Array);
var Xg = class extends mle {
  constructor(r) {
    if (r.length !== 3)
      throw new Error("SphericalTriangleShape requires exactly 3 vertices");
    super(r);
  }
};
Fo.setMatrixArrayType(Float64Array);
var _le = class {
  /**
   * Forward projection: converts a spherical point to face coordinates
   * @param v - The spherical point to project
   * @param sphericalTriangle - The spherical triangle vertices
   * @param faceTriangle - The face triangle vertices
   * @returns The face coordinates
   */
  forward(r, e, t) {
    const [n, i, s] = e, o = new Xg([n, i, s]), l = dr.subtract(dr.create(), r, n);
    dr.normalize(l, l);
    const u = gle(dr.create(), n, l, i, s);
    dr.normalize(u, u);
    const m = m1(n, r) / m1(n, u), y = o.getArea(), E = m / y, P = [
      1 - m,
      E * new Xg([n, u, s]).getArea(),
      E * new Xg([n, i, u]).getArea()
    ];
    return sle(P, t);
  }
  /**
   * Inverse projection: converts face coordinates back to spherical coordinates
   * @param facePoint - The face coordinates
   * @param faceTriangle - The face triangle vertices
   * @param sphericalTriangle - The spherical triangle vertices
   * @returns The spherical coordinates
   */
  inverse(r, e, t) {
    const [n, i, s] = t, o = new Xg([n, i, s]), l = ile(r, e), u = 1 - 1e-14;
    if (l[0] > u) return n;
    if (l[1] > u) return i;
    if (l[2] > u) return s;
    const m = dr.create();
    dr.cross(m, i, s);
    const y = o.getArea(), E = 1 - l[0], L = l[2] / E * y, U = Math.sin(L), V = Math.sin(L / 2), q = 2 * V * V, j = dr.dot(n, i), K = dr.dot(i, s), Y = dr.dot(s, n), de = dr.length(m), ne = dr.dot(n, m), ae = U * ne + q * (j * K - Y), De = q * de * (1 + j), Ge = 2 / Math.acos(K) * Math.atan2(De, ae), fe = E2(dr.create(), i, s, Ge), ve = m1(n, fe), me = this.safeAcos(E * ve) / this.safeAcos(ve);
    return E2([0, 0, 0], n, fe, me);
  }
  /**
   * Computes acos(1 - 2 * x * x) without loss of precision for small x
   * @param x 
   * @returns acos(1 - x)
   */
  safeAcos(r) {
    return r < 1e-3 ? 2 * r + r * r * r / 3 : Math.acos(1 - 2 * r * r);
  }
};
Fo.setMatrixArrayType(Float64Array);
var fa = -1, Lo = 1, yle = ([r, e]) => vn.fromValues(r - e, e), C2 = vn.fromValues(1, 0), S2 = vn.fromValues(0, 1), FP = vn.negate(vn.create(), C2), NP = vn.negate(vn.create(), S2), _1 = vn.fromValues(0, 0), vle = (r, [e, t]) => {
  let n = _1, i = _1;
  switch (e === Lo && t === Lo ? (n = C2, i = S2) : e === fa && t === Lo ? (n = NP, i = FP) : e === Lo && t === fa ? (n = S2, i = C2) : e === fa && t === fa && (n = FP, i = NP), r) {
    case 0:
      return _1;
    // Length 0
    case 1:
      return n;
    // Length 1
    case 2:
      return vn.add(vn.create(), i, n);
    // Length SQRT2
    case 3:
      return vn.scaleAndAdd(vn.create(), i, n, 2);
    // Length SQRT5
    default:
      throw new Error(`Invalid Quaternary value: ${r}`);
  }
}, UP = (r) => [[Lo, Lo], [Lo, fa], [Lo, Lo], [fa, Lo]][r], zP = vn.fromValues(-1, 1);
function OL(r) {
  return Array.from({ length: r.length }, (e, t) => r.indexOf(t));
}
var DL = [0, 1, 3, 4, 5, 6, 7, 2], LL = [0, 1, 2, 7, 3, 4, 5, 6];
OL(DL);
OL(LL);
var ble = (r, e, t, n, i) => {
  if (e <= 0) return;
  const s = r[e] || 0, o = r[e - 1], l = t[0] + t[1];
  let u = !0, m = !0;
  if (n !== (l === 0) ? (u = s === 1 || s === 2, m = s === 1) : (u = s < 2, m = s === 0), !u) return;
  const y = m ? o : o + 4, E = i[y];
  r[e - 1] = E % 4, r[e] = (s + 4 + Math.floor(E / 4) - Math.floor(y / 4)) % 4;
}, xle = (r, e, t) => {
  let n = BigInt(r);
  const i = t === "vu" || t === "wu" || t === "vw", s = t === "wv" || t === "vw", o = t === "wu" || t === "uw";
  i && (n = (1n << BigInt(2 * e)) - n - 1n);
  const l = wle(n, e, s, o);
  if (o) {
    const { offset: [u, m], flips: [y, E] } = l;
    l.offset = [m, u], y === fa && vn.add(l.offset, l.offset, zP), E === fa && vn.subtract(l.offset, l.offset, zP);
  }
  if (s) {
    const { offset: [u, m], flips: y } = l, E = (1 << e) - (u + m);
    y[0] = -y[0], l.offset[1] = E, l.flips = y;
  }
  return l;
}, wle = (r, e, t, n) => {
  const i = vn.create(), s = [Lo, Lo];
  let o = BigInt(r);
  const l = [];
  for (; o > 0n || l.length < e; )
    l.push(Number(o % 4n)), o = o >> 2n;
  const u = n ? LL : DL;
  for (let y = l.length - 1; y >= 0; y--)
    ble(l, y, s, t, u), vn.multiply(s, s, UP(l[y]));
  s[0] = Lo, s[1] = Lo;
  for (let y = l.length - 1; y >= 0; y--) {
    vn.scale(i, i, 2);
    const E = vle(l[y], s);
    vn.add(i, i, E), vn.multiply(s, s, UP(l[y]));
  }
  const m = l[0] || 0;
  return { flips: s, k: m, offset: yle(i) };
};
Fo.setMatrixArrayType(Float64Array);
var Tle = vn.clone(p0), Ele = vn.negate(vn.create(), p0), Mw = [0, 1, 2, 3, 4].map((r) => {
  const e = oh.create();
  return oh.fromRotation(e, __ * r), e;
}), VP = vn.create();
function Cle(r, e, t) {
  const n = Kae.clone();
  vn.transformMat2(VP, t.offset, CL), t.flips[0] === Lo && t.flips[1] === fa && n.rotate180();
  const { k: i } = t, s = t.flips[0] + t.flips[1];
  return (
    // Orient last two pentagons when both or neither flips are YES
    ((s === -2 || s === 2) && i > 1 || // Orient first & last pentagons when only one of flips is YES
    s === 0 && (i === 0 || i === 3)) && n.reflectY(), t.flips[0] === fa && t.flips[1] === fa ? n.rotate180() : t.flips[0] === fa ? n.translate(Ele) : t.flips[1] === fa && n.translate(Tle), n.translate(VP), n.scale(1 / 2 ** r), n.transform(Mw[e]), n
  );
}
function kL(r) {
  const e = Jae.clone();
  return e.transform(Mw[r]), e;
}
function Sle() {
  const r = [];
  for (const e of Mw)
    r.push(vn.transformMat2(vn.create(), v_, e));
  return r.reverse(), new Pw(r);
}
Fo.setMatrixArrayType(Float64Array);
var Ile = class {
  constructor() {
    if (this.vertices = [], this.invocations = 0, this.addFaceCenters(), this.addVertices(), this.addMidpoints(), this.vertices.length !== 62)
      throw new Error("Failed to construct CRS: vertices length is not 62");
    Object.freeze(this.vertices);
  }
  getVertex(r) {
    this.invocations++, this.invocations === 1e4 && console.warn("Too many CRS invocations, results should be cached");
    for (const e of this.vertices)
      if (dr.distance(r, e) < 1e-5)
        return e;
    throw new Error("Failed to find vertex in CRS");
  }
  addFaceCenters() {
    _l.forEach((r) => this.add(hp(r.axis)));
  }
  addVertices() {
    const r = Math.atan(qae);
    for (const e of _l)
      for (let t = 0; t < 5; t++) {
        const n = (2 * t + 1) * Math.PI / 5, i = hp([n + e.angle, r]);
        dr.transformQuat(i, i, e.quat), this.add(i);
      }
  }
  addMidpoints() {
    const r = Math.atan(ey);
    for (const e of _l)
      for (let t = 0; t < 5; t++) {
        const n = 2 * t * Math.PI / 5, i = hp([n + e.angle, r]);
        dr.transformQuat(i, i, e.quat), this.add(i);
      }
  }
  add(r) {
    const e = dr.normalize(dr.create(), r);
    return this.vertices.find((n) => dr.distance(e, n) < 1e-5) ? !1 : (this.vertices.push(e), !0);
  }
};
Fo.setMatrixArrayType(Float64Array);
var Ple = new Ile(), Mle = class {
  constructor() {
    this.faceTriangles = [], this.sphericalTriangles = [], this.polyhedral = new _le(), this.gnomonic = new ple();
  }
  /**
   * Projects spherical coordinates to face coordinates using dodecahedron projection
   * @param spherical Spherical coordinates [theta, phi]
   * @param originId Origin ID
   * @returns Face coordinates [x, y]
   */
  forward(r, e) {
    const t = _l[e], n = hp(r), i = dr.create();
    dr.transformQuat(i, n, t.inverseQuat);
    const s = T2(i), o = this.gnomonic.forward(s);
    o[1] = o[1] - t.angle;
    const l = this.getFaceTriangleIndex(o), u = this.shouldReflect(o);
    let m = this.getFaceTriangle(l, u, !1), y = this.getSphericalTriangle(l, e, u);
    return this.polyhedral.forward(n, y, m);
  }
  /**
   * Unprojects face coordinates to spherical coordinates using dodecahedron projection
   * @param face Face coordinates [x, y]
   * @param originId Origin ID
   * @returns Spherical coordinates [theta, phi]
   */
  inverse(r, e) {
    const t = SP(r), n = this.getFaceTriangleIndex(t), i = this.shouldReflect(t), s = this.getFaceTriangle(n, i, !1), o = this.getSphericalTriangle(n, e, i), l = this.polyhedral.inverse(r, s, o);
    return T2(l);
  }
  /**
   * Detects when point is beyond the edge of the dodecahedron face
   * In the standard case (reflect = false), the face and spherical triangle can be
   * used directly.
   * In the reflected case (reflect = true), the point is beyond the edge of the dodecahedron face,
   * and so the face triangle is squashed to unproject correctly onto the neighboring dodecahedron face.
   * @param polar Polar coordinates
   * @returns True if point is beyond the edge of the dodecahedron face
   */
  shouldReflect(r) {
    const [e, t] = r;
    return nle([e, this.normalizeGamma(t)])[0] > ey;
  }
  /**
   * Given a polar coordinate, returns the index of the face triangle it belongs to
   * @param polar Polar coordinates
   * @returns Face triangle index, value from 0 to 9
   */
  getFaceTriangleIndex([r, e]) {
    return (Math.floor(e / ac) + 10) % 10;
  }
  /**
   * Gets the face triangle for a given polar coordinate
   * @param faceTriangleIndex Face triangle index, value from 0 to 9
   * @returns FaceTriangle: 3 vertices in counter-clockwise order
   */
  getFaceTriangle(r, e = !1, t = !1) {
    let n = r;
    return e && (n += t ? 20 : 10), this.faceTriangles[n] ? this.faceTriangles[n] : (this.faceTriangles[n] = e ? this._getReflectedFaceTriangle(r, t) : this._getFaceTriangle(r), Object.freeze(this.faceTriangles[n]), this.faceTriangles[n]);
  }
  _getFaceTriangle(r) {
    const e = Math.floor((r + 1) / 2) % 5, [t, n, i] = kL(e).getVertices(), s = vn.create();
    return vn.lerp(s, n, i, 0.5), r % 2 === 0 ? [t, s, n] : [t, i, s];
  }
  _getReflectedFaceTriangle(r, e = !1) {
    let [t, n, i] = this._getFaceTriangle(r).map((l) => vn.clone(l));
    const s = r % 2 === 0;
    vn.negate(t, t);
    const o = s ? n : i;
    return vn.scaleAndAdd(t, t, o, e ? 1 + 1 / Math.cos(x2) : 2), [t, i, n];
  }
  /**
   * Gets the spherical triangle for a given face triangle index and origin
   * @param faceTriangleIndex Face triangle index
   * @param originId Origin ID
   * @returns Spherical triangle
   */
  getSphericalTriangle(r, e, t = !1) {
    let n = 10 * e + r;
    return t && (n += 120), this.sphericalTriangles[n] ? this.sphericalTriangles[n] : (this.sphericalTriangles[n] = this._getSphericalTriangle(r, e, t), Object.freeze(this.sphericalTriangles[n]), this.sphericalTriangles[n]);
  }
  _getSphericalTriangle(r, e, t = !1) {
    const n = _l[e];
    return this.getFaceTriangle(r, t, !0).map((o) => {
      const [l, u] = SP(o), m = [l, u + n.angle], y = hp(this.gnomonic.inverse(m));
      return dr.transformQuat(y, y, n.quat), Ple.getVertex(y);
    });
  }
  /**
   * Normalizes gamma to the range [-PI_OVER_5, PI_OVER_5]
   * @param gamma The gamma value to normalize
   * @returns Normalized gamma value
   */
  normalizeGamma(r) {
    const e = r / __, t = Math.round(e);
    return (e - t) * __;
  }
}, dp = 2, Rle = 30, Ble = 58n, Ole = 0x3ffffffffffffffn;
function Dle(r) {
  let e = Rle - 1, t = r >> 1n;
  for (; e > -1 && (t & 0b1n) === 0n; )
    e -= 1, t = t >> (e < dp ? 1n : 2n);
  return e;
}
function Lle(r) {
  const e = Dle(r);
  if (e === -1)
    return { origin: _l[0], segment: 0, S: 0n, resolution: e };
  const t = Number(r >> 58n);
  let n, i;
  if (e === 0)
    n = _l[t], i = 0;
  else {
    const m = Math.floor(t / 5);
    n = _l[m], i = (t + n.firstQuintant) % 5;
  }
  if (!n)
    throw new Error(`Could not parse origin: ${t}`);
  if (e < dp)
    return { origin: n, segment: i, S: 0n, resolution: e };
  const s = e - dp + 1, o = BigInt(2 * s), l = Ble - o, u = (r & Ole) >> l;
  return { origin: n, segment: i, S: u, resolution: e };
}
Fo.setMatrixArrayType(Float64Array);
oh.create();
var kle = new Mle();
function Fle({ S: r, segment: e, origin: t, resolution: n }) {
  const { quintant: i, orientation: s } = dle(e, t);
  if (n === dp - 1)
    return kL(i);
  if (n === dp - 2)
    return Sle();
  const o = n - dp + 1, l = xle(r, o, s);
  return Cle(o, i, l);
}
function Nle(r, { closedRing: e = !0, segments: t = "auto" } = { closedRing: !0, segments: "auto" }) {
  const { S: n, segment: i, origin: s, resolution: o } = Lle(r);
  t === "auto" && (t = Math.max(1, Math.pow(2, 6 - o)));
  const E = Fle({ S: n, segment: i, origin: s, resolution: o }).splitEdges(t).getVertices().map((L) => kle.inverse(L, s.id)).map((L) => PL(L)), P = ale(E);
  return e && P.push(P[0]), P.reverse(), P;
}
function Ule(r) {
  return BigInt(`0x${r}`);
}
Fo.setMatrixArrayType(Float64Array);
var Vr = (function(r) {
  r = r || {};
  var e = typeof r < "u" ? r : {}, t = {}, n;
  for (n in e)
    e.hasOwnProperty(n) && (t[n] = e[n]);
  var i = "";
  function s(pe) {
    return e.locateFile ? e.locateFile(pe, i) : i + pe;
  }
  var o;
  typeof document < "u" && document.currentScript && (i = document.currentScript.src), i.indexOf("blob:") !== 0 ? i = i.substr(0, i.lastIndexOf("/") + 1) : i = "", o = function(Te, le, ge) {
    var d = new XMLHttpRequest();
    d.open("GET", Te, !0), d.responseType = "arraybuffer", d.onload = function() {
      if (d.status == 200 || d.status == 0 && d.response) {
        le(d.response);
        return;
      }
      var It = Ft(Te);
      if (It) {
        le(It.buffer);
        return;
      }
      ge();
    }, d.onerror = ge, d.send(null);
  };
  var l = e.print || console.log.bind(console), u = e.printErr || console.warn.bind(console);
  for (n in t)
    t.hasOwnProperty(n) && (e[n] = t[n]);
  t = null, e.arguments && e.arguments;
  var m = 0, y = function(pe) {
    m = pe;
  }, E = function() {
    return m;
  }, P = 8;
  function L(pe, Te, le, ge) {
    switch (le = le || "i8", le.charAt(le.length - 1) === "*" && (le = "i32"), le) {
      case "i1":
        X[pe >> 0] = Te;
        break;
      case "i8":
        X[pe >> 0] = Te;
        break;
      case "i16":
        Me[pe >> 1] = Te;
        break;
      case "i32":
        ot[pe >> 2] = Te;
        break;
      case "i64":
        ei = [Te >>> 0, (Rn = Te, +Pr(Rn) >= 1 ? Rn > 0 ? (wr(+xr(Rn / 4294967296), 4294967295) | 0) >>> 0 : ~~+$n((Rn - +(~~Rn >>> 0)) / 4294967296) >>> 0 : 0)], ot[pe >> 2] = ei[0], ot[pe + 4 >> 2] = ei[1];
        break;
      case "float":
        be[pe >> 2] = Te;
        break;
      case "double":
        Ue[pe >> 3] = Te;
        break;
      default:
        Ne("invalid type for setValue: " + le);
    }
  }
  function U(pe, Te, le) {
    switch (Te = Te || "i8", Te.charAt(Te.length - 1) === "*" && (Te = "i32"), Te) {
      case "i1":
        return X[pe >> 0];
      case "i8":
        return X[pe >> 0];
      case "i16":
        return Me[pe >> 1];
      case "i32":
        return ot[pe >> 2];
      case "i64":
        return ot[pe >> 2];
      case "float":
        return be[pe >> 2];
      case "double":
        return Ue[pe >> 3];
      default:
        Ne("invalid type for getValue: " + Te);
    }
    return null;
  }
  var V = !1;
  function q(pe, Te) {
    pe || Ne("Assertion failed: " + Te);
  }
  function j(pe) {
    var Te = e["_" + pe];
    return q(Te, "Cannot call unknown function " + pe + ", make sure it is exported"), Te;
  }
  function K(pe, Te, le, ge, d) {
    var ee = {
      string: function(Lt) {
        var Yt = 0;
        if (Lt != null && Lt !== 0) {
          var Hr = (Lt.length << 2) + 1;
          Yt = Et(Hr), Ge(Lt, Yt, Hr);
        }
        return Yt;
      },
      array: function(Lt) {
        var Yt = Et(Lt.length);
        return fe(Lt, Yt), Yt;
      }
    };
    function It(Lt) {
      return Te === "string" ? ae(Lt) : Te === "boolean" ? !!Lt : Lt;
    }
    var nt = j(pe), Mt = [], kt = 0;
    if (ge)
      for (var zt = 0; zt < ge.length; zt++) {
        var _t = ee[le[zt]];
        _t ? (kt === 0 && (kt = Pe()), Mt[zt] = _t(ge[zt])) : Mt[zt] = ge[zt];
      }
    var Vt = nt.apply(null, Mt);
    return Vt = It(Vt), kt !== 0 && Rt(kt), Vt;
  }
  function Y(pe, Te, le, ge) {
    le = le || [];
    var d = le.every(function(It) {
      return It === "number";
    }), ee = Te !== "string";
    return ee && d && !ge ? j(pe) : function() {
      return K(pe, Te, le, arguments);
    };
  }
  var de = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0;
  function ne(pe, Te, le) {
    for (var ge = Te + le, d = Te; pe[d] && !(d >= ge); )
      ++d;
    if (d - Te > 16 && pe.subarray && de)
      return de.decode(pe.subarray(Te, d));
    for (var ee = ""; Te < d; ) {
      var It = pe[Te++];
      if (!(It & 128)) {
        ee += String.fromCharCode(It);
        continue;
      }
      var nt = pe[Te++] & 63;
      if ((It & 224) == 192) {
        ee += String.fromCharCode((It & 31) << 6 | nt);
        continue;
      }
      var Mt = pe[Te++] & 63;
      if ((It & 240) == 224 ? It = (It & 15) << 12 | nt << 6 | Mt : It = (It & 7) << 18 | nt << 12 | Mt << 6 | pe[Te++] & 63, It < 65536)
        ee += String.fromCharCode(It);
      else {
        var kt = It - 65536;
        ee += String.fromCharCode(55296 | kt >> 10, 56320 | kt & 1023);
      }
    }
    return ee;
  }
  function ae(pe, Te) {
    return pe ? ne(re, pe, Te) : "";
  }
  function De(pe, Te, le, ge) {
    if (!(ge > 0))
      return 0;
    for (var d = le, ee = le + ge - 1, It = 0; It < pe.length; ++It) {
      var nt = pe.charCodeAt(It);
      if (nt >= 55296 && nt <= 57343) {
        var Mt = pe.charCodeAt(++It);
        nt = 65536 + ((nt & 1023) << 10) | Mt & 1023;
      }
      if (nt <= 127) {
        if (le >= ee)
          break;
        Te[le++] = nt;
      } else if (nt <= 2047) {
        if (le + 1 >= ee)
          break;
        Te[le++] = 192 | nt >> 6, Te[le++] = 128 | nt & 63;
      } else if (nt <= 65535) {
        if (le + 2 >= ee)
          break;
        Te[le++] = 224 | nt >> 12, Te[le++] = 128 | nt >> 6 & 63, Te[le++] = 128 | nt & 63;
      } else {
        if (le + 3 >= ee)
          break;
        Te[le++] = 240 | nt >> 18, Te[le++] = 128 | nt >> 12 & 63, Te[le++] = 128 | nt >> 6 & 63, Te[le++] = 128 | nt & 63;
      }
    }
    return Te[le] = 0, le - d;
  }
  function Ge(pe, Te, le) {
    return De(pe, re, Te, le);
  }
  typeof TextDecoder < "u" && new TextDecoder("utf-16le");
  function fe(pe, Te) {
    X.set(pe, Te);
  }
  function ve(pe, Te) {
    return pe % Te > 0 && (pe += Te - pe % Te), pe;
  }
  var me, X, re, Me, ot, be, Ue;
  function Xe(pe) {
    me = pe, e.HEAP8 = X = new Int8Array(pe), e.HEAP16 = Me = new Int16Array(pe), e.HEAP32 = ot = new Int32Array(pe), e.HEAPU8 = re = new Uint8Array(pe), e.HEAPU16 = new Uint16Array(pe), e.HEAPU32 = new Uint32Array(pe), e.HEAPF32 = be = new Float32Array(pe), e.HEAPF64 = Ue = new Float64Array(pe);
  }
  var lt = 5271520, at = 28608, ct = e.TOTAL_MEMORY || 33554432;
  e.buffer ? me = e.buffer : me = new ArrayBuffer(ct), ct = me.byteLength, Xe(me), ot[at >> 2] = lt;
  function gt(pe) {
    for (; pe.length > 0; ) {
      var Te = pe.shift();
      if (typeof Te == "function") {
        Te();
        continue;
      }
      var le = Te.func;
      typeof le == "number" ? Te.arg === void 0 ? e.dynCall_v(le) : e.dynCall_vi(le, Te.arg) : le(Te.arg === void 0 ? null : Te.arg);
    }
  }
  var St = [], Ot = [], dt = [], _r = [];
  function sr() {
    if (e.preRun)
      for (typeof e.preRun == "function" && (e.preRun = [e.preRun]); e.preRun.length; )
        An(e.preRun.shift());
    gt(St);
  }
  function tr() {
    gt(Ot);
  }
  function Wt() {
    gt(dt);
  }
  function yr() {
    if (e.postRun)
      for (typeof e.postRun == "function" && (e.postRun = [e.postRun]); e.postRun.length; )
        Fr(e.postRun.shift());
    gt(_r);
  }
  function An(pe) {
    St.unshift(pe);
  }
  function Fr(pe) {
    _r.unshift(pe);
  }
  var Pr = Math.abs, $n = Math.ceil, xr = Math.floor, wr = Math.min, gn = 0, zr = null;
  function ci(pe) {
    gn++, e.monitorRunDependencies && e.monitorRunDependencies(gn);
  }
  function Jn(pe) {
    if (gn--, e.monitorRunDependencies && e.monitorRunDependencies(gn), gn == 0 && zr) {
      var Te = zr;
      zr = null, Te();
    }
  }
  e.preloadedImages = {}, e.preloadedAudios = {};
  var wn = null, ii = "data:application/octet-stream;base64,";
  function qn(pe) {
    return String.prototype.startsWith ? pe.startsWith(ii) : pe.indexOf(ii) === 0;
  }
  var Rn, ei;
  wn = "data:application/octet-stream;base64,AAAAAAAAAAAAAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAAAQAAAAQAAAADAAAABgAAAAUAAAACAAAAAAAAAAIAAAADAAAAAQAAAAQAAAAGAAAAAAAAAAUAAAADAAAABgAAAAQAAAAFAAAAAAAAAAEAAAACAAAABAAAAAUAAAAGAAAAAAAAAAIAAAADAAAAAQAAAAUAAAACAAAAAAAAAAEAAAADAAAABgAAAAQAAAAGAAAAAAAAAAUAAAACAAAAAQAAAAQAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAIAAAADAAAAAAAAAAAAAAACAAAAAAAAAAEAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAYAAAAAAAAABQAAAAAAAAAAAAAABAAAAAUAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAYAAAAAAAAABgAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAgAAAAMAAAAEAAAABQAAAAYAAAABAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAAAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAAAAAAAQAAAAMAAAAEAAAABQAAAAYAAAAAAAAAAQAAAAIAAAAEAAAABQAAAAYAAAAAAAAAAQAAAAIAAAADAAAABQAAAAYAAAAAAAAAAQAAAAIAAAADAAAABAAAAAYAAAAAAAAAAQAAAAIAAAADAAAABAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAgAAAAIAAAAAAAAAAAAAAAYAAAAAAAAAAwAAAAIAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAFAAAABAAAAAAAAAABAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAYAAAAAAAAABAAAAAAAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAgAAAAQAAAADAAAACAAAAAEAAAAHAAAABgAAAAkAAAAAAAAAAwAAAAIAAAACAAAABgAAAAoAAAALAAAAAAAAAAEAAAAFAAAAAwAAAA0AAAABAAAABwAAAAQAAAAMAAAAAAAAAAQAAAB/AAAADwAAAAgAAAADAAAAAAAAAAwAAAAFAAAAAgAAABIAAAAKAAAACAAAAAAAAAAQAAAABgAAAA4AAAALAAAAEQAAAAEAAAAJAAAAAgAAAAcAAAAVAAAACQAAABMAAAADAAAADQAAAAEAAAAIAAAABQAAABYAAAAQAAAABAAAAAAAAAAPAAAACQAAABMAAAAOAAAAFAAAAAEAAAAHAAAABgAAAAoAAAALAAAAGAAAABcAAAAFAAAAAgAAABIAAAALAAAAEQAAABcAAAAZAAAAAgAAAAYAAAAKAAAADAAAABwAAAANAAAAGgAAAAQAAAAPAAAAAwAAAA0AAAAaAAAAFQAAAB0AAAADAAAADAAAAAcAAAAOAAAAfwAAABEAAAAbAAAACQAAABQAAAAGAAAADwAAABYAAAAcAAAAHwAAAAQAAAAIAAAADAAAABAAAAASAAAAIQAAAB4AAAAIAAAABQAAABYAAAARAAAACwAAAA4AAAAGAAAAIwAAABkAAAAbAAAAEgAAABgAAAAeAAAAIAAAAAUAAAAKAAAAEAAAABMAAAAiAAAAFAAAACQAAAAHAAAAFQAAAAkAAAAUAAAADgAAABMAAAAJAAAAKAAAABsAAAAkAAAAFQAAACYAAAATAAAAIgAAAA0AAAAdAAAABwAAABYAAAAQAAAAKQAAACEAAAAPAAAACAAAAB8AAAAXAAAAGAAAAAsAAAAKAAAAJwAAACUAAAAZAAAAGAAAAH8AAAAgAAAAJQAAAAoAAAAXAAAAEgAAABkAAAAXAAAAEQAAAAsAAAAtAAAAJwAAACMAAAAaAAAAKgAAAB0AAAArAAAADAAAABwAAAANAAAAGwAAACgAAAAjAAAALgAAAA4AAAAUAAAAEQAAABwAAAAfAAAAKgAAACwAAAAMAAAADwAAABoAAAAdAAAAKwAAACYAAAAvAAAADQAAABoAAAAVAAAAHgAAACAAAAAwAAAAMgAAABAAAAASAAAAIQAAAB8AAAApAAAALAAAADUAAAAPAAAAFgAAABwAAAAgAAAAHgAAABgAAAASAAAANAAAADIAAAAlAAAAIQAAAB4AAAAxAAAAMAAAABYAAAAQAAAAKQAAACIAAAATAAAAJgAAABUAAAA2AAAAJAAAADMAAAAjAAAALgAAAC0AAAA4AAAAEQAAABsAAAAZAAAAJAAAABQAAAAiAAAAEwAAADcAAAAoAAAANgAAACUAAAAnAAAANAAAADkAAAAYAAAAFwAAACAAAAAmAAAAfwAAACIAAAAzAAAAHQAAAC8AAAAVAAAAJwAAACUAAAAZAAAAFwAAADsAAAA5AAAALQAAACgAAAAbAAAAJAAAABQAAAA8AAAALgAAADcAAAApAAAAMQAAADUAAAA9AAAAFgAAACEAAAAfAAAAKgAAADoAAAArAAAAPgAAABwAAAAsAAAAGgAAACsAAAA+AAAALwAAAEAAAAAaAAAAKgAAAB0AAAAsAAAANQAAADoAAABBAAAAHAAAAB8AAAAqAAAALQAAACcAAAAjAAAAGQAAAD8AAAA7AAAAOAAAAC4AAAA8AAAAOAAAAEQAAAAbAAAAKAAAACMAAAAvAAAAJgAAACsAAAAdAAAARQAAADMAAABAAAAAMAAAADEAAAAeAAAAIQAAAEMAAABCAAAAMgAAADEAAAB/AAAAPQAAAEIAAAAhAAAAMAAAACkAAAAyAAAAMAAAACAAAAAeAAAARgAAAEMAAAA0AAAAMwAAAEUAAAA2AAAARwAAACYAAAAvAAAAIgAAADQAAAA5AAAARgAAAEoAAAAgAAAAJQAAADIAAAA1AAAAPQAAAEEAAABLAAAAHwAAACkAAAAsAAAANgAAAEcAAAA3AAAASQAAACIAAAAzAAAAJAAAADcAAAAoAAAANgAAACQAAABIAAAAPAAAAEkAAAA4AAAARAAAAD8AAABNAAAAIwAAAC4AAAAtAAAAOQAAADsAAABKAAAATgAAACUAAAAnAAAANAAAADoAAAB/AAAAPgAAAEwAAAAsAAAAQQAAACoAAAA7AAAAPwAAAE4AAABPAAAAJwAAAC0AAAA5AAAAPAAAAEgAAABEAAAAUAAAACgAAAA3AAAALgAAAD0AAAA1AAAAMQAAACkAAABRAAAASwAAAEIAAAA+AAAAKwAAADoAAAAqAAAAUgAAAEAAAABMAAAAPwAAAH8AAAA4AAAALQAAAE8AAAA7AAAATQAAAEAAAAAvAAAAPgAAACsAAABUAAAARQAAAFIAAABBAAAAOgAAADUAAAAsAAAAVgAAAEwAAABLAAAAQgAAAEMAAABRAAAAVQAAADEAAAAwAAAAPQAAAEMAAABCAAAAMgAAADAAAABXAAAAVQAAAEYAAABEAAAAOAAAADwAAAAuAAAAWgAAAE0AAABQAAAARQAAADMAAABAAAAALwAAAFkAAABHAAAAVAAAAEYAAABDAAAANAAAADIAAABTAAAAVwAAAEoAAABHAAAAWQAAAEkAAABbAAAAMwAAAEUAAAA2AAAASAAAAH8AAABJAAAANwAAAFAAAAA8AAAAWAAAAEkAAABbAAAASAAAAFgAAAA2AAAARwAAADcAAABKAAAATgAAAFMAAABcAAAANAAAADkAAABGAAAASwAAAEEAAAA9AAAANQAAAF4AAABWAAAAUQAAAEwAAABWAAAAUgAAAGAAAAA6AAAAQQAAAD4AAABNAAAAPwAAAEQAAAA4AAAAXQAAAE8AAABaAAAATgAAAEoAAAA7AAAAOQAAAF8AAABcAAAATwAAAE8AAABOAAAAPwAAADsAAABdAAAAXwAAAE0AAABQAAAARAAAAEgAAAA8AAAAYwAAAFoAAABYAAAAUQAAAFUAAABeAAAAZQAAAD0AAABCAAAASwAAAFIAAABgAAAAVAAAAGIAAAA+AAAATAAAAEAAAABTAAAAfwAAAEoAAABGAAAAZAAAAFcAAABcAAAAVAAAAEUAAABSAAAAQAAAAGEAAABZAAAAYgAAAFUAAABXAAAAZQAAAGYAAABCAAAAQwAAAFEAAABWAAAATAAAAEsAAABBAAAAaAAAAGAAAABeAAAAVwAAAFMAAABmAAAAZAAAAEMAAABGAAAAVQAAAFgAAABIAAAAWwAAAEkAAABjAAAAUAAAAGkAAABZAAAAYQAAAFsAAABnAAAARQAAAFQAAABHAAAAWgAAAE0AAABQAAAARAAAAGoAAABdAAAAYwAAAFsAAABJAAAAWQAAAEcAAABpAAAAWAAAAGcAAABcAAAAUwAAAE4AAABKAAAAbAAAAGQAAABfAAAAXQAAAE8AAABaAAAATQAAAG0AAABfAAAAagAAAF4AAABWAAAAUQAAAEsAAABrAAAAaAAAAGUAAABfAAAAXAAAAE8AAABOAAAAbQAAAGwAAABdAAAAYAAAAGgAAABiAAAAbgAAAEwAAABWAAAAUgAAAGEAAAB/AAAAYgAAAFQAAABnAAAAWQAAAG8AAABiAAAAbgAAAGEAAABvAAAAUgAAAGAAAABUAAAAYwAAAFAAAABpAAAAWAAAAGoAAABaAAAAcQAAAGQAAABmAAAAUwAAAFcAAABsAAAAcgAAAFwAAABlAAAAZgAAAGsAAABwAAAAUQAAAFUAAABeAAAAZgAAAGUAAABXAAAAVQAAAHIAAABwAAAAZAAAAGcAAABbAAAAYQAAAFkAAAB0AAAAaQAAAG8AAABoAAAAawAAAG4AAABzAAAAVgAAAF4AAABgAAAAaQAAAFgAAABnAAAAWwAAAHEAAABjAAAAdAAAAGoAAABdAAAAYwAAAFoAAAB1AAAAbQAAAHEAAABrAAAAfwAAAGUAAABeAAAAcwAAAGgAAABwAAAAbAAAAGQAAABfAAAAXAAAAHYAAAByAAAAbQAAAG0AAABsAAAAXQAAAF8AAAB1AAAAdgAAAGoAAABuAAAAYgAAAGgAAABgAAAAdwAAAG8AAABzAAAAbwAAAGEAAABuAAAAYgAAAHQAAABnAAAAdwAAAHAAAABrAAAAZgAAAGUAAAB4AAAAcwAAAHIAAABxAAAAYwAAAHQAAABpAAAAdQAAAGoAAAB5AAAAcgAAAHAAAABkAAAAZgAAAHYAAAB4AAAAbAAAAHMAAABuAAAAawAAAGgAAAB4AAAAdwAAAHAAAAB0AAAAZwAAAHcAAABvAAAAcQAAAGkAAAB5AAAAdQAAAH8AAABtAAAAdgAAAHEAAAB5AAAAagAAAHYAAAB4AAAAbAAAAHIAAAB1AAAAeQAAAG0AAAB3AAAAbwAAAHMAAABuAAAAeQAAAHQAAAB4AAAAeAAAAHMAAAByAAAAcAAAAHkAAAB3AAAAdgAAAHkAAAB0AAAAeAAAAHcAAAB1AAAAcQAAAHYAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAABAAAABQAAAAEAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAACAAAABQAAAAEAAAAAAAAA/////wEAAAAAAAAAAwAAAAQAAAACAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAMAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAFAAAAAQAAAAAAAAAAAAAAAQAAAAMAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAADAAAAAAAAAAAAAAABAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAADAAAABQAAAAEAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAEAAAABQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAFAAAABQAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAD/////AwAAAAAAAAAFAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAAAAAABAAAAAwAAAAAAAAAAAAAAAQAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAQAAAAMAAAAAAAAAAAAAAAEAAAAAAAAAAwAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAADAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAFAAAABQAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAwAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAAAAAAA/////wMAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAA/////wMAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAADAAAAAAAAAAAAAAADAAAAAwAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAD/////AwAAAAAAAAAFAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAAAAAD/////AwAAAAAAAAAFAAAAAgAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAADAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAFAAAAAAAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAADAAAAAQAAAAAAAAABAAAAAAAAAAAAAAABAAAAAwAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAADAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAADAAAAAwAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAUAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAFAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAA/////wMAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAFAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAEAAAADAAAAAQAAAAAAAAABAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAADAAAAAQAAAAAAAAABAAAAAAAAAAMAAAADAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAAAAAAAAwAAAAUAAAABAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAABAAAAAUAAAABAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAIAAAAFAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAADAAAAAQAAAAAAAAABAAAAAAAAAAUAAAAAAAAAAAAAAAUAAAAFAAAAAAAAAAAAAAD/////AQAAAAAAAAADAAAABAAAAAIAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAUAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAFAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAUAAAABAAAAAAAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAEAAAD//////////wEAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAADAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAsAAAACAAAAAAAAAAAAAAABAAAAAgAAAAYAAAAEAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAKAAAAAgAAAAAAAAAAAAAAAQAAAAEAAAAFAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAsAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAACAAAAAAAAAAAAAAABAAAAAwAAAAcAAAAGAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAABwAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAADgAAAAIAAAAAAAAAAAAAAAEAAAAAAAAACQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAMAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAsAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADQAAAAIAAAAAAAAAAAAAAAEAAAAEAAAACAAAAAoAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAALAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAACQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAgAAAAAAAAAAAAAAAQAAAAsAAAAPAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAOAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAIAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAABQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAgAAAAAAAAAAAAAAAQAAAAwAAAAQAAAADAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAoAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAPAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAADwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAADQAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAACAAAAAAAAAAAAAAABAAAACgAAABMAAAAIAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEQAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEQAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAA8AAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAQAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAACQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAIAAAAAAAAAAAAAAAEAAAANAAAAEQAAAA0AAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAARAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAAEQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAA0AAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkAAAACAAAAAAAAAAAAAAABAAAADgAAABIAAAAPAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAADwAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAASAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEwAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAABEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAABIAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAATAAAAAgAAAAAAAAAAAAAAAQAAAP//////////EwAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAASAAAAAAAAABgAAAAAAAAAIQAAAAAAAAAeAAAAAAAAACAAAAADAAAAMQAAAAEAAAAwAAAAAwAAADIAAAADAAAACAAAAAAAAAAFAAAABQAAAAoAAAAFAAAAFgAAAAAAAAAQAAAAAAAAABIAAAAAAAAAKQAAAAEAAAAhAAAAAAAAAB4AAAAAAAAABAAAAAAAAAAAAAAABQAAAAIAAAAFAAAADwAAAAEAAAAIAAAAAAAAAAUAAAAFAAAAHwAAAAEAAAAWAAAAAAAAABAAAAAAAAAAAgAAAAAAAAAGAAAAAAAAAA4AAAAAAAAACgAAAAAAAAALAAAAAAAAABEAAAADAAAAGAAAAAEAAAAXAAAAAwAAABkAAAADAAAAAAAAAAAAAAABAAAABQAAAAkAAAAFAAAABQAAAAAAAAACAAAAAAAAAAYAAAAAAAAAEgAAAAEAAAAKAAAAAAAAAAsAAAAAAAAABAAAAAEAAAADAAAABQAAAAcAAAAFAAAACAAAAAEAAAAAAAAAAAAAAAEAAAAFAAAAEAAAAAEAAAAFAAAAAAAAAAIAAAAAAAAABwAAAAAAAAAVAAAAAAAAACYAAAAAAAAACQAAAAAAAAATAAAAAAAAACIAAAADAAAADgAAAAEAAAAUAAAAAwAAACQAAAADAAAAAwAAAAAAAAANAAAABQAAAB0AAAAFAAAAAQAAAAAAAAAHAAAAAAAAABUAAAAAAAAABgAAAAEAAAAJAAAAAAAAABMAAAAAAAAABAAAAAIAAAAMAAAABQAAABoAAAAFAAAAAAAAAAEAAAADAAAAAAAAAA0AAAAFAAAAAgAAAAEAAAABAAAAAAAAAAcAAAAAAAAAGgAAAAAAAAAqAAAAAAAAADoAAAAAAAAAHQAAAAAAAAArAAAAAAAAAD4AAAADAAAAJgAAAAEAAAAvAAAAAwAAAEAAAAADAAAADAAAAAAAAAAcAAAABQAAACwAAAAFAAAADQAAAAAAAAAaAAAAAAAAACoAAAAAAAAAFQAAAAEAAAAdAAAAAAAAACsAAAAAAAAABAAAAAMAAAAPAAAABQAAAB8AAAAFAAAAAwAAAAEAAAAMAAAAAAAAABwAAAAFAAAABwAAAAEAAAANAAAAAAAAABoAAAAAAAAAHwAAAAAAAAApAAAAAAAAADEAAAAAAAAALAAAAAAAAAA1AAAAAAAAAD0AAAADAAAAOgAAAAEAAABBAAAAAwAAAEsAAAADAAAADwAAAAAAAAAWAAAABQAAACEAAAAFAAAAHAAAAAAAAAAfAAAAAAAAACkAAAAAAAAAKgAAAAEAAAAsAAAAAAAAADUAAAAAAAAABAAAAAQAAAAIAAAABQAAABAAAAAFAAAADAAAAAEAAAAPAAAAAAAAABYAAAAFAAAAGgAAAAEAAAAcAAAAAAAAAB8AAAAAAAAAMgAAAAAAAAAwAAAAAAAAADEAAAADAAAAIAAAAAAAAAAeAAAAAwAAACEAAAADAAAAGAAAAAMAAAASAAAAAwAAABAAAAADAAAARgAAAAAAAABDAAAAAAAAAEIAAAADAAAANAAAAAMAAAAyAAAAAAAAADAAAAAAAAAAJQAAAAMAAAAgAAAAAAAAAB4AAAADAAAAUwAAAAAAAABXAAAAAwAAAFUAAAADAAAASgAAAAMAAABGAAAAAAAAAEMAAAAAAAAAOQAAAAEAAAA0AAAAAwAAADIAAAAAAAAAGQAAAAAAAAAXAAAAAAAAABgAAAADAAAAEQAAAAAAAAALAAAAAwAAAAoAAAADAAAADgAAAAMAAAAGAAAAAwAAAAIAAAADAAAALQAAAAAAAAAnAAAAAAAAACUAAAADAAAAIwAAAAMAAAAZAAAAAAAAABcAAAAAAAAAGwAAAAMAAAARAAAAAAAAAAsAAAADAAAAPwAAAAAAAAA7AAAAAwAAADkAAAADAAAAOAAAAAMAAAAtAAAAAAAAACcAAAAAAAAALgAAAAMAAAAjAAAAAwAAABkAAAAAAAAAJAAAAAAAAAAUAAAAAAAAAA4AAAADAAAAIgAAAAAAAAATAAAAAwAAAAkAAAADAAAAJgAAAAMAAAAVAAAAAwAAAAcAAAADAAAANwAAAAAAAAAoAAAAAAAAABsAAAADAAAANgAAAAMAAAAkAAAAAAAAABQAAAAAAAAAMwAAAAMAAAAiAAAAAAAAABMAAAADAAAASAAAAAAAAAA8AAAAAwAAAC4AAAADAAAASQAAAAMAAAA3AAAAAAAAACgAAAAAAAAARwAAAAMAAAA2AAAAAwAAACQAAAAAAAAAQAAAAAAAAAAvAAAAAAAAACYAAAADAAAAPgAAAAAAAAArAAAAAwAAAB0AAAADAAAAOgAAAAMAAAAqAAAAAwAAABoAAAADAAAAVAAAAAAAAABFAAAAAAAAADMAAAADAAAAUgAAAAMAAABAAAAAAAAAAC8AAAAAAAAATAAAAAMAAAA+AAAAAAAAACsAAAADAAAAYQAAAAAAAABZAAAAAwAAAEcAAAADAAAAYgAAAAMAAABUAAAAAAAAAEUAAAAAAAAAYAAAAAMAAABSAAAAAwAAAEAAAAAAAAAASwAAAAAAAABBAAAAAAAAADoAAAADAAAAPQAAAAAAAAA1AAAAAwAAACwAAAADAAAAMQAAAAMAAAApAAAAAwAAAB8AAAADAAAAXgAAAAAAAABWAAAAAAAAAEwAAAADAAAAUQAAAAMAAABLAAAAAAAAAEEAAAAAAAAAQgAAAAMAAAA9AAAAAAAAADUAAAADAAAAawAAAAAAAABoAAAAAwAAAGAAAAADAAAAZQAAAAMAAABeAAAAAAAAAFYAAAAAAAAAVQAAAAMAAABRAAAAAwAAAEsAAAAAAAAAOQAAAAAAAAA7AAAAAAAAAD8AAAADAAAASgAAAAAAAABOAAAAAwAAAE8AAAADAAAAUwAAAAMAAABcAAAAAwAAAF8AAAADAAAAJQAAAAAAAAAnAAAAAwAAAC0AAAADAAAANAAAAAAAAAA5AAAAAAAAADsAAAAAAAAARgAAAAMAAABKAAAAAAAAAE4AAAADAAAAGAAAAAAAAAAXAAAAAwAAABkAAAADAAAAIAAAAAMAAAAlAAAAAAAAACcAAAADAAAAMgAAAAMAAAA0AAAAAAAAADkAAAAAAAAALgAAAAAAAAA8AAAAAAAAAEgAAAADAAAAOAAAAAAAAABEAAAAAwAAAFAAAAADAAAAPwAAAAMAAABNAAAAAwAAAFoAAAADAAAAGwAAAAAAAAAoAAAAAwAAADcAAAADAAAAIwAAAAAAAAAuAAAAAAAAADwAAAAAAAAALQAAAAMAAAA4AAAAAAAAAEQAAAADAAAADgAAAAAAAAAUAAAAAwAAACQAAAADAAAAEQAAAAMAAAAbAAAAAAAAACgAAAADAAAAGQAAAAMAAAAjAAAAAAAAAC4AAAAAAAAARwAAAAAAAABZAAAAAAAAAGEAAAADAAAASQAAAAAAAABbAAAAAwAAAGcAAAADAAAASAAAAAMAAABYAAAAAwAAAGkAAAADAAAAMwAAAAAAAABFAAAAAwAAAFQAAAADAAAANgAAAAAAAABHAAAAAAAAAFkAAAAAAAAANwAAAAMAAABJAAAAAAAAAFsAAAADAAAAJgAAAAAAAAAvAAAAAwAAAEAAAAADAAAAIgAAAAMAAAAzAAAAAAAAAEUAAAADAAAAJAAAAAMAAAA2AAAAAAAAAEcAAAAAAAAAYAAAAAAAAABoAAAAAAAAAGsAAAADAAAAYgAAAAAAAABuAAAAAwAAAHMAAAADAAAAYQAAAAMAAABvAAAAAwAAAHcAAAADAAAATAAAAAAAAABWAAAAAwAAAF4AAAADAAAAUgAAAAAAAABgAAAAAAAAAGgAAAAAAAAAVAAAAAMAAABiAAAAAAAAAG4AAAADAAAAOgAAAAAAAABBAAAAAwAAAEsAAAADAAAAPgAAAAMAAABMAAAAAAAAAFYAAAADAAAAQAAAAAMAAABSAAAAAAAAAGAAAAAAAAAAVQAAAAAAAABXAAAAAAAAAFMAAAADAAAAZQAAAAAAAABmAAAAAwAAAGQAAAADAAAAawAAAAMAAABwAAAAAwAAAHIAAAADAAAAQgAAAAAAAABDAAAAAwAAAEYAAAADAAAAUQAAAAAAAABVAAAAAAAAAFcAAAAAAAAAXgAAAAMAAABlAAAAAAAAAGYAAAADAAAAMQAAAAAAAAAwAAAAAwAAADIAAAADAAAAPQAAAAMAAABCAAAAAAAAAEMAAAADAAAASwAAAAMAAABRAAAAAAAAAFUAAAAAAAAAXwAAAAAAAABcAAAAAAAAAFMAAAAAAAAATwAAAAAAAABOAAAAAAAAAEoAAAADAAAAPwAAAAEAAAA7AAAAAwAAADkAAAADAAAAbQAAAAAAAABsAAAAAAAAAGQAAAAFAAAAXQAAAAEAAABfAAAAAAAAAFwAAAAAAAAATQAAAAEAAABPAAAAAAAAAE4AAAAAAAAAdQAAAAQAAAB2AAAABQAAAHIAAAAFAAAAagAAAAEAAABtAAAAAAAAAGwAAAAAAAAAWgAAAAEAAABdAAAAAQAAAF8AAAAAAAAAWgAAAAAAAABNAAAAAAAAAD8AAAAAAAAAUAAAAAAAAABEAAAAAAAAADgAAAADAAAASAAAAAEAAAA8AAAAAwAAAC4AAAADAAAAagAAAAAAAABdAAAAAAAAAE8AAAAFAAAAYwAAAAEAAABaAAAAAAAAAE0AAAAAAAAAWAAAAAEAAABQAAAAAAAAAEQAAAAAAAAAdQAAAAMAAABtAAAABQAAAF8AAAAFAAAAcQAAAAEAAABqAAAAAAAAAF0AAAAAAAAAaQAAAAEAAABjAAAAAQAAAFoAAAAAAAAAaQAAAAAAAABYAAAAAAAAAEgAAAAAAAAAZwAAAAAAAABbAAAAAAAAAEkAAAADAAAAYQAAAAEAAABZAAAAAwAAAEcAAAADAAAAcQAAAAAAAABjAAAAAAAAAFAAAAAFAAAAdAAAAAEAAABpAAAAAAAAAFgAAAAAAAAAbwAAAAEAAABnAAAAAAAAAFsAAAAAAAAAdQAAAAIAAABqAAAABQAAAFoAAAAFAAAAeQAAAAEAAABxAAAAAAAAAGMAAAAAAAAAdwAAAAEAAAB0AAAAAQAAAGkAAAAAAAAAdwAAAAAAAABvAAAAAAAAAGEAAAAAAAAAcwAAAAAAAABuAAAAAAAAAGIAAAADAAAAawAAAAEAAABoAAAAAwAAAGAAAAADAAAAeQAAAAAAAAB0AAAAAAAAAGcAAAAFAAAAeAAAAAEAAAB3AAAAAAAAAG8AAAAAAAAAcAAAAAEAAABzAAAAAAAAAG4AAAAAAAAAdQAAAAEAAABxAAAABQAAAGkAAAAFAAAAdgAAAAEAAAB5AAAAAAAAAHQAAAAAAAAAcgAAAAEAAAB4AAAAAQAAAHcAAAAAAAAAcgAAAAAAAABwAAAAAAAAAGsAAAAAAAAAZAAAAAAAAABmAAAAAAAAAGUAAAADAAAAUwAAAAEAAABXAAAAAwAAAFUAAAADAAAAdgAAAAAAAAB4AAAAAAAAAHMAAAAFAAAAbAAAAAEAAAByAAAAAAAAAHAAAAAAAAAAXAAAAAEAAABkAAAAAAAAAGYAAAAAAAAAdQAAAAAAAAB5AAAABQAAAHcAAAAFAAAAbQAAAAEAAAB2AAAAAAAAAHgAAAAAAAAAXwAAAAEAAABsAAAAAQAAAHIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAABAAAAAQAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAGAAAAAgAAAAUAAAABAAAABAAAAAAAAAAAAAAABQAAAAMAAAABAAAABgAAAAQAAAACAAAAAAAAAH6iBfbytuk/Gq6akm/58z/Xrm0Liez0P5doSdOpSwRAWs602ULg8D/dT7Rcbo/1v1N1RQHFNOM/g9Snx7HW3L8HWsP8Q3jfP6VwOLosutk/9rjk1YQcxj+gnmKMsNn6P/HDeuPFY+M/YHwDjqKhB0Ci19/fCVrbP4UxKkDWOP6/pvljWa09tL9wi7wrQXjnv/Z6yLImkM2/3yTlOzY14D+m+WNZrT20PzwKVQnrQwNA9nrIsiaQzT/g40rFrRQFwPa45NWEHMa/kbslHEZq97/xw3rjxWPjv4cLC2SMBci/otff3wla27+rKF5oIAv0P1N1RQHFNOO/iDJPGyWHBUAHWsP8Q3jfvwQf/by16gXAfqIF9vK26b8XrO0Vh0r+v9eubQuJ7PS/BxLrA0ZZ479azrTZQuDwv1MK1EuItPw/yscgV9Z6FkAwHBR2WjQMQJNRzXsQ5vY/GlUHVJYKF0DONuFv2lMNQNCGZ28QJfk/0WUwoIL36D8ggDOMQuATQNqMOeAy/wZAWFYOYM+M2z/LWC4uH3oSQDE+LyTsMgRAkJzhRGWFGEDd4soovCQQQKqk0DJMEP8/rGmNdwOLBUAW2X/9xCbjP4hu3dcqJhNAzuYItRvdB0CgzW3zJW/sPxotm/Y2TxRAQAk9XmdDDEC1Kx9MKgT3P1M+NctcghZAFVqcLlb0C0Bgzd3sB2b2P77mZDPUWhZAFROHJpUGCEDAfma5CxXtPz1DWq/zYxRAmhYY5824F0DOuQKWSbAOQNCMqrvu3fs/L6DR22K2wT9nAAxPBU8RQGiN6mW43AFAZhu25b633D8c1YgmzowSQNM25BRKWARArGS08/lNxD+LFssHwmMRQLC5aNcxBgJABL9HT0WRF0CjCmJmOGEOQHsuaVzMP/s/TWJCaGGwBUCeu1PAPLzjP9nqN9DZOBNAKE4JcydbCkCGtbd1qjPzP8dgm9U8jhVAtPeKTkVwDkCeCLss5l37P401XMPLmBdAFd29VMVQDUBg0yA55h75Pz6odcYLCRdApBM4rBrkAkDyAVWgQxbRP4XDMnK20hFAymLlF7EmzD8GUgo9XBHlP3lbK7T9COc/k+OhPthhy7+YGEpnrOvCPzBFhLs15u4/epbqB6H4uz9IuuLF5svev6lzLKY31es/CaQ0envF5z8ZY0xlUADXv7zaz7HYEuI/CfbK1sn16T8uAQfWwxLWPzKn/YuFN94/5KdbC1AFu793fyCSnlfvPzK2y4doAMY/NRg5t1/X6b/shq4QJaHDP5yNIAKPOeI/vpn7BSE30r/X4YQrO6nrv78Ziv/Thto/DqJ1Y6+y5z9l51NaxFrlv8QlA65HOLS/86dxiEc96z+Hj0+LFjneP6LzBZ8LTc2/DaJ1Y6+y579l51NaxFrlP8QlA65HOLQ/8qdxiEc967+Jj0+LFjnev6LzBZ8LTc0/1qdbC1AFuz93fyCSnlfvvzK2y4doAMa/NRg5t1/X6T/vhq4QJaHDv5yNIAKPOeK/wJn7BSE30j/W4YQrO6nrP78Ziv/Thtq/CaQ0envF578XY0xlUADXP7zaz7HYEuK/CvbK1sn16b8rAQfWwxLWvzKn/YuFN96/zWLlF7EmzL8GUgo9XBHlv3lbK7T9COe/kOOhPthhyz+cGEpnrOvCvzBFhLs15u6/c5bqB6H4u79IuuLF5sveP6lzLKY31eu/AQAAAP////8HAAAA/////zEAAAD/////VwEAAP////9hCQAA/////6dBAAD/////kcsBAP/////3kAwA/////8H2VwAAAAAAAAAAAAAAAAACAAAA/////w4AAAD/////YgAAAP////+uAgAA/////8ISAAD/////ToMAAP////8ilwMA/////+4hGQD/////gu2vAAAAAAAAAAAAAAAAAAAAAAACAAAA//////////8BAAAAAwAAAP//////////////////////////////////////////////////////////////////////////AQAAAAAAAAACAAAA////////////////AwAAAP//////////////////////////////////////////////////////////////////////////AQAAAAAAAAACAAAA////////////////AwAAAP//////////////////////////////////////////////////////////////////////////AQAAAAAAAAACAAAA////////////////AwAAAP//////////////////////////////////////////////////////////AgAAAP//////////AQAAAAAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAD/////////////////////AQAAAP///////////////wIAAAD///////////////////////////////8DAAAA/////////////////////wAAAAD///////////////8CAAAAAQAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAD///////////////8CAAAAAQAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAD///////////////8CAAAAAQAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAD///////////////8CAAAAAQAAAP////////////////////////////////////////////////////8BAAAAAgAAAP///////////////wAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8BAAAAAgAAAP///////////////wAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8BAAAAAgAAAP///////////////wAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8BAAAAAgAAAP///////////////wAAAAD/////////////////////AwAAAP///////////////////////////////wIAAAD///////////////8BAAAA/////////////////////wAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAABAAAA//////////8CAAAA//////////////////////////////////////////////////////////8DAAAA////////////////AgAAAAAAAAABAAAA//////////////////////////////////////////////////////////////////////////8DAAAA////////////////AgAAAAAAAAABAAAA//////////////////////////////////////////////////////////////////////////8DAAAA////////////////AgAAAAAAAAABAAAA//////////////////////////////////////////////////////////////////////////8DAAAAAQAAAP//////////AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAACAAAAAAAAAAIAAAABAAAAAQAAAAIAAAACAAAAAAAAAAUAAAAFAAAAAAAAAAIAAAACAAAAAwAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAgAAAAEAAAACAAAAAgAAAAIAAAAAAAAABQAAAAYAAAAAAAAAAgAAAAIAAAADAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAgAAAAAAAAACAAAAAQAAAAMAAAACAAAAAgAAAAAAAAAFAAAABwAAAAAAAAACAAAAAgAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAACAAAAAAAAAAIAAAABAAAABAAAAAIAAAACAAAAAAAAAAUAAAAIAAAAAAAAAAIAAAACAAAAAwAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAIAAAAAAAAAAgAAAAEAAAAAAAAAAgAAAAIAAAAAAAAABQAAAAkAAAAAAAAAAgAAAAIAAAADAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAgAAAAIAAAAAAAAAAwAAAA4AAAACAAAAAAAAAAIAAAADAAAAAAAAAAAAAAACAAAAAgAAAAMAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAsAAAACAAAAAgAAAAAAAAADAAAACgAAAAIAAAAAAAAAAgAAAAMAAAABAAAAAAAAAAIAAAACAAAAAwAAAAcAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAIAAAACAAAAAAAAAAMAAAALAAAAAgAAAAAAAAACAAAAAwAAAAIAAAAAAAAAAgAAAAIAAAADAAAACAAAAAAAAAAAAAAAAAAAAAAAAAANAAAAAgAAAAIAAAAAAAAAAwAAAAwAAAACAAAAAAAAAAIAAAADAAAAAwAAAAAAAAACAAAAAgAAAAMAAAAJAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAACAAAAAgAAAAAAAAADAAAADQAAAAIAAAAAAAAAAgAAAAMAAAAEAAAAAAAAAAIAAAACAAAAAwAAAAoAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAIAAAACAAAAAAAAAAMAAAAGAAAAAgAAAAAAAAACAAAAAwAAAA8AAAAAAAAAAgAAAAIAAAADAAAACwAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAgAAAAIAAAAAAAAAAwAAAAcAAAACAAAAAAAAAAIAAAADAAAAEAAAAAAAAAACAAAAAgAAAAMAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAcAAAACAAAAAgAAAAAAAAADAAAACAAAAAIAAAAAAAAAAgAAAAMAAAARAAAAAAAAAAIAAAACAAAAAwAAAA0AAAAAAAAAAAAAAAAAAAAAAAAACAAAAAIAAAACAAAAAAAAAAMAAAAJAAAAAgAAAAAAAAACAAAAAwAAABIAAAAAAAAAAgAAAAIAAAADAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAJAAAAAgAAAAIAAAAAAAAAAwAAAAUAAAACAAAAAAAAAAIAAAADAAAAEwAAAAAAAAACAAAAAgAAAAMAAAAPAAAAAAAAAAAAAAAAAAAAAAAAABAAAAACAAAAAAAAAAIAAAABAAAAEwAAAAIAAAACAAAAAAAAAAUAAAAKAAAAAAAAAAIAAAACAAAAAwAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEQAAAAIAAAAAAAAAAgAAAAEAAAAPAAAAAgAAAAIAAAAAAAAABQAAAAsAAAAAAAAAAgAAAAIAAAADAAAAEQAAAAAAAAAAAAAAAAAAAAAAAAASAAAAAgAAAAAAAAACAAAAAQAAABAAAAACAAAAAgAAAAAAAAAFAAAADAAAAAAAAAACAAAAAgAAAAMAAAASAAAAAAAAAAAAAAAAAAAAAAAAABMAAAACAAAAAAAAAAIAAAABAAAAEQAAAAIAAAACAAAAAAAAAAUAAAANAAAAAAAAAAIAAAACAAAAAwAAABMAAAAAAAAAAAAAAAAAAAAAAAAADwAAAAIAAAAAAAAAAgAAAAEAAAASAAAAAgAAAAIAAAAAAAAABQAAAA4AAAAAAAAAAgAAAAIAAAADAAAAAgAAAAEAAAAAAAAAAQAAAAIAAAAAAAAAAAAAAAIAAAABAAAAAAAAAAEAAAACAAAAAQAAAAAAAAACAAAAAAAAAAUAAAAEAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAFAAAABAAAAAAAAAABAAAABQAAAAQAAAAAAAAABQAAAAAAAAACAAAAAQAAAAAAAAABAAAAAgAAAAAAAAAAAAAAAgAAAAEAAAAAAAAAAQAAAAIAAAABAAAAAAAAAAIAAAACAAAAAAAAAAEAAAAAAAAAAAAAAAUAAAAEAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAFAAAABAAAAAAAAAABAAAABQAAAAQAAAAAAAAABQAAAAUAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAABAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAEAAAAAAAAAAAEAAAAAAQAAAAAAAAAAAQAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAABAAAAAAAAAAAAAQAAAAAAAAAAAAA6B6FaUp9QQTPXMuL4myJBraiDfBwx9UBYJseitzTIQOL5if9jqZtAnXX+Z+ycb0C3pucbhRBCQG8wJBYqpRRAlWbDCzCY5z/eFWBUEve6P/+qo4Q50Y4/D9YM3iCcYT8fcA2QJSA0P4ADxu0qAAc/BNcGolVJ2j5d9FACqwquPh9z7MthtI9CSUSYJke/YUJQ/64OyjU0Qpi0+HCmFQdCm3GfIVdh2kHsJ11kAyauQYC3UDFJOoFBSJsFV1OwU0FK5fcxX4AmQWhy/zZIt/lACqaCPsBjzUDbdUNIScugQMYQlVJ4MXNANiuq8GTvRUDxTXnulxEZQFZ8QX5kpuw/qmG/JwYFlEAluh3Q6DB+QKn4vyNq0GZAKOXekas+UUB8xabXXhI6QG63C2pLtSNAdDBtyNfLDUDyOcu67ID2P0rCMvRXAeE/Ki2TSVyzyT9Dk+8Sz2uzP5J+w5ARWp0/NQAoOiMuhj9YnP+RyMJwPxgW7TvQVFk/KgsLYF0kQz9g5dAC6IwzQcgHPVvDex1B1XjppodHBkHJq3OMM9fwQNvcmJ7wddlAInGPpQs/w0BRobq5EBmtQJZ2ai7n+ZVAtv2G5E+bgECG+gIfKBlpQK5f8jdI91JAL39sL/WpPEB8rGxhDqklQK6yUf43XhBAxL9y/tK8+D86XyZpgrHiPwAAAAD/////AAAAAAAAAAAAAAAAAAAAAAAAAAD/////////////////////////////////////AAAAAP////8AAAAAAAAAAAAAAAABAAAAAAAAAAAAAAD/////AAAAAAAAAAABAAAAAQAAAAAAAAAAAAAA/////wAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAP////8FAAAABQAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////////////////////////////////////wAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////////////////////////////////////8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAFAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////////////////////////////////////AAAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAQAAAAEAAAABAAAAAAAAAAEAAAAAAAAABQAAAAEAAAABAAAAAAAAAAAAAAABAAAAAQAAAAAAAAABAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQAAAAAAAQABAAABAQAAAAAAAQAAAAEAAAABAAEAAAAAAAAAAAAAAAAAAAAAquJYWJZl+D9jaeZNtj/zPwwdI9KqaeO/qGefXwdHdz+q4lhYlmX4P+OrlPMN3PI/DB0j0qpp47+7SQLV4VIEQKriWFiWZfg/r2kma3tz8T82eQmLqNIGwMRIWXMqSvo/fcCszPux9j+jara6ozTwP6hnn18HR3c/MSoKLequ8r+SabgA2nj0P7jBLbDOHO8/1Ym/ICfH4T+6lxjvlFXHv73m373LRPU/0vXyDVxo7T+ToKRHJXMAQF/33578aPE/pAyy64tD9T8+U/hCvyruPwxv8Y7YYwLAuXYr8NAiCEB4+LDK0Sn0P1Qeuy4j+eo/OMx50n7K7L+TrGB/nyf8v5ehC2fbYPM/aXMKexiT6z8mFRIMjg/zP7yUVwGGBNw/E6opHERf8z/z0wR2g9DqPw4pBpcOhvu/NbA29uWAA8DMaTExyXzyP02biiQ+Ruk/S8jz2/FKBEB1pzZnpbb9P7pQU4wLfPI//7ZcQXeG6D9CqEQvAYoIwDB2VB6sSgRAVyv8H5We8T+EHWF8XNPmPzB2wT8Nrrg/SEi+cX+w4L8of+GtdSDxP1sjk5AdouU/6ZjOVru13r8K0obqI6bxvwVbdNXyhfA/w5GG024n5z+rwmtMzP8BwLw9pSX49QXABe/2uQxP8D+b6wCzCvXkP7uGT87fK+Q/pz/JWw4coj+qoBf2J0nwP/yE3PUo0+I/vFJeHcaC+D96luSIqvntP/bf8sHUYu8/gZNN41mL4z9bhOqVOF4FwO6lmAh1hQhAbCVxbdhk7z+1C8NdDcfiPwG36x/0OQBAx0WJ76c2+D9nlSHXANfuP2HlfZ3gqOE/EwnVlVPg9r96+oHzEH//v5bXzdT1Auw/DM3GwLsA4D9p/8uoKcr+v+U9x5DQVAPAehjSdghb7D9sc1IetODgP8MVwwB1pu6/azPk6OGe978W8t/TUc3rP+0QMvYfP+A/RsG/QpSE8D+l3uwScxzgPwQaifgujuw/k1Vti1I43z8MAwLnSh0GQH5nYnwwZgJAiGUzWC5s6j8WyyI/BbLgPw4iUapGeQJAB3W+imnp/j9BLWR4ssrpP2t+gG5Pstk/cpBsfm6DCMCOpU9dOZsFQEv8nFypHeo/ehJ6i+6S2D9jqlGEmarLv7STC5TRiOa/bC+x8WZD6D9H3yUkWpDZP8gZvmCMuQLAreY19/eRBsCoPOc8UzzpP6KI/QV+y9g/t/MoboyWzT+Hv5q3Zu3Mvy2xROCT4uY/9gQitMMg1T9abAqhWMDkv1oLTavoUfG/PMUJP9CD5j+fHRX3t6fSPz7W2gk6bvs/WRnuHwqN9D8YFturGCTmP1EZczv0b9I/5t4exabB5D/1ESLh5fTEP9X2z6SYweQ/6lv3I2zT0D9zkRGNUNMAQKoSvc4EIfs/Xggt8wQI5T+mJHHg/w/SP4lhT/9t8vQ/DrZ/DbwH7D+XlhbYZrjkP34LIpFt6c4/lwfp8fLX9L+j96CTTf76v3WdNhEv9uM/d8c3o4lV0D/vFdCHVcsFwAHeDq0F1QhApbYqcZiN5D9KoilqByXLPwX0/diA0vq/0fo0GxnxAMBbaTkvlCzjP/RrFrWXrMs/UYTrky7jA0DB9f4FiZYAQEGAk/3QzeE/r/TeqE8t0D/OqjlsnPbvvz8RKU8JOfW/smSEbK/O4T8MzuyPm3DDP/rFtctq9gZAfb1EVEaSA0Dts5dVInnhP18SFMc79MM/7y34cw6LAMDFrRJsZO0DwC2KLvLSYuA/hx5wcUHewz+49SnK/4ruPyeS0PX9a+E/ZxaaLvvZ3z8WPu5T2QS8Pygo4RIvMqa/BJ0Kqsd0279cKW4ay8jdP3b05bmZ364/10/qtdxk2r+Bcz6CDMvpv54qOw+Amdw/qLV71pW7sT/YKc80nIPUP8OfIaBJ77G/LyTuD1un2z+diYu8efWzP1wU7ACkfwjAZroyPL1yBkAmv3lKJJbbPysKSE4W+p0/dIgqY79TA8ATLTOQ3tsGwJ2zweD/Xdg/XO/jXeFUaL8VW2qLFKfov1cA9Aa6XfK/tIa7YGgI2T+f3hu/sxqPv2nXdPpf3Pc/jkw8Jbda8j+tT/z8tGPVP1yBHpJd35k/KYvYOy1s8j/yz+kCQjPrP9+agH7x59g/PZfJ9aBhpr/rDKzvYBb+PwtkiaGCt/c/vb1mVr+f1T/JIHwHc8Govw7aeF6+9vG/Xv7kD6fp979isYioQYHVP7AIQZuSFrG/3z1AdUTnAUDN3XY9O7f9P0AdQ9ljYNQ/dJANJPTOrb8kLECUiiPlP4yF7UgmStA/9xGmXxCG1T9qZzix4W2zv2SGJRJVrPe/Fh9a2M/B/b8IexzFCoPSP9y1QFD2bLe/Q86cWLJe/b+mOOfYm78BwOTjkPAGE9E/8aPCUKu/ub9pPZyLCiUGwBA7Mev/BQlALOmrlRi+0j+AMJ/dKULBv7iLtL6a6QRAEMDV/yajAUDa62dE3crJP1P70RgBUbq/38hVnR6esT/s1tG10Z/Ov/zLwalHPss/dTS9NKTXx78nMcRzCIEHQAabxDsAmQRA0tyLK3gSyT+Aui7nOhDGv5Gs58z3WgHATN3forJuBMCAui7nOhDGP9Lciyt4Esm/WAJyHQ4c7z8UP5HFIs3iP3U0vTSk18c//MvBqUc+y7+cvv8HLg/Kvy1I/mHsI+K/U/vRGAFRuj/a62dE3crJv8p+WV8KlQjAuQ/nOP43B0CAMJ/dKULBPyzpq5UYvtK/ZoU+VoLh4L9etLlRUfvtv/GjwlCrv7k/5OOQ8AYT0b9DfT9FhufXPwUX8hJp+4u/3LVAUPZstz8IexzFCoPSv9+L609E5fQ/q9Fz7X2J7T9qZzix4W2zP/cRpl8QhtW/vtNilqGX+j8MOy7QJoL0P3SQDST0zq0/QB1D2WNg1L8IIjSvGNkDwGB8Jou2GAfAsAhBm5IWsT9isYioQYHVvyS9D3zb6uy/gnwRa7uM9L/JIHwHc8GoP729Zla/n9W/CsAHJZwmAEDEW6OYT1r6Pz2XyfWgYaY/35qAfvHn2L83Tdy4lS30vxf2/gZ0jPq/XIEekl3fmb+tT/z8tGPVvybPr2zJ1/+/K7mJ0ypVAsCf3hu/sxqPPwCGu2BoCNm/5oITrpZn+r+UDUyDP+n/v1zv413hVGg/nbPB4P9d2L9MlmkxNvgCQMtZlKE85v8/KwpIThb6nb8mv3lKJJbbv8+SZsTvOOc/pQCIIOYw0j+diYu8efWzvy8k7g9bp9u/kxYDa+pKtD9XlYvA8HnVv6i1e9aVu7G/nio7D4CZ3L/WR6rNh5EGwCkgQweBkghAdvTluZnfrr9cKW4ay8jdvxbjhr1f1QVAR5C0MzivAkAWPu5T2QS8v2cWmi772d+/cKj4lzLJCEBx2QJfYrMFQIcecHFB3sO/LYou8tJi4L+jr7lhO38BwIcI0Nb7xgTAXxIUxzv0w7/ts5dVInnhv0T+l8DZLfE/MP3FoFvS5D8MzuyPm3DDv7JkhGyvzuG/tzhzRIRc0b9Ovv3/0z7mv6/03qhPLdC/m4CT/dDN4b9dwjU5VCQBQBBJX1ntCv0/9GsWtZesy79baTkvlCzjv1mjYgEz++S/oW6KnOQW8b9KoilqByXLv6W2KnGYjeS/SmaKz3Vx9z+BZB5yxGHwP3fHN6OJVdC/dZ02ES/2478PuaBjLrXaP4/JU81pPaO/fgsikW3pzr+XlhbYZrjkv4tSn7YDbP0/f2LnFKlF9z+mJHHg/w/Sv14ILfMECOW/mfg4qYhR/b+OP+RQDCACwOpb9yNs09C/1fbPpJjB5L9pN2WOVZ3wv3hHy9nxIve/URlzO/Rv0r8YFturGCTmv1d1/KKR8QPA8gsy9qzSB8CfHRX3t6fSvzzFCT/Qg+a/EYStnrzV9r/2QJqI7Lb9v/YEIrTDINW/LbFE4JPi5r/7kQEs5fEDQHunnf4GeQBAooj9BX7L2L+oPOc8Uzzpv+ydYY2SSAfAL4HK6CRTB0BH3yUkWpDZv2wvsfFmQ+i/Ik0Yzruh6T8fM3LoGoDUP3oSeovukti/S/ycXKkd6r9rEv+7UWcHQCRIQe/GfwNAa36Abk+y2b9BLWR4ssrpv9KT87qa0bM/FTyktw823L8WyyI/BbLgv4hlM1gubOq/DizMp9Ki6r8b5ckdjVrzv5NVbYtSON+/BBqJ+C6O7L/dUBFqgyXYv00Wh18r7+q/7RAy9h8/4L8W8t/TUc3rv4RM5DKx3wDAfvWIj94aBcBsc1IetODgv3oY0nYIW+y/oGcTFF54AUDkJqS/FKX6PwzNxsC7AOC/ltfN1PUC7L+5Wrz/zHnzP6688w2rNOc/YeV9neCo4b9nlSHXANfuvw9RsxKjY/s/1V8GteXE8j+1C8NdDcfiv2wlcW3YZO+/IOywaA7Q8b9bFP+4Tg36v4GTTeNZi+O/9t/ywdRi77+tRc3yFR7eP2bkcHXJkLO//ITc9SjT4r+qoBf2J0nwv2YHKoswwfm/iQcLspCjAcCb6wCzCvXkvwXv9rkMT/C/YkuwYAMXBMApCNUai9kIwMORhtNuJ+e/BVt01fKF8L+ZqWEfvIjsP6h693QZYNk/WyOTkB2i5b8of+GtdSDxvwpaaulDSwVADMQAX+lOAECEHWF8XNPmv1cr/B+VnvG/XyFG6opcCMD/mtR32/UEQP+2XEF3hui/ulBTjAt88r/imfCfRP+yP9zbvtc8XeO/TZuKJD5G6b/MaTExyXzyvxiTQeElXOO/rbJRQVGN9L/z0wR2g9DqvxOqKRxEX/O/FDGCEei99j9x8zV4VYTmP2lzCnsYk+u/l6ELZ9tg878pRXacaDT/v3k6GZRqoQXAVB67LiP56r94+LDK0Sn0vwO6pZ9b7wFAvK0nKVcc9j8+U/hCvyruv6QMsuuLQ/W/FPhKFYv46j8MyxaDTOW/v9L18g1caO2/vebfvctE9b/7GD8ZrF3xv3gx1AR9bQDAuMEtsM4c77+SabgA2nj0v5xKFIwxsATArKNSBaKsB0Cjara6ozTwv33ArMz7sfa/dF2U0FcWCcDxL357DJX/P69pJmt7c/G/quJYWJZl+L/YntVJlnrSP4sRLzXM+fe/46uU8w3c8r+q4lhYlmX4v85lu5+QRwRAsI0H/WU8479jaeZNtj/zv6riWFiWZfi/sI0H/WU847/OZbufkEcEQHAoPUBrnss/9exKzDtFtT88wM8kax+gP9OqeKeAYog/MW0ItiZvcj+ph+smvt5bP2lCaV5dEUU/StaUmQDaLz+kK9y22BMYP0O3whZuMwI/IIbgZGWE6z7UkjYaEM3UPuezxwa9cr8+LybxRMnFpz6E1N8DbPiRPsYjySMvK3s+//////8fAAj//////zMQCP////9/MiAI/////28yMAj/////YzJACP///z9iMlAI////N2IyYAj///8zYjJwCP//vzNiMoAI//+rM2IykAj/f6szYjKgCP8PqzNiMrAI/wOrM2IywAi/A6szYjLQCJ8DqzNiMuAImQOrM2Iy8Aj//////z8PCP//////Kx8I/////38pLwj/////Pyk/CP////85KU8I////PzgpXwj///8POClvCP///w44KX8I//8fDjgpjwj//w8OOCmfCP9/DQ44Ka8I/w8NDjgpvwj/DQ0OOCnPCP8MDQ44Kd8IxwwNDjgp7wjEDA0OOCn/CAcAAAAHAAAAAQAAAAIAAAAEAAAAAwAAAAAAAAAAAAAABwAAAAMAAAABAAAAAgAAAAUAAAAEAAAAAAAAAAAAAAAEAAAABAAAAAAAAAACAAAAAQAAAAMAAAAOAAAABgAAAAsAAAACAAAABwAAAAEAAAAYAAAABQAAAAoAAAABAAAABgAAAAAAAAAmAAAABwAAAAwAAAADAAAACAAAAAIAAAAxAAAACQAAAA4AAAAAAAAABQAAAAQAAAA6AAAACAAAAA0AAAAEAAAACQAAAAMAAAA/AAAACwAAAAYAAAAPAAAACgAAABAAAABIAAAADAAAAAcAAAAQAAAACwAAABEAAABTAAAACgAAAAUAAAATAAAADgAAAA8AAABhAAAADQAAAAgAAAARAAAADAAAABIAAABrAAAADgAAAAkAAAASAAAADQAAABMAAAB1AAAADwAAABMAAAARAAAAEgAAABAAAAAGAAAAAgAAAAMAAAAFAAAABAAAAAAAAAAAAAAAAAAAAAYAAAACAAAAAwAAAAEAAAAFAAAABAAAAAAAAAAAAAAABwAAAAUAAAADAAAABAAAAAEAAAAAAAAAAgAAAAAAAAACAAAAAwAAAAEAAAAFAAAABAAAAAYAAAAAAAAAAAAAABgtRFT7Ifk/GC1EVPsh+b8YLURU+yEJQBgtRFT7IQnAYWxnb3MuYwBoM05laWdoYm9yUm90YXRpb25zAGNvb3JkaWprLmMAX3VwQXA3Q2hlY2tlZABfdXBBcDdyQ2hlY2tlZABkaXJlY3RlZEVkZ2UuYwBkaXJlY3RlZEVkZ2VUb0JvdW5kYXJ5AGFkamFjZW50RmFjZURpclt0bXBGaWprLmZhY2VdW2ZpamsuZmFjZV0gPT0gS0kAZmFjZWlqay5jAF9mYWNlSWprUGVudFRvQ2VsbEJvdW5kYXJ5AGFkamFjZW50RmFjZURpcltjZW50ZXJJSksuZmFjZV1bZmFjZTJdID09IEtJAF9mYWNlSWprVG9DZWxsQm91bmRhcnkAaDNJbmRleC5jAGNvbXBhY3RDZWxscwBsYXRMbmdUb0NlbGwAY2VsbFRvQ2hpbGRQb3MAdmFsaWRhdGVDaGlsZFBvcwBsYXRMbmcuYwBjZWxsQXJlYVJhZHMyAHBvbHlnb24tPm5leHQgPT0gTlVMTABsaW5rZWRHZW8uYwBhZGROZXdMaW5rZWRQb2x5Z29uAG5leHQgIT0gTlVMTABsb29wICE9IE5VTEwAYWRkTmV3TGlua2VkTG9vcABwb2x5Z29uLT5maXJzdCA9PSBOVUxMAGFkZExpbmtlZExvb3AAY29vcmQgIT0gTlVMTABhZGRMaW5rZWRDb29yZABsb29wLT5maXJzdCA9PSBOVUxMAGlubmVyTG9vcHMgIT0gTlVMTABub3JtYWxpemVNdWx0aVBvbHlnb24AYmJveGVzICE9IE5VTEwAY2FuZGlkYXRlcyAhPSBOVUxMAGZpbmRQb2x5Z29uRm9ySG9sZQBjYW5kaWRhdGVCQm94ZXMgIT0gTlVMTAByZXZEaXIgIT0gSU5WQUxJRF9ESUdJVABsb2NhbGlqLmMAY2VsbFRvTG9jYWxJamsAYmFzZUNlbGwgIT0gb3JpZ2luQmFzZUNlbGwAIShvcmlnaW5PblBlbnQgJiYgaW5kZXhPblBlbnQpAGJhc2VDZWxsID09IG9yaWdpbkJhc2VDZWxsAGJhc2VDZWxsICE9IElOVkFMSURfQkFTRV9DRUxMAGxvY2FsSWprVG9DZWxsACFfaXNCYXNlQ2VsbFBlbnRhZ29uKGJhc2VDZWxsKQBiYXNlQ2VsbFJvdGF0aW9ucyA+PSAwAGdyaWRQYXRoQ2VsbHMAcG9seWZpbGwuYwBpdGVyU3RlcFBvbHlnb25Db21wYWN0ADAAdmVydGV4LmMAY2VsbFRvVmVydGV4AGdyYXBoLT5idWNrZXRzICE9IE5VTEwAdmVydGV4R3JhcGguYwBpbml0VmVydGV4R3JhcGgAbm9kZSAhPSBOVUxMAGFkZFZlcnRleE5vZGU=";
  var Zt = 28624;
  function br(pe, Te, le, ge) {
    Ne("Assertion failed: " + ae(pe) + ", at: " + [Te ? ae(Te) : "unknown filename", le, ge ? ae(ge) : "unknown function"]);
  }
  function Nr() {
    return X.length;
  }
  function on(pe, Te, le) {
    re.set(re.subarray(Te, Te + le), pe);
  }
  function pi(pe) {
    return e.___errno_location && (ot[e.___errno_location() >> 2] = pe), pe;
  }
  function Le(pe) {
    Ne("OOM");
  }
  function Gt(pe) {
    try {
      var Te = new ArrayBuffer(pe);
      return Te.byteLength != pe ? void 0 : (new Int8Array(Te).set(X), $(Te), Xe(Te), 1);
    } catch {
    }
  }
  function Jt(pe) {
    var Te = Nr(), le = 16777216, ge = 2147483648 - le;
    if (pe > ge)
      return !1;
    for (var d = 16777216, ee = Math.max(Te, d); ee < pe; )
      ee <= 536870912 ? ee = ve(2 * ee, le) : ee = Math.min(ve((3 * ee + 2147483648) / 4, le), ge);
    var It = Gt(ee);
    return !!It;
  }
  var pr = typeof atob == "function" ? atob : function(pe) {
    var Te = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", le = "", ge, d, ee, It, nt, Mt, kt, zt = 0;
    pe = pe.replace(/[^A-Za-z0-9\+\/\=]/g, "");
    do
      It = Te.indexOf(pe.charAt(zt++)), nt = Te.indexOf(pe.charAt(zt++)), Mt = Te.indexOf(pe.charAt(zt++)), kt = Te.indexOf(pe.charAt(zt++)), ge = It << 2 | nt >> 4, d = (nt & 15) << 4 | Mt >> 2, ee = (Mt & 3) << 6 | kt, le = le + String.fromCharCode(ge), Mt !== 64 && (le = le + String.fromCharCode(d)), kt !== 64 && (le = le + String.fromCharCode(ee));
    while (zt < pe.length);
    return le;
  };
  function st(pe) {
    try {
      for (var Te = pr(pe), le = new Uint8Array(Te.length), ge = 0; ge < Te.length; ++ge)
        le[ge] = Te.charCodeAt(ge);
      return le;
    } catch {
      throw new Error("Converting base64 string to bytes failed.");
    }
  }
  function Ft(pe) {
    if (qn(pe))
      return st(pe.slice(ii.length));
  }
  var _e = {
    Math,
    Int8Array,
    Int32Array,
    Uint8Array,
    Float32Array,
    Float64Array
  }, Xt = {
    b: y,
    c: E,
    d: br,
    e: pi,
    f: Nr,
    g: on,
    h: Jt,
    i: Le,
    o: Zt,
    p: at
  }, Ct = (
    /** @suppress {uselessCode} */
    (function(pe, Te, le) {
      "almost asm";
      var ge = new pe.Int8Array(le), d = new pe.Int32Array(le);
      new pe.Uint8Array(le), new pe.Float32Array(le);
      var ee = new pe.Float64Array(le), It = Te.o | 0, nt = Te.p | 0, Mt = pe.Math.floor, kt = pe.Math.abs, zt = pe.Math.sqrt, _t = pe.Math.pow, Vt = pe.Math.cos, Lt = pe.Math.sin, Yt = pe.Math.tan, Hr = pe.Math.acos, ir = pe.Math.asin, nn = pe.Math.atan, un = pe.Math.atan2, Yr = pe.Math.ceil, Qr = pe.Math.imul, $r = pe.Math.min, Ai = pe.Math.max, Kr = pe.Math.clz32, hr = Te.b, ye = Te.c, er = Te.d, sn = Te.e, Wi = Te.f, ma = Te.g, ui = Te.h, Xn = Te.i, Ae = 28640;
      function Ko(h) {
        return ge = new Int8Array(h), d = new Int32Array(h), ee = new Float64Array(h), le = h, !0;
      }
      function Zn(h) {
        h = h | 0;
        var f = 0;
        return f = Ae, Ae = Ae + h | 0, Ae = Ae + 15 & -16, f | 0;
      }
      function Qo() {
        return Ae | 0;
      }
      function Oi(h) {
        h = h | 0, Ae = h;
      }
      function fi(h, f) {
        h = h | 0, Ae = h;
      }
      function Ci(h, f) {
        h = h | 0, f = f | 0;
        var A = 0, b = 0, T = 0;
        return (h | 0) < 0 ? (f = 2, f | 0) : (h | 0) > 13780509 ? (f = ao(15, f) | 0, f | 0) : (A = ((h | 0) < 0) << 31 >> 31, T = v(h | 0, A | 0, 3, 0) | 0, b = ye() | 0, A = Er(h | 0, A | 0, 1, 0) | 0, A = v(T | 0, b | 0, A | 0, ye() | 0) | 0, A = Er(A | 0, ye() | 0, 1, 0) | 0, h = ye() | 0, d[f >> 2] = A, d[f + 4 >> 2] = h, f = 0, f | 0);
      }
      function Fn(h, f, A, b) {
        return h = h | 0, f = f | 0, A = A | 0, b = b | 0, ms(h, f, A, b, 0) | 0;
      }
      function ms(h, f, A, b, T) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0, T = T | 0;
        var C = 0, I = 0, B = 0, F = 0, z = 0;
        if (F = Ae, Ae = Ae + 16 | 0, I = F, !($i(h, f, A, b, T) | 0))
          return b = 0, Ae = F, b | 0;
        do
          if ((A | 0) >= 0) {
            if ((A | 0) > 13780509) {
              if (C = ao(15, I) | 0, C | 0)
                break;
              B = I, I = d[B >> 2] | 0, B = d[B + 4 >> 2] | 0;
            } else
              C = ((A | 0) < 0) << 31 >> 31, z = v(A | 0, C | 0, 3, 0) | 0, B = ye() | 0, C = Er(A | 0, C | 0, 1, 0) | 0, C = v(z | 0, B | 0, C | 0, ye() | 0) | 0, C = Er(C | 0, ye() | 0, 1, 0) | 0, B = ye() | 0, d[I >> 2] = C, d[I + 4 >> 2] = B, I = C;
            if (Oe(b | 0, 0, I << 3 | 0) | 0, T | 0) {
              Oe(T | 0, 0, I << 2 | 0) | 0, C = Ms(h, f, A, b, T, I, B, 0) | 0;
              break;
            }
            C = Ii(I, 4) | 0, C ? (z = Ms(h, f, A, b, C, I, B, 0) | 0, Ur(C), C = z) : C = 13;
          } else
            C = 2;
        while (!1);
        return z = C, Ae = F, z | 0;
      }
      function $i(h, f, A, b, T) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0, T = T | 0;
        var C = 0, I = 0, B = 0, F = 0, z = 0, W = 0, ue = 0, Ie = 0, Re = 0, Be = 0, Ze = 0;
        if (Ze = Ae, Ae = Ae + 16 | 0, Re = Ze, Be = Ze + 8 | 0, Ie = Re, d[Ie >> 2] = h, d[Ie + 4 >> 2] = f, (A | 0) < 0)
          return Be = 2, Ae = Ze, Be | 0;
        if (C = b, d[C >> 2] = h, d[C + 4 >> 2] = f, C = (T | 0) != 0, C && (d[T >> 2] = 0), Bn(h, f) | 0)
          return Be = 9, Ae = Ze, Be | 0;
        d[Be >> 2] = 0;
        e: do
          if ((A | 0) >= 1)
            if (C)
              for (W = 1, z = 0, ue = 0, Ie = 1, C = h; ; ) {
                if (!(z | ue)) {
                  if (C = On(C, f, 4, Be, Re) | 0, C | 0)
                    break e;
                  if (f = Re, C = d[f >> 2] | 0, f = d[f + 4 >> 2] | 0, Bn(C, f) | 0) {
                    C = 9;
                    break e;
                  }
                }
                if (C = On(C, f, d[26800 + (ue << 2) >> 2] | 0, Be, Re) | 0, C | 0)
                  break e;
                if (f = Re, C = d[f >> 2] | 0, f = d[f + 4 >> 2] | 0, h = b + (W << 3) | 0, d[h >> 2] = C, d[h + 4 >> 2] = f, d[T + (W << 2) >> 2] = Ie, h = z + 1 | 0, I = (h | 0) == (Ie | 0), B = ue + 1 | 0, F = (B | 0) == 6, Bn(C, f) | 0) {
                  C = 9;
                  break e;
                }
                if (Ie = Ie + (F & I & 1) | 0, (Ie | 0) > (A | 0)) {
                  C = 0;
                  break;
                } else
                  W = W + 1 | 0, z = I ? 0 : h, ue = I ? F ? 0 : B : ue;
              }
            else
              for (W = 1, z = 0, ue = 0, Ie = 1, C = h; ; ) {
                if (!(z | ue)) {
                  if (C = On(C, f, 4, Be, Re) | 0, C | 0)
                    break e;
                  if (f = Re, C = d[f >> 2] | 0, f = d[f + 4 >> 2] | 0, Bn(C, f) | 0) {
                    C = 9;
                    break e;
                  }
                }
                if (C = On(C, f, d[26800 + (ue << 2) >> 2] | 0, Be, Re) | 0, C | 0)
                  break e;
                if (f = Re, C = d[f >> 2] | 0, f = d[f + 4 >> 2] | 0, h = b + (W << 3) | 0, d[h >> 2] = C, d[h + 4 >> 2] = f, h = z + 1 | 0, I = (h | 0) == (Ie | 0), B = ue + 1 | 0, F = (B | 0) == 6, Bn(C, f) | 0) {
                  C = 9;
                  break e;
                }
                if (Ie = Ie + (F & I & 1) | 0, (Ie | 0) > (A | 0)) {
                  C = 0;
                  break;
                } else
                  W = W + 1 | 0, z = I ? 0 : h, ue = I ? F ? 0 : B : ue;
              }
          else
            C = 0;
        while (!1);
        return Be = C, Ae = Ze, Be | 0;
      }
      function Ms(h, f, A, b, T, C, I, B) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0, T = T | 0, C = C | 0, I = I | 0, B = B | 0;
        var F = 0, z = 0, W = 0, ue = 0, Ie = 0, Re = 0, Be = 0, Ze = 0, We = 0, rt = 0;
        if (Ze = Ae, Ae = Ae + 16 | 0, Re = Ze + 8 | 0, Be = Ze, F = w(h | 0, f | 0, C | 0, I | 0) | 0, W = ye() | 0, ue = b + (F << 3) | 0, We = ue, rt = d[We >> 2] | 0, We = d[We + 4 >> 2] | 0, z = (rt | 0) == (h | 0) & (We | 0) == (f | 0), !((rt | 0) == 0 & (We | 0) == 0 | z))
          do
            F = Er(F | 0, W | 0, 1, 0) | 0, F = _(F | 0, ye() | 0, C | 0, I | 0) | 0, W = ye() | 0, ue = b + (F << 3) | 0, rt = ue, We = d[rt >> 2] | 0, rt = d[rt + 4 >> 2] | 0, z = (We | 0) == (h | 0) & (rt | 0) == (f | 0);
          while (!((We | 0) == 0 & (rt | 0) == 0 | z));
        if (F = T + (F << 2) | 0, z && (d[F >> 2] | 0) <= (B | 0) || (rt = ue, d[rt >> 2] = h, d[rt + 4 >> 2] = f, d[F >> 2] = B, (B | 0) >= (A | 0)))
          return rt = 0, Ae = Ze, rt | 0;
        switch (z = B + 1 | 0, d[Re >> 2] = 0, F = On(h, f, 2, Re, Be) | 0, F | 0) {
          case 9: {
            Ie = 9;
            break;
          }
          case 0: {
            F = Be, F = Ms(d[F >> 2] | 0, d[F + 4 >> 2] | 0, A, b, T, C, I, z) | 0, F || (Ie = 9);
            break;
          }
        }
        e: do
          if ((Ie | 0) == 9) {
            switch (d[Re >> 2] = 0, F = On(h, f, 3, Re, Be) | 0, F | 0) {
              case 9:
                break;
              case 0: {
                if (F = Be, F = Ms(d[F >> 2] | 0, d[F + 4 >> 2] | 0, A, b, T, C, I, z) | 0, F | 0)
                  break e;
                break;
              }
              default:
                break e;
            }
            switch (d[Re >> 2] = 0, F = On(h, f, 1, Re, Be) | 0, F | 0) {
              case 9:
                break;
              case 0: {
                if (F = Be, F = Ms(d[F >> 2] | 0, d[F + 4 >> 2] | 0, A, b, T, C, I, z) | 0, F | 0)
                  break e;
                break;
              }
              default:
                break e;
            }
            switch (d[Re >> 2] = 0, F = On(h, f, 5, Re, Be) | 0, F | 0) {
              case 9:
                break;
              case 0: {
                if (F = Be, F = Ms(d[F >> 2] | 0, d[F + 4 >> 2] | 0, A, b, T, C, I, z) | 0, F | 0)
                  break e;
                break;
              }
              default:
                break e;
            }
            switch (d[Re >> 2] = 0, F = On(h, f, 4, Re, Be) | 0, F | 0) {
              case 9:
                break;
              case 0: {
                if (F = Be, F = Ms(d[F >> 2] | 0, d[F + 4 >> 2] | 0, A, b, T, C, I, z) | 0, F | 0)
                  break e;
                break;
              }
              default:
                break e;
            }
            switch (d[Re >> 2] = 0, F = On(h, f, 6, Re, Be) | 0, F | 0) {
              case 9:
                break;
              case 0: {
                if (F = Be, F = Ms(d[F >> 2] | 0, d[F + 4 >> 2] | 0, A, b, T, C, I, z) | 0, F | 0)
                  break e;
                break;
              }
              default:
                break e;
            }
            return rt = 0, Ae = Ze, rt | 0;
          }
        while (!1);
        return rt = F, Ae = Ze, rt | 0;
      }
      function On(h, f, A, b, T) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0, T = T | 0;
        var C = 0, I = 0, B = 0, F = 0, z = 0, W = 0, ue = 0, Ie = 0, Re = 0, Be = 0;
        if (A >>> 0 > 6)
          return T = 1, T | 0;
        if (ue = (d[b >> 2] | 0) % 6 | 0, d[b >> 2] = ue, (ue | 0) > 0) {
          C = 0;
          do
            A = Bs(A) | 0, C = C + 1 | 0;
          while ((C | 0) < (d[b >> 2] | 0));
        }
        if (ue = D(h | 0, f | 0, 45) | 0, ye() | 0, W = ue & 127, W >>> 0 > 121)
          return T = 5, T | 0;
        F = ys(h, f) | 0, C = D(h | 0, f | 0, 52) | 0, ye() | 0, C = C & 15;
        e: do
          if (!C)
            z = 8;
          else {
            for (; ; ) {
              if (I = (15 - C | 0) * 3 | 0, B = D(h | 0, f | 0, I | 0) | 0, ye() | 0, B = B & 7, (B | 0) == 7) {
                f = 5;
                break;
              }
              if (Be = (vs(C) | 0) == 0, C = C + -1 | 0, Ie = k(7, 0, I | 0) | 0, f = f & ~(ye() | 0), Re = k(d[(Be ? 432 : 16) + (B * 28 | 0) + (A << 2) >> 2] | 0, 0, I | 0) | 0, I = ye() | 0, A = d[(Be ? 640 : 224) + (B * 28 | 0) + (A << 2) >> 2] | 0, h = Re | h & ~Ie, f = I | f, !A) {
                A = 0;
                break e;
              }
              if (!C) {
                z = 8;
                break e;
              }
            }
            return f | 0;
          }
        while (!1);
        (z | 0) == 8 && (Be = d[848 + (W * 28 | 0) + (A << 2) >> 2] | 0, Re = k(Be | 0, 0, 45) | 0, h = Re | h, f = ye() | 0 | f & -1040385, A = d[4272 + (W * 28 | 0) + (A << 2) >> 2] | 0, (Be & 127 | 0) == 127 && (Be = k(d[848 + (W * 28 | 0) + 20 >> 2] | 0, 0, 45) | 0, f = ye() | 0 | f & -1040385, A = d[4272 + (W * 28 | 0) + 20 >> 2] | 0, h = Xs(Be | h, f) | 0, f = ye() | 0, d[b >> 2] = (d[b >> 2] | 0) + 1)), B = D(h | 0, f | 0, 45) | 0, ye() | 0, B = B & 127;
        e: do
          if (mn(B) | 0) {
            t: do
              if ((ys(h, f) | 0) == 1) {
                if ((W | 0) != (B | 0))
                  if (au(B, d[7696 + (W * 28 | 0) >> 2] | 0) | 0) {
                    h = Bl(h, f) | 0, I = 1, f = ye() | 0;
                    break;
                  } else
                    er(27795, 26864, 533, 26872);
                switch (F | 0) {
                  case 3: {
                    h = Xs(h, f) | 0, f = ye() | 0, d[b >> 2] = (d[b >> 2] | 0) + 1, I = 0;
                    break t;
                  }
                  case 5: {
                    h = Bl(h, f) | 0, f = ye() | 0, d[b >> 2] = (d[b >> 2] | 0) + 5, I = 0;
                    break t;
                  }
                  case 0:
                    return Be = 9, Be | 0;
                  default:
                    return Be = 1, Be | 0;
                }
              } else
                I = 0;
            while (!1);
            if ((A | 0) > 0) {
              C = 0;
              do
                h = mu(h, f) | 0, f = ye() | 0, C = C + 1 | 0;
              while ((C | 0) != (A | 0));
            }
            if ((W | 0) != (B | 0)) {
              if (!(Di(B) | 0)) {
                if ((I | 0) != 0 | (ys(h, f) | 0) != 5)
                  break;
                d[b >> 2] = (d[b >> 2] | 0) + 1;
                break;
              }
              switch (ue & 127) {
                case 8:
                case 118:
                  break e;
              }
              (ys(h, f) | 0) != 3 && (d[b >> 2] = (d[b >> 2] | 0) + 1);
            }
          } else if ((A | 0) > 0) {
            C = 0;
            do
              h = Xs(h, f) | 0, f = ye() | 0, C = C + 1 | 0;
            while ((C | 0) != (A | 0));
          }
        while (!1);
        return d[b >> 2] = ((d[b >> 2] | 0) + A | 0) % 6 | 0, Be = T, d[Be >> 2] = h, d[Be + 4 >> 2] = f, Be = 0, Be | 0;
      }
      function lf(h, f, A, b) {
        return h = h | 0, f = f | 0, A = A | 0, b = b | 0, Ee(h, f, A, b) | 0 ? (Oe(b | 0, 0, A * 48 | 0) | 0, b = ke(h, f, A, b) | 0, b | 0) : (b = 0, b | 0);
      }
      function Ee(h, f, A, b) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0;
        var T = 0, C = 0, I = 0, B = 0, F = 0, z = 0, W = 0, ue = 0, Ie = 0, Re = 0, Be = 0;
        if (Be = Ae, Ae = Ae + 16 | 0, Ie = Be, Re = Be + 8 | 0, ue = Ie, d[ue >> 2] = h, d[ue + 4 >> 2] = f, (A | 0) < 0)
          return Re = 2, Ae = Be, Re | 0;
        if (!A)
          return Re = b, d[Re >> 2] = h, d[Re + 4 >> 2] = f, Re = 0, Ae = Be, Re | 0;
        d[Re >> 2] = 0;
        e: do
          if (Bn(h, f) | 0)
            h = 9;
          else {
            T = 0, ue = h;
            do {
              if (h = On(ue, f, 4, Re, Ie) | 0, h | 0)
                break e;
              if (f = Ie, ue = d[f >> 2] | 0, f = d[f + 4 >> 2] | 0, T = T + 1 | 0, Bn(ue, f) | 0) {
                h = 9;
                break e;
              }
            } while ((T | 0) < (A | 0));
            W = b, d[W >> 2] = ue, d[W + 4 >> 2] = f, W = A + -1 | 0, z = 0, h = 1;
            do {
              if (T = 26800 + (z << 2) | 0, (z | 0) == 5)
                for (I = d[T >> 2] | 0, C = 0, T = h; ; ) {
                  if (h = Ie, h = On(d[h >> 2] | 0, d[h + 4 >> 2] | 0, I, Re, Ie) | 0, h | 0)
                    break e;
                  if ((C | 0) != (W | 0))
                    if (F = Ie, B = d[F >> 2] | 0, F = d[F + 4 >> 2] | 0, h = b + (T << 3) | 0, d[h >> 2] = B, d[h + 4 >> 2] = F, !(Bn(B, F) | 0))
                      h = T + 1 | 0;
                    else {
                      h = 9;
                      break e;
                    }
                  else
                    h = T;
                  if (C = C + 1 | 0, (C | 0) >= (A | 0))
                    break;
                  T = h;
                }
              else
                for (I = Ie, F = d[T >> 2] | 0, B = 0, T = h, C = d[I >> 2] | 0, I = d[I + 4 >> 2] | 0; ; ) {
                  if (h = On(C, I, F, Re, Ie) | 0, h | 0)
                    break e;
                  if (I = Ie, C = d[I >> 2] | 0, I = d[I + 4 >> 2] | 0, h = b + (T << 3) | 0, d[h >> 2] = C, d[h + 4 >> 2] = I, h = T + 1 | 0, Bn(C, I) | 0) {
                    h = 9;
                    break e;
                  }
                  if (B = B + 1 | 0, (B | 0) >= (A | 0))
                    break;
                  T = h;
                }
              z = z + 1 | 0;
            } while (z >>> 0 < 6);
            h = Ie, h = (ue | 0) == (d[h >> 2] | 0) && (f | 0) == (d[h + 4 >> 2] | 0) ? 0 : 9;
          }
        while (!1);
        return Re = h, Ae = Be, Re | 0;
      }
      function ke(h, f, A, b) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0;
        var T = 0, C = 0, I = 0, B = 0, F = 0, z = 0, W = 0, ue = 0, Ie = 0;
        if (ue = Ae, Ae = Ae + 16 | 0, I = ue, !A)
          return d[b >> 2] = h, d[b + 4 >> 2] = f, b = 0, Ae = ue, b | 0;
        do
          if ((A | 0) >= 0) {
            if ((A | 0) > 13780509) {
              if (T = ao(15, I) | 0, T | 0)
                break;
              C = I, T = d[C >> 2] | 0, C = d[C + 4 >> 2] | 0;
            } else
              T = ((A | 0) < 0) << 31 >> 31, W = v(A | 0, T | 0, 3, 0) | 0, C = ye() | 0, T = Er(A | 0, T | 0, 1, 0) | 0, T = v(W | 0, C | 0, T | 0, ye() | 0) | 0, T = Er(T | 0, ye() | 0, 1, 0) | 0, C = ye() | 0, W = I, d[W >> 2] = T, d[W + 4 >> 2] = C;
            if (z = Ii(T, 8) | 0, !z)
              T = 13;
            else {
              if (W = Ii(T, 4) | 0, !W) {
                Ur(z), T = 13;
                break;
              }
              if (T = Ms(h, f, A, z, W, T, C, 0) | 0, T | 0) {
                Ur(z), Ur(W);
                break;
              }
              if (f = d[I >> 2] | 0, I = d[I + 4 >> 2] | 0, (I | 0) > 0 | (I | 0) == 0 & f >>> 0 > 0) {
                T = 0, B = 0, F = 0;
                do
                  h = z + (B << 3) | 0, C = d[h >> 2] | 0, h = d[h + 4 >> 2] | 0, !((C | 0) == 0 & (h | 0) == 0) && (d[W + (B << 2) >> 2] | 0) == (A | 0) && (Ie = b + (T << 3) | 0, d[Ie >> 2] = C, d[Ie + 4 >> 2] = h, T = T + 1 | 0), B = Er(B | 0, F | 0, 1, 0) | 0, F = ye() | 0;
                while ((F | 0) < (I | 0) | (F | 0) == (I | 0) & B >>> 0 < f >>> 0);
              }
              Ur(z), Ur(W), T = 0;
            }
          } else
            T = 2;
        while (!1);
        return Ie = T, Ae = ue, Ie | 0;
      }
      function Ke(h, f, A, b) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0;
        var T = 0, C = 0, I = 0, B = 0, F = 0, z = 0;
        for (B = Ae, Ae = Ae + 16 | 0, C = B, I = B + 8 | 0, T = (Bn(h, f) | 0) == 0, T = T ? 1 : 2; ; ) {
          if (d[I >> 2] = 0, z = (On(h, f, T, I, C) | 0) == 0, F = C, z & ((d[F >> 2] | 0) == (A | 0) ? (d[F + 4 >> 2] | 0) == (b | 0) : 0)) {
            h = 4;
            break;
          }
          if (T = T + 1 | 0, T >>> 0 >= 7) {
            T = 7, h = 4;
            break;
          }
        }
        return (h | 0) == 4 ? (Ae = B, T | 0) : 0;
      }
      function bt(h, f, A, b) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0;
        var T = 0, C = 0, I = 0, B = 0, F = 0, z = 0;
        if (B = Ae, Ae = Ae + 48 | 0, T = B + 16 | 0, C = B + 8 | 0, I = B, A = ks(A) | 0, A | 0)
          return I = A, Ae = B, I | 0;
        if (z = h, F = d[z + 4 >> 2] | 0, A = C, d[A >> 2] = d[z >> 2], d[A + 4 >> 2] = F, cn(C, T), A = Ha(T, f, I) | 0, !A) {
          if (f = d[C >> 2] | 0, C = d[h + 8 >> 2] | 0, (C | 0) > 0) {
            T = d[h + 12 >> 2] | 0, A = 0;
            do
              f = (d[T + (A << 3) >> 2] | 0) + f | 0, A = A + 1 | 0;
            while ((A | 0) < (C | 0));
          }
          A = I, T = d[A >> 2] | 0, A = d[A + 4 >> 2] | 0, C = ((f | 0) < 0) << 31 >> 31, (A | 0) < (C | 0) | (A | 0) == (C | 0) & T >>> 0 < f >>> 0 ? (A = I, d[A >> 2] = f, d[A + 4 >> 2] = C, A = C) : f = T, F = Er(f | 0, A | 0, 12, 0) | 0, z = ye() | 0, A = I, d[A >> 2] = F, d[A + 4 >> 2] = z, A = b, d[A >> 2] = F, d[A + 4 >> 2] = z, A = 0;
        }
        return z = A, Ae = B, z | 0;
      }
      function Qt(h, f, A, b, T, C, I) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0, T = T | 0, C = C | 0, I = I | 0;
        var B = 0, F = 0, z = 0, W = 0, ue = 0, Ie = 0, Re = 0, Be = 0, Ze = 0, We = 0, rt = 0, et = 0, Je = 0, $e = 0, Bt = 0, Ht = 0, Ut = 0, Or = 0, Cr = 0, Gr = 0, Sr = 0, ar = 0, jt = 0, Wr = 0, fn = 0, Zr = 0, _n = 0, si = 0, Ys = 0;
        if (fn = Ae, Ae = Ae + 64 | 0, Sr = fn + 48 | 0, ar = fn + 32 | 0, jt = fn + 24 | 0, Bt = fn + 8 | 0, Ht = fn, F = d[h >> 2] | 0, (F | 0) <= 0)
          return Wr = 0, Ae = fn, Wr | 0;
        for (Ut = h + 4 | 0, Or = Sr + 8 | 0, Cr = ar + 8 | 0, Gr = Bt + 8 | 0, B = 0, Je = 0; ; ) {
          z = d[Ut >> 2] | 0, et = z + (Je << 4) | 0, d[Sr >> 2] = d[et >> 2], d[Sr + 4 >> 2] = d[et + 4 >> 2], d[Sr + 8 >> 2] = d[et + 8 >> 2], d[Sr + 12 >> 2] = d[et + 12 >> 2], (Je | 0) == (F + -1 | 0) ? (d[ar >> 2] = d[z >> 2], d[ar + 4 >> 2] = d[z + 4 >> 2], d[ar + 8 >> 2] = d[z + 8 >> 2], d[ar + 12 >> 2] = d[z + 12 >> 2]) : (et = z + (Je + 1 << 4) | 0, d[ar >> 2] = d[et >> 2], d[ar + 4 >> 2] = d[et + 4 >> 2], d[ar + 8 >> 2] = d[et + 8 >> 2], d[ar + 12 >> 2] = d[et + 12 >> 2]), F = Eh(Sr, ar, b, jt) | 0;
          e: do
            if (F)
              z = 0, B = F;
            else if (F = jt, z = d[F >> 2] | 0, F = d[F + 4 >> 2] | 0, (F | 0) > 0 | (F | 0) == 0 & z >>> 0 > 0) {
              rt = 0, et = 0;
              t: for (; ; ) {
                if (_n = 1 / (+(z >>> 0) + 4294967296 * +(F | 0)), Ys = +ee[Sr >> 3], F = Vi(z | 0, F | 0, rt | 0, et | 0) | 0, si = +(F >>> 0) + 4294967296 * +(ye() | 0), Zr = +(rt >>> 0) + 4294967296 * +(et | 0), ee[Bt >> 3] = _n * (Ys * si) + _n * (+ee[ar >> 3] * Zr), ee[Gr >> 3] = _n * (+ee[Or >> 3] * si) + _n * (+ee[Cr >> 3] * Zr), F = gf(Bt, b, Ht) | 0, F | 0) {
                  B = F;
                  break;
                }
                We = Ht, Ze = d[We >> 2] | 0, We = d[We + 4 >> 2] | 0, Ie = w(Ze | 0, We | 0, f | 0, A | 0) | 0, W = ye() | 0, F = I + (Ie << 3) | 0, ue = F, z = d[ue >> 2] | 0, ue = d[ue + 4 >> 2] | 0;
                r: do
                  if ((z | 0) == 0 & (ue | 0) == 0)
                    $e = F, Wr = 16;
                  else
                    for (Re = 0, Be = 0; ; ) {
                      if ((Re | 0) > (A | 0) | (Re | 0) == (A | 0) & Be >>> 0 > f >>> 0) {
                        B = 1;
                        break t;
                      }
                      if ((z | 0) == (Ze | 0) & (ue | 0) == (We | 0))
                        break r;
                      if (F = Er(Ie | 0, W | 0, 1, 0) | 0, Ie = _(F | 0, ye() | 0, f | 0, A | 0) | 0, W = ye() | 0, Be = Er(Be | 0, Re | 0, 1, 0) | 0, Re = ye() | 0, F = I + (Ie << 3) | 0, ue = F, z = d[ue >> 2] | 0, ue = d[ue + 4 >> 2] | 0, (z | 0) == 0 & (ue | 0) == 0) {
                        $e = F, Wr = 16;
                        break;
                      }
                    }
                while (!1);
                if ((Wr | 0) == 16 && (Wr = 0, !((Ze | 0) == 0 & (We | 0) == 0)) && (Be = $e, d[Be >> 2] = Ze, d[Be + 4 >> 2] = We, Be = C + (d[T >> 2] << 3) | 0, d[Be >> 2] = Ze, d[Be + 4 >> 2] = We, Be = T, Be = Er(d[Be >> 2] | 0, d[Be + 4 >> 2] | 0, 1, 0) | 0, Ze = ye() | 0, We = T, d[We >> 2] = Be, d[We + 4 >> 2] = Ze), rt = Er(rt | 0, et | 0, 1, 0) | 0, et = ye() | 0, F = jt, z = d[F >> 2] | 0, F = d[F + 4 >> 2] | 0, !((F | 0) > (et | 0) | (F | 0) == (et | 0) & z >>> 0 > rt >>> 0)) {
                  z = 1;
                  break e;
                }
              }
              z = 0;
            } else
              z = 1;
          while (!1);
          if (Je = Je + 1 | 0, !z) {
            Wr = 21;
            break;
          }
          if (F = d[h >> 2] | 0, (Je | 0) >= (F | 0)) {
            B = 0, Wr = 21;
            break;
          }
        }
        return (Wr | 0) == 21 ? (Ae = fn, B | 0) : 0;
      }
      function Tr(h, f, A, b) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0;
        var T = 0, C = 0, I = 0, B = 0, F = 0, z = 0, W = 0, ue = 0, Ie = 0, Re = 0, Be = 0, Ze = 0, We = 0, rt = 0, et = 0, Je = 0, $e = 0, Bt = 0, Ht = 0, Ut = 0, Or = 0, Cr = 0, Gr = 0, Sr = 0, ar = 0, jt = 0, Wr = 0, fn = 0, Zr = 0, _n = 0, si = 0;
        if (si = Ae, Ae = Ae + 112 | 0, Wr = si + 80 | 0, F = si + 72 | 0, fn = si, Zr = si + 56 | 0, T = ks(A) | 0, T | 0)
          return _n = T, Ae = si, _n | 0;
        if (z = h + 8 | 0, _n = ss((d[z >> 2] << 5) + 32 | 0) | 0, !_n)
          return _n = 13, Ae = si, _n | 0;
        if (Fs(h, _n), T = ks(A) | 0, !T) {
          if (ar = h, jt = d[ar + 4 >> 2] | 0, T = F, d[T >> 2] = d[ar >> 2], d[T + 4 >> 2] = jt, cn(F, Wr), T = Ha(Wr, f, fn) | 0, T)
            ar = 0, jt = 0;
          else {
            if (T = d[F >> 2] | 0, C = d[z >> 2] | 0, (C | 0) > 0) {
              I = d[h + 12 >> 2] | 0, A = 0;
              do
                T = (d[I + (A << 3) >> 2] | 0) + T | 0, A = A + 1 | 0;
              while ((A | 0) != (C | 0));
              A = T;
            } else
              A = T;
            T = fn, C = d[T >> 2] | 0, T = d[T + 4 >> 2] | 0, I = ((A | 0) < 0) << 31 >> 31, (T | 0) < (I | 0) | (T | 0) == (I | 0) & C >>> 0 < A >>> 0 ? (T = fn, d[T >> 2] = A, d[T + 4 >> 2] = I, T = I) : A = C, ar = Er(A | 0, T | 0, 12, 0) | 0, jt = ye() | 0, T = fn, d[T >> 2] = ar, d[T + 4 >> 2] = jt, T = 0;
          }
          if (!T) {
            if (A = Ii(ar, 8) | 0, !A)
              return Ur(_n), _n = 13, Ae = si, _n | 0;
            if (B = Ii(ar, 8) | 0, !B)
              return Ur(_n), Ur(A), _n = 13, Ae = si, _n | 0;
            Gr = Wr, d[Gr >> 2] = 0, d[Gr + 4 >> 2] = 0, Gr = h, Sr = d[Gr + 4 >> 2] | 0, T = F, d[T >> 2] = d[Gr >> 2], d[T + 4 >> 2] = Sr, T = Qt(F, ar, jt, f, Wr, A, B) | 0;
            e: do
              if (T)
                Ur(A), Ur(B), Ur(_n);
              else {
                t: do
                  if ((d[z >> 2] | 0) > 0) {
                    for (I = h + 12 | 0, C = 0; T = Qt((d[I >> 2] | 0) + (C << 3) | 0, ar, jt, f, Wr, A, B) | 0, C = C + 1 | 0, !(T | 0); )
                      if ((C | 0) >= (d[z >> 2] | 0))
                        break t;
                    Ur(A), Ur(B), Ur(_n);
                    break e;
                  }
                while (!1);
                (jt | 0) > 0 | (jt | 0) == 0 & ar >>> 0 > 0 && Oe(B | 0, 0, ar << 3 | 0) | 0, Sr = Wr, Gr = d[Sr + 4 >> 2] | 0;
                t: do
                  if ((Gr | 0) > 0 | (Gr | 0) == 0 & (d[Sr >> 2] | 0) >>> 0 > 0) {
                    Ut = A, Or = B, Cr = A, Gr = B, Sr = A, T = A, $e = A, Bt = B, Ht = B, A = B;
                    r: for (; ; ) {
                      for (We = 0, rt = 0, et = 0, Je = 0, C = 0, I = 0; ; ) {
                        B = fn, F = B + 56 | 0;
                        do
                          d[B >> 2] = 0, B = B + 4 | 0;
                        while ((B | 0) < (F | 0));
                        if (f = Ut + (We << 3) | 0, z = d[f >> 2] | 0, f = d[f + 4 >> 2] | 0, $i(z, f, 1, fn, 0) | 0) {
                          B = fn, F = B + 56 | 0;
                          do
                            d[B >> 2] = 0, B = B + 4 | 0;
                          while ((B | 0) < (F | 0));
                          B = Ii(7, 4) | 0, B | 0 && (Ms(z, f, 1, fn, B, 7, 0, 0) | 0, Ur(B));
                        }
                        for (Ze = 0; ; ) {
                          Be = fn + (Ze << 3) | 0, Re = d[Be >> 2] | 0, Be = d[Be + 4 >> 2] | 0;
                          n: do
                            if ((Re | 0) == 0 & (Be | 0) == 0)
                              B = C, F = I;
                            else {
                              if (W = w(Re | 0, Be | 0, ar | 0, jt | 0) | 0, z = ye() | 0, B = b + (W << 3) | 0, f = B, F = d[f >> 2] | 0, f = d[f + 4 >> 2] | 0, !((F | 0) == 0 & (f | 0) == 0)) {
                                ue = 0, Ie = 0;
                                do {
                                  if ((ue | 0) > (jt | 0) | (ue | 0) == (jt | 0) & Ie >>> 0 > ar >>> 0)
                                    break r;
                                  if ((F | 0) == (Re | 0) & (f | 0) == (Be | 0)) {
                                    B = C, F = I;
                                    break n;
                                  }
                                  B = Er(W | 0, z | 0, 1, 0) | 0, W = _(B | 0, ye() | 0, ar | 0, jt | 0) | 0, z = ye() | 0, Ie = Er(Ie | 0, ue | 0, 1, 0) | 0, ue = ye() | 0, B = b + (W << 3) | 0, f = B, F = d[f >> 2] | 0, f = d[f + 4 >> 2] | 0;
                                } while (!((F | 0) == 0 & (f | 0) == 0));
                              }
                              if ((Re | 0) == 0 & (Be | 0) == 0) {
                                B = C, F = I;
                                break;
                              }
                              wa(Re, Be, Zr) | 0, Li(h, _n, Zr) | 0 && (Ie = Er(C | 0, I | 0, 1, 0) | 0, I = ye() | 0, ue = B, d[ue >> 2] = Re, d[ue + 4 >> 2] = Be, C = Or + (C << 3) | 0, d[C >> 2] = Re, d[C + 4 >> 2] = Be, C = Ie), B = C, F = I;
                            }
                          while (!1);
                          if (Ze = Ze + 1 | 0, Ze >>> 0 >= 7)
                            break;
                          C = B, I = F;
                        }
                        if (We = Er(We | 0, rt | 0, 1, 0) | 0, rt = ye() | 0, et = Er(et | 0, Je | 0, 1, 0) | 0, Je = ye() | 0, I = Wr, C = d[I >> 2] | 0, I = d[I + 4 >> 2] | 0, (Je | 0) < (I | 0) | (Je | 0) == (I | 0) & et >>> 0 < C >>> 0)
                          C = B, I = F;
                        else
                          break;
                      }
                      if ((I | 0) > 0 | (I | 0) == 0 & C >>> 0 > 0) {
                        C = 0, I = 0;
                        do
                          Je = Ut + (C << 3) | 0, d[Je >> 2] = 0, d[Je + 4 >> 2] = 0, C = Er(C | 0, I | 0, 1, 0) | 0, I = ye() | 0, Je = Wr, et = d[Je + 4 >> 2] | 0;
                        while ((I | 0) < (et | 0) | ((I | 0) == (et | 0) ? C >>> 0 < (d[Je >> 2] | 0) >>> 0 : 0));
                      }
                      if (Je = Wr, d[Je >> 2] = B, d[Je + 4 >> 2] = F, (F | 0) > 0 | (F | 0) == 0 & B >>> 0 > 0)
                        Ze = A, We = Ht, rt = Sr, et = Bt, Je = Or, A = $e, Ht = T, Bt = Cr, $e = Ze, T = We, Sr = Gr, Gr = rt, Cr = et, Or = Ut, Ut = Je;
                      else
                        break t;
                    }
                    Ur(Cr), Ur(Gr), Ur(_n), T = 1;
                    break e;
                  } else
                    T = B;
                while (!1);
                Ur(_n), Ur(A), Ur(T), T = 0;
              }
            while (!1);
            return _n = T, Ae = si, _n | 0;
          }
        }
        return Ur(_n), _n = T, Ae = si, _n | 0;
      }
      function Tn(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0;
        var b = 0, T = 0, C = 0, I = 0, B = 0, F = 0, z = 0, W = 0;
        if (W = Ae, Ae = Ae + 176 | 0, F = W, (f | 0) < 1)
          return Po(A, 0, 0), z = 0, Ae = W, z | 0;
        for (B = h, B = D(d[B >> 2] | 0, d[B + 4 >> 2] | 0, 52) | 0, ye() | 0, Po(A, (f | 0) > 6 ? f : 6, B & 15), B = 0; b = h + (B << 3) | 0, b = Za(d[b >> 2] | 0, d[b + 4 >> 2] | 0, F) | 0, !(b | 0); ) {
          if (b = d[F >> 2] | 0, (b | 0) > 0) {
            I = 0;
            do
              C = F + 8 + (I << 4) | 0, I = I + 1 | 0, b = F + 8 + (((I | 0) % (b | 0) | 0) << 4) | 0, T = Ul(A, b, C) | 0, T ? Nl(A, T) | 0 : bf(A, C, b) | 0, b = d[F >> 2] | 0;
            while ((I | 0) < (b | 0));
          }
          if (B = B + 1 | 0, (B | 0) >= (f | 0)) {
            b = 0, z = 13;
            break;
          }
        }
        return (z | 0) == 13 ? (Ae = W, b | 0) : (Ic(A), z = b, Ae = W, z | 0);
      }
      function bi(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0;
        var b = 0, T = 0, C = 0, I = 0;
        if (C = Ae, Ae = Ae + 32 | 0, b = C, T = C + 16 | 0, h = Tn(h, f, T) | 0, h | 0)
          return A = h, Ae = C, A | 0;
        if (d[A >> 2] = 0, d[A + 4 >> 2] = 0, d[A + 8 >> 2] = 0, h = Ka(T) | 0, h | 0)
          do {
            f = kl(A) | 0;
            do
              xo(f, h) | 0, I = h + 16 | 0, d[b >> 2] = d[I >> 2], d[b + 4 >> 2] = d[I + 4 >> 2], d[b + 8 >> 2] = d[I + 8 >> 2], d[b + 12 >> 2] = d[I + 12 >> 2], Nl(T, h) | 0, h = Qa(T, b) | 0;
            while ((h | 0) != 0);
            h = Ka(T) | 0;
          } while ((h | 0) != 0);
        return Ic(T), h = _f(A) | 0, h ? (bs(A), I = h, Ae = C, I | 0) : (I = 0, Ae = C, I | 0);
      }
      function mn(h) {
        return h = h | 0, h >>> 0 > 121 ? (h = 0, h | 0) : (h = d[7696 + (h * 28 | 0) + 16 >> 2] | 0, h | 0);
      }
      function Di(h) {
        return h = h | 0, (h | 0) == 4 | (h | 0) == 117 | 0;
      }
      function qs(h) {
        return h = h | 0, d[11120 + ((d[h >> 2] | 0) * 216 | 0) + ((d[h + 4 >> 2] | 0) * 72 | 0) + ((d[h + 8 >> 2] | 0) * 24 | 0) + (d[h + 12 >> 2] << 3) >> 2] | 0;
      }
      function wh(h) {
        return h = h | 0, d[11120 + ((d[h >> 2] | 0) * 216 | 0) + ((d[h + 4 >> 2] | 0) * 72 | 0) + ((d[h + 8 >> 2] | 0) * 24 | 0) + (d[h + 12 >> 2] << 3) + 4 >> 2] | 0;
      }
      function Th(h, f) {
        h = h | 0, f = f | 0, h = 7696 + (h * 28 | 0) | 0, d[f >> 2] = d[h >> 2], d[f + 4 >> 2] = d[h + 4 >> 2], d[f + 8 >> 2] = d[h + 8 >> 2], d[f + 12 >> 2] = d[h + 12 >> 2];
      }
      function Tl(h, f) {
        h = h | 0, f = f | 0;
        var A = 0, b = 0;
        if (f >>> 0 > 20)
          return f = -1, f | 0;
        do
          if ((d[11120 + (f * 216 | 0) >> 2] | 0) != (h | 0))
            if ((d[11120 + (f * 216 | 0) + 8 >> 2] | 0) != (h | 0))
              if ((d[11120 + (f * 216 | 0) + 16 >> 2] | 0) != (h | 0))
                if ((d[11120 + (f * 216 | 0) + 24 >> 2] | 0) != (h | 0))
                  if ((d[11120 + (f * 216 | 0) + 32 >> 2] | 0) != (h | 0))
                    if ((d[11120 + (f * 216 | 0) + 40 >> 2] | 0) != (h | 0))
                      if ((d[11120 + (f * 216 | 0) + 48 >> 2] | 0) != (h | 0))
                        if ((d[11120 + (f * 216 | 0) + 56 >> 2] | 0) != (h | 0))
                          if ((d[11120 + (f * 216 | 0) + 64 >> 2] | 0) != (h | 0))
                            if ((d[11120 + (f * 216 | 0) + 72 >> 2] | 0) != (h | 0))
                              if ((d[11120 + (f * 216 | 0) + 80 >> 2] | 0) != (h | 0))
                                if ((d[11120 + (f * 216 | 0) + 88 >> 2] | 0) != (h | 0))
                                  if ((d[11120 + (f * 216 | 0) + 96 >> 2] | 0) != (h | 0))
                                    if ((d[11120 + (f * 216 | 0) + 104 >> 2] | 0) != (h | 0))
                                      if ((d[11120 + (f * 216 | 0) + 112 >> 2] | 0) != (h | 0))
                                        if ((d[11120 + (f * 216 | 0) + 120 >> 2] | 0) != (h | 0))
                                          if ((d[11120 + (f * 216 | 0) + 128 >> 2] | 0) != (h | 0))
                                            if ((d[11120 + (f * 216 | 0) + 136 >> 2] | 0) == (h | 0))
                                              h = 2, A = 1, b = 2;
                                            else {
                                              if ((d[11120 + (f * 216 | 0) + 144 >> 2] | 0) == (h | 0)) {
                                                h = 0, A = 2, b = 0;
                                                break;
                                              }
                                              if ((d[11120 + (f * 216 | 0) + 152 >> 2] | 0) == (h | 0)) {
                                                h = 0, A = 2, b = 1;
                                                break;
                                              }
                                              if ((d[11120 + (f * 216 | 0) + 160 >> 2] | 0) == (h | 0)) {
                                                h = 0, A = 2, b = 2;
                                                break;
                                              }
                                              if ((d[11120 + (f * 216 | 0) + 168 >> 2] | 0) == (h | 0)) {
                                                h = 1, A = 2, b = 0;
                                                break;
                                              }
                                              if ((d[11120 + (f * 216 | 0) + 176 >> 2] | 0) == (h | 0)) {
                                                h = 1, A = 2, b = 1;
                                                break;
                                              }
                                              if ((d[11120 + (f * 216 | 0) + 184 >> 2] | 0) == (h | 0)) {
                                                h = 1, A = 2, b = 2;
                                                break;
                                              }
                                              if ((d[11120 + (f * 216 | 0) + 192 >> 2] | 0) == (h | 0)) {
                                                h = 2, A = 2, b = 0;
                                                break;
                                              }
                                              if ((d[11120 + (f * 216 | 0) + 200 >> 2] | 0) == (h | 0)) {
                                                h = 2, A = 2, b = 1;
                                                break;
                                              }
                                              if ((d[11120 + (f * 216 | 0) + 208 >> 2] | 0) == (h | 0)) {
                                                h = 2, A = 2, b = 2;
                                                break;
                                              } else
                                                h = -1;
                                              return h | 0;
                                            }
                                          else
                                            h = 2, A = 1, b = 1;
                                        else
                                          h = 2, A = 1, b = 0;
                                      else
                                        h = 1, A = 1, b = 2;
                                    else
                                      h = 1, A = 1, b = 1;
                                  else
                                    h = 1, A = 1, b = 0;
                                else
                                  h = 0, A = 1, b = 2;
                              else
                                h = 0, A = 1, b = 1;
                            else
                              h = 0, A = 1, b = 0;
                          else
                            h = 2, A = 0, b = 2;
                        else
                          h = 2, A = 0, b = 1;
                      else
                        h = 2, A = 0, b = 0;
                    else
                      h = 1, A = 0, b = 2;
                  else
                    h = 1, A = 0, b = 1;
                else
                  h = 1, A = 0, b = 0;
              else
                h = 0, A = 0, b = 2;
            else
              h = 0, A = 0, b = 1;
          else
            h = 0, A = 0, b = 0;
        while (!1);
        return f = d[11120 + (f * 216 | 0) + (A * 72 | 0) + (h * 24 | 0) + (b << 3) + 4 >> 2] | 0, f | 0;
      }
      function au(h, f) {
        return h = h | 0, f = f | 0, (d[7696 + (h * 28 | 0) + 20 >> 2] | 0) == (f | 0) ? (f = 1, f | 0) : (f = (d[7696 + (h * 28 | 0) + 24 >> 2] | 0) == (f | 0), f | 0);
      }
      function Va(h, f) {
        return h = h | 0, f = f | 0, d[848 + (h * 28 | 0) + (f << 2) >> 2] | 0;
      }
      function lu(h, f) {
        return h = h | 0, f = f | 0, (d[848 + (h * 28 | 0) >> 2] | 0) == (f | 0) ? (f = 0, f | 0) : (d[848 + (h * 28 | 0) + 4 >> 2] | 0) == (f | 0) ? (f = 1, f | 0) : (d[848 + (h * 28 | 0) + 8 >> 2] | 0) == (f | 0) ? (f = 2, f | 0) : (d[848 + (h * 28 | 0) + 12 >> 2] | 0) == (f | 0) ? (f = 3, f | 0) : (d[848 + (h * 28 | 0) + 16 >> 2] | 0) == (f | 0) ? (f = 4, f | 0) : (d[848 + (h * 28 | 0) + 20 >> 2] | 0) == (f | 0) ? (f = 5, f | 0) : ((d[848 + (h * 28 | 0) + 24 >> 2] | 0) == (f | 0) ? 6 : 7) | 0;
      }
      function cu() {
        return 122;
      }
      function oo(h) {
        h = h | 0;
        var f = 0, A = 0, b = 0;
        f = 0;
        do
          k(f | 0, 0, 45) | 0, b = ye() | 0 | 134225919, A = h + (f << 3) | 0, d[A >> 2] = -1, d[A + 4 >> 2] = b, f = f + 1 | 0;
        while ((f | 0) != 122);
        return 0;
      }
      function _a(h) {
        h = h | 0;
        var f = 0, A = 0, b = 0;
        return b = +ee[h + 16 >> 3], A = +ee[h + 24 >> 3], f = b - A, +(b < A ? f + 6.283185307179586 : f);
      }
      function Jo(h) {
        return h = h | 0, +ee[h + 16 >> 3] < +ee[h + 24 >> 3] | 0;
      }
      function ja(h) {
        return h = h | 0, +(+ee[h >> 3] - +ee[h + 8 >> 3]);
      }
      function No(h, f) {
        h = h | 0, f = f | 0;
        var A = 0, b = 0, T = 0;
        return A = +ee[f >> 3], !(A >= +ee[h + 8 >> 3]) || !(A <= +ee[h >> 3]) ? (f = 0, f | 0) : (b = +ee[h + 16 >> 3], A = +ee[h + 24 >> 3], T = +ee[f + 8 >> 3], f = T >= A, h = T <= b & 1, b < A ? f && (h = 1) : f || (h = 0), f = (h | 0) != 0, f | 0);
      }
      function Uo(h, f) {
        h = h | 0, f = f | 0;
        var A = 0, b = 0, T = 0, C = 0, I = 0, B = 0, F = 0, z = 0, W = 0;
        return +ee[h >> 3] < +ee[f + 8 >> 3] || +ee[h + 8 >> 3] > +ee[f >> 3] ? (b = 0, b | 0) : (C = +ee[h + 16 >> 3], A = h + 24 | 0, W = +ee[A >> 3], I = C < W, b = f + 16 | 0, z = +ee[b >> 3], T = f + 24 | 0, F = +ee[T >> 3], B = z < F, f = W - z < F - C, h = I ? B | f ? 1 : 2 : 0, f = B ? I ? 1 : f ? 2 : 1 : 0, C = +qr(C, h), C < +qr(+ee[T >> 3], f) || (W = +qr(+ee[A >> 3], h), W > +qr(+ee[b >> 3], f)) ? (B = 0, B | 0) : (B = 1, B | 0));
      }
      function uu(h, f, A, b) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0;
        var T = 0, C = 0, I = 0, B = 0, F = 0;
        C = +ee[h + 16 >> 3], F = +ee[h + 24 >> 3], h = C < F, B = +ee[f + 16 >> 3], I = +ee[f + 24 >> 3], T = B < I, f = F - B < I - C, d[A >> 2] = h ? T | f ? 1 : 2 : 0, d[b >> 2] = T ? h ? 1 : f ? 2 : 1 : 0;
      }
      function _s(h, f) {
        h = h | 0, f = f | 0;
        var A = 0, b = 0, T = 0, C = 0, I = 0, B = 0, F = 0, z = 0, W = 0;
        return +ee[h >> 3] < +ee[f >> 3] || +ee[h + 8 >> 3] > +ee[f + 8 >> 3] ? (b = 0, b | 0) : (b = h + 16 | 0, F = +ee[b >> 3], C = +ee[h + 24 >> 3], I = F < C, A = f + 16 | 0, W = +ee[A >> 3], T = f + 24 | 0, z = +ee[T >> 3], B = W < z, f = C - W < z - F, h = I ? B | f ? 1 : 2 : 0, f = B ? I ? 1 : f ? 2 : 1 : 0, C = +qr(C, h), C <= +qr(+ee[T >> 3], f) ? (W = +qr(+ee[b >> 3], h), B = W >= +qr(+ee[A >> 3], f), B | 0) : (B = 0, B | 0));
      }
      function gi(h, f) {
        h = h | 0, f = f | 0;
        var A = 0, b = 0, T = 0, C = 0, I = 0, B = 0;
        T = Ae, Ae = Ae + 176 | 0, b = T, d[b >> 2] = 4, B = +ee[f >> 3], ee[b + 8 >> 3] = B, C = +ee[f + 16 >> 3], ee[b + 16 >> 3] = C, ee[b + 24 >> 3] = B, B = +ee[f + 24 >> 3], ee[b + 32 >> 3] = B, I = +ee[f + 8 >> 3], ee[b + 40 >> 3] = I, ee[b + 48 >> 3] = B, ee[b + 56 >> 3] = I, ee[b + 64 >> 3] = C, f = b + 72 | 0, A = f + 96 | 0;
        do
          d[f >> 2] = 0, f = f + 4 | 0;
        while ((f | 0) < (A | 0));
        Se(h | 0, b | 0, 168) | 0, Ae = T;
      }
      function Ha(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0;
        var b = 0, T = 0, C = 0, I = 0, B = 0, F = 0, z = 0, W = 0, ue = 0, Ie = 0, Re = 0, Be = 0, Ze = 0, We = 0;
        Be = Ae, Ae = Ae + 288 | 0, W = Be + 264 | 0, ue = Be + 96 | 0, z = Be, B = z, F = B + 96 | 0;
        do
          d[B >> 2] = 0, B = B + 4 | 0;
        while ((B | 0) < (F | 0));
        return f = yc(f, z) | 0, f | 0 ? (Re = f, Ae = Be, Re | 0) : (F = z, z = d[F >> 2] | 0, F = d[F + 4 >> 2] | 0, wa(z, F, W) | 0, Za(z, F, ue) | 0, I = +ns(W, ue + 8 | 0), ee[W >> 3] = +ee[h >> 3], F = W + 8 | 0, ee[F >> 3] = +ee[h + 16 >> 3], ee[ue >> 3] = +ee[h + 8 >> 3], z = ue + 8 | 0, ee[z >> 3] = +ee[h + 24 >> 3], T = +ns(W, ue), We = +ee[F >> 3] - +ee[z >> 3], C = +kt(+We), Ze = +ee[W >> 3] - +ee[ue >> 3], b = +kt(+Ze), !(We == 0 | Ze == 0) && (We = +J(+C, +b), We = +Yr(+(T * T / +oe(+(We / +oe(+C, +b)), 3) / (I * (I * 2.59807621135) * 0.8))), ee[It >> 3] = We, Ie = ~~We >>> 0, Re = +kt(We) >= 1 ? We > 0 ? ~~+$r(+Mt(We / 4294967296), 4294967295) >>> 0 : ~~+Yr((We - +(~~We >>> 0)) / 4294967296) >>> 0 : 0, (d[It + 4 >> 2] & 2146435072 | 0) != 2146435072) ? (ue = (Ie | 0) == 0 & (Re | 0) == 0, f = A, d[f >> 2] = ue ? 1 : Ie, d[f + 4 >> 2] = ue ? 0 : Re, f = 0) : f = 1, Re = f, Ae = Be, Re | 0);
      }
      function Eh(h, f, A, b) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0;
        var T = 0, C = 0, I = 0, B = 0, F = 0, z = 0, W = 0;
        z = Ae, Ae = Ae + 288 | 0, I = z + 264 | 0, B = z + 96 | 0, F = z, T = F, C = T + 96 | 0;
        do
          d[T >> 2] = 0, T = T + 4 | 0;
        while ((T | 0) < (C | 0));
        return A = yc(A, F) | 0, A | 0 ? (b = A, Ae = z, b | 0) : (A = F, T = d[A >> 2] | 0, A = d[A + 4 >> 2] | 0, wa(T, A, I) | 0, Za(T, A, B) | 0, W = +ns(I, B + 8 | 0), W = +Yr(+(+ns(h, f) / (W * 2))), ee[It >> 3] = W, A = ~~W >>> 0, T = +kt(W) >= 1 ? W > 0 ? ~~+$r(+Mt(W / 4294967296), 4294967295) >>> 0 : ~~+Yr((W - +(~~W >>> 0)) / 4294967296) >>> 0 : 0, (d[It + 4 >> 2] & 2146435072 | 0) == 2146435072 ? (b = 1, Ae = z, b | 0) : (F = (A | 0) == 0 & (T | 0) == 0, d[b >> 2] = F ? 1 : A, d[b + 4 >> 2] = F ? 0 : T, b = 0, Ae = z, b | 0));
      }
      function Hp(h, f) {
        h = h | 0, f = +f;
        var A = 0, b = 0, T = 0, C = 0, I = 0, B = 0, F = 0, z = 0, W = 0;
        C = h + 16 | 0, I = +ee[C >> 3], A = h + 24 | 0, T = +ee[A >> 3], b = I - T, b = I < T ? b + 6.283185307179586 : b, z = +ee[h >> 3], B = h + 8 | 0, F = +ee[B >> 3], W = z - F, b = (b * f - b) * 0.5, f = (W * f - W) * 0.5, z = z + f, ee[h >> 3] = z > 1.5707963267948966 ? 1.5707963267948966 : z, f = F - f, ee[B >> 3] = f < -1.5707963267948966 ? -1.5707963267948966 : f, f = I + b, f = f > 3.141592653589793 ? f + -6.283185307179586 : f, ee[C >> 3] = f < -3.141592653589793 ? f + 6.283185307179586 : f, f = T - b, f = f > 3.141592653589793 ? f + -6.283185307179586 : f, ee[A >> 3] = f < -3.141592653589793 ? f + 6.283185307179586 : f;
      }
      function Gp(h, f, A, b) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0, d[h >> 2] = f, d[h + 4 >> 2] = A, d[h + 8 >> 2] = b;
      }
      function cf(h, f) {
        h = h | 0, f = f | 0;
        var A = 0, b = 0, T = 0, C = 0, I = 0, B = 0, F = 0, z = 0, W = 0, ue = 0, Ie = 0;
        ue = f + 8 | 0, d[ue >> 2] = 0, F = +ee[h >> 3], I = +kt(+F), z = +ee[h + 8 >> 3], B = +kt(+z) * 1.1547005383792515, I = I + B * 0.5, A = ~~I, h = ~~B, I = I - +(A | 0), B = B - +(h | 0);
        do
          if (I < 0.5)
            if (I < 0.3333333333333333)
              if (d[f >> 2] = A, B < (I + 1) * 0.5) {
                d[f + 4 >> 2] = h;
                break;
              } else {
                h = h + 1 | 0, d[f + 4 >> 2] = h;
                break;
              }
            else if (Ie = 1 - I, h = (!(B < Ie) & 1) + h | 0, d[f + 4 >> 2] = h, Ie <= B & B < I * 2) {
              A = A + 1 | 0, d[f >> 2] = A;
              break;
            } else {
              d[f >> 2] = A;
              break;
            }
          else {
            if (!(I < 0.6666666666666666))
              if (A = A + 1 | 0, d[f >> 2] = A, B < I * 0.5) {
                d[f + 4 >> 2] = h;
                break;
              } else {
                h = h + 1 | 0, d[f + 4 >> 2] = h;
                break;
              }
            if (B < 1 - I) {
              if (d[f + 4 >> 2] = h, I * 2 + -1 < B) {
                d[f >> 2] = A;
                break;
              }
            } else
              h = h + 1 | 0, d[f + 4 >> 2] = h;
            A = A + 1 | 0, d[f >> 2] = A;
          }
        while (!1);
        do
          if (F < 0)
            if (h & 1) {
              W = (h + 1 | 0) / 2 | 0, W = Vi(A | 0, ((A | 0) < 0) << 31 >> 31 | 0, W | 0, ((W | 0) < 0) << 31 >> 31 | 0) | 0, A = ~~(+(A | 0) - ((+(W >>> 0) + 4294967296 * +(ye() | 0)) * 2 + 1)), d[f >> 2] = A;
              break;
            } else {
              W = (h | 0) / 2 | 0, W = Vi(A | 0, ((A | 0) < 0) << 31 >> 31 | 0, W | 0, ((W | 0) < 0) << 31 >> 31 | 0) | 0, A = ~~(+(A | 0) - (+(W >>> 0) + 4294967296 * +(ye() | 0)) * 2), d[f >> 2] = A;
              break;
            }
        while (!1);
        W = f + 4 | 0, z < 0 && (A = A - ((h << 1 | 1 | 0) / 2 | 0) | 0, d[f >> 2] = A, h = 0 - h | 0, d[W >> 2] = h), b = h - A | 0, (A | 0) < 0 ? (T = 0 - A | 0, d[W >> 2] = b, d[ue >> 2] = T, d[f >> 2] = 0, h = b, A = 0) : T = 0, (h | 0) < 0 && (A = A - h | 0, d[f >> 2] = A, T = T - h | 0, d[ue >> 2] = T, d[W >> 2] = 0, h = 0), C = A - T | 0, b = h - T | 0, (T | 0) < 0 && (d[f >> 2] = C, d[W >> 2] = b, d[ue >> 2] = 0, h = b, A = C, T = 0), b = (h | 0) < (A | 0) ? h : A, b = (T | 0) < (b | 0) ? T : b, !((b | 0) <= 0) && (d[f >> 2] = A - b, d[W >> 2] = h - b, d[ue >> 2] = T - b);
      }
      function qi(h) {
        h = h | 0;
        var f = 0, A = 0, b = 0, T = 0, C = 0, I = 0;
        f = d[h >> 2] | 0, I = h + 4 | 0, A = d[I >> 2] | 0, (f | 0) < 0 && (A = A - f | 0, d[I >> 2] = A, C = h + 8 | 0, d[C >> 2] = (d[C >> 2] | 0) - f, d[h >> 2] = 0, f = 0), (A | 0) < 0 ? (f = f - A | 0, d[h >> 2] = f, C = h + 8 | 0, T = (d[C >> 2] | 0) - A | 0, d[C >> 2] = T, d[I >> 2] = 0, A = 0) : (T = h + 8 | 0, C = T, T = d[T >> 2] | 0), (T | 0) < 0 && (f = f - T | 0, d[h >> 2] = f, A = A - T | 0, d[I >> 2] = A, d[C >> 2] = 0, T = 0), b = (A | 0) < (f | 0) ? A : f, b = (T | 0) < (b | 0) ? T : b, !((b | 0) <= 0) && (d[h >> 2] = f - b, d[I >> 2] = A - b, d[C >> 2] = T - b);
      }
      function ea(h, f) {
        h = h | 0, f = f | 0;
        var A = 0, b = 0;
        b = d[h + 8 >> 2] | 0, A = +((d[h + 4 >> 2] | 0) - b | 0), ee[f >> 3] = +((d[h >> 2] | 0) - b | 0) - A * 0.5, ee[f + 8 >> 3] = A * 0.8660254037844386;
      }
      function rs(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0, d[A >> 2] = (d[f >> 2] | 0) + (d[h >> 2] | 0), d[A + 4 >> 2] = (d[f + 4 >> 2] | 0) + (d[h + 4 >> 2] | 0), d[A + 8 >> 2] = (d[f + 8 >> 2] | 0) + (d[h + 8 >> 2] | 0);
      }
      function fu(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0, d[A >> 2] = (d[h >> 2] | 0) - (d[f >> 2] | 0), d[A + 4 >> 2] = (d[h + 4 >> 2] | 0) - (d[f + 4 >> 2] | 0), d[A + 8 >> 2] = (d[h + 8 >> 2] | 0) - (d[f + 8 >> 2] | 0);
      }
      function uf(h, f) {
        h = h | 0, f = f | 0;
        var A = 0, b = 0;
        A = Qr(d[h >> 2] | 0, f) | 0, d[h >> 2] = A, A = h + 4 | 0, b = Qr(d[A >> 2] | 0, f) | 0, d[A >> 2] = b, h = h + 8 | 0, f = Qr(d[h >> 2] | 0, f) | 0, d[h >> 2] = f;
      }
      function hu(h) {
        h = h | 0;
        var f = 0, A = 0, b = 0, T = 0, C = 0, I = 0, B = 0;
        I = d[h >> 2] | 0, B = (I | 0) < 0, b = (d[h + 4 >> 2] | 0) - (B ? I : 0) | 0, C = (b | 0) < 0, T = (C ? 0 - b | 0 : 0) + ((d[h + 8 >> 2] | 0) - (B ? I : 0)) | 0, A = (T | 0) < 0, h = A ? 0 : T, f = (C ? 0 : b) - (A ? T : 0) | 0, T = (B ? 0 : I) - (C ? b : 0) - (A ? T : 0) | 0, A = (f | 0) < (T | 0) ? f : T, A = (h | 0) < (A | 0) ? h : A, b = (A | 0) > 0, h = h - (b ? A : 0) | 0, f = f - (b ? A : 0) | 0;
        e: do
          switch (T - (b ? A : 0) | 0) {
            case 0:
              switch (f | 0) {
                case 0:
                  return B = (h | 0) == 0 ? 0 : (h | 0) == 1 ? 1 : 7, B | 0;
                case 1:
                  return B = (h | 0) == 0 ? 2 : (h | 0) == 1 ? 3 : 7, B | 0;
                default:
                  break e;
              }
            case 1:
              switch (f | 0) {
                case 0:
                  return B = (h | 0) == 0 ? 4 : (h | 0) == 1 ? 5 : 7, B | 0;
                case 1: {
                  if (!h)
                    h = 6;
                  else
                    break e;
                  return h | 0;
                }
                default:
                  break e;
              }
          }
        while (!1);
        return B = 7, B | 0;
      }
      function Ac(h) {
        h = h | 0;
        var f = 0, A = 0, b = 0, T = 0, C = 0, I = 0, B = 0, F = 0, z = 0;
        if (F = h + 8 | 0, I = d[F >> 2] | 0, B = (d[h >> 2] | 0) - I | 0, z = h + 4 | 0, I = (d[z >> 2] | 0) - I | 0, B >>> 0 > 715827881 | I >>> 0 > 715827881) {
          if (b = (B | 0) > 0, T = 2147483647 - B | 0, C = -2147483648 - B | 0, (b ? (T | 0) < (B | 0) : (C | 0) > (B | 0)) || (A = B << 1, b ? (2147483647 - A | 0) < (B | 0) : (-2147483648 - A | 0) > (B | 0)) || ((I | 0) > 0 ? (2147483647 - I | 0) < (I | 0) : (-2147483648 - I | 0) > (I | 0)) || (f = B * 3 | 0, A = I << 1, (b ? (T | 0) < (A | 0) : (C | 0) > (A | 0)) || ((B | 0) > -1 ? (f | -2147483648 | 0) >= (I | 0) : (f ^ -2147483648 | 0) < (I | 0))))
            return z = 1, z | 0;
        } else
          A = I << 1, f = B * 3 | 0;
        return b = xs(+(f - I | 0) * 0.14285714285714285) | 0, d[h >> 2] = b, T = xs(+(A + B | 0) * 0.14285714285714285) | 0, d[z >> 2] = T, d[F >> 2] = 0, A = (T | 0) < (b | 0), f = A ? b : T, A = A ? T : b, (A | 0) < 0 && (((A | 0) == -2147483648 || ((f | 0) > 0 ? (2147483647 - f | 0) < (A | 0) : (-2147483648 - f | 0) > (A | 0))) && er(27795, 26892, 354, 26903), ((f | 0) > -1 ? (f | -2147483648 | 0) >= (A | 0) : (f ^ -2147483648 | 0) < (A | 0)) && er(27795, 26892, 354, 26903)), f = T - b | 0, (b | 0) < 0 ? (A = 0 - b | 0, d[z >> 2] = f, d[F >> 2] = A, d[h >> 2] = 0, b = 0) : (f = T, A = 0), (f | 0) < 0 && (b = b - f | 0, d[h >> 2] = b, A = A - f | 0, d[F >> 2] = A, d[z >> 2] = 0, f = 0), C = b - A | 0, T = f - A | 0, (A | 0) < 0 ? (d[h >> 2] = C, d[z >> 2] = T, d[F >> 2] = 0, f = T, T = C, A = 0) : T = b, b = (f | 0) < (T | 0) ? f : T, b = (A | 0) < (b | 0) ? A : b, (b | 0) <= 0 ? (z = 0, z | 0) : (d[h >> 2] = T - b, d[z >> 2] = f - b, d[F >> 2] = A - b, z = 0, z | 0);
      }
      function gc(h) {
        h = h | 0;
        var f = 0, A = 0, b = 0, T = 0, C = 0, I = 0, B = 0, F = 0;
        if (I = h + 8 | 0, T = d[I >> 2] | 0, C = (d[h >> 2] | 0) - T | 0, B = h + 4 | 0, T = (d[B >> 2] | 0) - T | 0, C >>> 0 > 715827881 | T >>> 0 > 715827881) {
          if (A = (C | 0) > 0, (A ? (2147483647 - C | 0) < (C | 0) : (-2147483648 - C | 0) > (C | 0)) || (f = C << 1, b = (T | 0) > 0, b ? (2147483647 - T | 0) < (T | 0) : (-2147483648 - T | 0) > (T | 0)))
            return B = 1, B | 0;
          if (F = T << 1, (b ? (2147483647 - F | 0) < (T | 0) : (-2147483648 - F | 0) > (T | 0)) || (A ? (2147483647 - f | 0) < (T | 0) : (-2147483648 - f | 0) > (T | 0)) || (A = T * 3 | 0, (T | 0) > -1 ? (A | -2147483648 | 0) >= (C | 0) : (A ^ -2147483648 | 0) < (C | 0)))
            return F = 1, F | 0;
        } else
          A = T * 3 | 0, f = C << 1;
        return b = xs(+(f + T | 0) * 0.14285714285714285) | 0, d[h >> 2] = b, T = xs(+(A - C | 0) * 0.14285714285714285) | 0, d[B >> 2] = T, d[I >> 2] = 0, A = (T | 0) < (b | 0), f = A ? b : T, A = A ? T : b, (A | 0) < 0 && (((A | 0) == -2147483648 || ((f | 0) > 0 ? (2147483647 - f | 0) < (A | 0) : (-2147483648 - f | 0) > (A | 0))) && er(27795, 26892, 402, 26917), ((f | 0) > -1 ? (f | -2147483648 | 0) >= (A | 0) : (f ^ -2147483648 | 0) < (A | 0)) && er(27795, 26892, 402, 26917)), f = T - b | 0, (b | 0) < 0 ? (A = 0 - b | 0, d[B >> 2] = f, d[I >> 2] = A, d[h >> 2] = 0, b = 0) : (f = T, A = 0), (f | 0) < 0 && (b = b - f | 0, d[h >> 2] = b, A = A - f | 0, d[I >> 2] = A, d[B >> 2] = 0, f = 0), C = b - A | 0, T = f - A | 0, (A | 0) < 0 ? (d[h >> 2] = C, d[B >> 2] = T, d[I >> 2] = 0, f = T, T = C, A = 0) : T = b, b = (f | 0) < (T | 0) ? f : T, b = (A | 0) < (b | 0) ? A : b, (b | 0) <= 0 ? (F = 0, F | 0) : (d[h >> 2] = T - b, d[B >> 2] = f - b, d[I >> 2] = A - b, F = 0, F | 0);
      }
      function Ch(h) {
        h = h | 0;
        var f = 0, A = 0, b = 0, T = 0, C = 0, I = 0, B = 0;
        I = h + 8 | 0, A = d[I >> 2] | 0, f = (d[h >> 2] | 0) - A | 0, B = h + 4 | 0, A = (d[B >> 2] | 0) - A | 0, b = xs(+((f * 3 | 0) - A | 0) * 0.14285714285714285) | 0, d[h >> 2] = b, f = xs(+((A << 1) + f | 0) * 0.14285714285714285) | 0, d[B >> 2] = f, d[I >> 2] = 0, A = f - b | 0, (b | 0) < 0 ? (C = 0 - b | 0, d[B >> 2] = A, d[I >> 2] = C, d[h >> 2] = 0, f = A, b = 0, A = C) : A = 0, (f | 0) < 0 && (b = b - f | 0, d[h >> 2] = b, A = A - f | 0, d[I >> 2] = A, d[B >> 2] = 0, f = 0), C = b - A | 0, T = f - A | 0, (A | 0) < 0 ? (d[h >> 2] = C, d[B >> 2] = T, d[I >> 2] = 0, f = T, T = C, A = 0) : T = b, b = (f | 0) < (T | 0) ? f : T, b = (A | 0) < (b | 0) ? A : b, !((b | 0) <= 0) && (d[h >> 2] = T - b, d[B >> 2] = f - b, d[I >> 2] = A - b);
      }
      function Ui(h) {
        h = h | 0;
        var f = 0, A = 0, b = 0, T = 0, C = 0, I = 0, B = 0;
        I = h + 8 | 0, A = d[I >> 2] | 0, f = (d[h >> 2] | 0) - A | 0, B = h + 4 | 0, A = (d[B >> 2] | 0) - A | 0, b = xs(+((f << 1) + A | 0) * 0.14285714285714285) | 0, d[h >> 2] = b, f = xs(+((A * 3 | 0) - f | 0) * 0.14285714285714285) | 0, d[B >> 2] = f, d[I >> 2] = 0, A = f - b | 0, (b | 0) < 0 ? (C = 0 - b | 0, d[B >> 2] = A, d[I >> 2] = C, d[h >> 2] = 0, f = A, b = 0, A = C) : A = 0, (f | 0) < 0 && (b = b - f | 0, d[h >> 2] = b, A = A - f | 0, d[I >> 2] = A, d[B >> 2] = 0, f = 0), C = b - A | 0, T = f - A | 0, (A | 0) < 0 ? (d[h >> 2] = C, d[B >> 2] = T, d[I >> 2] = 0, f = T, T = C, A = 0) : T = b, b = (f | 0) < (T | 0) ? f : T, b = (A | 0) < (b | 0) ? A : b, !((b | 0) <= 0) && (d[h >> 2] = T - b, d[B >> 2] = f - b, d[I >> 2] = A - b);
      }
      function El(h) {
        h = h | 0;
        var f = 0, A = 0, b = 0, T = 0, C = 0, I = 0, B = 0;
        f = d[h >> 2] | 0, I = h + 4 | 0, A = d[I >> 2] | 0, B = h + 8 | 0, b = d[B >> 2] | 0, T = A + (f * 3 | 0) | 0, d[h >> 2] = T, A = b + (A * 3 | 0) | 0, d[I >> 2] = A, f = (b * 3 | 0) + f | 0, d[B >> 2] = f, b = A - T | 0, (T | 0) < 0 ? (f = f - T | 0, d[I >> 2] = b, d[B >> 2] = f, d[h >> 2] = 0, A = b, b = 0) : b = T, (A | 0) < 0 && (b = b - A | 0, d[h >> 2] = b, f = f - A | 0, d[B >> 2] = f, d[I >> 2] = 0, A = 0), C = b - f | 0, T = A - f | 0, (f | 0) < 0 ? (d[h >> 2] = C, d[I >> 2] = T, d[B >> 2] = 0, b = C, f = 0) : T = A, A = (T | 0) < (b | 0) ? T : b, A = (f | 0) < (A | 0) ? f : A, !((A | 0) <= 0) && (d[h >> 2] = b - A, d[I >> 2] = T - A, d[B >> 2] = f - A);
      }
      function Rs(h) {
        h = h | 0;
        var f = 0, A = 0, b = 0, T = 0, C = 0, I = 0, B = 0;
        T = d[h >> 2] | 0, I = h + 4 | 0, f = d[I >> 2] | 0, B = h + 8 | 0, A = d[B >> 2] | 0, b = (f * 3 | 0) + T | 0, T = A + (T * 3 | 0) | 0, d[h >> 2] = T, d[I >> 2] = b, f = (A * 3 | 0) + f | 0, d[B >> 2] = f, A = b - T | 0, (T | 0) < 0 ? (f = f - T | 0, d[I >> 2] = A, d[B >> 2] = f, d[h >> 2] = 0, T = 0) : A = b, (A | 0) < 0 && (T = T - A | 0, d[h >> 2] = T, f = f - A | 0, d[B >> 2] = f, d[I >> 2] = 0, A = 0), C = T - f | 0, b = A - f | 0, (f | 0) < 0 ? (d[h >> 2] = C, d[I >> 2] = b, d[B >> 2] = 0, T = C, f = 0) : b = A, A = (b | 0) < (T | 0) ? b : T, A = (f | 0) < (A | 0) ? f : A, !((A | 0) <= 0) && (d[h >> 2] = T - A, d[I >> 2] = b - A, d[B >> 2] = f - A);
      }
      function ta(h, f) {
        h = h | 0, f = f | 0;
        var A = 0, b = 0, T = 0, C = 0, I = 0, B = 0;
        (f + -1 | 0) >>> 0 >= 6 || (T = (d[15440 + (f * 12 | 0) >> 2] | 0) + (d[h >> 2] | 0) | 0, d[h >> 2] = T, B = h + 4 | 0, b = (d[15440 + (f * 12 | 0) + 4 >> 2] | 0) + (d[B >> 2] | 0) | 0, d[B >> 2] = b, I = h + 8 | 0, f = (d[15440 + (f * 12 | 0) + 8 >> 2] | 0) + (d[I >> 2] | 0) | 0, d[I >> 2] = f, A = b - T | 0, (T | 0) < 0 ? (f = f - T | 0, d[B >> 2] = A, d[I >> 2] = f, d[h >> 2] = 0, b = 0) : (A = b, b = T), (A | 0) < 0 && (b = b - A | 0, d[h >> 2] = b, f = f - A | 0, d[I >> 2] = f, d[B >> 2] = 0, A = 0), C = b - f | 0, T = A - f | 0, (f | 0) < 0 ? (d[h >> 2] = C, d[B >> 2] = T, d[I >> 2] = 0, b = C, f = 0) : T = A, A = (T | 0) < (b | 0) ? T : b, A = (f | 0) < (A | 0) ? f : A, !((A | 0) <= 0) && (d[h >> 2] = b - A, d[B >> 2] = T - A, d[I >> 2] = f - A));
      }
      function ya(h) {
        h = h | 0;
        var f = 0, A = 0, b = 0, T = 0, C = 0, I = 0, B = 0;
        T = d[h >> 2] | 0, I = h + 4 | 0, f = d[I >> 2] | 0, B = h + 8 | 0, A = d[B >> 2] | 0, b = f + T | 0, T = A + T | 0, d[h >> 2] = T, d[I >> 2] = b, f = A + f | 0, d[B >> 2] = f, A = b - T | 0, (T | 0) < 0 ? (f = f - T | 0, d[I >> 2] = A, d[B >> 2] = f, d[h >> 2] = 0, b = 0) : (A = b, b = T), (A | 0) < 0 && (b = b - A | 0, d[h >> 2] = b, f = f - A | 0, d[B >> 2] = f, d[I >> 2] = 0, A = 0), C = b - f | 0, T = A - f | 0, (f | 0) < 0 ? (d[h >> 2] = C, d[I >> 2] = T, d[B >> 2] = 0, b = C, f = 0) : T = A, A = (T | 0) < (b | 0) ? T : b, A = (f | 0) < (A | 0) ? f : A, !((A | 0) <= 0) && (d[h >> 2] = b - A, d[I >> 2] = T - A, d[B >> 2] = f - A);
      }
      function zo(h) {
        h = h | 0;
        var f = 0, A = 0, b = 0, T = 0, C = 0, I = 0, B = 0;
        f = d[h >> 2] | 0, I = h + 4 | 0, b = d[I >> 2] | 0, B = h + 8 | 0, A = d[B >> 2] | 0, T = b + f | 0, d[h >> 2] = T, b = A + b | 0, d[I >> 2] = b, f = A + f | 0, d[B >> 2] = f, A = b - T | 0, (T | 0) < 0 ? (f = f - T | 0, d[I >> 2] = A, d[B >> 2] = f, d[h >> 2] = 0, b = 0) : (A = b, b = T), (A | 0) < 0 && (b = b - A | 0, d[h >> 2] = b, f = f - A | 0, d[B >> 2] = f, d[I >> 2] = 0, A = 0), C = b - f | 0, T = A - f | 0, (f | 0) < 0 ? (d[h >> 2] = C, d[I >> 2] = T, d[B >> 2] = 0, b = C, f = 0) : T = A, A = (T | 0) < (b | 0) ? T : b, A = (f | 0) < (A | 0) ? f : A, !((A | 0) <= 0) && (d[h >> 2] = b - A, d[I >> 2] = T - A, d[B >> 2] = f - A);
      }
      function Bs(h) {
        switch (h = h | 0, h | 0) {
          case 1: {
            h = 5;
            break;
          }
          case 5: {
            h = 4;
            break;
          }
          case 4: {
            h = 6;
            break;
          }
          case 6: {
            h = 2;
            break;
          }
          case 2: {
            h = 3;
            break;
          }
          case 3: {
            h = 1;
            break;
          }
        }
        return h | 0;
      }
      function Os(h) {
        switch (h = h | 0, h | 0) {
          case 1: {
            h = 3;
            break;
          }
          case 3: {
            h = 2;
            break;
          }
          case 2: {
            h = 6;
            break;
          }
          case 6: {
            h = 4;
            break;
          }
          case 4: {
            h = 5;
            break;
          }
          case 5: {
            h = 1;
            break;
          }
        }
        return h | 0;
      }
      function va(h) {
        h = h | 0;
        var f = 0, A = 0, b = 0, T = 0, C = 0, I = 0, B = 0;
        f = d[h >> 2] | 0, I = h + 4 | 0, A = d[I >> 2] | 0, B = h + 8 | 0, b = d[B >> 2] | 0, T = A + (f << 1) | 0, d[h >> 2] = T, A = b + (A << 1) | 0, d[I >> 2] = A, f = (b << 1) + f | 0, d[B >> 2] = f, b = A - T | 0, (T | 0) < 0 ? (f = f - T | 0, d[I >> 2] = b, d[B >> 2] = f, d[h >> 2] = 0, A = b, b = 0) : b = T, (A | 0) < 0 && (b = b - A | 0, d[h >> 2] = b, f = f - A | 0, d[B >> 2] = f, d[I >> 2] = 0, A = 0), C = b - f | 0, T = A - f | 0, (f | 0) < 0 ? (d[h >> 2] = C, d[I >> 2] = T, d[B >> 2] = 0, b = C, f = 0) : T = A, A = (T | 0) < (b | 0) ? T : b, A = (f | 0) < (A | 0) ? f : A, !((A | 0) <= 0) && (d[h >> 2] = b - A, d[I >> 2] = T - A, d[B >> 2] = f - A);
      }
      function ra(h) {
        h = h | 0;
        var f = 0, A = 0, b = 0, T = 0, C = 0, I = 0, B = 0;
        T = d[h >> 2] | 0, I = h + 4 | 0, f = d[I >> 2] | 0, B = h + 8 | 0, A = d[B >> 2] | 0, b = (f << 1) + T | 0, T = A + (T << 1) | 0, d[h >> 2] = T, d[I >> 2] = b, f = (A << 1) + f | 0, d[B >> 2] = f, A = b - T | 0, (T | 0) < 0 ? (f = f - T | 0, d[I >> 2] = A, d[B >> 2] = f, d[h >> 2] = 0, T = 0) : A = b, (A | 0) < 0 && (T = T - A | 0, d[h >> 2] = T, f = f - A | 0, d[B >> 2] = f, d[I >> 2] = 0, A = 0), C = T - f | 0, b = A - f | 0, (f | 0) < 0 ? (d[h >> 2] = C, d[I >> 2] = b, d[B >> 2] = 0, T = C, f = 0) : b = A, A = (b | 0) < (T | 0) ? b : T, A = (f | 0) < (A | 0) ? f : A, !((A | 0) <= 0) && (d[h >> 2] = T - A, d[I >> 2] = b - A, d[B >> 2] = f - A);
      }
      function du(h, f) {
        h = h | 0, f = f | 0;
        var A = 0, b = 0, T = 0, C = 0, I = 0, B = 0;
        return I = (d[h >> 2] | 0) - (d[f >> 2] | 0) | 0, B = (I | 0) < 0, b = (d[h + 4 >> 2] | 0) - (d[f + 4 >> 2] | 0) - (B ? I : 0) | 0, C = (b | 0) < 0, T = (B ? 0 - I | 0 : 0) + (d[h + 8 >> 2] | 0) - (d[f + 8 >> 2] | 0) + (C ? 0 - b | 0 : 0) | 0, h = (T | 0) < 0, f = h ? 0 : T, A = (C ? 0 : b) - (h ? T : 0) | 0, T = (B ? 0 : I) - (C ? b : 0) - (h ? T : 0) | 0, h = (A | 0) < (T | 0) ? A : T, h = (f | 0) < (h | 0) ? f : h, b = (h | 0) > 0, f = f - (b ? h : 0) | 0, A = A - (b ? h : 0) | 0, h = T - (b ? h : 0) | 0, h = (h | 0) > -1 ? h : 0 - h | 0, A = (A | 0) > -1 ? A : 0 - A | 0, f = (f | 0) > -1 ? f : 0 - f | 0, f = (A | 0) > (f | 0) ? A : f, ((h | 0) > (f | 0) ? h : f) | 0;
      }
      function Sh(h, f) {
        h = h | 0, f = f | 0;
        var A = 0;
        A = d[h + 8 >> 2] | 0, d[f >> 2] = (d[h >> 2] | 0) - A, d[f + 4 >> 2] = (d[h + 4 >> 2] | 0) - A;
      }
      function Dn(h, f) {
        h = h | 0, f = f | 0;
        var A = 0, b = 0, T = 0, C = 0, I = 0, B = 0;
        return b = d[h >> 2] | 0, d[f >> 2] = b, T = d[h + 4 >> 2] | 0, I = f + 4 | 0, d[I >> 2] = T, B = f + 8 | 0, d[B >> 2] = 0, A = (T | 0) < (b | 0), h = A ? b : T, A = A ? T : b, (A | 0) < 0 && ((A | 0) == -2147483648 || ((h | 0) > 0 ? (2147483647 - h | 0) < (A | 0) : (-2147483648 - h | 0) > (A | 0)) || ((h | 0) > -1 ? (h | -2147483648 | 0) >= (A | 0) : (h ^ -2147483648 | 0) < (A | 0))) ? (f = 1, f | 0) : (h = T - b | 0, (b | 0) < 0 ? (A = 0 - b | 0, d[I >> 2] = h, d[B >> 2] = A, d[f >> 2] = 0, b = 0) : (h = T, A = 0), (h | 0) < 0 && (b = b - h | 0, d[f >> 2] = b, A = A - h | 0, d[B >> 2] = A, d[I >> 2] = 0, h = 0), C = b - A | 0, T = h - A | 0, (A | 0) < 0 ? (d[f >> 2] = C, d[I >> 2] = T, d[B >> 2] = 0, h = T, T = C, A = 0) : T = b, b = (h | 0) < (T | 0) ? h : T, b = (A | 0) < (b | 0) ? A : b, (b | 0) <= 0 ? (f = 0, f | 0) : (d[f >> 2] = T - b, d[I >> 2] = h - b, d[B >> 2] = A - b, f = 0, f | 0));
      }
      function Ih(h) {
        h = h | 0;
        var f = 0, A = 0, b = 0, T = 0;
        f = h + 8 | 0, T = d[f >> 2] | 0, A = T - (d[h >> 2] | 0) | 0, d[h >> 2] = A, b = h + 4 | 0, h = (d[b >> 2] | 0) - T | 0, d[b >> 2] = h, d[f >> 2] = 0 - (h + A);
      }
      function pu(h) {
        h = h | 0;
        var f = 0, A = 0, b = 0, T = 0, C = 0, I = 0, B = 0;
        A = d[h >> 2] | 0, f = 0 - A | 0, d[h >> 2] = f, I = h + 8 | 0, d[I >> 2] = 0, B = h + 4 | 0, b = d[B >> 2] | 0, T = b + A | 0, (A | 0) > 0 ? (d[B >> 2] = T, d[I >> 2] = A, d[h >> 2] = 0, f = 0, b = T) : A = 0, (b | 0) < 0 ? (C = f - b | 0, d[h >> 2] = C, A = A - b | 0, d[I >> 2] = A, d[B >> 2] = 0, T = C - A | 0, f = 0 - A | 0, (A | 0) < 0 ? (d[h >> 2] = T, d[B >> 2] = f, d[I >> 2] = 0, b = f, A = 0) : (b = 0, T = C)) : T = f, f = (b | 0) < (T | 0) ? b : T, f = (A | 0) < (f | 0) ? A : f, !((f | 0) <= 0) && (d[h >> 2] = T - f, d[B >> 2] = b - f, d[I >> 2] = A - f);
      }
      function Ph(h, f, A, b, T) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0, T = T | 0;
        var C = 0, I = 0, B = 0, F = 0, z = 0, W = 0, ue = 0;
        if (ue = Ae, Ae = Ae + 64 | 0, W = ue, B = ue + 56 | 0, !(!0 & (f & 2013265920 | 0) == 134217728 & (!0 & (b & 2013265920 | 0) == 134217728)))
          return T = 5, Ae = ue, T | 0;
        if ((h | 0) == (A | 0) & (f | 0) == (b | 0))
          return d[T >> 2] = 0, T = 0, Ae = ue, T | 0;
        if (I = D(h | 0, f | 0, 52) | 0, ye() | 0, I = I & 15, z = D(A | 0, b | 0, 52) | 0, ye() | 0, (I | 0) != (z & 15 | 0))
          return T = 12, Ae = ue, T | 0;
        if (C = I + -1 | 0, I >>> 0 > 1) {
          Pl(h, f, C, W) | 0, Pl(A, b, C, B) | 0, z = W, F = d[z >> 2] | 0, z = d[z + 4 >> 2] | 0;
          e: do
            if ((F | 0) == (d[B >> 2] | 0) && (z | 0) == (d[B + 4 >> 2] | 0)) {
              I = (I ^ 15) * 3 | 0, C = D(h | 0, f | 0, I | 0) | 0, ye() | 0, C = C & 7, I = D(A | 0, b | 0, I | 0) | 0, ye() | 0, I = I & 7;
              do
                if ((C | 0) == 0 | (I | 0) == 0)
                  d[T >> 2] = 1, C = 0;
                else if ((C | 0) == 7)
                  C = 5;
                else {
                  if ((C | 0) == 1 | (I | 0) == 1 && Bn(F, z) | 0) {
                    C = 5;
                    break;
                  }
                  if ((d[15536 + (C << 2) >> 2] | 0) != (I | 0) && (d[15568 + (C << 2) >> 2] | 0) != (I | 0))
                    break e;
                  d[T >> 2] = 1, C = 0;
                }
              while (!1);
              return T = C, Ae = ue, T | 0;
            }
          while (!1);
        }
        C = W, I = C + 56 | 0;
        do
          d[C >> 2] = 0, C = C + 4 | 0;
        while ((C | 0) < (I | 0));
        return Fn(h, f, 1, W) | 0, f = W, !((d[f >> 2] | 0) == (A | 0) && (d[f + 4 >> 2] | 0) == (b | 0)) && (f = W + 8 | 0, !((d[f >> 2] | 0) == (A | 0) && (d[f + 4 >> 2] | 0) == (b | 0))) && (f = W + 16 | 0, !((d[f >> 2] | 0) == (A | 0) && (d[f + 4 >> 2] | 0) == (b | 0))) && (f = W + 24 | 0, !((d[f >> 2] | 0) == (A | 0) && (d[f + 4 >> 2] | 0) == (b | 0))) && (f = W + 32 | 0, !((d[f >> 2] | 0) == (A | 0) && (d[f + 4 >> 2] | 0) == (b | 0))) && (f = W + 40 | 0, !((d[f >> 2] | 0) == (A | 0) && (d[f + 4 >> 2] | 0) == (b | 0))) ? (C = W + 48 | 0, C = ((d[C >> 2] | 0) == (A | 0) ? (d[C + 4 >> 2] | 0) == (b | 0) : 0) & 1) : C = 1, d[T >> 2] = C, T = 0, Ae = ue, T | 0;
      }
      function Mh(h, f, A, b, T) {
        return h = h | 0, f = f | 0, A = A | 0, b = b | 0, T = T | 0, A = Ke(h, f, A, b) | 0, (A | 0) == 7 ? (T = 11, T | 0) : (b = k(A | 0, 0, 56) | 0, f = f & -2130706433 | (ye() | 0) | 268435456, d[T >> 2] = h | b, d[T + 4 >> 2] = f, T = 0, T | 0);
      }
      function Rh(h, f, A) {
        return h = h | 0, f = f | 0, A = A | 0, !0 & (f & 2013265920 | 0) == 268435456 ? (d[A >> 2] = h, d[A + 4 >> 2] = f & -2130706433 | 134217728, A = 0, A | 0) : (A = 6, A | 0);
      }
      function Bh(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0;
        var b = 0, T = 0, C = 0;
        return T = Ae, Ae = Ae + 16 | 0, b = T, d[b >> 2] = 0, !0 & (f & 2013265920 | 0) == 268435456 ? (C = D(h | 0, f | 0, 56) | 0, ye() | 0, b = On(h, f & -2130706433 | 134217728, C & 7, b, A) | 0, Ae = T, b | 0) : (b = 6, Ae = T, b | 0);
      }
      function Ga(h, f) {
        h = h | 0, f = f | 0;
        var A = 0;
        switch (A = D(h | 0, f | 0, 56) | 0, ye() | 0, A & 7) {
          case 0:
          case 7:
            return A = 0, A | 0;
        }
        return A = f & -2130706433 | 134217728, !(!0 & (f & 2013265920 | 0) == 268435456) || !0 & (f & 117440512 | 0) == 16777216 & (Bn(h, A) | 0) != 0 ? (A = 0, A | 0) : (A = pf(h, A) | 0, A | 0);
      }
      function ba(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0;
        var b = 0, T = 0, C = 0, I = 0;
        return T = Ae, Ae = Ae + 16 | 0, b = T, !0 & (f & 2013265920 | 0) == 268435456 ? (C = f & -2130706433 | 134217728, I = A, d[I >> 2] = h, d[I + 4 >> 2] = C, d[b >> 2] = 0, f = D(h | 0, f | 0, 56) | 0, ye() | 0, b = On(h, C, f & 7, b, A + 8 | 0) | 0, Ae = T, b | 0) : (b = 6, Ae = T, b | 0);
      }
      function Wa(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0;
        var b = 0, T = 0;
        return T = (Bn(h, f) | 0) == 0, f = f & -2130706433, b = A, d[b >> 2] = T ? h : 0, d[b + 4 >> 2] = T ? f | 285212672 : 0, b = A + 8 | 0, d[b >> 2] = h, d[b + 4 >> 2] = f | 301989888, b = A + 16 | 0, d[b >> 2] = h, d[b + 4 >> 2] = f | 318767104, b = A + 24 | 0, d[b >> 2] = h, d[b + 4 >> 2] = f | 335544320, b = A + 32 | 0, d[b >> 2] = h, d[b + 4 >> 2] = f | 352321536, A = A + 40 | 0, d[A >> 2] = h, d[A + 4 >> 2] = f | 369098752, 0;
      }
      function mc(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0;
        var b = 0, T = 0, C = 0, I = 0;
        return I = Ae, Ae = Ae + 16 | 0, T = I, C = f & -2130706433 | 134217728, !0 & (f & 2013265920 | 0) == 268435456 ? (b = D(h | 0, f | 0, 56) | 0, ye() | 0, b = Vh(h, C, b & 7) | 0, (b | 0) == -1 ? (d[A >> 2] = 0, C = 6, Ae = I, C | 0) : (xa(h, C, T) | 0 && er(27795, 26932, 282, 26947), f = D(h | 0, f | 0, 52) | 0, ye() | 0, f = f & 15, Bn(h, C) | 0 ? na(T, f, b, 2, A) : Sl(T, f, b, 2, A), C = 0, Ae = I, C | 0)) : (C = 6, Ae = I, C | 0);
      }
      function Oh(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0;
        var b = 0, T = 0;
        b = Ae, Ae = Ae + 16 | 0, T = b, ff(h, f, A, T), cf(T, A + 4 | 0), Ae = b;
      }
      function ff(h, f, A, b) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0;
        var T = 0, C = 0, I = 0, B = 0, F = 0;
        if (B = Ae, Ae = Ae + 16 | 0, F = B, $a(h, A, F), C = +Hr(+(1 - +ee[F >> 3] * 0.5)), C < 1e-16) {
          d[b >> 2] = 0, d[b + 4 >> 2] = 0, d[b + 8 >> 2] = 0, d[b + 12 >> 2] = 0, Ae = B;
          return;
        }
        if (F = d[A >> 2] | 0, T = +ee[15920 + (F * 24 | 0) >> 3], T = +bo(T - +bo(+Ll(15600 + (F << 4) | 0, h))), vs(f) | 0 ? I = +bo(T + -0.3334731722518321) : I = T, T = +Yt(+C) * 2.618033988749896, (f | 0) > 0) {
          h = 0;
          do
            T = T * 2.6457513110645907, h = h + 1 | 0;
          while ((h | 0) != (f | 0));
        }
        C = +Vt(+I) * T, ee[b >> 3] = C, I = +Lt(+I) * T, ee[b + 8 >> 3] = I, Ae = B;
      }
      function $a(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0;
        var b = 0, T = 0, C = 0;
        if (C = Ae, Ae = Ae + 32 | 0, T = C, zi(h, T), d[f >> 2] = 0, ee[A >> 3] = 5, b = +Xr(16400, T), b < +ee[A >> 3] && (d[f >> 2] = 0, ee[A >> 3] = b), b = +Xr(16424, T), b < +ee[A >> 3] && (d[f >> 2] = 1, ee[A >> 3] = b), b = +Xr(16448, T), b < +ee[A >> 3] && (d[f >> 2] = 2, ee[A >> 3] = b), b = +Xr(16472, T), b < +ee[A >> 3] && (d[f >> 2] = 3, ee[A >> 3] = b), b = +Xr(16496, T), b < +ee[A >> 3] && (d[f >> 2] = 4, ee[A >> 3] = b), b = +Xr(16520, T), b < +ee[A >> 3] && (d[f >> 2] = 5, ee[A >> 3] = b), b = +Xr(16544, T), b < +ee[A >> 3] && (d[f >> 2] = 6, ee[A >> 3] = b), b = +Xr(16568, T), b < +ee[A >> 3] && (d[f >> 2] = 7, ee[A >> 3] = b), b = +Xr(16592, T), b < +ee[A >> 3] && (d[f >> 2] = 8, ee[A >> 3] = b), b = +Xr(16616, T), b < +ee[A >> 3] && (d[f >> 2] = 9, ee[A >> 3] = b), b = +Xr(16640, T), b < +ee[A >> 3] && (d[f >> 2] = 10, ee[A >> 3] = b), b = +Xr(16664, T), b < +ee[A >> 3] && (d[f >> 2] = 11, ee[A >> 3] = b), b = +Xr(16688, T), b < +ee[A >> 3] && (d[f >> 2] = 12, ee[A >> 3] = b), b = +Xr(16712, T), b < +ee[A >> 3] && (d[f >> 2] = 13, ee[A >> 3] = b), b = +Xr(16736, T), b < +ee[A >> 3] && (d[f >> 2] = 14, ee[A >> 3] = b), b = +Xr(16760, T), b < +ee[A >> 3] && (d[f >> 2] = 15, ee[A >> 3] = b), b = +Xr(16784, T), b < +ee[A >> 3] && (d[f >> 2] = 16, ee[A >> 3] = b), b = +Xr(16808, T), b < +ee[A >> 3] && (d[f >> 2] = 17, ee[A >> 3] = b), b = +Xr(16832, T), b < +ee[A >> 3] && (d[f >> 2] = 18, ee[A >> 3] = b), b = +Xr(16856, T), !(b < +ee[A >> 3])) {
          Ae = C;
          return;
        }
        d[f >> 2] = 19, ee[A >> 3] = b, Ae = C;
      }
      function Cl(h, f, A, b, T) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0, T = T | 0;
        var C = 0, I = 0, B = 0;
        if (C = +Ho(h), C < 1e-16) {
          f = 15600 + (f << 4) | 0, d[T >> 2] = d[f >> 2], d[T + 4 >> 2] = d[f + 4 >> 2], d[T + 8 >> 2] = d[f + 8 >> 2], d[T + 12 >> 2] = d[f + 12 >> 2];
          return;
        }
        if (I = +un(+ +ee[h + 8 >> 3], + +ee[h >> 3]), (A | 0) > 0) {
          h = 0;
          do
            C = C * 0.37796447300922725, h = h + 1 | 0;
          while ((h | 0) != (A | 0));
        }
        B = C * 0.3333333333333333, b ? (A = (vs(A) | 0) == 0, C = +nn(+((A ? B : B * 0.37796447300922725) * 0.381966011250105))) : (C = +nn(+(C * 0.381966011250105)), vs(A) | 0 && (I = +bo(I + 0.3334731722518321))), xc(15600 + (f << 4) | 0, +bo(+ee[15920 + (f * 24 | 0) >> 3] - I), C, T);
      }
      function qa(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0;
        var b = 0, T = 0;
        b = Ae, Ae = Ae + 16 | 0, T = b, ea(h + 4 | 0, T), Cl(T, d[h >> 2] | 0, f, 0, A), Ae = b;
      }
      function na(h, f, A, b, T) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0, T = T | 0;
        var C = 0, I = 0, B = 0, F = 0, z = 0, W = 0, ue = 0, Ie = 0, Re = 0, Be = 0, Ze = 0, We = 0, rt = 0, et = 0, Je = 0, $e = 0, Bt = 0, Ht = 0, Ut = 0, Or = 0, Cr = 0, Gr = 0, Sr = 0, ar = 0, jt = 0, Wr = 0, fn = 0, Zr = 0;
        if (Wr = Ae, Ae = Ae + 272 | 0, C = Wr + 256 | 0, et = Wr + 240 | 0, Sr = Wr, ar = Wr + 224 | 0, jt = Wr + 208 | 0, Je = Wr + 176 | 0, $e = Wr + 160 | 0, Bt = Wr + 192 | 0, Ht = Wr + 144 | 0, Ut = Wr + 128 | 0, Or = Wr + 112 | 0, Cr = Wr + 96 | 0, Gr = Wr + 80 | 0, d[C >> 2] = f, d[et >> 2] = d[h >> 2], d[et + 4 >> 2] = d[h + 4 >> 2], d[et + 8 >> 2] = d[h + 8 >> 2], d[et + 12 >> 2] = d[h + 12 >> 2], hf(et, C, Sr), d[T >> 2] = 0, et = b + A + ((b | 0) == 5 & 1) | 0, (et | 0) <= (A | 0)) {
          Ae = Wr;
          return;
        }
        F = d[C >> 2] | 0, z = ar + 4 | 0, W = Je + 4 | 0, ue = A + 5 | 0, Ie = 16880 + (F << 2) | 0, Re = 16960 + (F << 2) | 0, Be = Ut + 8 | 0, Ze = Or + 8 | 0, We = Cr + 8 | 0, rt = jt + 4 | 0, B = A;
        e: for (; ; ) {
          I = Sr + (((B | 0) % 5 | 0) << 4) | 0, d[jt >> 2] = d[I >> 2], d[jt + 4 >> 2] = d[I + 4 >> 2], d[jt + 8 >> 2] = d[I + 8 >> 2], d[jt + 12 >> 2] = d[I + 12 >> 2];
          do
            ;
          while ((Vo(jt, F, 0, 1) | 0) == 2);
          if ((B | 0) > (A | 0) & (vs(f) | 0) != 0) {
            if (d[Je >> 2] = d[jt >> 2], d[Je + 4 >> 2] = d[jt + 4 >> 2], d[Je + 8 >> 2] = d[jt + 8 >> 2], d[Je + 12 >> 2] = d[jt + 12 >> 2], ea(z, $e), b = d[Je >> 2] | 0, C = d[17040 + (b * 80 | 0) + (d[ar >> 2] << 2) >> 2] | 0, d[Je >> 2] = d[18640 + (b * 80 | 0) + (C * 20 | 0) >> 2], I = d[18640 + (b * 80 | 0) + (C * 20 | 0) + 16 >> 2] | 0, (I | 0) > 0) {
              h = 0;
              do
                ya(W), h = h + 1 | 0;
              while ((h | 0) < (I | 0));
            }
            switch (I = 18640 + (b * 80 | 0) + (C * 20 | 0) + 4 | 0, d[Bt >> 2] = d[I >> 2], d[Bt + 4 >> 2] = d[I + 4 >> 2], d[Bt + 8 >> 2] = d[I + 8 >> 2], uf(Bt, (d[Ie >> 2] | 0) * 3 | 0), rs(W, Bt, W), qi(W), ea(W, Ht), fn = +(d[Re >> 2] | 0), ee[Ut >> 3] = fn * 3, ee[Be >> 3] = 0, Zr = fn * -1.5, ee[Or >> 3] = Zr, ee[Ze >> 3] = fn * 2.598076211353316, ee[Cr >> 3] = Zr, ee[We >> 3] = fn * -2.598076211353316, d[17040 + ((d[Je >> 2] | 0) * 80 | 0) + (d[jt >> 2] << 2) >> 2] | 0) {
              case 1: {
                h = Or, b = Ut;
                break;
              }
              case 3: {
                h = Cr, b = Or;
                break;
              }
              case 2: {
                h = Ut, b = Cr;
                break;
              }
              default: {
                h = 12;
                break e;
              }
            }
            Eu($e, Ht, b, h, Gr), Cl(Gr, d[Je >> 2] | 0, F, 1, T + 8 + (d[T >> 2] << 4) | 0), d[T >> 2] = (d[T >> 2] | 0) + 1;
          }
          if ((B | 0) < (ue | 0) && (ea(rt, Je), Cl(Je, d[jt >> 2] | 0, F, 1, T + 8 + (d[T >> 2] << 4) | 0), d[T >> 2] = (d[T >> 2] | 0) + 1), d[ar >> 2] = d[jt >> 2], d[ar + 4 >> 2] = d[jt + 4 >> 2], d[ar + 8 >> 2] = d[jt + 8 >> 2], d[ar + 12 >> 2] = d[jt + 12 >> 2], B = B + 1 | 0, (B | 0) >= (et | 0)) {
            h = 3;
            break;
          }
        }
        if ((h | 0) == 3) {
          Ae = Wr;
          return;
        } else (h | 0) == 12 && er(26970, 27017, 572, 27027);
      }
      function hf(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0;
        var b = 0, T = 0, C = 0, I = 0, B = 0, F = 0;
        F = Ae, Ae = Ae + 128 | 0, b = F + 64 | 0, T = F, C = b, I = 20240, B = C + 60 | 0;
        do
          d[C >> 2] = d[I >> 2], C = C + 4 | 0, I = I + 4 | 0;
        while ((C | 0) < (B | 0));
        C = T, I = 20304, B = C + 60 | 0;
        do
          d[C >> 2] = d[I >> 2], C = C + 4 | 0, I = I + 4 | 0;
        while ((C | 0) < (B | 0));
        B = (vs(d[f >> 2] | 0) | 0) == 0, b = B ? b : T, T = h + 4 | 0, va(T), ra(T), vs(d[f >> 2] | 0) | 0 && (Rs(T), d[f >> 2] = (d[f >> 2] | 0) + 1), d[A >> 2] = d[h >> 2], f = A + 4 | 0, rs(T, b, f), qi(f), d[A + 16 >> 2] = d[h >> 2], f = A + 20 | 0, rs(T, b + 12 | 0, f), qi(f), d[A + 32 >> 2] = d[h >> 2], f = A + 36 | 0, rs(T, b + 24 | 0, f), qi(f), d[A + 48 >> 2] = d[h >> 2], f = A + 52 | 0, rs(T, b + 36 | 0, f), qi(f), d[A + 64 >> 2] = d[h >> 2], A = A + 68 | 0, rs(T, b + 48 | 0, A), qi(A), Ae = F;
      }
      function Vo(h, f, A, b) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0;
        var T = 0, C = 0, I = 0, B = 0, F = 0, z = 0, W = 0, ue = 0, Ie = 0, Re = 0, Be = 0;
        if (Be = Ae, Ae = Ae + 32 | 0, Ie = Be + 12 | 0, B = Be, Re = h + 4 | 0, ue = d[16960 + (f << 2) >> 2] | 0, W = (b | 0) != 0, ue = W ? ue * 3 | 0 : ue, T = d[Re >> 2] | 0, z = h + 8 | 0, I = d[z >> 2] | 0, W) {
          if (C = h + 12 | 0, b = d[C >> 2] | 0, T = I + T + b | 0, (T | 0) == (ue | 0))
            return Re = 1, Ae = Be, Re | 0;
          F = C;
        } else
          F = h + 12 | 0, b = d[F >> 2] | 0, T = I + T + b | 0;
        if ((T | 0) <= (ue | 0))
          return Re = 0, Ae = Be, Re | 0;
        do
          if ((b | 0) > 0) {
            if (b = d[h >> 2] | 0, (I | 0) > 0) {
              C = 18640 + (b * 80 | 0) + 60 | 0, b = h;
              break;
            }
            b = 18640 + (b * 80 | 0) + 40 | 0, A ? (Gp(Ie, ue, 0, 0), fu(Re, Ie, B), zo(B), rs(B, Ie, Re), C = b, b = h) : (C = b, b = h);
          } else
            C = 18640 + ((d[h >> 2] | 0) * 80 | 0) + 20 | 0, b = h;
        while (!1);
        if (d[b >> 2] = d[C >> 2], T = C + 16 | 0, (d[T >> 2] | 0) > 0) {
          b = 0;
          do
            ya(Re), b = b + 1 | 0;
          while ((b | 0) < (d[T >> 2] | 0));
        }
        return h = C + 4 | 0, d[Ie >> 2] = d[h >> 2], d[Ie + 4 >> 2] = d[h + 4 >> 2], d[Ie + 8 >> 2] = d[h + 8 >> 2], f = d[16880 + (f << 2) >> 2] | 0, uf(Ie, W ? f * 3 | 0 : f), rs(Re, Ie, Re), qi(Re), W ? b = ((d[z >> 2] | 0) + (d[Re >> 2] | 0) + (d[F >> 2] | 0) | 0) == (ue | 0) ? 1 : 2 : b = 2, Re = b, Ae = Be, Re | 0;
      }
      function Un(h, f) {
        h = h | 0, f = f | 0;
        var A = 0;
        do
          A = Vo(h, f, 0, 1) | 0;
        while ((A | 0) == 2);
        return A | 0;
      }
      function Sl(h, f, A, b, T) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0, T = T | 0;
        var C = 0, I = 0, B = 0, F = 0, z = 0, W = 0, ue = 0, Ie = 0, Re = 0, Be = 0, Ze = 0, We = 0, rt = 0, et = 0, Je = 0, $e = 0, Bt = 0, Ht = 0, Ut = 0, Or = 0, Cr = 0, Gr = 0, Sr = 0;
        if (Cr = Ae, Ae = Ae + 240 | 0, C = Cr + 224 | 0, Bt = Cr + 208 | 0, Ht = Cr, Ut = Cr + 192 | 0, Or = Cr + 176 | 0, We = Cr + 160 | 0, rt = Cr + 144 | 0, et = Cr + 128 | 0, Je = Cr + 112 | 0, $e = Cr + 96 | 0, d[C >> 2] = f, d[Bt >> 2] = d[h >> 2], d[Bt + 4 >> 2] = d[h + 4 >> 2], d[Bt + 8 >> 2] = d[h + 8 >> 2], d[Bt + 12 >> 2] = d[h + 12 >> 2], Dh(Bt, C, Ht), d[T >> 2] = 0, Ze = b + A + ((b | 0) == 6 & 1) | 0, (Ze | 0) <= (A | 0)) {
          Ae = Cr;
          return;
        }
        F = d[C >> 2] | 0, z = A + 6 | 0, W = 16960 + (F << 2) | 0, ue = rt + 8 | 0, Ie = et + 8 | 0, Re = Je + 8 | 0, Be = Ut + 4 | 0, I = 0, B = A, b = -1;
        e: for (; ; ) {
          if (C = (B | 0) % 6 | 0, h = Ht + (C << 4) | 0, d[Ut >> 2] = d[h >> 2], d[Ut + 4 >> 2] = d[h + 4 >> 2], d[Ut + 8 >> 2] = d[h + 8 >> 2], d[Ut + 12 >> 2] = d[h + 12 >> 2], h = I, I = Vo(Ut, F, 0, 1) | 0, (B | 0) > (A | 0) & (vs(f) | 0) != 0 && (h | 0) != 1 && (d[Ut >> 2] | 0) != (b | 0)) {
            switch (ea(Ht + (((C + 5 | 0) % 6 | 0) << 4) + 4 | 0, Or), ea(Ht + (C << 4) + 4 | 0, We), Gr = +(d[W >> 2] | 0), ee[rt >> 3] = Gr * 3, ee[ue >> 3] = 0, Sr = Gr * -1.5, ee[et >> 3] = Sr, ee[Ie >> 3] = Gr * 2.598076211353316, ee[Je >> 3] = Sr, ee[Re >> 3] = Gr * -2.598076211353316, C = d[Bt >> 2] | 0, d[17040 + (C * 80 | 0) + (((b | 0) == (C | 0) ? d[Ut >> 2] | 0 : b) << 2) >> 2] | 0) {
              case 1: {
                h = et, b = rt;
                break;
              }
              case 3: {
                h = Je, b = et;
                break;
              }
              case 2: {
                h = rt, b = Je;
                break;
              }
              default: {
                h = 8;
                break e;
              }
            }
            Eu(Or, We, b, h, $e), !(Sc(Or, $e) | 0) && !(Sc(We, $e) | 0) && (Cl($e, d[Bt >> 2] | 0, F, 1, T + 8 + (d[T >> 2] << 4) | 0), d[T >> 2] = (d[T >> 2] | 0) + 1);
          }
          if ((B | 0) < (z | 0) && (ea(Be, Or), Cl(Or, d[Ut >> 2] | 0, F, 1, T + 8 + (d[T >> 2] << 4) | 0), d[T >> 2] = (d[T >> 2] | 0) + 1), B = B + 1 | 0, (B | 0) >= (Ze | 0)) {
            h = 3;
            break;
          } else
            b = d[Ut >> 2] | 0;
        }
        if ((h | 0) == 3) {
          Ae = Cr;
          return;
        } else (h | 0) == 8 && er(27054, 27017, 737, 27099);
      }
      function Dh(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0;
        var b = 0, T = 0, C = 0, I = 0, B = 0, F = 0;
        F = Ae, Ae = Ae + 160 | 0, b = F + 80 | 0, T = F, C = b, I = 20368, B = C + 72 | 0;
        do
          d[C >> 2] = d[I >> 2], C = C + 4 | 0, I = I + 4 | 0;
        while ((C | 0) < (B | 0));
        C = T, I = 20448, B = C + 72 | 0;
        do
          d[C >> 2] = d[I >> 2], C = C + 4 | 0, I = I + 4 | 0;
        while ((C | 0) < (B | 0));
        B = (vs(d[f >> 2] | 0) | 0) == 0, b = B ? b : T, T = h + 4 | 0, va(T), ra(T), vs(d[f >> 2] | 0) | 0 && (Rs(T), d[f >> 2] = (d[f >> 2] | 0) + 1), d[A >> 2] = d[h >> 2], f = A + 4 | 0, rs(T, b, f), qi(f), d[A + 16 >> 2] = d[h >> 2], f = A + 20 | 0, rs(T, b + 12 | 0, f), qi(f), d[A + 32 >> 2] = d[h >> 2], f = A + 36 | 0, rs(T, b + 24 | 0, f), qi(f), d[A + 48 >> 2] = d[h >> 2], f = A + 52 | 0, rs(T, b + 36 | 0, f), qi(f), d[A + 64 >> 2] = d[h >> 2], f = A + 68 | 0, rs(T, b + 48 | 0, f), qi(f), d[A + 80 >> 2] = d[h >> 2], A = A + 84 | 0, rs(T, b + 60 | 0, A), qi(A), Ae = F;
      }
      function Il(h, f) {
        return h = h | 0, f = f | 0, f = D(h | 0, f | 0, 52) | 0, ye() | 0, f & 15 | 0;
      }
      function df(h, f) {
        return h = h | 0, f = f | 0, f = D(h | 0, f | 0, 45) | 0, ye() | 0, f & 127 | 0;
      }
      function pf(h, f) {
        h = h | 0, f = f | 0;
        var A = 0, b = 0, T = 0, C = 0, I = 0;
        return !(!0 & (f & -16777216 | 0) == 134217728) || (b = D(h | 0, f | 0, 52) | 0, ye() | 0, b = b & 15, A = D(h | 0, f | 0, 45) | 0, ye() | 0, A = A & 127, A >>> 0 > 121) ? (h = 0, h | 0) : (I = (b ^ 15) * 3 | 0, T = D(h | 0, f | 0, I | 0) | 0, I = k(T | 0, ye() | 0, I | 0) | 0, T = ye() | 0, C = Vi(-1227133514, -1171, I | 0, T | 0) | 0, !((I & 613566756 & C | 0) == 0 & (T & 4681 & (ye() | 0) | 0) == 0) || (I = (b * 3 | 0) + 19 | 0, C = k(~h | 0, ~f | 0, I | 0) | 0, I = D(C | 0, ye() | 0, I | 0) | 0, !((b | 0) == 15 | (I | 0) == 0 & (ye() | 0) == 0)) ? (I = 0, I | 0) : !(ge[20528 + A >> 0] | 0) || (f = f & 8191, (h | 0) == 0 & (f | 0) == 0) ? (I = 1, I | 0) : (I = H(h | 0, f | 0) | 0, ye() | 0, ((63 - I | 0) % 3 | 0 | 0) != 0 | 0));
      }
      function Au(h, f, A, b) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0;
        var T = 0, C = 0, I = 0, B = 0;
        if (T = k(f | 0, 0, 52) | 0, C = ye() | 0, A = k(A | 0, 0, 45) | 0, A = C | (ye() | 0) | 134225919, (f | 0) < 1) {
          C = -1, b = A, f = h, d[f >> 2] = C, h = h + 4 | 0, d[h >> 2] = b;
          return;
        }
        for (C = 1, T = -1; I = (15 - C | 0) * 3 | 0, B = k(7, 0, I | 0) | 0, A = A & ~(ye() | 0), I = k(b | 0, 0, I | 0) | 0, T = T & ~B | I, A = A | (ye() | 0), (C | 0) != (f | 0); )
          C = C + 1 | 0;
        B = h, I = B, d[I >> 2] = T, B = B + 4 | 0, d[B >> 2] = A;
      }
      function Pl(h, f, A, b) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0;
        var T = 0, C = 0;
        if (C = D(h | 0, f | 0, 52) | 0, ye() | 0, C = C & 15, A >>> 0 > 15)
          return b = 4, b | 0;
        if ((C | 0) < (A | 0))
          return b = 12, b | 0;
        if ((C | 0) == (A | 0))
          return d[b >> 2] = h, d[b + 4 >> 2] = f, b = 0, b | 0;
        if (T = k(A | 0, 0, 52) | 0, T = T | h, h = ye() | 0 | f & -15728641, (C | 0) > (A | 0))
          do
            f = k(7, 0, (14 - A | 0) * 3 | 0) | 0, A = A + 1 | 0, T = f | T, h = ye() | 0 | h;
          while ((A | 0) < (C | 0));
        return d[b >> 2] = T, d[b + 4 >> 2] = h, b = 0, b | 0;
      }
      function jo(h, f, A, b) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0;
        var T = 0, C = 0, I = 0;
        if (C = D(h | 0, f | 0, 52) | 0, ye() | 0, C = C & 15, !((A | 0) < 16 & (C | 0) <= (A | 0)))
          return b = 4, b | 0;
        T = A - C | 0, A = D(h | 0, f | 0, 45) | 0, ye() | 0;
        e: do
          if (!(mn(A & 127) | 0))
            A = Si(7, 0, T, ((T | 0) < 0) << 31 >> 31) | 0, T = ye() | 0;
          else {
            t: do
              if (C | 0) {
                for (A = 1; I = k(7, 0, (15 - A | 0) * 3 | 0) | 0, !!((I & h | 0) == 0 & ((ye() | 0) & f | 0) == 0); )
                  if (A >>> 0 < C >>> 0)
                    A = A + 1 | 0;
                  else
                    break t;
                A = Si(7, 0, T, ((T | 0) < 0) << 31 >> 31) | 0, T = ye() | 0;
                break e;
              }
            while (!1);
            A = Si(7, 0, T, ((T | 0) < 0) << 31 >> 31) | 0, A = v(A | 0, ye() | 0, 5, 0) | 0, A = Er(A | 0, ye() | 0, -5, -1) | 0, A = Mo(A | 0, ye() | 0, 6, 0) | 0, A = Er(A | 0, ye() | 0, 1, 0) | 0, T = ye() | 0;
          }
        while (!1);
        return I = b, d[I >> 2] = A, d[I + 4 >> 2] = T, I = 0, I | 0;
      }
      function Bn(h, f) {
        h = h | 0, f = f | 0;
        var A = 0, b = 0, T = 0;
        if (T = D(h | 0, f | 0, 45) | 0, ye() | 0, !(mn(T & 127) | 0))
          return T = 0, T | 0;
        T = D(h | 0, f | 0, 52) | 0, ye() | 0, T = T & 15;
        e: do
          if (!T)
            A = 0;
          else
            for (b = 1; ; ) {
              if (A = D(h | 0, f | 0, (15 - b | 0) * 3 | 0) | 0, ye() | 0, A = A & 7, A | 0)
                break e;
              if (b >>> 0 < T >>> 0)
                b = b + 1 | 0;
              else {
                A = 0;
                break;
              }
            }
        while (!1);
        return T = (A | 0) == 0 & 1, T | 0;
      }
      function gu(h, f, A, b) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0;
        var T = 0, C = 0, I = 0, B = 0;
        if (I = Ae, Ae = Ae + 16 | 0, C = I, ia(C, h, f, A), f = C, h = d[f >> 2] | 0, f = d[f + 4 >> 2] | 0, (h | 0) == 0 & (f | 0) == 0)
          return Ae = I, 0;
        T = 0, A = 0;
        do
          B = b + (T << 3) | 0, d[B >> 2] = h, d[B + 4 >> 2] = f, T = Er(T | 0, A | 0, 1, 0) | 0, A = ye() | 0, Dl(C), B = C, h = d[B >> 2] | 0, f = d[B + 4 >> 2] | 0;
        while (!((h | 0) == 0 & (f | 0) == 0));
        return Ae = I, 0;
      }
      function Ml(h, f, A, b) {
        return h = h | 0, f = f | 0, A = A | 0, b = b | 0, (b | 0) < (A | 0) ? (A = f, b = h, hr(A | 0), b | 0) : (A = k(-1, -1, ((b - A | 0) * 3 | 0) + 3 | 0) | 0, b = k(~A | 0, ~(ye() | 0) | 0, (15 - b | 0) * 3 | 0) | 0, A = ~(ye() | 0) & f, b = ~b & h, hr(A | 0), b | 0);
      }
      function Xa(h, f, A, b) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0;
        var T = 0;
        return T = D(h | 0, f | 0, 52) | 0, ye() | 0, T = T & 15, (A | 0) < 16 & (T | 0) <= (A | 0) ? ((T | 0) < (A | 0) && (T = k(-1, -1, ((A + -1 - T | 0) * 3 | 0) + 3 | 0) | 0, T = k(~T | 0, ~(ye() | 0) | 0, (15 - A | 0) * 3 | 0) | 0, f = ~(ye() | 0) & f, h = ~T & h), T = k(A | 0, 0, 52) | 0, A = f & -15728641 | (ye() | 0), d[b >> 2] = h | T, d[b + 4 >> 2] = A, b = 0, b | 0) : (b = 4, b | 0);
      }
      function Lh(h, f, A, b) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0;
        var T = 0, C = 0, I = 0, B = 0, F = 0, z = 0, W = 0, ue = 0, Ie = 0, Re = 0, Be = 0, Ze = 0, We = 0, rt = 0, et = 0, Je = 0, $e = 0, Bt = 0, Ht = 0, Ut = 0, Or = 0, Cr = 0, Gr = 0, Sr = 0, ar = 0, jt = 0;
        if ((A | 0) == 0 & (b | 0) == 0)
          return jt = 0, jt | 0;
        if (T = h, C = d[T >> 2] | 0, T = d[T + 4 >> 2] | 0, !0 & (T & 15728640 | 0) == 0) {
          if (!((b | 0) > 0 | (b | 0) == 0 & A >>> 0 > 0) || (jt = f, d[jt >> 2] = C, d[jt + 4 >> 2] = T, (A | 0) == 1 & (b | 0) == 0))
            return jt = 0, jt | 0;
          T = 1, C = 0;
          do
            Sr = h + (T << 3) | 0, ar = d[Sr + 4 >> 2] | 0, jt = f + (T << 3) | 0, d[jt >> 2] = d[Sr >> 2], d[jt + 4 >> 2] = ar, T = Er(T | 0, C | 0, 1, 0) | 0, C = ye() | 0;
          while ((C | 0) < (b | 0) | (C | 0) == (b | 0) & T >>> 0 < A >>> 0);
          return T = 0, T | 0;
        }
        if (Gr = A << 3, ar = ss(Gr) | 0, !ar)
          return jt = 13, jt | 0;
        if (Se(ar | 0, h | 0, Gr | 0) | 0, Sr = Ii(A, 8) | 0, !Sr)
          return Ur(ar), jt = 13, jt | 0;
        e: for (; ; ) {
          T = ar, z = d[T >> 2] | 0, T = d[T + 4 >> 2] | 0, Or = D(z | 0, T | 0, 52) | 0, ye() | 0, Or = Or & 15, Cr = Or + -1 | 0, Ut = (Or | 0) != 0, Ht = (b | 0) > 0 | (b | 0) == 0 & A >>> 0 > 0;
          t: do
            if (Ut & Ht) {
              if (et = k(Cr | 0, 0, 52) | 0, Je = ye() | 0, Cr >>> 0 > 15) {
                if (!((z | 0) == 0 & (T | 0) == 0)) {
                  jt = 16;
                  break e;
                }
                for (C = 0, h = 0; ; ) {
                  if (C = Er(C | 0, h | 0, 1, 0) | 0, h = ye() | 0, !((h | 0) < (b | 0) | (h | 0) == (b | 0) & C >>> 0 < A >>> 0))
                    break t;
                  if (I = ar + (C << 3) | 0, Bt = d[I >> 2] | 0, I = d[I + 4 >> 2] | 0, !((Bt | 0) == 0 & (I | 0) == 0)) {
                    T = I, jt = 16;
                    break e;
                  }
                }
              }
              for (B = z, h = T, C = 0, I = 0; ; ) {
                if (!((B | 0) == 0 & (h | 0) == 0)) {
                  if (!(!0 & (h & 117440512 | 0) == 0)) {
                    jt = 21;
                    break e;
                  }
                  if (W = D(B | 0, h | 0, 52) | 0, ye() | 0, W = W & 15, (W | 0) < (Cr | 0)) {
                    T = 12, jt = 27;
                    break e;
                  }
                  if ((W | 0) != (Cr | 0) && (B = B | et, h = h & -15728641 | Je, W >>> 0 >= Or >>> 0)) {
                    F = Cr;
                    do
                      Bt = k(7, 0, (14 - F | 0) * 3 | 0) | 0, F = F + 1 | 0, B = Bt | B, h = ye() | 0 | h;
                    while (F >>> 0 < W >>> 0);
                  }
                  if (Ie = w(B | 0, h | 0, A | 0, b | 0) | 0, Re = ye() | 0, F = Sr + (Ie << 3) | 0, W = F, ue = d[W >> 2] | 0, W = d[W + 4 >> 2] | 0, !((ue | 0) == 0 & (W | 0) == 0)) {
                    We = 0, rt = 0;
                    do {
                      if ((We | 0) > (b | 0) | (We | 0) == (b | 0) & rt >>> 0 > A >>> 0) {
                        jt = 31;
                        break e;
                      }
                      if ((ue | 0) == (B | 0) & (W & -117440513 | 0) == (h | 0)) {
                        Be = D(ue | 0, W | 0, 56) | 0, ye() | 0, Be = Be & 7, Ze = Be + 1 | 0, Bt = D(ue | 0, W | 0, 45) | 0, ye() | 0;
                        r: do
                          if (!(mn(Bt & 127) | 0))
                            W = 7;
                          else {
                            if (ue = D(ue | 0, W | 0, 52) | 0, ye() | 0, ue = ue & 15, !ue) {
                              W = 6;
                              break;
                            }
                            for (W = 1; ; ) {
                              if (Bt = k(7, 0, (15 - W | 0) * 3 | 0) | 0, !((Bt & B | 0) == 0 & ((ye() | 0) & h | 0) == 0)) {
                                W = 7;
                                break r;
                              }
                              if (W >>> 0 < ue >>> 0)
                                W = W + 1 | 0;
                              else {
                                W = 6;
                                break;
                              }
                            }
                          }
                        while (!1);
                        if ((Be + 2 | 0) >>> 0 > W >>> 0) {
                          jt = 41;
                          break e;
                        }
                        Bt = k(Ze | 0, 0, 56) | 0, h = ye() | 0 | h & -117440513, $e = F, d[$e >> 2] = 0, d[$e + 4 >> 2] = 0, B = Bt | B;
                      } else
                        Ie = Er(Ie | 0, Re | 0, 1, 0) | 0, Ie = _(Ie | 0, ye() | 0, A | 0, b | 0) | 0, Re = ye() | 0;
                      rt = Er(rt | 0, We | 0, 1, 0) | 0, We = ye() | 0, F = Sr + (Ie << 3) | 0, W = F, ue = d[W >> 2] | 0, W = d[W + 4 >> 2] | 0;
                    } while (!((ue | 0) == 0 & (W | 0) == 0));
                  }
                  Bt = F, d[Bt >> 2] = B, d[Bt + 4 >> 2] = h;
                }
                if (C = Er(C | 0, I | 0, 1, 0) | 0, I = ye() | 0, !((I | 0) < (b | 0) | (I | 0) == (b | 0) & C >>> 0 < A >>> 0))
                  break t;
                h = ar + (C << 3) | 0, B = d[h >> 2] | 0, h = d[h + 4 >> 2] | 0;
              }
            }
          while (!1);
          if (Bt = Er(A | 0, b | 0, 5, 0) | 0, $e = ye() | 0, $e >>> 0 < 0 | ($e | 0) == 0 & Bt >>> 0 < 11) {
            jt = 85;
            break;
          }
          if (Bt = Mo(A | 0, b | 0, 6, 0) | 0, ye() | 0, Bt = Ii(Bt, 8) | 0, !Bt) {
            jt = 48;
            break;
          }
          do
            if (Ht) {
              for (Ze = 0, h = 0, Be = 0, We = 0; ; ) {
                if (W = Sr + (Ze << 3) | 0, I = W, C = d[I >> 2] | 0, I = d[I + 4 >> 2] | 0, (C | 0) == 0 & (I | 0) == 0)
                  $e = Be;
                else {
                  ue = D(C | 0, I | 0, 56) | 0, ye() | 0, ue = ue & 7, B = ue + 1 | 0, Ie = I & -117440513, $e = D(C | 0, I | 0, 45) | 0, ye() | 0;
                  t: do
                    if (mn($e & 127) | 0) {
                      if (Re = D(C | 0, I | 0, 52) | 0, ye() | 0, Re = Re & 15, Re | 0)
                        for (F = 1; ; ) {
                          if ($e = k(7, 0, (15 - F | 0) * 3 | 0) | 0, !((C & $e | 0) == 0 & (Ie & (ye() | 0) | 0) == 0))
                            break t;
                          if (F >>> 0 < Re >>> 0)
                            F = F + 1 | 0;
                          else
                            break;
                        }
                      I = k(B | 0, 0, 56) | 0, C = I | C, I = ye() | 0 | Ie, B = W, d[B >> 2] = C, d[B + 4 >> 2] = I, B = ue + 2 | 0;
                    }
                  while (!1);
                  (B | 0) == 7 ? ($e = Bt + (h << 3) | 0, d[$e >> 2] = C, d[$e + 4 >> 2] = I & -117440513, h = Er(h | 0, Be | 0, 1, 0) | 0, $e = ye() | 0) : $e = Be;
                }
                if (Ze = Er(Ze | 0, We | 0, 1, 0) | 0, We = ye() | 0, (We | 0) < (b | 0) | (We | 0) == (b | 0) & Ze >>> 0 < A >>> 0)
                  Be = $e;
                else
                  break;
              }
              if (Ht) {
                if (rt = Cr >>> 0 > 15, et = k(Cr | 0, 0, 52) | 0, Je = ye() | 0, !Ut) {
                  for (C = 0, F = 0, B = 0, I = 0; (z | 0) == 0 & (T | 0) == 0 || (Cr = f + (C << 3) | 0, d[Cr >> 2] = z, d[Cr + 4 >> 2] = T, C = Er(C | 0, F | 0, 1, 0) | 0, F = ye() | 0), B = Er(B | 0, I | 0, 1, 0) | 0, I = ye() | 0, !!((I | 0) < (b | 0) | (I | 0) == (b | 0) & B >>> 0 < A >>> 0); )
                    T = ar + (B << 3) | 0, z = d[T >> 2] | 0, T = d[T + 4 >> 2] | 0;
                  T = $e;
                  break;
                }
                for (C = 0, F = 0, I = 0, B = 0; ; ) {
                  do
                    if (!((z | 0) == 0 & (T | 0) == 0)) {
                      if (Re = D(z | 0, T | 0, 52) | 0, ye() | 0, Re = Re & 15, rt | (Re | 0) < (Cr | 0)) {
                        jt = 80;
                        break e;
                      }
                      if ((Re | 0) != (Cr | 0)) {
                        if (W = z | et, ue = T & -15728641 | Je, Re >>> 0 >= Or >>> 0) {
                          Ie = Cr;
                          do
                            Ut = k(7, 0, (14 - Ie | 0) * 3 | 0) | 0, Ie = Ie + 1 | 0, W = Ut | W, ue = ye() | 0 | ue;
                          while (Ie >>> 0 < Re >>> 0);
                        }
                      } else
                        W = z, ue = T;
                      Be = w(W | 0, ue | 0, A | 0, b | 0) | 0, Ie = 0, Re = 0, We = ye() | 0;
                      do {
                        if ((Ie | 0) > (b | 0) | (Ie | 0) == (b | 0) & Re >>> 0 > A >>> 0) {
                          jt = 81;
                          break e;
                        }
                        if (Ut = Sr + (Be << 3) | 0, Ze = d[Ut + 4 >> 2] | 0, (Ze & -117440513 | 0) == (ue | 0) && (d[Ut >> 2] | 0) == (W | 0)) {
                          jt = 65;
                          break;
                        }
                        Ut = Er(Be | 0, We | 0, 1, 0) | 0, Be = _(Ut | 0, ye() | 0, A | 0, b | 0) | 0, We = ye() | 0, Re = Er(Re | 0, Ie | 0, 1, 0) | 0, Ie = ye() | 0, Ut = Sr + (Be << 3) | 0;
                      } while (!((d[Ut >> 2] | 0) == (W | 0) && (d[Ut + 4 >> 2] | 0) == (ue | 0)));
                      if ((jt | 0) == 65 && (jt = 0, !0 & (Ze & 117440512 | 0) == 100663296))
                        break;
                      Ut = f + (C << 3) | 0, d[Ut >> 2] = z, d[Ut + 4 >> 2] = T, C = Er(C | 0, F | 0, 1, 0) | 0, F = ye() | 0;
                    }
                  while (!1);
                  if (I = Er(I | 0, B | 0, 1, 0) | 0, B = ye() | 0, !((B | 0) < (b | 0) | (B | 0) == (b | 0) & I >>> 0 < A >>> 0))
                    break;
                  T = ar + (I << 3) | 0, z = d[T >> 2] | 0, T = d[T + 4 >> 2] | 0;
                }
                T = $e;
              } else
                C = 0, T = $e;
            } else
              C = 0, h = 0, T = 0;
          while (!1);
          if (Oe(Sr | 0, 0, Gr | 0) | 0, Se(ar | 0, Bt | 0, h << 3 | 0) | 0, Ur(Bt), (h | 0) == 0 & (T | 0) == 0) {
            jt = 89;
            break;
          } else
            f = f + (C << 3) | 0, b = T, A = h;
        }
        if ((jt | 0) == 16)
          !0 & (T & 117440512 | 0) == 0 ? (T = 4, jt = 27) : jt = 21;
        else if ((jt | 0) == 31)
          er(27795, 27122, 529, 27132);
        else {
          if ((jt | 0) == 41)
            return Ur(ar), Ur(Sr), jt = 10, jt | 0;
          if ((jt | 0) == 48)
            return Ur(ar), Ur(Sr), jt = 13, jt | 0;
          (jt | 0) == 80 ? er(27795, 27122, 620, 27132) : (jt | 0) == 81 ? er(27795, 27122, 632, 27132) : (jt | 0) == 85 && (Se(f | 0, ar | 0, A << 3 | 0) | 0, jt = 89);
        }
        return (jt | 0) == 21 ? (Ur(ar), Ur(Sr), jt = 5, jt | 0) : (jt | 0) == 27 ? (Ur(ar), Ur(Sr), jt = T, jt | 0) : (jt | 0) == 89 ? (Ur(ar), Ur(Sr), jt = 0, jt | 0) : 0;
      }
      function Rl(h, f, A, b, T, C, I) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0, T = T | 0, C = C | 0, I = I | 0;
        var B = 0, F = 0, z = 0, W = 0, ue = 0, Ie = 0, Re = 0, Be = 0, Ze = 0;
        if (Ze = Ae, Ae = Ae + 16 | 0, Be = Ze, !((A | 0) > 0 | (A | 0) == 0 & f >>> 0 > 0))
          return Be = 0, Ae = Ze, Be | 0;
        if ((I | 0) >= 16)
          return Be = 12, Ae = Ze, Be | 0;
        Ie = 0, Re = 0, ue = 0, B = 0;
        e: for (; ; ) {
          if (z = h + (Ie << 3) | 0, F = d[z >> 2] | 0, z = d[z + 4 >> 2] | 0, W = D(F | 0, z | 0, 52) | 0, ye() | 0, (W & 15 | 0) > (I | 0)) {
            B = 12, F = 11;
            break;
          }
          if (ia(Be, F, z, I), W = Be, z = d[W >> 2] | 0, W = d[W + 4 >> 2] | 0, (z | 0) == 0 & (W | 0) == 0)
            F = ue;
          else {
            F = ue;
            do {
              if (!((B | 0) < (C | 0) | (B | 0) == (C | 0) & F >>> 0 < T >>> 0)) {
                F = 10;
                break e;
              }
              ue = b + (F << 3) | 0, d[ue >> 2] = z, d[ue + 4 >> 2] = W, F = Er(F | 0, B | 0, 1, 0) | 0, B = ye() | 0, Dl(Be), ue = Be, z = d[ue >> 2] | 0, W = d[ue + 4 >> 2] | 0;
            } while (!((z | 0) == 0 & (W | 0) == 0));
          }
          if (Ie = Er(Ie | 0, Re | 0, 1, 0) | 0, Re = ye() | 0, (Re | 0) < (A | 0) | (Re | 0) == (A | 0) & Ie >>> 0 < f >>> 0)
            ue = F;
          else {
            B = 0, F = 11;
            break;
          }
        }
        return (F | 0) == 10 ? (Be = 14, Ae = Ze, Be | 0) : (F | 0) == 11 ? (Ae = Ze, B | 0) : 0;
      }
      function vo(h, f, A, b, T) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0, T = T | 0;
        var C = 0, I = 0, B = 0, F = 0, z = 0, W = 0, ue = 0, Ie = 0;
        Ie = Ae, Ae = Ae + 16 | 0, ue = Ie;
        e: do
          if ((A | 0) > 0 | (A | 0) == 0 & f >>> 0 > 0) {
            for (z = 0, I = 0, C = 0, W = 0; ; ) {
              if (F = h + (z << 3) | 0, B = d[F >> 2] | 0, F = d[F + 4 >> 2] | 0, !((B | 0) == 0 & (F | 0) == 0) && (F = (jo(B, F, b, ue) | 0) == 0, B = ue, I = Er(d[B >> 2] | 0, d[B + 4 >> 2] | 0, I | 0, C | 0) | 0, C = ye() | 0, !F)) {
                C = 12;
                break;
              }
              if (z = Er(z | 0, W | 0, 1, 0) | 0, W = ye() | 0, !((W | 0) < (A | 0) | (W | 0) == (A | 0) & z >>> 0 < f >>> 0))
                break e;
            }
            return Ae = Ie, C | 0;
          } else
            I = 0, C = 0;
        while (!1);
        return d[T >> 2] = I, d[T + 4 >> 2] = C, T = 0, Ae = Ie, T | 0;
      }
      function kh(h, f) {
        return h = h | 0, f = f | 0, f = D(h | 0, f | 0, 52) | 0, ye() | 0, f & 1 | 0;
      }
      function ys(h, f) {
        h = h | 0, f = f | 0;
        var A = 0, b = 0, T = 0;
        if (T = D(h | 0, f | 0, 52) | 0, ye() | 0, T = T & 15, !T)
          return T = 0, T | 0;
        for (b = 1; ; ) {
          if (A = D(h | 0, f | 0, (15 - b | 0) * 3 | 0) | 0, ye() | 0, A = A & 7, A | 0) {
            b = 5;
            break;
          }
          if (b >>> 0 < T >>> 0)
            b = b + 1 | 0;
          else {
            A = 0, b = 5;
            break;
          }
        }
        return (b | 0) == 5 ? A | 0 : 0;
      }
      function mu(h, f) {
        h = h | 0, f = f | 0;
        var A = 0, b = 0, T = 0, C = 0, I = 0, B = 0, F = 0;
        if (F = D(h | 0, f | 0, 52) | 0, ye() | 0, F = F & 15, !F)
          return B = f, F = h, hr(B | 0), F | 0;
        for (B = 1, A = 0; ; ) {
          C = (15 - B | 0) * 3 | 0, b = k(7, 0, C | 0) | 0, T = ye() | 0, I = D(h | 0, f | 0, C | 0) | 0, ye() | 0, C = k(Bs(I & 7) | 0, 0, C | 0) | 0, I = ye() | 0, h = C | h & ~b, f = I | f & ~T;
          e: do
            if (!A)
              if ((C & b | 0) == 0 & (I & T | 0) == 0)
                A = 0;
              else if (b = D(h | 0, f | 0, 52) | 0, ye() | 0, b = b & 15, !b)
                A = 1;
              else {
                A = 1;
                t: for (; ; ) {
                  switch (I = D(h | 0, f | 0, (15 - A | 0) * 3 | 0) | 0, ye() | 0, I & 7) {
                    case 1:
                      break t;
                    case 0:
                      break;
                    default: {
                      A = 1;
                      break e;
                    }
                  }
                  if (A >>> 0 < b >>> 0)
                    A = A + 1 | 0;
                  else {
                    A = 1;
                    break e;
                  }
                }
                for (A = 1; ; )
                  if (I = (15 - A | 0) * 3 | 0, T = D(h | 0, f | 0, I | 0) | 0, ye() | 0, C = k(7, 0, I | 0) | 0, f = f & ~(ye() | 0), I = k(Bs(T & 7) | 0, 0, I | 0) | 0, h = h & ~C | I, f = f | (ye() | 0), A >>> 0 < b >>> 0)
                    A = A + 1 | 0;
                  else {
                    A = 1;
                    break;
                  }
              }
          while (!1);
          if (B >>> 0 < F >>> 0)
            B = B + 1 | 0;
          else
            break;
        }
        return hr(f | 0), h | 0;
      }
      function Xs(h, f) {
        h = h | 0, f = f | 0;
        var A = 0, b = 0, T = 0, C = 0, I = 0;
        if (b = D(h | 0, f | 0, 52) | 0, ye() | 0, b = b & 15, !b)
          return A = f, b = h, hr(A | 0), b | 0;
        for (A = 1; C = (15 - A | 0) * 3 | 0, I = D(h | 0, f | 0, C | 0) | 0, ye() | 0, T = k(7, 0, C | 0) | 0, f = f & ~(ye() | 0), C = k(Bs(I & 7) | 0, 0, C | 0) | 0, h = C | h & ~T, f = ye() | 0 | f, A >>> 0 < b >>> 0; )
          A = A + 1 | 0;
        return hr(f | 0), h | 0;
      }
      function _c(h, f) {
        h = h | 0, f = f | 0;
        var A = 0, b = 0, T = 0, C = 0, I = 0, B = 0, F = 0;
        if (F = D(h | 0, f | 0, 52) | 0, ye() | 0, F = F & 15, !F)
          return B = f, F = h, hr(B | 0), F | 0;
        for (B = 1, A = 0; ; ) {
          C = (15 - B | 0) * 3 | 0, b = k(7, 0, C | 0) | 0, T = ye() | 0, I = D(h | 0, f | 0, C | 0) | 0, ye() | 0, C = k(Os(I & 7) | 0, 0, C | 0) | 0, I = ye() | 0, h = C | h & ~b, f = I | f & ~T;
          e: do
            if (!A)
              if ((C & b | 0) == 0 & (I & T | 0) == 0)
                A = 0;
              else if (b = D(h | 0, f | 0, 52) | 0, ye() | 0, b = b & 15, !b)
                A = 1;
              else {
                A = 1;
                t: for (; ; ) {
                  switch (I = D(h | 0, f | 0, (15 - A | 0) * 3 | 0) | 0, ye() | 0, I & 7) {
                    case 1:
                      break t;
                    case 0:
                      break;
                    default: {
                      A = 1;
                      break e;
                    }
                  }
                  if (A >>> 0 < b >>> 0)
                    A = A + 1 | 0;
                  else {
                    A = 1;
                    break e;
                  }
                }
                for (A = 1; ; )
                  if (T = (15 - A | 0) * 3 | 0, C = k(7, 0, T | 0) | 0, I = f & ~(ye() | 0), f = D(h | 0, f | 0, T | 0) | 0, ye() | 0, f = k(Os(f & 7) | 0, 0, T | 0) | 0, h = h & ~C | f, f = I | (ye() | 0), A >>> 0 < b >>> 0)
                    A = A + 1 | 0;
                  else {
                    A = 1;
                    break;
                  }
              }
          while (!1);
          if (B >>> 0 < F >>> 0)
            B = B + 1 | 0;
          else
            break;
        }
        return hr(f | 0), h | 0;
      }
      function Bl(h, f) {
        h = h | 0, f = f | 0;
        var A = 0, b = 0, T = 0, C = 0, I = 0;
        if (b = D(h | 0, f | 0, 52) | 0, ye() | 0, b = b & 15, !b)
          return A = f, b = h, hr(A | 0), b | 0;
        for (A = 1; I = (15 - A | 0) * 3 | 0, C = k(7, 0, I | 0) | 0, T = f & ~(ye() | 0), f = D(h | 0, f | 0, I | 0) | 0, ye() | 0, f = k(Os(f & 7) | 0, 0, I | 0) | 0, h = f | h & ~C, f = ye() | 0 | T, A >>> 0 < b >>> 0; )
          A = A + 1 | 0;
        return hr(f | 0), h | 0;
      }
      function Af(h, f) {
        h = h | 0, f = f | 0;
        var A = 0, b = 0, T = 0, C = 0, I = 0, B = 0, F = 0, z = 0, W = 0;
        if (F = Ae, Ae = Ae + 64 | 0, B = F + 40 | 0, b = F + 24 | 0, T = F + 12 | 0, C = F, k(f | 0, 0, 52) | 0, A = ye() | 0 | 134225919, !f)
          return (d[h + 4 >> 2] | 0) > 2 || (d[h + 8 >> 2] | 0) > 2 || (d[h + 12 >> 2] | 0) > 2 ? (I = 0, B = 0, hr(I | 0), Ae = F, B | 0) : (k(qs(h) | 0, 0, 45) | 0, I = ye() | 0 | A, B = -1, hr(I | 0), Ae = F, B | 0);
        if (d[B >> 2] = d[h >> 2], d[B + 4 >> 2] = d[h + 4 >> 2], d[B + 8 >> 2] = d[h + 8 >> 2], d[B + 12 >> 2] = d[h + 12 >> 2], I = B + 4 | 0, (f | 0) > 0)
          for (h = -1; d[b >> 2] = d[I >> 2], d[b + 4 >> 2] = d[I + 4 >> 2], d[b + 8 >> 2] = d[I + 8 >> 2], f & 1 ? (Ch(I), d[T >> 2] = d[I >> 2], d[T + 4 >> 2] = d[I + 4 >> 2], d[T + 8 >> 2] = d[I + 8 >> 2], El(T)) : (Ui(I), d[T >> 2] = d[I >> 2], d[T + 4 >> 2] = d[I + 4 >> 2], d[T + 8 >> 2] = d[I + 8 >> 2], Rs(T)), fu(b, T, C), qi(C), W = (15 - f | 0) * 3 | 0, z = k(7, 0, W | 0) | 0, A = A & ~(ye() | 0), W = k(hu(C) | 0, 0, W | 0) | 0, h = W | h & ~z, A = ye() | 0 | A, (f | 0) > 1; )
            f = f + -1 | 0;
        else
          h = -1;
        e: do
          if ((d[I >> 2] | 0) <= 2 && (d[B + 8 >> 2] | 0) <= 2 && (d[B + 12 >> 2] | 0) <= 2) {
            if (b = qs(B) | 0, f = k(b | 0, 0, 45) | 0, f = f | h, h = ye() | 0 | A & -1040385, C = wh(B) | 0, !(mn(b) | 0)) {
              if ((C | 0) <= 0)
                break;
              for (T = 0; ; ) {
                if (b = D(f | 0, h | 0, 52) | 0, ye() | 0, b = b & 15, b)
                  for (A = 1; W = (15 - A | 0) * 3 | 0, B = D(f | 0, h | 0, W | 0) | 0, ye() | 0, z = k(7, 0, W | 0) | 0, h = h & ~(ye() | 0), W = k(Bs(B & 7) | 0, 0, W | 0) | 0, f = f & ~z | W, h = h | (ye() | 0), A >>> 0 < b >>> 0; )
                    A = A + 1 | 0;
                if (T = T + 1 | 0, (T | 0) == (C | 0))
                  break e;
              }
            }
            T = D(f | 0, h | 0, 52) | 0, ye() | 0, T = T & 15;
            t: do
              if (T) {
                A = 1;
                r: for (; ; ) {
                  switch (W = D(f | 0, h | 0, (15 - A | 0) * 3 | 0) | 0, ye() | 0, W & 7) {
                    case 1:
                      break r;
                    case 0:
                      break;
                    default:
                      break t;
                  }
                  if (A >>> 0 < T >>> 0)
                    A = A + 1 | 0;
                  else
                    break t;
                }
                if (au(b, d[B >> 2] | 0) | 0)
                  for (A = 1; B = (15 - A | 0) * 3 | 0, z = k(7, 0, B | 0) | 0, W = h & ~(ye() | 0), h = D(f | 0, h | 0, B | 0) | 0, ye() | 0, h = k(Os(h & 7) | 0, 0, B | 0) | 0, f = f & ~z | h, h = W | (ye() | 0), A >>> 0 < T >>> 0; )
                    A = A + 1 | 0;
                else
                  for (A = 1; W = (15 - A | 0) * 3 | 0, B = D(f | 0, h | 0, W | 0) | 0, ye() | 0, z = k(7, 0, W | 0) | 0, h = h & ~(ye() | 0), W = k(Bs(B & 7) | 0, 0, W | 0) | 0, f = f & ~z | W, h = h | (ye() | 0), A >>> 0 < T >>> 0; )
                    A = A + 1 | 0;
              }
            while (!1);
            if ((C | 0) > 0) {
              A = 0;
              do
                f = mu(f, h) | 0, h = ye() | 0, A = A + 1 | 0;
              while ((A | 0) != (C | 0));
            }
          } else
            f = 0, h = 0;
        while (!1);
        return z = h, W = f, hr(z | 0), Ae = F, W | 0;
      }
      function vs(h) {
        return h = h | 0, (h | 0) % 2 | 0 | 0;
      }
      function gf(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0;
        var b = 0, T = 0;
        return T = Ae, Ae = Ae + 16 | 0, b = T, f >>> 0 > 15 ? (b = 4, Ae = T, b | 0) : (d[h + 4 >> 2] & 2146435072 | 0) == 2146435072 || (d[h + 8 + 4 >> 2] & 2146435072 | 0) == 2146435072 ? (b = 3, Ae = T, b | 0) : (Oh(h, f, b), f = Af(b, f) | 0, b = ye() | 0, d[A >> 2] = f, d[A + 4 >> 2] = b, (f | 0) == 0 & (b | 0) == 0 && er(27795, 27122, 959, 27145), b = 0, Ae = T, b | 0);
      }
      function Ol(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0;
        var b = 0, T = 0, C = 0, I = 0;
        if (T = A + 4 | 0, C = D(h | 0, f | 0, 52) | 0, ye() | 0, C = C & 15, I = D(h | 0, f | 0, 45) | 0, ye() | 0, b = (C | 0) == 0, mn(I & 127) | 0) {
          if (b)
            return I = 1, I | 0;
          b = 1;
        } else {
          if (b)
            return I = 0, I | 0;
          (d[T >> 2] | 0) == 0 && (d[A + 8 >> 2] | 0) == 0 ? b = (d[A + 12 >> 2] | 0) != 0 & 1 : b = 1;
        }
        for (A = 1; A & 1 ? El(T) : Rs(T), I = D(h | 0, f | 0, (15 - A | 0) * 3 | 0) | 0, ye() | 0, ta(T, I & 7), A >>> 0 < C >>> 0; )
          A = A + 1 | 0;
        return b | 0;
      }
      function xa(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0;
        var b = 0, T = 0, C = 0, I = 0, B = 0, F = 0, z = 0, W = 0;
        if (W = Ae, Ae = Ae + 16 | 0, F = W, z = D(h | 0, f | 0, 45) | 0, ye() | 0, z = z & 127, z >>> 0 > 121)
          return d[A >> 2] = 0, d[A + 4 >> 2] = 0, d[A + 8 >> 2] = 0, d[A + 12 >> 2] = 0, z = 5, Ae = W, z | 0;
        e: do
          if ((mn(z) | 0) != 0 && (C = D(h | 0, f | 0, 52) | 0, ye() | 0, C = C & 15, (C | 0) != 0)) {
            b = 1;
            t: for (; ; ) {
              switch (B = D(h | 0, f | 0, (15 - b | 0) * 3 | 0) | 0, ye() | 0, B & 7) {
                case 5:
                  break t;
                case 0:
                  break;
                default: {
                  b = f;
                  break e;
                }
              }
              if (b >>> 0 < C >>> 0)
                b = b + 1 | 0;
              else {
                b = f;
                break e;
              }
            }
            for (T = 1, b = f; f = (15 - T | 0) * 3 | 0, I = k(7, 0, f | 0) | 0, B = b & ~(ye() | 0), b = D(h | 0, b | 0, f | 0) | 0, ye() | 0, b = k(Os(b & 7) | 0, 0, f | 0) | 0, h = h & ~I | b, b = B | (ye() | 0), T >>> 0 < C >>> 0; )
              T = T + 1 | 0;
          } else
            b = f;
        while (!1);
        if (B = 7696 + (z * 28 | 0) | 0, d[A >> 2] = d[B >> 2], d[A + 4 >> 2] = d[B + 4 >> 2], d[A + 8 >> 2] = d[B + 8 >> 2], d[A + 12 >> 2] = d[B + 12 >> 2], !(Ol(h, b, A) | 0))
          return z = 0, Ae = W, z | 0;
        if (I = A + 4 | 0, d[F >> 2] = d[I >> 2], d[F + 4 >> 2] = d[I + 4 >> 2], d[F + 8 >> 2] = d[I + 8 >> 2], C = D(h | 0, b | 0, 52) | 0, ye() | 0, B = C & 15, C & 1 ? (Rs(I), C = B + 1 | 0) : C = B, !(mn(z) | 0))
          b = 0;
        else {
          e: do
            if (!B)
              b = 0;
            else
              for (f = 1; ; ) {
                if (T = D(h | 0, b | 0, (15 - f | 0) * 3 | 0) | 0, ye() | 0, T = T & 7, T | 0) {
                  b = T;
                  break e;
                }
                if (f >>> 0 < B >>> 0)
                  f = f + 1 | 0;
                else {
                  b = 0;
                  break;
                }
              }
          while (!1);
          b = (b | 0) == 4 & 1;
        }
        if (!(Vo(A, C, b, 0) | 0))
          (C | 0) != (B | 0) && (d[I >> 2] = d[F >> 2], d[I + 4 >> 2] = d[F + 4 >> 2], d[I + 8 >> 2] = d[F + 8 >> 2]);
        else {
          if (mn(z) | 0)
            do
              ;
            while ((Vo(A, C, 0, 0) | 0) != 0);
          (C | 0) != (B | 0) && Ui(I);
        }
        return z = 0, Ae = W, z | 0;
      }
      function wa(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0;
        var b = 0, T = 0, C = 0;
        return C = Ae, Ae = Ae + 16 | 0, b = C, T = xa(h, f, b) | 0, T | 0 ? (Ae = C, T | 0) : (T = D(h | 0, f | 0, 52) | 0, ye() | 0, qa(b, T & 15, A), T = 0, Ae = C, T | 0);
      }
      function Za(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0;
        var b = 0, T = 0, C = 0, I = 0, B = 0;
        if (I = Ae, Ae = Ae + 16 | 0, C = I, b = xa(h, f, C) | 0, b | 0)
          return C = b, Ae = I, C | 0;
        b = D(h | 0, f | 0, 45) | 0, ye() | 0, b = (mn(b & 127) | 0) == 0, T = D(h | 0, f | 0, 52) | 0, ye() | 0, T = T & 15;
        e: do
          if (!b) {
            if (T | 0)
              for (b = 1; ; ) {
                if (B = k(7, 0, (15 - b | 0) * 3 | 0) | 0, !((B & h | 0) == 0 & ((ye() | 0) & f | 0) == 0))
                  break e;
                if (b >>> 0 < T >>> 0)
                  b = b + 1 | 0;
                else
                  break;
              }
            return na(C, T, 0, 5, A), B = 0, Ae = I, B | 0;
          }
        while (!1);
        return Sl(C, T, 0, 6, A), B = 0, Ae = I, B | 0;
      }
      function _u(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0;
        var b = 0, T = 0, C = 0;
        if (T = D(h | 0, f | 0, 45) | 0, ye() | 0, !(mn(T & 127) | 0))
          return T = 2, d[A >> 2] = T, 0;
        if (T = D(h | 0, f | 0, 52) | 0, ye() | 0, T = T & 15, !T)
          return T = 5, d[A >> 2] = T, 0;
        for (b = 1; ; ) {
          if (C = k(7, 0, (15 - b | 0) * 3 | 0) | 0, !((C & h | 0) == 0 & ((ye() | 0) & f | 0) == 0)) {
            b = 2, h = 6;
            break;
          }
          if (b >>> 0 < T >>> 0)
            b = b + 1 | 0;
          else {
            b = 5, h = 6;
            break;
          }
        }
        return (h | 0) == 6 && (d[A >> 2] = b), 0;
      }
      function yu(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0;
        var b = 0, T = 0, C = 0, I = 0, B = 0, F = 0, z = 0, W = 0, ue = 0;
        ue = Ae, Ae = Ae + 128 | 0, z = ue + 112 | 0, C = ue + 96 | 0, W = ue, T = D(h | 0, f | 0, 52) | 0, ye() | 0, B = T & 15, d[z >> 2] = B, I = D(h | 0, f | 0, 45) | 0, ye() | 0, I = I & 127;
        e: do
          if (mn(I) | 0) {
            if (B | 0)
              for (b = 1; ; ) {
                if (F = k(7, 0, (15 - b | 0) * 3 | 0) | 0, !((F & h | 0) == 0 & ((ye() | 0) & f | 0) == 0)) {
                  T = 0;
                  break e;
                }
                if (b >>> 0 < B >>> 0)
                  b = b + 1 | 0;
                else
                  break;
              }
            if (T & 1)
              T = 1;
            else
              return F = k(B + 1 | 0, 0, 52) | 0, W = ye() | 0 | f & -15728641, z = k(7, 0, (14 - B | 0) * 3 | 0) | 0, W = yu((F | h) & ~z, W & ~(ye() | 0), A) | 0, Ae = ue, W | 0;
          } else
            T = 0;
        while (!1);
        if (b = xa(h, f, C) | 0, !b) {
          T ? (hf(C, z, W), F = 5) : (Dh(C, z, W), F = 6);
          e: do
            if (mn(I) | 0)
              if (!B)
                h = 5;
              else
                for (b = 1; ; ) {
                  if (I = k(7, 0, (15 - b | 0) * 3 | 0) | 0, !((I & h | 0) == 0 & ((ye() | 0) & f | 0) == 0)) {
                    h = 2;
                    break e;
                  }
                  if (b >>> 0 < B >>> 0)
                    b = b + 1 | 0;
                  else {
                    h = 5;
                    break;
                  }
                }
            else
              h = 2;
          while (!1);
          Oe(A | 0, -1, h << 2 | 0) | 0;
          e: do
            if (T)
              for (C = 0; ; ) {
                if (I = W + (C << 4) | 0, Un(I, d[z >> 2] | 0) | 0, I = d[I >> 2] | 0, B = d[A >> 2] | 0, (B | 0) == -1 | (B | 0) == (I | 0))
                  b = A;
                else {
                  T = 0;
                  do {
                    if (T = T + 1 | 0, T >>> 0 >= h >>> 0) {
                      b = 1;
                      break e;
                    }
                    b = A + (T << 2) | 0, B = d[b >> 2] | 0;
                  } while (!((B | 0) == -1 | (B | 0) == (I | 0)));
                }
                if (d[b >> 2] = I, C = C + 1 | 0, C >>> 0 >= F >>> 0) {
                  b = 0;
                  break;
                }
              }
            else
              for (C = 0; ; ) {
                if (I = W + (C << 4) | 0, Vo(I, d[z >> 2] | 0, 0, 1) | 0, I = d[I >> 2] | 0, B = d[A >> 2] | 0, (B | 0) == -1 | (B | 0) == (I | 0))
                  b = A;
                else {
                  T = 0;
                  do {
                    if (T = T + 1 | 0, T >>> 0 >= h >>> 0) {
                      b = 1;
                      break e;
                    }
                    b = A + (T << 2) | 0, B = d[b >> 2] | 0;
                  } while (!((B | 0) == -1 | (B | 0) == (I | 0)));
                }
                if (d[b >> 2] = I, C = C + 1 | 0, C >>> 0 >= F >>> 0) {
                  b = 0;
                  break;
                }
              }
          while (!1);
        }
        return W = b, Ae = ue, W | 0;
      }
      function mf() {
        return 12;
      }
      function yc(h, f) {
        h = h | 0, f = f | 0;
        var A = 0, b = 0, T = 0, C = 0, I = 0, B = 0, F = 0;
        if (h >>> 0 > 15)
          return B = 4, B | 0;
        if (k(h | 0, 0, 52) | 0, B = ye() | 0 | 134225919, !h) {
          A = 0, b = 0;
          do
            mn(b) | 0 && (k(b | 0, 0, 45) | 0, I = B | (ye() | 0), h = f + (A << 3) | 0, d[h >> 2] = -1, d[h + 4 >> 2] = I, A = A + 1 | 0), b = b + 1 | 0;
          while ((b | 0) != 122);
          return A = 0, A | 0;
        }
        A = 0, I = 0;
        do {
          if (mn(I) | 0) {
            for (k(I | 0, 0, 45) | 0, b = 1, T = -1, C = B | (ye() | 0); F = k(7, 0, (15 - b | 0) * 3 | 0) | 0, T = T & ~F, C = C & ~(ye() | 0), (b | 0) != (h | 0); )
              b = b + 1 | 0;
            F = f + (A << 3) | 0, d[F >> 2] = T, d[F + 4 >> 2] = C, A = A + 1 | 0;
          }
          I = I + 1 | 0;
        } while ((I | 0) != 122);
        return A = 0, A | 0;
      }
      function vc(h, f, A, b) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0;
        var T = 0, C = 0, I = 0, B = 0, F = 0, z = 0, W = 0, ue = 0, Ie = 0, Re = 0, Be = 0, Ze = 0, We = 0, rt = 0, et = 0;
        if (et = Ae, Ae = Ae + 16 | 0, We = et, rt = D(h | 0, f | 0, 52) | 0, ye() | 0, rt = rt & 15, A >>> 0 > 15)
          return rt = 4, Ae = et, rt | 0;
        if ((rt | 0) < (A | 0))
          return rt = 12, Ae = et, rt | 0;
        if ((rt | 0) != (A | 0))
          if (C = k(A | 0, 0, 52) | 0, C = C | h, B = ye() | 0 | f & -15728641, (rt | 0) > (A | 0)) {
            F = A;
            do
              Ze = k(7, 0, (14 - F | 0) * 3 | 0) | 0, F = F + 1 | 0, C = Ze | C, B = ye() | 0 | B;
            while ((F | 0) < (rt | 0));
            Ze = C;
          } else
            Ze = C;
        else
          Ze = h, B = f;
        Be = D(Ze | 0, B | 0, 45) | 0, ye() | 0;
        e: do
          if (mn(Be & 127) | 0) {
            if (F = D(Ze | 0, B | 0, 52) | 0, ye() | 0, F = F & 15, F | 0)
              for (C = 1; ; ) {
                if (Be = k(7, 0, (15 - C | 0) * 3 | 0) | 0, !((Be & Ze | 0) == 0 & ((ye() | 0) & B | 0) == 0)) {
                  z = 33;
                  break e;
                }
                if (C >>> 0 < F >>> 0)
                  C = C + 1 | 0;
                else
                  break;
              }
            if (Be = b, d[Be >> 2] = 0, d[Be + 4 >> 2] = 0, (rt | 0) > (A | 0)) {
              for (Be = f & -15728641, Re = rt; ; ) {
                if (Ie = Re, Re = Re + -1 | 0, Re >>> 0 > 15 | (rt | 0) < (Re | 0)) {
                  z = 19;
                  break;
                }
                if ((rt | 0) != (Re | 0))
                  if (C = k(Re | 0, 0, 52) | 0, C = C | h, F = ye() | 0 | Be, (rt | 0) < (Ie | 0))
                    ue = C;
                  else {
                    z = Re;
                    do
                      ue = k(7, 0, (14 - z | 0) * 3 | 0) | 0, z = z + 1 | 0, C = ue | C, F = ye() | 0 | F;
                    while ((z | 0) < (rt | 0));
                    ue = C;
                  }
                else
                  ue = h, F = f;
                if (W = D(ue | 0, F | 0, 45) | 0, ye() | 0, !(mn(W & 127) | 0))
                  C = 0;
                else {
                  W = D(ue | 0, F | 0, 52) | 0, ye() | 0, W = W & 15;
                  t: do
                    if (!W)
                      C = 0;
                    else
                      for (z = 1; ; ) {
                        if (C = D(ue | 0, F | 0, (15 - z | 0) * 3 | 0) | 0, ye() | 0, C = C & 7, C | 0)
                          break t;
                        if (z >>> 0 < W >>> 0)
                          z = z + 1 | 0;
                        else {
                          C = 0;
                          break;
                        }
                      }
                  while (!1);
                  C = (C | 0) == 0 & 1;
                }
                if (F = D(h | 0, f | 0, (15 - Ie | 0) * 3 | 0) | 0, ye() | 0, F = F & 7, (F | 0) == 7) {
                  T = 5, z = 42;
                  break;
                }
                if (C = (C | 0) != 0, (F | 0) == 1 & C) {
                  T = 5, z = 42;
                  break;
                }
                if (ue = F + (((F | 0) != 0 & C) << 31 >> 31) | 0, ue | 0 && (z = rt - Ie | 0, z = Si(7, 0, z, ((z | 0) < 0) << 31 >> 31) | 0, W = ye() | 0, C ? (C = v(z | 0, W | 0, 5, 0) | 0, C = Er(C | 0, ye() | 0, -5, -1) | 0, C = Mo(C | 0, ye() | 0, 6, 0) | 0, C = Er(C | 0, ye() | 0, 1, 0) | 0, F = ye() | 0) : (C = z, F = W), Ie = ue + -1 | 0, Ie = v(z | 0, W | 0, Ie | 0, ((Ie | 0) < 0) << 31 >> 31 | 0) | 0, Ie = Er(C | 0, F | 0, Ie | 0, ye() | 0) | 0, ue = ye() | 0, W = b, W = Er(Ie | 0, ue | 0, d[W >> 2] | 0, d[W + 4 >> 2] | 0) | 0, ue = ye() | 0, Ie = b, d[Ie >> 2] = W, d[Ie + 4 >> 2] = ue), (Re | 0) <= (A | 0)) {
                  z = 37;
                  break;
                }
              }
              if ((z | 0) == 19)
                er(27795, 27122, 1276, 27158);
              else if ((z | 0) == 37) {
                I = b, T = d[I + 4 >> 2] | 0, I = d[I >> 2] | 0;
                break;
              } else if ((z | 0) == 42)
                return Ae = et, T | 0;
            } else
              T = 0, I = 0;
          } else
            z = 33;
        while (!1);
        e: do
          if ((z | 0) == 33)
            if (Be = b, d[Be >> 2] = 0, d[Be + 4 >> 2] = 0, (rt | 0) > (A | 0)) {
              for (C = rt; ; ) {
                if (T = D(h | 0, f | 0, (15 - C | 0) * 3 | 0) | 0, ye() | 0, T = T & 7, (T | 0) == 7) {
                  T = 5;
                  break;
                }
                if (I = rt - C | 0, I = Si(7, 0, I, ((I | 0) < 0) << 31 >> 31) | 0, T = v(I | 0, ye() | 0, T | 0, 0) | 0, I = ye() | 0, Be = b, I = Er(d[Be >> 2] | 0, d[Be + 4 >> 2] | 0, T | 0, I | 0) | 0, T = ye() | 0, Be = b, d[Be >> 2] = I, d[Be + 4 >> 2] = T, C = C + -1 | 0, (C | 0) <= (A | 0))
                  break e;
              }
              return Ae = et, T | 0;
            } else
              T = 0, I = 0;
        while (!1);
        return jo(Ze, B, rt, We) | 0 && er(27795, 27122, 1236, 27173), rt = We, We = d[rt + 4 >> 2] | 0, ((T | 0) > -1 | (T | 0) == -1 & I >>> 0 > 4294967295) & ((We | 0) > (T | 0) | ((We | 0) == (T | 0) ? (d[rt >> 2] | 0) >>> 0 > I >>> 0 : 0)) ? (rt = 0, Ae = et, rt | 0) : (er(27795, 27122, 1316, 27158), 0);
      }
      function Fh(h, f, A, b, T, C) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0, T = T | 0, C = C | 0;
        var I = 0, B = 0, F = 0, z = 0, W = 0, ue = 0, Ie = 0, Re = 0, Be = 0, Ze = 0;
        if (ue = Ae, Ae = Ae + 16 | 0, I = ue, T >>> 0 > 15)
          return C = 4, Ae = ue, C | 0;
        if (B = D(A | 0, b | 0, 52) | 0, ye() | 0, B = B & 15, (B | 0) > (T | 0))
          return C = 12, Ae = ue, C | 0;
        if (jo(A, b, T, I) | 0 && er(27795, 27122, 1236, 27173), W = I, z = d[W + 4 >> 2] | 0, !(((f | 0) > -1 | (f | 0) == -1 & h >>> 0 > 4294967295) & ((z | 0) > (f | 0) | ((z | 0) == (f | 0) ? (d[W >> 2] | 0) >>> 0 > h >>> 0 : 0))))
          return C = 2, Ae = ue, C | 0;
        W = T - B | 0, T = k(T | 0, 0, 52) | 0, F = ye() | 0 | b & -15728641, z = C, d[z >> 2] = T | A, d[z + 4 >> 2] = F, z = D(A | 0, b | 0, 45) | 0, ye() | 0;
        e: do
          if (mn(z & 127) | 0) {
            if (B | 0)
              for (I = 1; ; ) {
                if (z = k(7, 0, (15 - I | 0) * 3 | 0) | 0, !((z & A | 0) == 0 & ((ye() | 0) & b | 0) == 0))
                  break e;
                if (I >>> 0 < B >>> 0)
                  I = I + 1 | 0;
                else
                  break;
              }
            if ((W | 0) < 1)
              return C = 0, Ae = ue, C | 0;
            for (z = B ^ 15, b = -1, F = 1, I = 1; ; ) {
              B = W - F | 0, B = Si(7, 0, B, ((B | 0) < 0) << 31 >> 31) | 0, A = ye() | 0;
              do
                if (I)
                  if (I = v(B | 0, A | 0, 5, 0) | 0, I = Er(I | 0, ye() | 0, -5, -1) | 0, I = Mo(I | 0, ye() | 0, 6, 0) | 0, T = ye() | 0, (f | 0) > (T | 0) | (f | 0) == (T | 0) & h >>> 0 > I >>> 0) {
                    f = Er(h | 0, f | 0, -1, -1) | 0, f = Vi(f | 0, ye() | 0, I | 0, T | 0) | 0, I = ye() | 0, Ie = C, Be = d[Ie >> 2] | 0, Ie = d[Ie + 4 >> 2] | 0, Ze = (z + b | 0) * 3 | 0, Re = k(7, 0, Ze | 0) | 0, Ie = Ie & ~(ye() | 0), b = Mo(f | 0, I | 0, B | 0, A | 0) | 0, h = ye() | 0, T = Er(b | 0, h | 0, 2, 0) | 0, Ze = k(T | 0, ye() | 0, Ze | 0) | 0, Ie = ye() | 0 | Ie, T = C, d[T >> 2] = Ze | Be & ~Re, d[T + 4 >> 2] = Ie, h = v(b | 0, h | 0, B | 0, A | 0) | 0, h = Vi(f | 0, I | 0, h | 0, ye() | 0) | 0, I = 0, f = ye() | 0;
                    break;
                  } else {
                    Ze = C, Re = d[Ze >> 2] | 0, Ze = d[Ze + 4 >> 2] | 0, Be = k(7, 0, (z + b | 0) * 3 | 0) | 0, Ze = Ze & ~(ye() | 0), I = C, d[I >> 2] = Re & ~Be, d[I + 4 >> 2] = Ze, I = 1;
                    break;
                  }
                else
                  Re = C, T = d[Re >> 2] | 0, Re = d[Re + 4 >> 2] | 0, b = (z + b | 0) * 3 | 0, Ie = k(7, 0, b | 0) | 0, Re = Re & ~(ye() | 0), Ze = Mo(h | 0, f | 0, B | 0, A | 0) | 0, I = ye() | 0, b = k(Ze | 0, I | 0, b | 0) | 0, Re = ye() | 0 | Re, Be = C, d[Be >> 2] = b | T & ~Ie, d[Be + 4 >> 2] = Re, I = v(Ze | 0, I | 0, B | 0, A | 0) | 0, h = Vi(h | 0, f | 0, I | 0, ye() | 0) | 0, I = 0, f = ye() | 0;
              while (!1);
              if ((W | 0) > (F | 0))
                b = ~F, F = F + 1 | 0;
              else {
                f = 0;
                break;
              }
            }
            return Ae = ue, f | 0;
          }
        while (!1);
        if ((W | 0) < 1)
          return Ze = 0, Ae = ue, Ze | 0;
        for (T = B ^ 15, I = 1; ; )
          if (Be = W - I | 0, Be = Si(7, 0, Be, ((Be | 0) < 0) << 31 >> 31) | 0, Ze = ye() | 0, F = C, A = d[F >> 2] | 0, F = d[F + 4 >> 2] | 0, B = (T - I | 0) * 3 | 0, b = k(7, 0, B | 0) | 0, F = F & ~(ye() | 0), Ie = Mo(h | 0, f | 0, Be | 0, Ze | 0) | 0, Re = ye() | 0, B = k(Ie | 0, Re | 0, B | 0) | 0, F = ye() | 0 | F, z = C, d[z >> 2] = B | A & ~b, d[z + 4 >> 2] = F, Ze = v(Ie | 0, Re | 0, Be | 0, Ze | 0) | 0, h = Vi(h | 0, f | 0, Ze | 0, ye() | 0) | 0, f = ye() | 0, (W | 0) <= (I | 0)) {
            f = 0;
            break;
          } else
            I = I + 1 | 0;
        return Ae = ue, f | 0;
      }
      function ia(h, f, A, b) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0;
        var T = 0, C = 0, I = 0;
        T = D(f | 0, A | 0, 52) | 0, ye() | 0, T = T & 15, (f | 0) == 0 & (A | 0) == 0 | ((b | 0) > 15 | (T | 0) > (b | 0)) ? (C = -1, f = -1, A = 0, T = 0) : (f = Ml(f, A, T + 1 | 0, b) | 0, I = (ye() | 0) & -15728641, A = k(b | 0, 0, 52) | 0, A = f | A, I = I | (ye() | 0), f = (Bn(A, I) | 0) == 0, C = T, f = f ? -1 : b, T = I), I = h, d[I >> 2] = A, d[I + 4 >> 2] = T, d[h + 8 >> 2] = C, d[h + 12 >> 2] = f;
      }
      function Gn(h, f, A, b) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0;
        var T = 0, C = 0;
        if (T = D(h | 0, f | 0, 52) | 0, ye() | 0, T = T & 15, C = b + 8 | 0, d[C >> 2] = T, (h | 0) == 0 & (f | 0) == 0 | ((A | 0) > 15 | (T | 0) > (A | 0))) {
          A = b, d[A >> 2] = 0, d[A + 4 >> 2] = 0, d[C >> 2] = -1, d[b + 12 >> 2] = -1;
          return;
        }
        if (h = Ml(h, f, T + 1 | 0, A) | 0, C = (ye() | 0) & -15728641, T = k(A | 0, 0, 52) | 0, T = h | T, C = C | (ye() | 0), h = b, d[h >> 2] = T, d[h + 4 >> 2] = C, h = b + 12 | 0, Bn(T, C) | 0) {
          d[h >> 2] = A;
          return;
        } else {
          d[h >> 2] = -1;
          return;
        }
      }
      function Dl(h) {
        h = h | 0;
        var f = 0, A = 0, b = 0, T = 0, C = 0, I = 0, B = 0, F = 0, z = 0;
        if (A = h, f = d[A >> 2] | 0, A = d[A + 4 >> 2] | 0, !((f | 0) == 0 & (A | 0) == 0) && (b = D(f | 0, A | 0, 52) | 0, ye() | 0, b = b & 15, B = k(1, 0, (b ^ 15) * 3 | 0) | 0, f = Er(B | 0, ye() | 0, f | 0, A | 0) | 0, A = ye() | 0, B = h, d[B >> 2] = f, d[B + 4 >> 2] = A, B = h + 8 | 0, I = d[B >> 2] | 0, !((b | 0) < (I | 0)))) {
          for (F = h + 12 | 0, C = b; ; ) {
            if ((C | 0) == (I | 0)) {
              b = 5;
              break;
            }
            if (z = (C | 0) == (d[F >> 2] | 0), T = (15 - C | 0) * 3 | 0, b = D(f | 0, A | 0, T | 0) | 0, ye() | 0, b = b & 7, z & ((b | 0) == 1 & !0)) {
              b = 7;
              break;
            }
            if (!((b | 0) == 7 & !0)) {
              b = 10;
              break;
            }
            if (z = k(1, 0, T | 0) | 0, f = Er(f | 0, A | 0, z | 0, ye() | 0) | 0, A = ye() | 0, z = h, d[z >> 2] = f, d[z + 4 >> 2] = A, (C | 0) > (I | 0))
              C = C + -1 | 0;
            else {
              b = 10;
              break;
            }
          }
          if ((b | 0) == 5) {
            z = h, d[z >> 2] = 0, d[z + 4 >> 2] = 0, d[B >> 2] = -1, d[F >> 2] = -1;
            return;
          } else if ((b | 0) == 7) {
            I = k(1, 0, T | 0) | 0, I = Er(f | 0, A | 0, I | 0, ye() | 0) | 0, B = ye() | 0, z = h, d[z >> 2] = I, d[z + 4 >> 2] = B, d[F >> 2] = C + -1;
            return;
          } else if ((b | 0) == 10)
            return;
        }
      }
      function bo(h) {
        h = +h;
        var f = 0;
        return f = h < 0 ? h + 6.283185307179586 : h, +(h >= 6.283185307179586 ? f + -6.283185307179586 : f);
      }
      function Zs(h, f) {
        return h = h | 0, f = f | 0, +kt(+(+ee[h >> 3] - +ee[f >> 3])) < 17453292519943298e-27 ? (f = +kt(+(+ee[h + 8 >> 3] - +ee[f + 8 >> 3])) < 17453292519943298e-27, f | 0) : (f = 0, f | 0);
      }
      function qr(h, f) {
        switch (h = +h, f = f | 0, f | 0) {
          case 1: {
            h = h < 0 ? h + 6.283185307179586 : h;
            break;
          }
          case 2: {
            h = h > 0 ? h + -6.283185307179586 : h;
            break;
          }
        }
        return +h;
      }
      function zn(h, f) {
        h = h | 0, f = f | 0;
        var A = 0, b = 0, T = 0, C = 0;
        return T = +ee[f >> 3], b = +ee[h >> 3], C = +Lt(+((T - b) * 0.5)), A = +Lt(+((+ee[f + 8 >> 3] - +ee[h + 8 >> 3]) * 0.5)), A = C * C + A * (+Vt(+T) * +Vt(+b) * A), +(+un(+ +zt(+A), + +zt(+(1 - A))) * 2);
      }
      function ns(h, f) {
        h = h | 0, f = f | 0;
        var A = 0, b = 0, T = 0, C = 0;
        return T = +ee[f >> 3], b = +ee[h >> 3], C = +Lt(+((T - b) * 0.5)), A = +Lt(+((+ee[f + 8 >> 3] - +ee[h + 8 >> 3]) * 0.5)), A = C * C + A * (+Vt(+T) * +Vt(+b) * A), +(+un(+ +zt(+A), + +zt(+(1 - A))) * 2 * 6371.007180918475);
      }
      function bc(h, f) {
        h = h | 0, f = f | 0;
        var A = 0, b = 0, T = 0, C = 0;
        return T = +ee[f >> 3], b = +ee[h >> 3], C = +Lt(+((T - b) * 0.5)), A = +Lt(+((+ee[f + 8 >> 3] - +ee[h + 8 >> 3]) * 0.5)), A = C * C + A * (+Vt(+T) * +Vt(+b) * A), +(+un(+ +zt(+A), + +zt(+(1 - A))) * 2 * 6371.007180918475 * 1e3);
      }
      function Ll(h, f) {
        h = h | 0, f = f | 0;
        var A = 0, b = 0, T = 0, C = 0, I = 0;
        return C = +ee[f >> 3], b = +Vt(+C), T = +ee[f + 8 >> 3] - +ee[h + 8 >> 3], I = b * +Lt(+T), A = +ee[h >> 3], + +un(+I, +(+Lt(+C) * +Vt(+A) - +Vt(+T) * (b * +Lt(+A))));
      }
      function xc(h, f, A, b) {
        h = h | 0, f = +f, A = +A, b = b | 0;
        var T = 0, C = 0, I = 0, B = 0;
        if (A < 1e-16) {
          d[b >> 2] = d[h >> 2], d[b + 4 >> 2] = d[h + 4 >> 2], d[b + 8 >> 2] = d[h + 8 >> 2], d[b + 12 >> 2] = d[h + 12 >> 2];
          return;
        }
        C = f < 0 ? f + 6.283185307179586 : f, C = f >= 6.283185307179586 ? C + -6.283185307179586 : C;
        do
          if (C < 1e-16)
            f = +ee[h >> 3] + A, ee[b >> 3] = f, T = b;
          else {
            if (T = +kt(+(C + -3.141592653589793)) < 1e-16, f = +ee[h >> 3], T) {
              f = f - A, ee[b >> 3] = f, T = b;
              break;
            }
            if (I = +Vt(+A), A = +Lt(+A), f = I * +Lt(+f) + +Vt(+C) * (A * +Vt(+f)), f = f > 1 ? 1 : f, f = +ir(+(f < -1 ? -1 : f)), ee[b >> 3] = f, +kt(+(f + -1.5707963267948966)) < 1e-16) {
              ee[b >> 3] = 1.5707963267948966, ee[b + 8 >> 3] = 0;
              return;
            }
            if (+kt(+(f + 1.5707963267948966)) < 1e-16) {
              ee[b >> 3] = -1.5707963267948966, ee[b + 8 >> 3] = 0;
              return;
            }
            if (B = 1 / +Vt(+f), C = A * +Lt(+C) * B, A = +ee[h >> 3], f = B * ((I - +Lt(+f) * +Lt(+A)) / +Vt(+A)), I = C > 1 ? 1 : C, f = f > 1 ? 1 : f, f = +ee[h + 8 >> 3] + +un(+(I < -1 ? -1 : I), +(f < -1 ? -1 : f)), f > 3.141592653589793)
              do
                f = f + -6.283185307179586;
              while (f > 3.141592653589793);
            if (f < -3.141592653589793)
              do
                f = f + 6.283185307179586;
              while (f < -3.141592653589793);
            ee[b + 8 >> 3] = f;
            return;
          }
        while (!1);
        if (+kt(+(f + -1.5707963267948966)) < 1e-16) {
          ee[T >> 3] = 1.5707963267948966, ee[b + 8 >> 3] = 0;
          return;
        }
        if (+kt(+(f + 1.5707963267948966)) < 1e-16) {
          ee[T >> 3] = -1.5707963267948966, ee[b + 8 >> 3] = 0;
          return;
        }
        if (f = +ee[h + 8 >> 3], f > 3.141592653589793)
          do
            f = f + -6.283185307179586;
          while (f > 3.141592653589793);
        if (f < -3.141592653589793)
          do
            f = f + 6.283185307179586;
          while (f < -3.141592653589793);
        ee[b + 8 >> 3] = f;
      }
      function Nh(h, f) {
        return h = h | 0, f = f | 0, h >>> 0 > 15 ? (f = 4, f | 0) : (ee[f >> 3] = +ee[20656 + (h << 3) >> 3], f = 0, f | 0);
      }
      function Wp(h, f) {
        return h = h | 0, f = f | 0, h >>> 0 > 15 ? (f = 4, f | 0) : (ee[f >> 3] = +ee[20784 + (h << 3) >> 3], f = 0, f | 0);
      }
      function wc(h, f) {
        return h = h | 0, f = f | 0, h >>> 0 > 15 ? (f = 4, f | 0) : (ee[f >> 3] = +ee[20912 + (h << 3) >> 3], f = 0, f | 0);
      }
      function Tc(h, f) {
        return h = h | 0, f = f | 0, h >>> 0 > 15 ? (f = 4, f | 0) : (ee[f >> 3] = +ee[21040 + (h << 3) >> 3], f = 0, f | 0);
      }
      function ao(h, f) {
        h = h | 0, f = f | 0;
        var A = 0;
        return h >>> 0 > 15 ? (f = 4, f | 0) : (A = Si(7, 0, h, ((h | 0) < 0) << 31 >> 31) | 0, A = v(A | 0, ye() | 0, 120, 0) | 0, h = ye() | 0, d[f >> 2] = A | 2, d[f + 4 >> 2] = h, f = 0, f | 0);
      }
      function xi(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0;
        var b = 0, T = 0, C = 0, I = 0, B = 0, F = 0, z = 0, W = 0, ue = 0, Ie = 0;
        return Ie = +ee[f >> 3], W = +ee[h >> 3], F = +Lt(+((Ie - W) * 0.5)), C = +ee[f + 8 >> 3], z = +ee[h + 8 >> 3], I = +Lt(+((C - z) * 0.5)), B = +Vt(+W), ue = +Vt(+Ie), I = F * F + I * (ue * B * I), I = +un(+ +zt(+I), + +zt(+(1 - I))) * 2, F = +ee[A >> 3], Ie = +Lt(+((F - Ie) * 0.5)), b = +ee[A + 8 >> 3], C = +Lt(+((b - C) * 0.5)), T = +Vt(+F), C = Ie * Ie + C * (ue * T * C), C = +un(+ +zt(+C), + +zt(+(1 - C))) * 2, F = +Lt(+((W - F) * 0.5)), b = +Lt(+((z - b) * 0.5)), b = F * F + b * (B * T * b), b = +un(+ +zt(+b), + +zt(+(1 - b))) * 2, T = (I + C + b) * 0.5, +(+nn(+ +zt(+(+Yt(+(T * 0.5)) * +Yt(+((T - I) * 0.5)) * +Yt(+((T - C) * 0.5)) * +Yt(+((T - b) * 0.5))))) * 4);
      }
      function Ya(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0;
        var b = 0, T = 0, C = 0, I = 0, B = 0;
        if (B = Ae, Ae = Ae + 192 | 0, C = B + 168 | 0, I = B, T = wa(h, f, C) | 0, T | 0)
          return A = T, Ae = B, A | 0;
        if (Za(h, f, I) | 0 && er(27795, 27190, 415, 27199), f = d[I >> 2] | 0, (f | 0) > 0) {
          if (b = +xi(I + 8 | 0, I + 8 + (((f | 0) != 1 & 1) << 4) | 0, C) + 0, (f | 0) != 1) {
            h = 1;
            do
              T = h, h = h + 1 | 0, b = b + +xi(I + 8 + (T << 4) | 0, I + 8 + (((h | 0) % (f | 0) | 0) << 4) | 0, C);
            while ((h | 0) < (f | 0));
          }
        } else
          b = 0;
        return ee[A >> 3] = b, A = 0, Ae = B, A | 0;
      }
      function Uh(h, f, A) {
        return h = h | 0, f = f | 0, A = A | 0, h = Ya(h, f, A) | 0, h | 0 || (ee[A >> 3] = +ee[A >> 3] * 6371.007180918475 * 6371.007180918475), h | 0;
      }
      function wi(h, f, A) {
        return h = h | 0, f = f | 0, A = A | 0, h = Ya(h, f, A) | 0, h | 0 || (ee[A >> 3] = +ee[A >> 3] * 6371.007180918475 * 6371.007180918475 * 1e3 * 1e3), h | 0;
      }
      function ur(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0;
        var b = 0, T = 0, C = 0, I = 0, B = 0, F = 0, z = 0, W = 0;
        if (B = Ae, Ae = Ae + 176 | 0, I = B, h = mc(h, f, I) | 0, h | 0)
          return I = h, Ae = B, I | 0;
        if (ee[A >> 3] = 0, h = d[I >> 2] | 0, (h | 0) <= 1)
          return I = 0, Ae = B, I | 0;
        f = h + -1 | 0, h = 0, b = +ee[I + 8 >> 3], T = +ee[I + 16 >> 3], C = 0;
        do
          h = h + 1 | 0, z = b, b = +ee[I + 8 + (h << 4) >> 3], W = +Lt(+((b - z) * 0.5)), F = T, T = +ee[I + 8 + (h << 4) + 8 >> 3], F = +Lt(+((T - F) * 0.5)), F = W * W + F * (+Vt(+b) * +Vt(+z) * F), C = C + +un(+ +zt(+F), + +zt(+(1 - F))) * 2;
        while ((h | 0) < (f | 0));
        return ee[A >> 3] = C, I = 0, Ae = B, I | 0;
      }
      function Ds(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0;
        var b = 0, T = 0, C = 0, I = 0, B = 0, F = 0, z = 0, W = 0;
        if (B = Ae, Ae = Ae + 176 | 0, I = B, h = mc(h, f, I) | 0, h | 0)
          return I = h, C = +ee[A >> 3], C = C * 6371.007180918475, ee[A >> 3] = C, Ae = B, I | 0;
        if (ee[A >> 3] = 0, h = d[I >> 2] | 0, (h | 0) <= 1)
          return I = 0, C = 0, C = C * 6371.007180918475, ee[A >> 3] = C, Ae = B, I | 0;
        f = h + -1 | 0, h = 0, b = +ee[I + 8 >> 3], T = +ee[I + 16 >> 3], C = 0;
        do
          h = h + 1 | 0, z = b, b = +ee[I + 8 + (h << 4) >> 3], W = +Lt(+((b - z) * 0.5)), F = T, T = +ee[I + 8 + (h << 4) + 8 >> 3], F = +Lt(+((T - F) * 0.5)), F = W * W + F * (+Vt(+z) * +Vt(+b) * F), C = C + +un(+ +zt(+F), + +zt(+(1 - F))) * 2;
        while ((h | 0) != (f | 0));
        return ee[A >> 3] = C, I = 0, W = C, W = W * 6371.007180918475, ee[A >> 3] = W, Ae = B, I | 0;
      }
      function vu(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0;
        var b = 0, T = 0, C = 0, I = 0, B = 0, F = 0, z = 0, W = 0;
        if (B = Ae, Ae = Ae + 176 | 0, I = B, h = mc(h, f, I) | 0, h | 0)
          return I = h, C = +ee[A >> 3], C = C * 6371.007180918475, C = C * 1e3, ee[A >> 3] = C, Ae = B, I | 0;
        if (ee[A >> 3] = 0, h = d[I >> 2] | 0, (h | 0) <= 1)
          return I = 0, C = 0, C = C * 6371.007180918475, C = C * 1e3, ee[A >> 3] = C, Ae = B, I | 0;
        f = h + -1 | 0, h = 0, b = +ee[I + 8 >> 3], T = +ee[I + 16 >> 3], C = 0;
        do
          h = h + 1 | 0, z = b, b = +ee[I + 8 + (h << 4) >> 3], W = +Lt(+((b - z) * 0.5)), F = T, T = +ee[I + 8 + (h << 4) + 8 >> 3], F = +Lt(+((T - F) * 0.5)), F = W * W + F * (+Vt(+z) * +Vt(+b) * F), C = C + +un(+ +zt(+F), + +zt(+(1 - F))) * 2;
        while ((h | 0) != (f | 0));
        return ee[A >> 3] = C, I = 0, W = C, W = W * 6371.007180918475, W = W * 1e3, ee[A >> 3] = W, Ae = B, I | 0;
      }
      function kl(h) {
        h = h | 0;
        var f = 0, A = 0, b = 0;
        return f = Ii(1, 12) | 0, f || er(27280, 27235, 49, 27293), A = h + 4 | 0, b = d[A >> 2] | 0, b | 0 ? (b = b + 8 | 0, d[b >> 2] = f, d[A >> 2] = f, f | 0) : (d[h >> 2] | 0 && er(27310, 27235, 61, 27333), b = h, d[b >> 2] = f, d[A >> 2] = f, f | 0);
      }
      function xo(h, f) {
        h = h | 0, f = f | 0;
        var A = 0, b = 0;
        return b = ss(24) | 0, b || er(27347, 27235, 78, 27361), d[b >> 2] = d[f >> 2], d[b + 4 >> 2] = d[f + 4 >> 2], d[b + 8 >> 2] = d[f + 8 >> 2], d[b + 12 >> 2] = d[f + 12 >> 2], d[b + 16 >> 2] = 0, f = h + 4 | 0, A = d[f >> 2] | 0, A | 0 ? (d[A + 16 >> 2] = b, d[f >> 2] = b, b | 0) : (d[h >> 2] | 0 && er(27376, 27235, 82, 27361), d[h >> 2] = b, d[f >> 2] = b, b | 0);
      }
      function bs(h) {
        h = h | 0;
        var f = 0, A = 0, b = 0, T = 0;
        if (h)
          for (b = 1; ; ) {
            if (f = d[h >> 2] | 0, f | 0)
              do {
                if (A = d[f >> 2] | 0, A | 0)
                  do
                    T = A, A = d[A + 16 >> 2] | 0, Ur(T);
                  while ((A | 0) != 0);
                T = f, f = d[f + 8 >> 2] | 0, Ur(T);
              } while ((f | 0) != 0);
            if (f = h, h = d[h + 8 >> 2] | 0, b || Ur(f), h)
              b = 0;
            else
              break;
          }
      }
      function _f(h) {
        h = h | 0;
        var f = 0, A = 0, b = 0, T = 0, C = 0, I = 0, B = 0, F = 0, z = 0, W = 0, ue = 0, Ie = 0, Re = 0, Be = 0, Ze = 0, We = 0, rt = 0, et = 0, Je = 0, $e = 0, Bt = 0, Ht = 0, Ut = 0, Or = 0, Cr = 0, Gr = 0, Sr = 0, ar = 0, jt = 0, Wr = 0, fn = 0, Zr = 0;
        if (T = h + 8 | 0, d[T >> 2] | 0)
          return Zr = 1, Zr | 0;
        if (b = d[h >> 2] | 0, !b)
          return Zr = 0, Zr | 0;
        f = b, A = 0;
        do
          A = A + 1 | 0, f = d[f + 8 >> 2] | 0;
        while ((f | 0) != 0);
        if (A >>> 0 < 2)
          return Zr = 0, Zr | 0;
        Wr = ss(A << 2) | 0, Wr || er(27396, 27235, 317, 27415), jt = ss(A << 5) | 0, jt || er(27437, 27235, 321, 27415), d[h >> 2] = 0, Ht = h + 4 | 0, d[Ht >> 2] = 0, d[T >> 2] = 0, A = 0, ar = 0, Bt = 0, ue = 0;
        e: for (; ; ) {
          if (W = d[b >> 2] | 0, W) {
            C = 0, I = W;
            do {
              if (F = +ee[I + 8 >> 3], f = I, I = d[I + 16 >> 2] | 0, z = (I | 0) == 0, T = z ? W : I, B = +ee[T + 8 >> 3], +kt(+(F - B)) > 3.141592653589793) {
                Zr = 14;
                break;
              }
              C = C + (B - F) * (+ee[f >> 3] + +ee[T >> 3]);
            } while (!z);
            if ((Zr | 0) == 14) {
              Zr = 0, C = 0, f = W;
              do
                $e = +ee[f + 8 >> 3], Sr = f + 16 | 0, Gr = d[Sr >> 2] | 0, Gr = (Gr | 0) == 0 ? W : Gr, Je = +ee[Gr + 8 >> 3], C = C + (+ee[f >> 3] + +ee[Gr >> 3]) * ((Je < 0 ? Je + 6.283185307179586 : Je) - ($e < 0 ? $e + 6.283185307179586 : $e)), f = d[((f | 0) == 0 ? b : Sr) >> 2] | 0;
              while ((f | 0) != 0);
            }
            C > 0 ? (d[Wr + (ar << 2) >> 2] = b, ar = ar + 1 | 0, T = Bt, f = ue) : Zr = 19;
          } else
            Zr = 19;
          if ((Zr | 0) == 19) {
            Zr = 0;
            do
              if (A) {
                if (f = A + 8 | 0, d[f >> 2] | 0) {
                  Zr = 21;
                  break e;
                }
                if (A = Ii(1, 12) | 0, !A) {
                  Zr = 23;
                  break e;
                }
                d[f >> 2] = A, T = A + 4 | 0, I = A, f = ue;
              } else if (ue) {
                T = Ht, I = ue + 8 | 0, f = b, A = h;
                break;
              } else if (d[h >> 2] | 0) {
                Zr = 27;
                break e;
              } else {
                T = Ht, I = h, f = b, A = h;
                break;
              }
            while (!1);
            if (d[I >> 2] = b, d[T >> 2] = b, I = jt + (Bt << 5) | 0, z = d[b >> 2] | 0, z) {
              for (W = jt + (Bt << 5) + 8 | 0, ee[W >> 3] = 17976931348623157e292, ue = jt + (Bt << 5) + 24 | 0, ee[ue >> 3] = 17976931348623157e292, ee[I >> 3] = -17976931348623157e292, Ie = jt + (Bt << 5) + 16 | 0, ee[Ie >> 3] = -17976931348623157e292, rt = 17976931348623157e292, et = -17976931348623157e292, T = 0, Re = z, F = 17976931348623157e292, Ze = 17976931348623157e292, We = -17976931348623157e292, B = -17976931348623157e292; C = +ee[Re >> 3], $e = +ee[Re + 8 >> 3], Re = d[Re + 16 >> 2] | 0, Be = (Re | 0) == 0, Je = +ee[(Be ? z : Re) + 8 >> 3], C < F && (ee[W >> 3] = C, F = C), $e < Ze && (ee[ue >> 3] = $e, Ze = $e), C > We ? ee[I >> 3] = C : C = We, $e > B && (ee[Ie >> 3] = $e, B = $e), rt = $e > 0 & $e < rt ? $e : rt, et = $e < 0 & $e > et ? $e : et, T = T | +kt(+($e - Je)) > 3.141592653589793, !Be; )
                We = C;
              T && (ee[Ie >> 3] = et, ee[ue >> 3] = rt);
            } else
              d[I >> 2] = 0, d[I + 4 >> 2] = 0, d[I + 8 >> 2] = 0, d[I + 12 >> 2] = 0, d[I + 16 >> 2] = 0, d[I + 20 >> 2] = 0, d[I + 24 >> 2] = 0, d[I + 28 >> 2] = 0;
            T = Bt + 1 | 0;
          }
          if (Sr = b + 8 | 0, b = d[Sr >> 2] | 0, d[Sr >> 2] = 0, b)
            Bt = T, ue = f;
          else {
            Zr = 45;
            break;
          }
        }
        if ((Zr | 0) == 21)
          er(27213, 27235, 35, 27247);
        else if ((Zr | 0) == 23)
          er(27267, 27235, 37, 27247);
        else if ((Zr | 0) == 27)
          er(27310, 27235, 61, 27333);
        else if ((Zr | 0) == 45) {
          e: do
            if ((ar | 0) > 0) {
              for (Sr = (T | 0) == 0, Cr = T << 2, Gr = (h | 0) == 0, Or = 0, f = 0; ; ) {
                if (Ut = d[Wr + (Or << 2) >> 2] | 0, Sr)
                  Zr = 73;
                else {
                  if (Bt = ss(Cr) | 0, !Bt) {
                    Zr = 50;
                    break;
                  }
                  if (Ht = ss(Cr) | 0, !Ht) {
                    Zr = 52;
                    break;
                  }
                  t: do
                    if (Gr)
                      A = 0;
                    else {
                      for (T = 0, A = 0, I = h; b = jt + (T << 5) | 0, nr(d[I >> 2] | 0, b, d[Ut >> 2] | 0) | 0 ? (d[Bt + (A << 2) >> 2] = I, d[Ht + (A << 2) >> 2] = b, Be = A + 1 | 0) : Be = A, I = d[I + 8 >> 2] | 0, I; )
                        T = T + 1 | 0, A = Be;
                      if ((Be | 0) > 0)
                        if (b = d[Bt >> 2] | 0, (Be | 0) == 1)
                          A = b;
                        else
                          for (Ie = 0, Re = -1, A = b, ue = b; ; ) {
                            for (z = d[ue >> 2] | 0, b = 0, I = 0; T = d[d[Bt + (I << 2) >> 2] >> 2] | 0, (T | 0) == (z | 0) ? W = b : W = b + ((nr(T, d[Ht + (I << 2) >> 2] | 0, d[z >> 2] | 0) | 0) & 1) | 0, I = I + 1 | 0, (I | 0) != (Be | 0); )
                              b = W;
                            if (T = (W | 0) > (Re | 0), A = T ? ue : A, b = Ie + 1 | 0, (b | 0) == (Be | 0))
                              break t;
                            Ie = b, Re = T ? W : Re, ue = d[Bt + (b << 2) >> 2] | 0;
                          }
                      else
                        A = 0;
                    }
                  while (!1);
                  if (Ur(Bt), Ur(Ht), A) {
                    if (T = A + 4 | 0, b = d[T >> 2] | 0, b)
                      A = b + 8 | 0;
                    else if (d[A >> 2] | 0) {
                      Zr = 70;
                      break;
                    }
                    d[A >> 2] = Ut, d[T >> 2] = Ut;
                  } else
                    Zr = 73;
                }
                if ((Zr | 0) == 73) {
                  if (Zr = 0, f = d[Ut >> 2] | 0, f | 0)
                    do
                      Ht = f, f = d[f + 16 >> 2] | 0, Ur(Ht);
                    while ((f | 0) != 0);
                  Ur(Ut), f = 1;
                }
                if (Or = Or + 1 | 0, (Or | 0) >= (ar | 0)) {
                  fn = f;
                  break e;
                }
              }
              (Zr | 0) == 50 ? er(27452, 27235, 249, 27471) : (Zr | 0) == 52 ? er(27490, 27235, 252, 27471) : (Zr | 0) == 70 && er(27310, 27235, 61, 27333);
            } else
              fn = 0;
          while (!1);
          return Ur(Wr), Ur(jt), Zr = fn, Zr | 0;
        }
        return 0;
      }
      function nr(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0;
        var b = 0, T = 0, C = 0, I = 0, B = 0, F = 0, z = 0, W = 0;
        if (!(No(f, A) | 0) || (f = Jo(f) | 0, b = +ee[A >> 3], T = +ee[A + 8 >> 3], T = f & T < 0 ? T + 6.283185307179586 : T, h = d[h >> 2] | 0, !h))
          return h = 0, h | 0;
        if (f) {
          f = 0, z = T, A = h;
          e: for (; ; ) {
            for (; I = +ee[A >> 3], T = +ee[A + 8 >> 3], A = A + 16 | 0, W = d[A >> 2] | 0, W = (W | 0) == 0 ? h : W, C = +ee[W >> 3], B = +ee[W + 8 >> 3], I > C ? (F = I, I = B) : (F = C, C = I, I = T, T = B), b = b == C | b == F ? b + 2220446049250313e-31 : b, !!(b < C | b > F); )
              if (A = d[A >> 2] | 0, !A) {
                A = 22;
                break e;
              }
            if (B = I < 0 ? I + 6.283185307179586 : I, I = T < 0 ? T + 6.283185307179586 : T, z = B == z | I == z ? z + -2220446049250313e-31 : z, F = B + (I - B) * ((b - C) / (F - C)), (F < 0 ? F + 6.283185307179586 : F) > z && (f = f ^ 1), A = d[A >> 2] | 0, !A) {
              A = 22;
              break;
            }
          }
          if ((A | 0) == 22)
            return f | 0;
        } else {
          f = 0, z = T, A = h;
          e: for (; ; ) {
            for (; I = +ee[A >> 3], T = +ee[A + 8 >> 3], A = A + 16 | 0, W = d[A >> 2] | 0, W = (W | 0) == 0 ? h : W, C = +ee[W >> 3], B = +ee[W + 8 >> 3], I > C ? (F = I, I = B) : (F = C, C = I, I = T, T = B), b = b == C | b == F ? b + 2220446049250313e-31 : b, !!(b < C | b > F); )
              if (A = d[A >> 2] | 0, !A) {
                A = 22;
                break e;
              }
            if (z = I == z | T == z ? z + -2220446049250313e-31 : z, I + (T - I) * ((b - C) / (F - C)) > z && (f = f ^ 1), A = d[A >> 2] | 0, !A) {
              A = 22;
              break;
            }
          }
          if ((A | 0) == 22)
            return f | 0;
        }
        return 0;
      }
      function wo(h, f, A, b, T) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0, T = T | 0;
        var C = 0, I = 0, B = 0, F = 0, z = 0, W = 0, ue = 0, Ie = 0, Re = 0, Be = 0, Ze = 0, We = 0, rt = 0, et = 0;
        if (et = Ae, Ae = Ae + 32 | 0, rt = et + 16 | 0, We = et, C = D(h | 0, f | 0, 52) | 0, ye() | 0, C = C & 15, Re = D(A | 0, b | 0, 52) | 0, ye() | 0, (C | 0) != (Re & 15 | 0))
          return rt = 12, Ae = et, rt | 0;
        if (z = D(h | 0, f | 0, 45) | 0, ye() | 0, z = z & 127, W = D(A | 0, b | 0, 45) | 0, ye() | 0, W = W & 127, z >>> 0 > 121 | W >>> 0 > 121)
          return rt = 5, Ae = et, rt | 0;
        if (Re = (z | 0) != (W | 0), Re) {
          if (B = lu(z, W) | 0, (B | 0) == 7)
            return rt = 1, Ae = et, rt | 0;
          F = lu(W, z) | 0, (F | 0) == 7 ? er(27514, 27538, 161, 27548) : (Be = B, I = F);
        } else
          Be = 0, I = 0;
        ue = mn(z) | 0, Ie = mn(W) | 0, d[rt >> 2] = 0, d[rt + 4 >> 2] = 0, d[rt + 8 >> 2] = 0, d[rt + 12 >> 2] = 0;
        do
          if (Be) {
            if (W = d[4272 + (z * 28 | 0) + (Be << 2) >> 2] | 0, B = (W | 0) > 0, Ie)
              if (B) {
                z = 0, F = A, B = b;
                do
                  F = _c(F, B) | 0, B = ye() | 0, I = Os(I) | 0, (I | 0) == 1 && (I = Os(1) | 0), z = z + 1 | 0;
                while ((z | 0) != (W | 0));
                W = I, z = F, F = B;
              } else
                W = I, z = A, F = b;
            else if (B) {
              z = 0, F = A, B = b;
              do
                F = Bl(F, B) | 0, B = ye() | 0, I = Os(I) | 0, z = z + 1 | 0;
              while ((z | 0) != (W | 0));
              W = I, z = F, F = B;
            } else
              W = I, z = A, F = b;
            if (Ol(z, F, rt) | 0, Re || er(27563, 27538, 191, 27548), B = (ue | 0) != 0, I = (Ie | 0) != 0, B & I && er(27590, 27538, 192, 27548), B) {
              if (I = ys(h, f) | 0, (I | 0) == 7) {
                C = 5;
                break;
              }
              if (ge[22e3 + (I * 7 | 0) + Be >> 0] | 0) {
                C = 1;
                break;
              }
              F = d[21168 + (I * 28 | 0) + (Be << 2) >> 2] | 0, z = F;
            } else if (I) {
              if (I = ys(z, F) | 0, (I | 0) == 7) {
                C = 5;
                break;
              }
              if (ge[22e3 + (I * 7 | 0) + W >> 0] | 0) {
                C = 1;
                break;
              }
              z = 0, F = d[21168 + (W * 28 | 0) + (I << 2) >> 2] | 0;
            } else
              z = 0, F = 0;
            if ((z | F | 0) < 0)
              C = 5;
            else {
              if ((F | 0) > 0) {
                B = rt + 4 | 0, I = 0;
                do
                  zo(B), I = I + 1 | 0;
                while ((I | 0) != (F | 0));
              }
              if (d[We >> 2] = 0, d[We + 4 >> 2] = 0, d[We + 8 >> 2] = 0, ta(We, Be), C | 0)
                for (; vs(C) | 0 ? El(We) : Rs(We), (C | 0) > 1; )
                  C = C + -1 | 0;
              if ((z | 0) > 0) {
                C = 0;
                do
                  zo(We), C = C + 1 | 0;
                while ((C | 0) != (z | 0));
              }
              Ze = rt + 4 | 0, rs(Ze, We, Ze), qi(Ze), Ze = 51;
            }
          } else if (Ol(A, b, rt) | 0, (ue | 0) != 0 & (Ie | 0) != 0)
            if ((W | 0) != (z | 0) && er(27621, 27538, 261, 27548), I = ys(h, f) | 0, C = ys(A, b) | 0, (I | 0) == 7 | (C | 0) == 7)
              C = 5;
            else if (ge[22e3 + (I * 7 | 0) + C >> 0] | 0)
              C = 1;
            else if (I = d[21168 + (I * 28 | 0) + (C << 2) >> 2] | 0, (I | 0) > 0) {
              B = rt + 4 | 0, C = 0;
              do
                zo(B), C = C + 1 | 0;
              while ((C | 0) != (I | 0));
              Ze = 51;
            } else
              Ze = 51;
          else
            Ze = 51;
        while (!1);
        return (Ze | 0) == 51 && (C = rt + 4 | 0, d[T >> 2] = d[C >> 2], d[T + 4 >> 2] = d[C + 4 >> 2], d[T + 8 >> 2] = d[C + 8 >> 2], C = 0), rt = C, Ae = et, rt | 0;
      }
      function Ec(h, f, A, b) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0;
        var T = 0, C = 0, I = 0, B = 0, F = 0, z = 0, W = 0, ue = 0, Ie = 0, Re = 0, Be = 0, Ze = 0, We = 0, rt = 0, et = 0, Je = 0;
        if (Ze = Ae, Ae = Ae + 48 | 0, z = Ze + 36 | 0, I = Ze + 24 | 0, B = Ze + 12 | 0, F = Ze, T = D(h | 0, f | 0, 52) | 0, ye() | 0, T = T & 15, Ie = D(h | 0, f | 0, 45) | 0, ye() | 0, Ie = Ie & 127, Ie >>> 0 > 121)
          return b = 5, Ae = Ze, b | 0;
        if (W = mn(Ie) | 0, k(T | 0, 0, 52) | 0, We = ye() | 0 | 134225919, C = b, d[C >> 2] = -1, d[C + 4 >> 2] = We, !T)
          return T = hu(A) | 0, (T | 0) == 7 || (T = Va(Ie, T) | 0, (T | 0) == 127) ? (We = 1, Ae = Ze, We | 0) : (Re = k(T | 0, 0, 45) | 0, Be = ye() | 0, Ie = b, Be = d[Ie + 4 >> 2] & -1040385 | Be, We = b, d[We >> 2] = d[Ie >> 2] | Re, d[We + 4 >> 2] = Be, We = 0, Ae = Ze, We | 0);
        for (d[z >> 2] = d[A >> 2], d[z + 4 >> 2] = d[A + 4 >> 2], d[z + 8 >> 2] = d[A + 8 >> 2], A = T; ; ) {
          if (C = A, A = A + -1 | 0, d[I >> 2] = d[z >> 2], d[I + 4 >> 2] = d[z + 4 >> 2], d[I + 8 >> 2] = d[z + 8 >> 2], vs(C) | 0) {
            if (T = Ac(z) | 0, T | 0) {
              A = 13;
              break;
            }
            d[B >> 2] = d[z >> 2], d[B + 4 >> 2] = d[z + 4 >> 2], d[B + 8 >> 2] = d[z + 8 >> 2], El(B);
          } else {
            if (T = gc(z) | 0, T | 0) {
              A = 13;
              break;
            }
            d[B >> 2] = d[z >> 2], d[B + 4 >> 2] = d[z + 4 >> 2], d[B + 8 >> 2] = d[z + 8 >> 2], Rs(B);
          }
          if (fu(I, B, F), qi(F), T = b, et = d[T >> 2] | 0, T = d[T + 4 >> 2] | 0, Je = (15 - C | 0) * 3 | 0, rt = k(7, 0, Je | 0) | 0, T = T & ~(ye() | 0), Je = k(hu(F) | 0, 0, Je | 0) | 0, T = ye() | 0 | T, We = b, d[We >> 2] = Je | et & ~rt, d[We + 4 >> 2] = T, (C | 0) <= 1) {
            A = 14;
            break;
          }
        }
        e: do
          if ((A | 0) != 13 && (A | 0) == 14)
            if ((d[z >> 2] | 0) <= 1 && (d[z + 4 >> 2] | 0) <= 1 && (d[z + 8 >> 2] | 0) <= 1) {
              A = hu(z) | 0, T = Va(Ie, A) | 0, (T | 0) == 127 ? F = 0 : F = mn(T) | 0;
              t: do
                if (A) {
                  if (W) {
                    if (T = ys(h, f) | 0, (T | 0) == 7) {
                      T = 5;
                      break e;
                    }
                    if (C = d[21376 + (T * 28 | 0) + (A << 2) >> 2] | 0, (C | 0) > 0) {
                      T = A, A = 0;
                      do
                        T = Bs(T) | 0, A = A + 1 | 0;
                      while ((A | 0) != (C | 0));
                    } else
                      T = A;
                    if ((T | 0) == 1) {
                      T = 9;
                      break e;
                    }
                    A = Va(Ie, T) | 0, (A | 0) == 127 && er(27648, 27538, 411, 27678), mn(A) | 0 ? er(27693, 27538, 412, 27678) : (Be = A, Re = C, ue = T);
                  } else
                    Be = T, Re = 0, ue = A;
                  if (B = d[4272 + (Ie * 28 | 0) + (ue << 2) >> 2] | 0, (B | 0) <= -1 && er(27724, 27538, 419, 27678), !F) {
                    if ((Re | 0) < 0) {
                      T = 5;
                      break e;
                    }
                    if (Re | 0) {
                      C = b, T = 0, A = d[C >> 2] | 0, C = d[C + 4 >> 2] | 0;
                      do
                        A = Xs(A, C) | 0, C = ye() | 0, Je = b, d[Je >> 2] = A, d[Je + 4 >> 2] = C, T = T + 1 | 0;
                      while ((T | 0) < (Re | 0));
                    }
                    if ((B | 0) <= 0) {
                      T = Be, A = 58;
                      break;
                    }
                    for (C = b, T = 0, A = d[C >> 2] | 0, C = d[C + 4 >> 2] | 0; ; )
                      if (A = Xs(A, C) | 0, C = ye() | 0, Je = b, d[Je >> 2] = A, d[Je + 4 >> 2] = C, T = T + 1 | 0, (T | 0) == (B | 0)) {
                        T = Be, A = 58;
                        break t;
                      }
                  }
                  if (I = lu(Be, Ie) | 0, (I | 0) == 7 && er(27514, 27538, 428, 27678), T = b, A = d[T >> 2] | 0, T = d[T + 4 >> 2] | 0, (B | 0) > 0) {
                    C = 0;
                    do
                      A = Xs(A, T) | 0, T = ye() | 0, Je = b, d[Je >> 2] = A, d[Je + 4 >> 2] = T, C = C + 1 | 0;
                    while ((C | 0) != (B | 0));
                  }
                  if (T = ys(A, T) | 0, (T | 0) == 7 && er(27795, 27538, 440, 27678), A = Di(Be) | 0, A = d[(A ? 21792 : 21584) + (I * 28 | 0) + (T << 2) >> 2] | 0, (A | 0) < 0 && er(27795, 27538, 454, 27678), !A)
                    T = Be, A = 58;
                  else {
                    I = b, T = 0, C = d[I >> 2] | 0, I = d[I + 4 >> 2] | 0;
                    do
                      C = mu(C, I) | 0, I = ye() | 0, Je = b, d[Je >> 2] = C, d[Je + 4 >> 2] = I, T = T + 1 | 0;
                    while ((T | 0) < (A | 0));
                    T = Be, A = 58;
                  }
                } else if ((W | 0) != 0 & (F | 0) != 0) {
                  if (A = ys(h, f) | 0, C = b, C = ys(d[C >> 2] | 0, d[C + 4 >> 2] | 0) | 0, (A | 0) == 7 | (C | 0) == 7) {
                    T = 5;
                    break e;
                  }
                  if (C = d[21376 + (A * 28 | 0) + (C << 2) >> 2] | 0, (C | 0) < 0) {
                    T = 5;
                    break e;
                  }
                  if (!C)
                    A = 59;
                  else {
                    B = b, A = 0, I = d[B >> 2] | 0, B = d[B + 4 >> 2] | 0;
                    do
                      I = Xs(I, B) | 0, B = ye() | 0, Je = b, d[Je >> 2] = I, d[Je + 4 >> 2] = B, A = A + 1 | 0;
                    while ((A | 0) < (C | 0));
                    A = 58;
                  }
                } else
                  A = 58;
              while (!1);
              if ((A | 0) == 58 && F && (A = 59), (A | 0) == 59 && (Je = b, (ys(d[Je >> 2] | 0, d[Je + 4 >> 2] | 0) | 0) == 1)) {
                T = 9;
                break;
              }
              Je = b, rt = d[Je >> 2] | 0, Je = d[Je + 4 >> 2] & -1040385, et = k(T | 0, 0, 45) | 0, Je = Je | (ye() | 0), T = b, d[T >> 2] = rt | et, d[T + 4 >> 2] = Je, T = 0;
            } else
              T = 1;
        while (!1);
        return Je = T, Ae = Ze, Je | 0;
      }
      function yf(h, f, A, b, T, C) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0, T = T | 0, C = C | 0;
        var I = 0, B = 0;
        return B = Ae, Ae = Ae + 16 | 0, I = B, T ? h = 15 : (h = wo(h, f, A, b, I) | 0, h || (Sh(I, C), h = 0)), Ae = B, h | 0;
      }
      function lo(h, f, A, b, T) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0, T = T | 0;
        var C = 0, I = 0;
        return I = Ae, Ae = Ae + 16 | 0, C = I, b ? A = 15 : (A = Dn(A, C) | 0, A || (A = Ec(h, f, C, T) | 0)), Ae = I, A | 0;
      }
      function Ls(h, f, A, b, T) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0, T = T | 0;
        var C = 0, I = 0, B = 0, F = 0;
        return F = Ae, Ae = Ae + 32 | 0, I = F + 12 | 0, B = F, C = wo(h, f, h, f, I) | 0, C | 0 ? (B = C, Ae = F, B | 0) : (h = wo(h, f, A, b, B) | 0, h | 0 ? (B = h, Ae = F, B | 0) : (I = du(I, B) | 0, B = T, d[B >> 2] = I, d[B + 4 >> 2] = ((I | 0) < 0) << 31 >> 31, B = 0, Ae = F, B | 0));
      }
      function bu(h, f, A, b, T) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0, T = T | 0;
        var C = 0, I = 0, B = 0, F = 0;
        return F = Ae, Ae = Ae + 32 | 0, I = F + 12 | 0, B = F, C = wo(h, f, h, f, I) | 0, !C && (C = wo(h, f, A, b, B) | 0, !C) ? (b = du(I, B) | 0, b = Er(b | 0, ((b | 0) < 0) << 31 >> 31 | 0, 1, 0) | 0, I = ye() | 0, B = T, d[B >> 2] = b, d[B + 4 >> 2] = I, B = 0, Ae = F, B | 0) : (B = C, Ae = F, B | 0);
      }
      function xu(h, f, A, b, T) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0, T = T | 0;
        var C = 0, I = 0, B = 0, F = 0, z = 0, W = 0, ue = 0, Ie = 0, Re = 0, Be = 0, Ze = 0, We = 0, rt = 0, et = 0, Je = 0, $e = 0, Bt = 0, Ht = 0, Ut = 0, Or = 0;
        if (Ut = Ae, Ae = Ae + 48 | 0, Bt = Ut + 24 | 0, I = Ut + 12 | 0, Ht = Ut, C = wo(h, f, h, f, Bt) | 0, !C && (C = wo(h, f, A, b, I) | 0, !C)) {
          Je = du(Bt, I) | 0, $e = ((Je | 0) < 0) << 31 >> 31, d[Bt >> 2] = 0, d[Bt + 4 >> 2] = 0, d[Bt + 8 >> 2] = 0, d[I >> 2] = 0, d[I + 4 >> 2] = 0, d[I + 8 >> 2] = 0, wo(h, f, h, f, Bt) | 0 && er(27795, 27538, 692, 27747), wo(h, f, A, b, I) | 0 && er(27795, 27538, 697, 27747), Ih(Bt), Ih(I), W = (Je | 0) == 0 ? 0 : 1 / +(Je | 0), A = d[Bt >> 2] | 0, Ze = W * +((d[I >> 2] | 0) - A | 0), We = Bt + 4 | 0, b = d[We >> 2] | 0, rt = W * +((d[I + 4 >> 2] | 0) - b | 0), et = Bt + 8 | 0, C = d[et >> 2] | 0, W = W * +((d[I + 8 >> 2] | 0) - C | 0), d[Ht >> 2] = A, ue = Ht + 4 | 0, d[ue >> 2] = b, Ie = Ht + 8 | 0, d[Ie >> 2] = C;
          e: do
            if ((Je | 0) < 0)
              C = 0;
            else
              for (Re = 0, Be = 0; ; ) {
                F = +(Be >>> 0) + 4294967296 * +(Re | 0), Or = Ze * F + +(A | 0), B = rt * F + +(b | 0), F = W * F + +(C | 0), A = ~~+Ce(+Or), I = ~~+Ce(+B), C = ~~+Ce(+F), Or = +kt(+(+(A | 0) - Or)), B = +kt(+(+(I | 0) - B)), F = +kt(+(+(C | 0) - F));
                do
                  if (Or > B & Or > F)
                    A = 0 - (I + C) | 0, b = I;
                  else if (z = 0 - A | 0, B > F) {
                    b = z - C | 0;
                    break;
                  } else {
                    b = I, C = z - I | 0;
                    break;
                  }
                while (!1);
                if (d[Ht >> 2] = A, d[ue >> 2] = b, d[Ie >> 2] = C, pu(Ht), C = Ec(h, f, Ht, T + (Be << 3) | 0) | 0, C | 0)
                  break e;
                if (!((Re | 0) < ($e | 0) | (Re | 0) == ($e | 0) & Be >>> 0 < Je >>> 0)) {
                  C = 0;
                  break e;
                }
                A = Er(Be | 0, Re | 0, 1, 0) | 0, b = ye() | 0, Re = b, Be = A, A = d[Bt >> 2] | 0, b = d[We >> 2] | 0, C = d[et >> 2] | 0;
              }
          while (!1);
          return Ht = C, Ae = Ut, Ht | 0;
        }
        return Ht = C, Ae = Ut, Ht | 0;
      }
      function Si(h, f, A, b) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0;
        var T = 0, C = 0, I = 0;
        if ((A | 0) == 0 & (b | 0) == 0)
          return T = 0, C = 1, hr(T | 0), C | 0;
        C = h, T = f, h = 1, f = 0;
        do
          I = (A & 1 | 0) == 0 & !0, h = v((I ? 1 : C) | 0, (I ? 0 : T) | 0, h | 0, f | 0) | 0, f = ye() | 0, A = R(A | 0, b | 0, 1) | 0, b = ye() | 0, C = v(C | 0, T | 0, C | 0, T | 0) | 0, T = ye() | 0;
        while (!((A | 0) == 0 & (b | 0) == 0));
        return hr(f | 0), h | 0;
      }
      function To(h, f, A, b) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0;
        var T = 0, C = 0, I = 0, B = 0, F = 0, z = 0, W = 0;
        B = Ae, Ae = Ae + 16 | 0, C = B, I = D(h | 0, f | 0, 52) | 0, ye() | 0, I = I & 15;
        do
          if (I) {
            if (T = wa(h, f, C) | 0, !T) {
              z = +ee[C >> 3], F = 1 / +Vt(+z), W = +ee[25968 + (I << 3) >> 3], ee[A >> 3] = z + W, ee[A + 8 >> 3] = z - W, z = +ee[C + 8 >> 3], F = W * F, ee[A + 16 >> 3] = F + z, ee[A + 24 >> 3] = z - F;
              break;
            }
            return I = T, Ae = B, I | 0;
          } else {
            if (T = D(h | 0, f | 0, 45) | 0, ye() | 0, T = T & 127, T >>> 0 > 121)
              return I = 5, Ae = B, I | 0;
            C = 22064 + (T << 5) | 0, d[A >> 2] = d[C >> 2], d[A + 4 >> 2] = d[C + 4 >> 2], d[A + 8 >> 2] = d[C + 8 >> 2], d[A + 12 >> 2] = d[C + 12 >> 2], d[A + 16 >> 2] = d[C + 16 >> 2], d[A + 20 >> 2] = d[C + 20 >> 2], d[A + 24 >> 2] = d[C + 24 >> 2], d[A + 28 >> 2] = d[C + 28 >> 2];
            break;
          }
        while (!1);
        return Hp(A, b ? 1.4 : 1.1), b = 26096 + (I << 3) | 0, (d[b >> 2] | 0) == (h | 0) && (d[b + 4 >> 2] | 0) == (f | 0) && (ee[A >> 3] = 1.5707963267948966), I = 26224 + (I << 3) | 0, (d[I >> 2] | 0) == (h | 0) && (d[I + 4 >> 2] | 0) == (f | 0) && (ee[A + 8 >> 3] = -1.5707963267948966), +ee[A >> 3] != 1.5707963267948966 && +ee[A + 8 >> 3] != -1.5707963267948966 ? (I = 0, Ae = B, I | 0) : (ee[A + 16 >> 3] = 3.141592653589793, ee[A + 24 >> 3] = -3.141592653589793, I = 0, Ae = B, I | 0);
      }
      function zh(h, f, A, b) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0;
        var T = 0, C = 0, I = 0, B = 0, F = 0, z = 0, W = 0;
        z = Ae, Ae = Ae + 48 | 0, I = z + 32 | 0, C = z + 40 | 0, B = z, Au(I, 0, 0, 0), F = d[I >> 2] | 0, I = d[I + 4 >> 2] | 0;
        do
          if (A >>> 0 <= 15) {
            if (T = ks(b) | 0, T | 0) {
              b = B, d[b >> 2] = 0, d[b + 4 >> 2] = 0, d[B + 8 >> 2] = T, d[B + 12 >> 2] = -1, b = B + 16 | 0, F = B + 29 | 0, d[b >> 2] = 0, d[b + 4 >> 2] = 0, d[b + 8 >> 2] = 0, ge[b + 12 >> 0] = 0, ge[F >> 0] = ge[C >> 0] | 0, ge[F + 1 >> 0] = ge[C + 1 >> 0] | 0, ge[F + 2 >> 0] = ge[C + 2 >> 0] | 0;
              break;
            }
            if (T = Ii((d[f + 8 >> 2] | 0) + 1 | 0, 32) | 0, T) {
              Fs(f, T), W = B, d[W >> 2] = F, d[W + 4 >> 2] = I, d[B + 8 >> 2] = 0, d[B + 12 >> 2] = A, d[B + 16 >> 2] = b, d[B + 20 >> 2] = f, d[B + 24 >> 2] = T, ge[B + 28 >> 0] = 0, F = B + 29 | 0, ge[F >> 0] = ge[C >> 0] | 0, ge[F + 1 >> 0] = ge[C + 1 >> 0] | 0, ge[F + 2 >> 0] = ge[C + 2 >> 0] | 0;
              break;
            } else {
              b = B, d[b >> 2] = 0, d[b + 4 >> 2] = 0, d[B + 8 >> 2] = 13, d[B + 12 >> 2] = -1, b = B + 16 | 0, F = B + 29 | 0, d[b >> 2] = 0, d[b + 4 >> 2] = 0, d[b + 8 >> 2] = 0, ge[b + 12 >> 0] = 0, ge[F >> 0] = ge[C >> 0] | 0, ge[F + 1 >> 0] = ge[C + 1 >> 0] | 0, ge[F + 2 >> 0] = ge[C + 2 >> 0] | 0;
              break;
            }
          } else
            F = B, d[F >> 2] = 0, d[F + 4 >> 2] = 0, d[B + 8 >> 2] = 4, d[B + 12 >> 2] = -1, F = B + 16 | 0, W = B + 29 | 0, d[F >> 2] = 0, d[F + 4 >> 2] = 0, d[F + 8 >> 2] = 0, ge[F + 12 >> 0] = 0, ge[W >> 0] = ge[C >> 0] | 0, ge[W + 1 >> 0] = ge[C + 1 >> 0] | 0, ge[W + 2 >> 0] = ge[C + 2 >> 0] | 0;
        while (!1);
        Ta(B), d[h >> 2] = d[B >> 2], d[h + 4 >> 2] = d[B + 4 >> 2], d[h + 8 >> 2] = d[B + 8 >> 2], d[h + 12 >> 2] = d[B + 12 >> 2], d[h + 16 >> 2] = d[B + 16 >> 2], d[h + 20 >> 2] = d[B + 20 >> 2], d[h + 24 >> 2] = d[B + 24 >> 2], d[h + 28 >> 2] = d[B + 28 >> 2], Ae = z;
      }
      function Ta(h) {
        h = h | 0;
        var f = 0, A = 0, b = 0, T = 0, C = 0, I = 0, B = 0, F = 0, z = 0, W = 0, ue = 0, Ie = 0, Re = 0, Be = 0, Ze = 0, We = 0, rt = 0, et = 0, Je = 0, $e = 0;
        if ($e = Ae, Ae = Ae + 336 | 0, Re = $e + 168 | 0, Be = $e, b = h, A = d[b >> 2] | 0, b = d[b + 4 >> 2] | 0, (A | 0) == 0 & (b | 0) == 0) {
          Ae = $e;
          return;
        }
        if (f = h + 28 | 0, ge[f >> 0] | 0 ? (A = wu(A, b) | 0, b = ye() | 0) : ge[f >> 0] = 1, Je = h + 20 | 0, !(d[d[Je >> 2] >> 2] | 0)) {
          f = h + 24 | 0, A = d[f >> 2] | 0, A | 0 && Ur(A), et = h, d[et >> 2] = 0, d[et + 4 >> 2] = 0, d[h + 8 >> 2] = 0, d[Je >> 2] = 0, d[h + 12 >> 2] = -1, d[h + 16 >> 2] = 0, d[f >> 2] = 0, Ae = $e;
          return;
        }
        et = h + 16 | 0, f = d[et >> 2] | 0, T = f & 15;
        e: do
          if ((A | 0) == 0 & (b | 0) == 0)
            rt = h + 24 | 0;
          else {
            Ze = h + 12 | 0, ue = (T | 0) == 3, W = f & 255, F = (T | 1 | 0) == 3, Ie = h + 24 | 0, z = (T + -1 | 0) >>> 0 < 3, I = (T | 2 | 0) == 3, B = Be + 8 | 0;
            t: for (; ; ) {
              if (C = D(A | 0, b | 0, 52) | 0, ye() | 0, C = C & 15, (C | 0) == (d[Ze >> 2] | 0)) {
                switch (W & 15) {
                  case 0:
                  case 2:
                  case 3: {
                    if (T = wa(A, b, Re) | 0, T | 0) {
                      We = 15;
                      break t;
                    }
                    if (Li(d[Je >> 2] | 0, d[Ie >> 2] | 0, Re) | 0) {
                      We = 19;
                      break t;
                    }
                    break;
                  }
                }
                if (F && (T = d[(d[Je >> 2] | 0) + 4 >> 2] | 0, d[Re >> 2] = d[T >> 2], d[Re + 4 >> 2] = d[T + 4 >> 2], d[Re + 8 >> 2] = d[T + 8 >> 2], d[Re + 12 >> 2] = d[T + 12 >> 2], No(26832, Re) | 0)) {
                  if (gf(d[(d[Je >> 2] | 0) + 4 >> 2] | 0, C, Be) | 0) {
                    We = 25;
                    break;
                  }
                  if (T = Be, (d[T >> 2] | 0) == (A | 0) && (d[T + 4 >> 2] | 0) == (b | 0)) {
                    We = 29;
                    break;
                  }
                }
                if (z) {
                  if (T = Za(A, b, Re) | 0, T | 0) {
                    We = 32;
                    break;
                  }
                  if (To(A, b, Be, 0) | 0) {
                    We = 36;
                    break;
                  }
                  if (I && Ea(d[Je >> 2] | 0, d[Ie >> 2] | 0, Re, Be) | 0) {
                    We = 42;
                    break;
                  }
                  if (F && co(d[Je >> 2] | 0, d[Ie >> 2] | 0, Re, Be) | 0) {
                    We = 42;
                    break;
                  }
                }
                if (ue) {
                  if (f = To(A, b, Re, 1) | 0, T = d[Ie >> 2] | 0, f | 0) {
                    We = 45;
                    break;
                  }
                  if (Uo(T, Re) | 0) {
                    if (gi(Be, Re), _s(Re, d[Ie >> 2] | 0) | 0) {
                      We = 53;
                      break;
                    }
                    if (Li(d[Je >> 2] | 0, d[Ie >> 2] | 0, B) | 0) {
                      We = 53;
                      break;
                    }
                    if (co(d[Je >> 2] | 0, d[Ie >> 2] | 0, Be, Re) | 0) {
                      We = 53;
                      break;
                    }
                  }
                }
              }
              do
                if ((C | 0) < (d[Ze >> 2] | 0)) {
                  if (f = To(A, b, Re, 1) | 0, T = d[Ie >> 2] | 0, f | 0) {
                    We = 58;
                    break t;
                  }
                  if (!(Uo(T, Re) | 0)) {
                    We = 73;
                    break;
                  }
                  if (_s(d[Ie >> 2] | 0, Re) | 0 && (gi(Be, Re), Ea(d[Je >> 2] | 0, d[Ie >> 2] | 0, Be, Re) | 0)) {
                    We = 65;
                    break t;
                  }
                  if (A = Xa(A, b, C + 1 | 0, Be) | 0, A | 0) {
                    We = 67;
                    break t;
                  }
                  b = Be, A = d[b >> 2] | 0, b = d[b + 4 >> 2] | 0;
                } else
                  We = 73;
              while (!1);
              if ((We | 0) == 73 && (We = 0, A = wu(A, b) | 0, b = ye() | 0), (A | 0) == 0 & (b | 0) == 0) {
                rt = Ie;
                break e;
              }
            }
            switch (We | 0) {
              case 15: {
                f = d[Ie >> 2] | 0, f | 0 && Ur(f), We = h, d[We >> 2] = 0, d[We + 4 >> 2] = 0, d[Je >> 2] = 0, d[Ze >> 2] = -1, d[et >> 2] = 0, d[Ie >> 2] = 0, d[h + 8 >> 2] = T, We = 20;
                break;
              }
              case 19: {
                d[h >> 2] = A, d[h + 4 >> 2] = b, We = 20;
                break;
              }
              case 25: {
                er(27795, 27761, 470, 27772);
                break;
              }
              case 29: {
                d[h >> 2] = A, d[h + 4 >> 2] = b, Ae = $e;
                return;
              }
              case 32: {
                f = d[Ie >> 2] | 0, f | 0 && Ur(f), rt = h, d[rt >> 2] = 0, d[rt + 4 >> 2] = 0, d[Je >> 2] = 0, d[Ze >> 2] = -1, d[et >> 2] = 0, d[Ie >> 2] = 0, d[h + 8 >> 2] = T, Ae = $e;
                return;
              }
              case 36: {
                er(27795, 27761, 493, 27772);
                break;
              }
              case 42: {
                d[h >> 2] = A, d[h + 4 >> 2] = b, Ae = $e;
                return;
              }
              case 45: {
                T | 0 && Ur(T), We = h, d[We >> 2] = 0, d[We + 4 >> 2] = 0, d[Je >> 2] = 0, d[Ze >> 2] = -1, d[et >> 2] = 0, d[Ie >> 2] = 0, d[h + 8 >> 2] = f, We = 55;
                break;
              }
              case 53: {
                d[h >> 2] = A, d[h + 4 >> 2] = b, We = 55;
                break;
              }
              case 58: {
                T | 0 && Ur(T), We = h, d[We >> 2] = 0, d[We + 4 >> 2] = 0, d[Je >> 2] = 0, d[Ze >> 2] = -1, d[et >> 2] = 0, d[Ie >> 2] = 0, d[h + 8 >> 2] = f, We = 71;
                break;
              }
              case 65: {
                d[h >> 2] = A, d[h + 4 >> 2] = b, We = 71;
                break;
              }
              case 67: {
                f = d[Ie >> 2] | 0, f | 0 && Ur(f), rt = h, d[rt >> 2] = 0, d[rt + 4 >> 2] = 0, d[Je >> 2] = 0, d[Ze >> 2] = -1, d[et >> 2] = 0, d[Ie >> 2] = 0, d[h + 8 >> 2] = A, Ae = $e;
                return;
              }
            }
            if ((We | 0) == 20) {
              Ae = $e;
              return;
            } else if ((We | 0) == 55) {
              Ae = $e;
              return;
            } else if ((We | 0) == 71) {
              Ae = $e;
              return;
            }
          }
        while (!1);
        f = d[rt >> 2] | 0, f | 0 && Ur(f), We = h, d[We >> 2] = 0, d[We + 4 >> 2] = 0, d[h + 8 >> 2] = 0, d[Je >> 2] = 0, d[h + 12 >> 2] = -1, d[et >> 2] = 0, d[rt >> 2] = 0, Ae = $e;
      }
      function wu(h, f) {
        h = h | 0, f = f | 0;
        var A = 0, b = 0, T = 0, C = 0, I = 0, B = 0, F = 0, z = 0, W = 0, ue = 0;
        ue = Ae, Ae = Ae + 16 | 0, W = ue, b = D(h | 0, f | 0, 52) | 0, ye() | 0, b = b & 15, A = D(h | 0, f | 0, 45) | 0, ye() | 0;
        do
          if (b) {
            for (; A = k(b + 4095 | 0, 0, 52) | 0, T = ye() | 0 | f & -15728641, C = (15 - b | 0) * 3 | 0, I = k(7, 0, C | 0) | 0, B = ye() | 0, A = A | h | I, T = T | B, F = D(h | 0, f | 0, C | 0) | 0, ye() | 0, F = F & 7, b = b + -1 | 0, !(F >>> 0 < 6); )
              if (b)
                f = T, h = A;
              else {
                z = 4;
                break;
              }
            if ((z | 0) == 4) {
              A = D(A | 0, T | 0, 45) | 0, ye() | 0;
              break;
            }
            return W = (F | 0) == 0 & (Bn(A, T) | 0) != 0, W = k((W ? 2 : 1) + F | 0, 0, C | 0) | 0, z = ye() | 0 | f & ~B, W = W | h & ~I, hr(z | 0), Ae = ue, W | 0;
          }
        while (!1);
        return A = A & 127, A >>> 0 > 120 ? (z = 0, W = 0, hr(z | 0), Ae = ue, W | 0) : (Au(W, 0, A + 1 | 0, 0), z = d[W + 4 >> 2] | 0, W = d[W >> 2] | 0, hr(z | 0), Ae = ue, W | 0);
      }
      function vf(h, f, A, b, T, C) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0, T = T | 0, C = C | 0;
        var I = 0, B = 0, F = 0, z = 0, W = 0, ue = 0, Ie = 0, Re = 0, Be = 0, Ze = 0, We = 0;
        We = Ae, Ae = Ae + 160 | 0, ue = We + 80 | 0, B = We + 64 | 0, Ie = We + 112 | 0, Ze = We, zh(ue, h, f, A), z = ue, ia(B, d[z >> 2] | 0, d[z + 4 >> 2] | 0, f), z = B, F = d[z >> 2] | 0, z = d[z + 4 >> 2] | 0, I = d[ue + 8 >> 2] | 0, Re = Ie + 4 | 0, d[Re >> 2] = d[ue >> 2], d[Re + 4 >> 2] = d[ue + 4 >> 2], d[Re + 8 >> 2] = d[ue + 8 >> 2], d[Re + 12 >> 2] = d[ue + 12 >> 2], d[Re + 16 >> 2] = d[ue + 16 >> 2], d[Re + 20 >> 2] = d[ue + 20 >> 2], d[Re + 24 >> 2] = d[ue + 24 >> 2], d[Re + 28 >> 2] = d[ue + 28 >> 2], Re = Ze, d[Re >> 2] = F, d[Re + 4 >> 2] = z, Re = Ze + 8 | 0, d[Re >> 2] = I, h = Ze + 12 | 0, f = Ie, A = h + 36 | 0;
        do
          d[h >> 2] = d[f >> 2], h = h + 4 | 0, f = f + 4 | 0;
        while ((h | 0) < (A | 0));
        if (Ie = Ze + 48 | 0, d[Ie >> 2] = d[B >> 2], d[Ie + 4 >> 2] = d[B + 4 >> 2], d[Ie + 8 >> 2] = d[B + 8 >> 2], d[Ie + 12 >> 2] = d[B + 12 >> 2], (F | 0) == 0 & (z | 0) == 0)
          return Ze = I, Ae = We, Ze | 0;
        A = Ze + 16 | 0, W = Ze + 24 | 0, ue = Ze + 28 | 0, I = 0, B = 0, f = F, h = z;
        do {
          if (!((I | 0) < (T | 0) | (I | 0) == (T | 0) & B >>> 0 < b >>> 0)) {
            Be = 4;
            break;
          }
          if (z = B, B = Er(B | 0, I | 0, 1, 0) | 0, I = ye() | 0, z = C + (z << 3) | 0, d[z >> 2] = f, d[z + 4 >> 2] = h, Dl(Ie), h = Ie, f = d[h >> 2] | 0, h = d[h + 4 >> 2] | 0, (f | 0) == 0 & (h | 0) == 0) {
            if (Ta(A), f = A, h = d[f >> 2] | 0, f = d[f + 4 >> 2] | 0, (h | 0) == 0 & (f | 0) == 0) {
              Be = 10;
              break;
            }
            Gn(h, f, d[ue >> 2] | 0, Ie), h = Ie, f = d[h >> 2] | 0, h = d[h + 4 >> 2] | 0;
          }
          z = Ze, d[z >> 2] = f, d[z + 4 >> 2] = h;
        } while (!((f | 0) == 0 & (h | 0) == 0));
        return (Be | 0) == 4 ? (h = Ze + 40 | 0, f = d[h >> 2] | 0, f | 0 && Ur(f), Be = Ze + 16 | 0, d[Be >> 2] = 0, d[Be + 4 >> 2] = 0, d[W >> 2] = 0, d[Ze + 36 >> 2] = 0, d[ue >> 2] = -1, d[Ze + 32 >> 2] = 0, d[h >> 2] = 0, Gn(0, 0, 0, Ie), d[Ze >> 2] = 0, d[Ze + 4 >> 2] = 0, d[Re >> 2] = 0, Ze = 14, Ae = We, Ze | 0) : ((Be | 0) == 10 && (d[Ze >> 2] = 0, d[Ze + 4 >> 2] = 0, d[Re >> 2] = d[W >> 2]), Ze = d[Re >> 2] | 0, Ae = We, Ze | 0);
      }
      function Eo(h, f, A, b) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0;
        var T = 0, C = 0, I = 0, B = 0, F = 0, z = 0, W = 0, ue = 0, Ie = 0, Re = 0;
        if (ue = Ae, Ae = Ae + 48 | 0, F = ue + 32 | 0, B = ue + 40 | 0, z = ue, !(d[h >> 2] | 0))
          return W = b, d[W >> 2] = 0, d[W + 4 >> 2] = 0, W = 0, Ae = ue, W | 0;
        Au(F, 0, 0, 0), I = F, T = d[I >> 2] | 0, I = d[I + 4 >> 2] | 0;
        do
          if (f >>> 0 > 15)
            W = z, d[W >> 2] = 0, d[W + 4 >> 2] = 0, d[z + 8 >> 2] = 4, d[z + 12 >> 2] = -1, W = z + 16 | 0, A = z + 29 | 0, d[W >> 2] = 0, d[W + 4 >> 2] = 0, d[W + 8 >> 2] = 0, ge[W + 12 >> 0] = 0, ge[A >> 0] = ge[B >> 0] | 0, ge[A + 1 >> 0] = ge[B + 1 >> 0] | 0, ge[A + 2 >> 0] = ge[B + 2 >> 0] | 0, A = 4, W = 9;
          else {
            if (A = ks(A) | 0, A | 0) {
              F = z, d[F >> 2] = 0, d[F + 4 >> 2] = 0, d[z + 8 >> 2] = A, d[z + 12 >> 2] = -1, F = z + 16 | 0, W = z + 29 | 0, d[F >> 2] = 0, d[F + 4 >> 2] = 0, d[F + 8 >> 2] = 0, ge[F + 12 >> 0] = 0, ge[W >> 0] = ge[B >> 0] | 0, ge[W + 1 >> 0] = ge[B + 1 >> 0] | 0, ge[W + 2 >> 0] = ge[B + 2 >> 0] | 0, W = 9;
              break;
            }
            if (A = Ii((d[h + 8 >> 2] | 0) + 1 | 0, 32) | 0, !A) {
              W = z, d[W >> 2] = 0, d[W + 4 >> 2] = 0, d[z + 8 >> 2] = 13, d[z + 12 >> 2] = -1, W = z + 16 | 0, A = z + 29 | 0, d[W >> 2] = 0, d[W + 4 >> 2] = 0, d[W + 8 >> 2] = 0, ge[W + 12 >> 0] = 0, ge[A >> 0] = ge[B >> 0] | 0, ge[A + 1 >> 0] = ge[B + 1 >> 0] | 0, ge[A + 2 >> 0] = ge[B + 2 >> 0] | 0, A = 13, W = 9;
              break;
            }
            Fs(h, A), Re = z, d[Re >> 2] = T, d[Re + 4 >> 2] = I, I = z + 8 | 0, d[I >> 2] = 0, d[z + 12 >> 2] = f, d[z + 20 >> 2] = h, d[z + 24 >> 2] = A, ge[z + 28 >> 0] = 0, T = z + 29 | 0, ge[T >> 0] = ge[B >> 0] | 0, ge[T + 1 >> 0] = ge[B + 1 >> 0] | 0, ge[T + 2 >> 0] = ge[B + 2 >> 0] | 0, d[z + 16 >> 2] = 3, Ie = +ja(A), Ie = Ie * +_a(A), C = +kt(+ +ee[A >> 3]), C = Ie / +Vt(+ +oe(+C, + +kt(+ +ee[A + 8 >> 3]))) * 6371.007180918475 * 6371.007180918475, T = z + 12 | 0, A = d[T >> 2] | 0;
            e: do
              if ((A | 0) > 0)
                do {
                  if (Nh(A + -1 | 0, F) | 0, !(C / +ee[F >> 3] > 10))
                    break e;
                  Re = d[T >> 2] | 0, A = Re + -1 | 0, d[T >> 2] = A;
                } while ((Re | 0) > 1);
            while (!1);
            if (Ta(z), T = b, d[T >> 2] = 0, d[T + 4 >> 2] = 0, T = z, A = d[T >> 2] | 0, T = d[T + 4 >> 2] | 0, !((A | 0) == 0 & (T | 0) == 0))
              do
                jo(A, T, f, F) | 0, B = F, h = b, B = Er(d[h >> 2] | 0, d[h + 4 >> 2] | 0, d[B >> 2] | 0, d[B + 4 >> 2] | 0) | 0, h = ye() | 0, Re = b, d[Re >> 2] = B, d[Re + 4 >> 2] = h, Ta(z), Re = z, A = d[Re >> 2] | 0, T = d[Re + 4 >> 2] | 0;
              while (!((A | 0) == 0 & (T | 0) == 0));
            A = d[I >> 2] | 0;
          }
        while (!1);
        return Re = A, Ae = ue, Re | 0;
      }
      function is(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0;
        var b = 0, T = 0, C = 0, I = 0, B = 0, F = 0, z = 0, W = 0, ue = 0, Ie = 0;
        if (!(No(f, A) | 0) || (f = Jo(f) | 0, b = +ee[A >> 3], T = +ee[A + 8 >> 3], T = f & T < 0 ? T + 6.283185307179586 : T, Ie = d[h >> 2] | 0, (Ie | 0) <= 0))
          return Ie = 0, Ie | 0;
        if (ue = d[h + 4 >> 2] | 0, f) {
          f = 0, W = T, A = -1, h = 0;
          e: for (; ; ) {
            for (z = h; I = +ee[ue + (z << 4) >> 3], T = +ee[ue + (z << 4) + 8 >> 3], h = (A + 2 | 0) % (Ie | 0) | 0, C = +ee[ue + (h << 4) >> 3], B = +ee[ue + (h << 4) + 8 >> 3], I > C ? (F = I, I = B) : (F = C, C = I, I = T, T = B), b = b == C | b == F ? b + 2220446049250313e-31 : b, !!(b < C | b > F); )
              if (A = z + 1 | 0, (A | 0) >= (Ie | 0)) {
                A = 22;
                break e;
              } else
                h = z, z = A, A = h;
            if (B = I < 0 ? I + 6.283185307179586 : I, I = T < 0 ? T + 6.283185307179586 : T, W = B == W | I == W ? W + -2220446049250313e-31 : W, F = B + (I - B) * ((b - C) / (F - C)), (F < 0 ? F + 6.283185307179586 : F) > W && (f = f ^ 1), h = z + 1 | 0, (h | 0) >= (Ie | 0)) {
              A = 22;
              break;
            } else
              A = z;
          }
          if ((A | 0) == 22)
            return f | 0;
        } else {
          f = 0, W = T, A = -1, h = 0;
          e: for (; ; ) {
            for (z = h; I = +ee[ue + (z << 4) >> 3], T = +ee[ue + (z << 4) + 8 >> 3], h = (A + 2 | 0) % (Ie | 0) | 0, C = +ee[ue + (h << 4) >> 3], B = +ee[ue + (h << 4) + 8 >> 3], I > C ? (F = I, I = B) : (F = C, C = I, I = T, T = B), b = b == C | b == F ? b + 2220446049250313e-31 : b, !!(b < C | b > F); )
              if (A = z + 1 | 0, (A | 0) >= (Ie | 0)) {
                A = 22;
                break e;
              } else
                h = z, z = A, A = h;
            if (W = I == W | T == W ? W + -2220446049250313e-31 : W, I + (T - I) * ((b - C) / (F - C)) > W && (f = f ^ 1), h = z + 1 | 0, (h | 0) >= (Ie | 0)) {
              A = 22;
              break;
            } else
              A = z;
          }
          if ((A | 0) == 22)
            return f | 0;
        }
        return 0;
      }
      function cn(h, f) {
        h = h | 0, f = f | 0;
        var A = 0, b = 0, T = 0, C = 0, I = 0, B = 0, F = 0, z = 0, W = 0, ue = 0, Ie = 0, Re = 0, Be = 0, Ze = 0, We = 0, rt = 0, et = 0;
        if (Be = d[h >> 2] | 0, !Be) {
          d[f >> 2] = 0, d[f + 4 >> 2] = 0, d[f + 8 >> 2] = 0, d[f + 12 >> 2] = 0, d[f + 16 >> 2] = 0, d[f + 20 >> 2] = 0, d[f + 24 >> 2] = 0, d[f + 28 >> 2] = 0;
          return;
        }
        if (Ze = f + 8 | 0, ee[Ze >> 3] = 17976931348623157e292, We = f + 24 | 0, ee[We >> 3] = 17976931348623157e292, ee[f >> 3] = -17976931348623157e292, rt = f + 16 | 0, ee[rt >> 3] = -17976931348623157e292, !((Be | 0) <= 0)) {
          for (Ie = d[h + 4 >> 2] | 0, z = 17976931348623157e292, W = -17976931348623157e292, ue = 0, h = -1, C = 17976931348623157e292, I = 17976931348623157e292, F = -17976931348623157e292, b = -17976931348623157e292, Re = 0; A = +ee[Ie + (Re << 4) >> 3], B = +ee[Ie + (Re << 4) + 8 >> 3], h = h + 2 | 0, T = +ee[Ie + (((h | 0) == (Be | 0) ? 0 : h) << 4) + 8 >> 3], A < C && (ee[Ze >> 3] = A, C = A), B < I && (ee[We >> 3] = B, I = B), A > F ? ee[f >> 3] = A : A = F, B > b && (ee[rt >> 3] = B, b = B), z = B > 0 & B < z ? B : z, W = B < 0 & B > W ? B : W, ue = ue | +kt(+(B - T)) > 3.141592653589793, h = Re + 1 | 0, (h | 0) != (Be | 0); )
            et = Re, F = A, Re = h, h = et;
          ue && (ee[rt >> 3] = W, ee[We >> 3] = z);
        }
      }
      function ks(h) {
        return h = h | 0, (h >>> 0 < 4 ? 0 : 15) | 0;
      }
      function Fs(h, f) {
        h = h | 0, f = f | 0;
        var A = 0, b = 0, T = 0, C = 0, I = 0, B = 0, F = 0, z = 0, W = 0, ue = 0, Ie = 0, Re = 0, Be = 0, Ze = 0, We = 0, rt = 0, et = 0, Je = 0, $e = 0, Bt = 0, Ht = 0, Ut = 0;
        if (Be = d[h >> 2] | 0, Be) {
          if (Ze = f + 8 | 0, ee[Ze >> 3] = 17976931348623157e292, We = f + 24 | 0, ee[We >> 3] = 17976931348623157e292, ee[f >> 3] = -17976931348623157e292, rt = f + 16 | 0, ee[rt >> 3] = -17976931348623157e292, (Be | 0) > 0) {
            for (T = d[h + 4 >> 2] | 0, Ie = 17976931348623157e292, Re = -17976931348623157e292, b = 0, A = -1, F = 17976931348623157e292, z = 17976931348623157e292, ue = -17976931348623157e292, I = -17976931348623157e292, et = 0; C = +ee[T + (et << 4) >> 3], W = +ee[T + (et << 4) + 8 >> 3], Ht = A + 2 | 0, B = +ee[T + (((Ht | 0) == (Be | 0) ? 0 : Ht) << 4) + 8 >> 3], C < F && (ee[Ze >> 3] = C, F = C), W < z && (ee[We >> 3] = W, z = W), C > ue ? ee[f >> 3] = C : C = ue, W > I && (ee[rt >> 3] = W, I = W), Ie = W > 0 & W < Ie ? W : Ie, Re = W < 0 & W > Re ? W : Re, b = b | +kt(+(W - B)) > 3.141592653589793, A = et + 1 | 0, (A | 0) != (Be | 0); )
              Ht = et, ue = C, et = A, A = Ht;
            b && (ee[rt >> 3] = Re, ee[We >> 3] = Ie);
          }
        } else
          d[f >> 2] = 0, d[f + 4 >> 2] = 0, d[f + 8 >> 2] = 0, d[f + 12 >> 2] = 0, d[f + 16 >> 2] = 0, d[f + 20 >> 2] = 0, d[f + 24 >> 2] = 0, d[f + 28 >> 2] = 0;
        if (Ht = h + 8 | 0, A = d[Ht >> 2] | 0, !((A | 0) <= 0)) {
          Bt = h + 12 | 0, $e = 0;
          do
            if (T = d[Bt >> 2] | 0, b = $e, $e = $e + 1 | 0, We = f + ($e << 5) | 0, rt = d[T + (b << 3) >> 2] | 0, rt) {
              if (et = f + ($e << 5) + 8 | 0, ee[et >> 3] = 17976931348623157e292, h = f + ($e << 5) + 24 | 0, ee[h >> 3] = 17976931348623157e292, ee[We >> 3] = -17976931348623157e292, Je = f + ($e << 5) + 16 | 0, ee[Je >> 3] = -17976931348623157e292, (rt | 0) > 0) {
                for (Be = d[T + (b << 3) + 4 >> 2] | 0, Ie = 17976931348623157e292, Re = -17976931348623157e292, T = 0, b = -1, Ze = 0, F = 17976931348623157e292, z = 17976931348623157e292, W = -17976931348623157e292, I = -17976931348623157e292; C = +ee[Be + (Ze << 4) >> 3], ue = +ee[Be + (Ze << 4) + 8 >> 3], b = b + 2 | 0, B = +ee[Be + (((b | 0) == (rt | 0) ? 0 : b) << 4) + 8 >> 3], C < F && (ee[et >> 3] = C, F = C), ue < z && (ee[h >> 3] = ue, z = ue), C > W ? ee[We >> 3] = C : C = W, ue > I && (ee[Je >> 3] = ue, I = ue), Ie = ue > 0 & ue < Ie ? ue : Ie, Re = ue < 0 & ue > Re ? ue : Re, T = T | +kt(+(ue - B)) > 3.141592653589793, b = Ze + 1 | 0, (b | 0) != (rt | 0); )
                  Ut = Ze, Ze = b, W = C, b = Ut;
                T && (ee[Je >> 3] = Re, ee[h >> 3] = Ie);
              }
            } else
              d[We >> 2] = 0, d[We + 4 >> 2] = 0, d[We + 8 >> 2] = 0, d[We + 12 >> 2] = 0, d[We + 16 >> 2] = 0, d[We + 20 >> 2] = 0, d[We + 24 >> 2] = 0, d[We + 28 >> 2] = 0, A = d[Ht >> 2] | 0;
          while (($e | 0) < (A | 0));
        }
      }
      function Li(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0;
        var b = 0, T = 0, C = 0;
        if (!(is(h, f, A) | 0))
          return T = 0, T | 0;
        if (T = h + 8 | 0, (d[T >> 2] | 0) <= 0)
          return T = 1, T | 0;
        for (b = h + 12 | 0, h = 0; ; ) {
          if (C = h, h = h + 1 | 0, is((d[b >> 2] | 0) + (C << 3) | 0, f + (h << 5) | 0, A) | 0) {
            h = 0, b = 6;
            break;
          }
          if ((h | 0) >= (d[T >> 2] | 0)) {
            h = 1, b = 6;
            break;
          }
        }
        return (b | 0) == 6 ? h | 0 : 0;
      }
      function Ea(h, f, A, b) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0;
        var T = 0, C = 0, I = 0, B = 0, F = 0, z = 0, W = 0;
        if (z = Ae, Ae = Ae + 16 | 0, B = z, I = A + 8 | 0, !(is(h, f, I) | 0))
          return F = 0, Ae = z, F | 0;
        F = h + 8 | 0;
        e: do
          if ((d[F >> 2] | 0) > 0) {
            for (C = h + 12 | 0, T = 0; ; ) {
              if (W = T, T = T + 1 | 0, is((d[C >> 2] | 0) + (W << 3) | 0, f + (T << 5) | 0, I) | 0) {
                T = 0;
                break;
              }
              if ((T | 0) >= (d[F >> 2] | 0))
                break e;
            }
            return Ae = z, T | 0;
          }
        while (!1);
        if (Co(h, f, A, b) | 0)
          return W = 0, Ae = z, W | 0;
        d[B >> 2] = d[A >> 2], d[B + 4 >> 2] = I, T = d[F >> 2] | 0;
        e: do
          if ((T | 0) > 0)
            for (h = h + 12 | 0, I = 0, C = T; ; ) {
              if (T = d[h >> 2] | 0, (d[T + (I << 3) >> 2] | 0) > 0) {
                if (is(B, b, d[T + (I << 3) + 4 >> 2] | 0) | 0) {
                  T = 0;
                  break e;
                }
                if (T = I + 1 | 0, Co((d[h >> 2] | 0) + (I << 3) | 0, f + (T << 5) | 0, A, b) | 0) {
                  T = 0;
                  break e;
                }
                C = d[F >> 2] | 0;
              } else
                T = I + 1 | 0;
              if ((T | 0) < (C | 0))
                I = T;
              else {
                T = 1;
                break;
              }
            }
          else
            T = 1;
        while (!1);
        return W = T, Ae = z, W | 0;
      }
      function Co(h, f, A, b) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0;
        var T = 0, C = 0, I = 0, B = 0, F = 0, z = 0, W = 0, ue = 0, Ie = 0, Re = 0, Be = 0, Ze = 0, We = 0, rt = 0, et = 0, Je = 0, $e = 0, Bt = 0, Ht = 0, Ut = 0, Or = 0;
        if (Ht = Ae, Ae = Ae + 176 | 0, et = Ht + 172 | 0, T = Ht + 168 | 0, Je = Ht, !(Uo(f, b) | 0))
          return h = 0, Ae = Ht, h | 0;
        if (uu(f, b, et, T), Se(Je | 0, A | 0, 168) | 0, (d[A >> 2] | 0) > 0) {
          f = 0;
          do
            Ut = Je + 8 + (f << 4) + 8 | 0, rt = +qr(+ee[Ut >> 3], d[T >> 2] | 0), ee[Ut >> 3] = rt, f = f + 1 | 0;
          while ((f | 0) < (d[A >> 2] | 0));
        }
        Ze = +ee[b >> 3], We = +ee[b + 8 >> 3], rt = +qr(+ee[b + 16 >> 3], d[T >> 2] | 0), Re = +qr(+ee[b + 24 >> 3], d[T >> 2] | 0);
        e: do
          if ((d[h >> 2] | 0) > 0) {
            if (b = h + 4 | 0, T = d[Je >> 2] | 0, (T | 0) <= 0) {
              for (f = 0; ; )
                if (f = f + 1 | 0, (f | 0) >= (d[h >> 2] | 0)) {
                  f = 0;
                  break e;
                }
            }
            for (A = 0; ; ) {
              if (f = d[b >> 2] | 0, Ie = +ee[f + (A << 4) >> 3], Be = +qr(+ee[f + (A << 4) + 8 >> 3], d[et >> 2] | 0), f = d[b >> 2] | 0, A = A + 1 | 0, Ut = (A | 0) % (d[h >> 2] | 0) | 0, C = +ee[f + (Ut << 4) >> 3], I = +qr(+ee[f + (Ut << 4) + 8 >> 3], d[et >> 2] | 0), !(Ie >= Ze) | !(C >= Ze) && !(Ie <= We) | !(C <= We) && !(Be <= Re) | !(I <= Re) && !(Be >= rt) | !(I >= rt)) {
                ue = C - Ie, z = I - Be, f = 0;
                do
                  if (Or = f, f = f + 1 | 0, Ut = (f | 0) == (T | 0) ? 0 : f, C = +ee[Je + 8 + (Or << 4) + 8 >> 3], I = +ee[Je + 8 + (Ut << 4) + 8 >> 3] - C, B = +ee[Je + 8 + (Or << 4) >> 3], F = +ee[Je + 8 + (Ut << 4) >> 3] - B, W = ue * I - z * F, W != 0 && ($e = Be - C, Bt = Ie - B, F = ($e * F - I * Bt) / W, !(F < 0 | F > 1)) && (W = (ue * $e - z * Bt) / W, W >= 0 & W <= 1)) {
                    f = 1;
                    break e;
                  }
                while ((f | 0) < (T | 0));
              }
              if ((A | 0) >= (d[h >> 2] | 0)) {
                f = 0;
                break;
              }
            }
          } else
            f = 0;
        while (!1);
        return Or = f, Ae = Ht, Or | 0;
      }
      function co(h, f, A, b) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0;
        var T = 0, C = 0, I = 0;
        if (Co(h, f, A, b) | 0)
          return C = 1, C | 0;
        if (C = h + 8 | 0, (d[C >> 2] | 0) <= 0)
          return C = 0, C | 0;
        for (T = h + 12 | 0, h = 0; ; ) {
          if (I = h, h = h + 1 | 0, Co((d[T >> 2] | 0) + (I << 3) | 0, f + (h << 5) | 0, A, b) | 0) {
            h = 1, T = 6;
            break;
          }
          if ((h | 0) >= (d[C >> 2] | 0)) {
            h = 0, T = 6;
            break;
          }
        }
        return (T | 0) == 6 ? h | 0 : 0;
      }
      function cs() {
        return 8;
      }
      function Cc() {
        return 16;
      }
      function Mr() {
        return 168;
      }
      function Ar() {
        return 8;
      }
      function Tu() {
        return 16;
      }
      function us() {
        return 12;
      }
      function So() {
        return 8;
      }
      function Xi(h) {
        return h = h | 0, +(+((d[h >> 2] | 0) >>> 0) + 4294967296 * +(d[h + 4 >> 2] | 0));
      }
      function Ho(h) {
        h = h | 0;
        var f = 0, A = 0;
        return A = +ee[h >> 3], f = +ee[h + 8 >> 3], + +zt(+(A * A + f * f));
      }
      function Eu(h, f, A, b, T) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0, T = T | 0;
        var C = 0, I = 0, B = 0, F = 0, z = 0, W = 0, ue = 0, Ie = 0;
        z = +ee[h >> 3], F = +ee[f >> 3] - z, B = +ee[h + 8 >> 3], I = +ee[f + 8 >> 3] - B, ue = +ee[A >> 3], C = +ee[b >> 3] - ue, Ie = +ee[A + 8 >> 3], W = +ee[b + 8 >> 3] - Ie, C = (C * (B - Ie) - (z - ue) * W) / (F * W - I * C), ee[T >> 3] = z + F * C, ee[T + 8 >> 3] = B + I * C;
      }
      function Sc(h, f) {
        return h = h | 0, f = f | 0, +kt(+(+ee[h >> 3] - +ee[f >> 3])) < 11920928955078125e-23 ? (f = +kt(+(+ee[h + 8 >> 3] - +ee[f + 8 >> 3])) < 11920928955078125e-23, f | 0) : (f = 0, f | 0);
      }
      function Xr(h, f) {
        h = h | 0, f = f | 0;
        var A = 0, b = 0, T = 0;
        return T = +ee[h >> 3] - +ee[f >> 3], b = +ee[h + 8 >> 3] - +ee[f + 8 >> 3], A = +ee[h + 16 >> 3] - +ee[f + 16 >> 3], +(T * T + b * b + A * A);
      }
      function zi(h, f) {
        h = h | 0, f = f | 0;
        var A = 0, b = 0, T = 0;
        A = +ee[h >> 3], b = +Vt(+A), A = +Lt(+A), ee[f + 16 >> 3] = A, A = +ee[h + 8 >> 3], T = b * +Vt(+A), ee[f >> 3] = T, A = b * +Lt(+A), ee[f + 8 >> 3] = A;
      }
      function Vh(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0;
        var b = 0, T = 0, C = 0;
        if (C = Ae, Ae = Ae + 16 | 0, T = C, b = Bn(h, f) | 0, (A + -1 | 0) >>> 0 > 5 || (b = (b | 0) != 0, (A | 0) == 1 & b))
          return T = -1, Ae = C, T | 0;
        do
          if (Io(h, f, T) | 0)
            b = -1;
          else if (b) {
            b = ((d[26352 + (A << 2) >> 2] | 0) + 5 - (d[T >> 2] | 0) | 0) % 5 | 0;
            break;
          } else {
            b = ((d[26384 + (A << 2) >> 2] | 0) + 6 - (d[T >> 2] | 0) | 0) % 6 | 0;
            break;
          }
        while (!1);
        return T = b, Ae = C, T | 0;
      }
      function Io(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0;
        var b = 0, T = 0, C = 0, I = 0, B = 0, F = 0, z = 0;
        if (z = Ae, Ae = Ae + 32 | 0, I = z + 16 | 0, B = z, b = xa(h, f, I) | 0, b | 0)
          return A = b, Ae = z, A | 0;
        C = df(h, f) | 0, F = ys(h, f) | 0, Th(C, B), b = Tl(C, d[I >> 2] | 0) | 0;
        e: do
          if (mn(C) | 0) {
            do
              switch (C | 0) {
                case 4: {
                  h = 0;
                  break;
                }
                case 14: {
                  h = 1;
                  break;
                }
                case 24: {
                  h = 2;
                  break;
                }
                case 38: {
                  h = 3;
                  break;
                }
                case 49: {
                  h = 4;
                  break;
                }
                case 58: {
                  h = 5;
                  break;
                }
                case 63: {
                  h = 6;
                  break;
                }
                case 72: {
                  h = 7;
                  break;
                }
                case 83: {
                  h = 8;
                  break;
                }
                case 97: {
                  h = 9;
                  break;
                }
                case 107: {
                  h = 10;
                  break;
                }
                case 117: {
                  h = 11;
                  break;
                }
                default: {
                  b = 1;
                  break e;
                }
              }
            while (!1);
            if (T = d[26416 + (h * 24 | 0) + 8 >> 2] | 0, f = d[26416 + (h * 24 | 0) + 16 >> 2] | 0, h = d[I >> 2] | 0, (h | 0) != (d[B >> 2] | 0) && (B = Di(C) | 0, h = d[I >> 2] | 0, B | (h | 0) == (f | 0) && (b = (b + 1 | 0) % 6 | 0)), (F | 0) == 3 & (h | 0) == (f | 0)) {
              b = (b + 5 | 0) % 6 | 0, T = 22;
              break;
            }
            (F | 0) == 5 & (h | 0) == (T | 0) && (b = (b + 1 | 0) % 6 | 0), T = 22;
          } else
            T = 22;
        while (!1);
        return (T | 0) == 22 && (d[A >> 2] = b, b = 0), A = b, Ae = z, A | 0;
      }
      function Ns(h, f, A, b) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0;
        var T = 0, C = 0, I = 0, B = 0, F = 0, z = 0, W = 0, ue = 0, Ie = 0, Re = 0, Be = 0, Ze = 0, We = 0, rt = 0, et = 0, Je = 0;
        if (Je = Ae, Ae = Ae + 32 | 0, et = Je + 24 | 0, We = Je + 20 | 0, Be = Je + 8 | 0, Re = Je + 16 | 0, Ie = Je, F = (Bn(h, f) | 0) == 0, F = F ? 6 : 5, W = D(h | 0, f | 0, 52) | 0, ye() | 0, W = W & 15, F >>> 0 <= A >>> 0)
          return b = 2, Ae = Je, b | 0;
        ue = (W | 0) == 0, !ue && (Ze = k(7, 0, (W ^ 15) * 3 | 0) | 0, (Ze & h | 0) == 0 & ((ye() | 0) & f | 0) == 0) ? T = A : C = 4;
        e: do
          if ((C | 0) == 4) {
            if (T = (Bn(h, f) | 0) != 0, ((T ? 4 : 5) | 0) < (A | 0) || Io(h, f, et) | 0 || (C = (d[et >> 2] | 0) + A | 0, T ? T = 26704 + (((C | 0) % 5 | 0) << 2) | 0 : T = 26736 + (((C | 0) % 6 | 0) << 2) | 0, Ze = d[T >> 2] | 0, (Ze | 0) == 7))
              return b = 1, Ae = Je, b | 0;
            d[We >> 2] = 0, T = On(h, f, Ze, We, Be) | 0;
            do
              if (!T) {
                if (B = Be, z = d[B >> 2] | 0, B = d[B + 4 >> 2] | 0, I = B >>> 0 < f >>> 0 | (B | 0) == (f | 0) & z >>> 0 < h >>> 0, C = I ? z : h, I = I ? B : f, !ue && (ue = k(7, 0, (W ^ 15) * 3 | 0) | 0, (z & ue | 0) == 0 & (B & (ye() | 0) | 0) == 0))
                  T = A;
                else {
                  if (B = (A + -1 + F | 0) % (F | 0) | 0, T = Bn(h, f) | 0, (B | 0) < 0 && er(27795, 27797, 246, 27806), F = (T | 0) != 0, ((F ? 4 : 5) | 0) < (B | 0) && er(27795, 27797, 246, 27806), Io(h, f, et) | 0 && er(27795, 27797, 246, 27806), T = (d[et >> 2] | 0) + B | 0, F ? T = 26704 + (((T | 0) % 5 | 0) << 2) | 0 : T = 26736 + (((T | 0) % 6 | 0) << 2) | 0, B = d[T >> 2] | 0, (B | 0) == 7 && er(27795, 27797, 246, 27806), d[Re >> 2] = 0, T = On(h, f, B, Re, Ie) | 0, T | 0)
                    break;
                  z = Ie, F = d[z >> 2] | 0, z = d[z + 4 >> 2] | 0;
                  do
                    if (z >>> 0 < I >>> 0 | (z | 0) == (I | 0) & F >>> 0 < C >>> 0) {
                      if (Bn(F, z) | 0 ? C = Ke(F, z, h, f) | 0 : C = d[26800 + ((((d[Re >> 2] | 0) + (d[26768 + (B << 2) >> 2] | 0) | 0) % 6 | 0) << 2) >> 2] | 0, T = Bn(F, z) | 0, (C + -1 | 0) >>> 0 > 5) {
                        T = -1, C = F, I = z;
                        break;
                      }
                      if (T = (T | 0) != 0, (C | 0) == 1 & T) {
                        T = -1, C = F, I = z;
                        break;
                      }
                      do
                        if (Io(F, z, et) | 0)
                          T = -1;
                        else if (T) {
                          T = ((d[26352 + (C << 2) >> 2] | 0) + 5 - (d[et >> 2] | 0) | 0) % 5 | 0;
                          break;
                        } else {
                          T = ((d[26384 + (C << 2) >> 2] | 0) + 6 - (d[et >> 2] | 0) | 0) % 6 | 0;
                          break;
                        }
                      while (!1);
                      C = F, I = z;
                    } else
                      T = A;
                  while (!1);
                  B = Be, z = d[B >> 2] | 0, B = d[B + 4 >> 2] | 0;
                }
                if ((C | 0) == (z | 0) & (I | 0) == (B | 0)) {
                  if (F = (Bn(z, B) | 0) != 0, F ? h = Ke(z, B, h, f) | 0 : h = d[26800 + ((((d[We >> 2] | 0) + (d[26768 + (Ze << 2) >> 2] | 0) | 0) % 6 | 0) << 2) >> 2] | 0, T = Bn(z, B) | 0, (h + -1 | 0) >>> 0 <= 5 && (rt = (T | 0) != 0, !((h | 0) == 1 & rt)))
                    do
                      if (Io(z, B, et) | 0)
                        T = -1;
                      else if (rt) {
                        T = ((d[26352 + (h << 2) >> 2] | 0) + 5 - (d[et >> 2] | 0) | 0) % 5 | 0;
                        break;
                      } else {
                        T = ((d[26384 + (h << 2) >> 2] | 0) + 6 - (d[et >> 2] | 0) | 0) % 6 | 0;
                        break;
                      }
                    while (!1);
                  else
                    T = -1;
                  T = T + 1 | 0, T = (T | 0) == 6 | F & (T | 0) == 5 ? 0 : T;
                }
                f = I, h = C;
                break e;
              }
            while (!1);
            return b = T, Ae = Je, b | 0;
          }
        while (!1);
        return rt = k(T | 0, 0, 56) | 0, et = ye() | 0 | f & -2130706433 | 536870912, d[b >> 2] = rt | h, d[b + 4 >> 2] = et, b = 0, Ae = Je, b | 0;
      }
      function sa(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0;
        var b = 0, T = 0, C = 0;
        return C = (Bn(h, f) | 0) == 0, b = Ns(h, f, 0, A) | 0, T = (b | 0) == 0, C ? !T || (b = Ns(h, f, 1, A + 8 | 0) | 0, b | 0) || (b = Ns(h, f, 2, A + 16 | 0) | 0, b | 0) || (b = Ns(h, f, 3, A + 24 | 0) | 0, b | 0) || (b = Ns(h, f, 4, A + 32 | 0) | 0, b) ? (C = b, C | 0) : Ns(h, f, 5, A + 40 | 0) | 0 : !T || (b = Ns(h, f, 1, A + 8 | 0) | 0, b | 0) || (b = Ns(h, f, 2, A + 16 | 0) | 0, b | 0) || (b = Ns(h, f, 3, A + 24 | 0) | 0, b | 0) || (b = Ns(h, f, 4, A + 32 | 0) | 0, b | 0) ? (C = b, C | 0) : (C = A + 40 | 0, d[C >> 2] = 0, d[C + 4 >> 2] = 0, C = 0, C | 0);
      }
      function Us(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0;
        var b = 0, T = 0, C = 0, I = 0, B = 0, F = 0;
        return F = Ae, Ae = Ae + 192 | 0, T = F, C = F + 168 | 0, I = D(h | 0, f | 0, 56) | 0, ye() | 0, I = I & 7, B = f & -2130706433 | 134217728, b = xa(h, B, C) | 0, b | 0 ? (B = b, Ae = F, B | 0) : (f = D(h | 0, f | 0, 52) | 0, ye() | 0, f = f & 15, Bn(h, B) | 0 ? na(C, f, I, 1, T) : Sl(C, f, I, 1, T), B = T + 8 | 0, d[A >> 2] = d[B >> 2], d[A + 4 >> 2] = d[B + 4 >> 2], d[A + 8 >> 2] = d[B + 8 >> 2], d[A + 12 >> 2] = d[B + 12 >> 2], B = 0, Ae = F, B | 0);
      }
      function Fl(h, f) {
        h = h | 0, f = f | 0;
        var A = 0, b = 0, T = 0, C = 0;
        return T = Ae, Ae = Ae + 16 | 0, A = T, !(!0 & (f & 2013265920 | 0) == 536870912) || (b = f & -2130706433 | 134217728, !(pf(h, b) | 0)) ? (b = 0, Ae = T, b | 0) : (C = D(h | 0, f | 0, 56) | 0, ye() | 0, C = (Ns(h, b, C & 7, A) | 0) == 0, b = A, b = C & ((d[b >> 2] | 0) == (h | 0) ? (d[b + 4 >> 2] | 0) == (f | 0) : 0) & 1, Ae = T, b | 0);
      }
      function Po(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0;
        var b = 0;
        (f | 0) > 0 ? (b = Ii(f, 4) | 0, d[h >> 2] = b, b || er(27819, 27842, 40, 27856)) : d[h >> 2] = 0, d[h + 4 >> 2] = f, d[h + 8 >> 2] = 0, d[h + 12 >> 2] = A;
      }
      function Ic(h) {
        h = h | 0;
        var f = 0, A = 0, b = 0, T = 0, C = 0, I = 0, B = 0;
        T = h + 4 | 0, C = h + 12 | 0, I = h + 8 | 0;
        e: for (; ; ) {
          for (A = d[T >> 2] | 0, f = 0; ; ) {
            if ((f | 0) >= (A | 0))
              break e;
            if (b = d[h >> 2] | 0, B = d[b + (f << 2) >> 2] | 0, !B)
              f = f + 1 | 0;
            else
              break;
          }
          f = b + (~~(+kt(+(+_t(10, + +(15 - (d[C >> 2] | 0) | 0)) * (+ee[B >> 3] + +ee[B + 8 >> 3]))) % +(A | 0)) >>> 0 << 2) | 0, A = d[f >> 2] | 0;
          t: do
            if (A | 0) {
              if (b = B + 32 | 0, (A | 0) == (B | 0))
                d[f >> 2] = d[b >> 2];
              else {
                if (A = A + 32 | 0, f = d[A >> 2] | 0, !f)
                  break;
                for (; (f | 0) != (B | 0); )
                  if (A = f + 32 | 0, f = d[A >> 2] | 0, !f)
                    break t;
                d[A >> 2] = d[b >> 2];
              }
              Ur(B), d[I >> 2] = (d[I >> 2] | 0) + -1;
            }
          while (!1);
        }
        Ur(d[h >> 2] | 0);
      }
      function Ka(h) {
        h = h | 0;
        var f = 0, A = 0, b = 0;
        for (b = d[h + 4 >> 2] | 0, A = 0; ; ) {
          if ((A | 0) >= (b | 0)) {
            f = 0, A = 4;
            break;
          }
          if (f = d[(d[h >> 2] | 0) + (A << 2) >> 2] | 0, !f)
            A = A + 1 | 0;
          else {
            A = 4;
            break;
          }
        }
        return (A | 0) == 4 ? f | 0 : 0;
      }
      function Nl(h, f) {
        h = h | 0, f = f | 0;
        var A = 0, b = 0, T = 0, C = 0;
        if (A = ~~(+kt(+(+_t(10, + +(15 - (d[h + 12 >> 2] | 0) | 0)) * (+ee[f >> 3] + +ee[f + 8 >> 3]))) % +(d[h + 4 >> 2] | 0)) >>> 0, A = (d[h >> 2] | 0) + (A << 2) | 0, b = d[A >> 2] | 0, !b)
          return C = 1, C | 0;
        C = f + 32 | 0;
        do
          if ((b | 0) != (f | 0)) {
            if (A = d[b + 32 >> 2] | 0, !A)
              return C = 1, C | 0;
            for (T = A; ; ) {
              if ((T | 0) == (f | 0)) {
                T = 8;
                break;
              }
              if (A = d[T + 32 >> 2] | 0, A)
                b = T, T = A;
              else {
                A = 1, T = 10;
                break;
              }
            }
            if ((T | 0) == 8) {
              d[b + 32 >> 2] = d[C >> 2];
              break;
            } else if ((T | 0) == 10)
              return A | 0;
          } else
            d[A >> 2] = d[C >> 2];
        while (!1);
        return Ur(f), C = h + 8 | 0, d[C >> 2] = (d[C >> 2] | 0) + -1, C = 0, C | 0;
      }
      function bf(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0;
        var b = 0, T = 0, C = 0, I = 0;
        C = ss(40) | 0, C || er(27872, 27842, 98, 27885), d[C >> 2] = d[f >> 2], d[C + 4 >> 2] = d[f + 4 >> 2], d[C + 8 >> 2] = d[f + 8 >> 2], d[C + 12 >> 2] = d[f + 12 >> 2], T = C + 16 | 0, d[T >> 2] = d[A >> 2], d[T + 4 >> 2] = d[A + 4 >> 2], d[T + 8 >> 2] = d[A + 8 >> 2], d[T + 12 >> 2] = d[A + 12 >> 2], d[C + 32 >> 2] = 0, T = ~~(+kt(+(+_t(10, + +(15 - (d[h + 12 >> 2] | 0) | 0)) * (+ee[f >> 3] + +ee[f + 8 >> 3]))) % +(d[h + 4 >> 2] | 0)) >>> 0, T = (d[h >> 2] | 0) + (T << 2) | 0, b = d[T >> 2] | 0;
        do
          if (!b)
            d[T >> 2] = C;
          else {
            for (; !(Zs(b, f) | 0 && Zs(b + 16 | 0, A) | 0); )
              if (T = d[b + 32 >> 2] | 0, b = (T | 0) == 0 ? b : T, !(d[b + 32 >> 2] | 0)) {
                I = 10;
                break;
              }
            if ((I | 0) == 10) {
              d[b + 32 >> 2] = C;
              break;
            }
            return Ur(C), I = b, I | 0;
          }
        while (!1);
        return I = h + 8 | 0, d[I >> 2] = (d[I >> 2] | 0) + 1, I = C, I | 0;
      }
      function Ul(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0;
        var b = 0, T = 0;
        if (T = ~~(+kt(+(+_t(10, + +(15 - (d[h + 12 >> 2] | 0) | 0)) * (+ee[f >> 3] + +ee[f + 8 >> 3]))) % +(d[h + 4 >> 2] | 0)) >>> 0, T = d[(d[h >> 2] | 0) + (T << 2) >> 2] | 0, !T)
          return A = 0, A | 0;
        if (!A) {
          for (h = T; ; ) {
            if (Zs(h, f) | 0) {
              b = 10;
              break;
            }
            if (h = d[h + 32 >> 2] | 0, !h) {
              h = 0, b = 10;
              break;
            }
          }
          if ((b | 0) == 10)
            return h | 0;
        }
        for (h = T; ; ) {
          if (Zs(h, f) | 0 && Zs(h + 16 | 0, A) | 0) {
            b = 10;
            break;
          }
          if (h = d[h + 32 >> 2] | 0, !h) {
            h = 0, b = 10;
            break;
          }
        }
        return (b | 0) == 10 ? h | 0 : 0;
      }
      function Qa(h, f) {
        h = h | 0, f = f | 0;
        var A = 0;
        if (A = ~~(+kt(+(+_t(10, + +(15 - (d[h + 12 >> 2] | 0) | 0)) * (+ee[f >> 3] + +ee[f + 8 >> 3]))) % +(d[h + 4 >> 2] | 0)) >>> 0, h = d[(d[h >> 2] | 0) + (A << 2) >> 2] | 0, !h)
          return A = 0, A | 0;
        for (; ; ) {
          if (Zs(h, f) | 0) {
            f = 5;
            break;
          }
          if (h = d[h + 32 >> 2] | 0, !h) {
            h = 0, f = 5;
            break;
          }
        }
        return (f | 0) == 5 ? h | 0 : 0;
      }
      function xf() {
        return 27904;
      }
      function xs(h) {
        return h = +h, ~~+He(+h) | 0;
      }
      function ss(h) {
        h = h | 0;
        var f = 0, A = 0, b = 0, T = 0, C = 0, I = 0, B = 0, F = 0, z = 0, W = 0, ue = 0, Ie = 0, Re = 0, Be = 0, Ze = 0, We = 0, rt = 0, et = 0, Je = 0, $e = 0, Bt = 0;
        Bt = Ae, Ae = Ae + 16 | 0, Ie = Bt;
        do
          if (h >>> 0 < 245) {
            if (z = h >>> 0 < 11 ? 16 : h + 11 & -8, h = z >>> 3, ue = d[6977] | 0, A = ue >>> h, A & 3 | 0)
              return f = (A & 1 ^ 1) + h | 0, h = 27948 + (f << 1 << 2) | 0, A = h + 8 | 0, b = d[A >> 2] | 0, T = b + 8 | 0, C = d[T >> 2] | 0, (C | 0) == (h | 0) ? d[6977] = ue & ~(1 << f) : (d[C + 12 >> 2] = h, d[A >> 2] = C), $e = f << 3, d[b + 4 >> 2] = $e | 3, $e = b + $e + 4 | 0, d[$e >> 2] = d[$e >> 2] | 1, $e = T, Ae = Bt, $e | 0;
            if (W = d[6979] | 0, z >>> 0 > W >>> 0) {
              if (A | 0)
                return f = 2 << h, f = A << h & (f | 0 - f), f = (f & 0 - f) + -1 | 0, B = f >>> 12 & 16, f = f >>> B, A = f >>> 5 & 8, f = f >>> A, C = f >>> 2 & 4, f = f >>> C, h = f >>> 1 & 2, f = f >>> h, b = f >>> 1 & 1, b = (A | B | C | h | b) + (f >>> b) | 0, f = 27948 + (b << 1 << 2) | 0, h = f + 8 | 0, C = d[h >> 2] | 0, B = C + 8 | 0, A = d[B >> 2] | 0, (A | 0) == (f | 0) ? (h = ue & ~(1 << b), d[6977] = h) : (d[A + 12 >> 2] = f, d[h >> 2] = A, h = ue), $e = b << 3, I = $e - z | 0, d[C + 4 >> 2] = z | 3, T = C + z | 0, d[T + 4 >> 2] = I | 1, d[C + $e >> 2] = I, W | 0 && (b = d[6982] | 0, f = W >>> 3, A = 27948 + (f << 1 << 2) | 0, f = 1 << f, h & f ? (h = A + 8 | 0, f = d[h >> 2] | 0) : (d[6977] = h | f, f = A, h = A + 8 | 0), d[h >> 2] = b, d[f + 12 >> 2] = b, d[b + 8 >> 2] = f, d[b + 12 >> 2] = A), d[6979] = I, d[6982] = T, $e = B, Ae = Bt, $e | 0;
              if (C = d[6978] | 0, C) {
                for (A = (C & 0 - C) + -1 | 0, T = A >>> 12 & 16, A = A >>> T, b = A >>> 5 & 8, A = A >>> b, I = A >>> 2 & 4, A = A >>> I, B = A >>> 1 & 2, A = A >>> B, F = A >>> 1 & 1, F = d[28212 + ((b | T | I | B | F) + (A >>> F) << 2) >> 2] | 0, A = F, B = F, F = (d[F + 4 >> 2] & -8) - z | 0; h = d[A + 16 >> 2] | 0, !(!h && (h = d[A + 20 >> 2] | 0, !h)); )
                  I = (d[h + 4 >> 2] & -8) - z | 0, T = I >>> 0 < F >>> 0, A = h, B = T ? h : B, F = T ? I : F;
                if (I = B + z | 0, I >>> 0 > B >>> 0) {
                  T = d[B + 24 >> 2] | 0, f = d[B + 12 >> 2] | 0;
                  do
                    if ((f | 0) == (B | 0)) {
                      if (h = B + 20 | 0, f = d[h >> 2] | 0, !f && (h = B + 16 | 0, f = d[h >> 2] | 0, !f)) {
                        A = 0;
                        break;
                      }
                      for (; ; )
                        if (b = f + 20 | 0, A = d[b >> 2] | 0, A)
                          f = A, h = b;
                        else if (b = f + 16 | 0, A = d[b >> 2] | 0, A)
                          f = A, h = b;
                        else
                          break;
                      d[h >> 2] = 0, A = f;
                    } else
                      A = d[B + 8 >> 2] | 0, d[A + 12 >> 2] = f, d[f + 8 >> 2] = A, A = f;
                  while (!1);
                  do
                    if (T | 0) {
                      if (f = d[B + 28 >> 2] | 0, h = 28212 + (f << 2) | 0, (B | 0) == (d[h >> 2] | 0)) {
                        if (d[h >> 2] = A, !A) {
                          d[6978] = C & ~(1 << f);
                          break;
                        }
                      } else if ($e = T + 16 | 0, d[((d[$e >> 2] | 0) == (B | 0) ? $e : T + 20 | 0) >> 2] = A, !A)
                        break;
                      d[A + 24 >> 2] = T, f = d[B + 16 >> 2] | 0, f | 0 && (d[A + 16 >> 2] = f, d[f + 24 >> 2] = A), f = d[B + 20 >> 2] | 0, f | 0 && (d[A + 20 >> 2] = f, d[f + 24 >> 2] = A);
                    }
                  while (!1);
                  return F >>> 0 < 16 ? ($e = F + z | 0, d[B + 4 >> 2] = $e | 3, $e = B + $e + 4 | 0, d[$e >> 2] = d[$e >> 2] | 1) : (d[B + 4 >> 2] = z | 3, d[I + 4 >> 2] = F | 1, d[I + F >> 2] = F, W | 0 && (b = d[6982] | 0, f = W >>> 3, A = 27948 + (f << 1 << 2) | 0, f = 1 << f, f & ue ? (h = A + 8 | 0, f = d[h >> 2] | 0) : (d[6977] = f | ue, f = A, h = A + 8 | 0), d[h >> 2] = b, d[f + 12 >> 2] = b, d[b + 8 >> 2] = f, d[b + 12 >> 2] = A), d[6979] = F, d[6982] = I), $e = B + 8 | 0, Ae = Bt, $e | 0;
                } else
                  ue = z;
              } else
                ue = z;
            } else
              ue = z;
          } else if (h >>> 0 <= 4294967231)
            if (h = h + 11 | 0, z = h & -8, b = d[6978] | 0, b) {
              T = 0 - z | 0, h = h >>> 8, h ? z >>> 0 > 16777215 ? F = 31 : (ue = (h + 1048320 | 0) >>> 16 & 8, Ze = h << ue, B = (Ze + 520192 | 0) >>> 16 & 4, Ze = Ze << B, F = (Ze + 245760 | 0) >>> 16 & 2, F = 14 - (B | ue | F) + (Ze << F >>> 15) | 0, F = z >>> (F + 7 | 0) & 1 | F << 1) : F = 0, A = d[28212 + (F << 2) >> 2] | 0;
              e: do
                if (!A)
                  A = 0, h = 0, Ze = 61;
                else
                  for (h = 0, B = z << ((F | 0) == 31 ? 0 : 25 - (F >>> 1) | 0), C = 0; ; ) {
                    if (I = (d[A + 4 >> 2] & -8) - z | 0, I >>> 0 < T >>> 0)
                      if (I)
                        h = A, T = I;
                      else {
                        h = A, T = 0, Ze = 65;
                        break e;
                      }
                    if (Ze = d[A + 20 >> 2] | 0, A = d[A + 16 + (B >>> 31 << 2) >> 2] | 0, C = (Ze | 0) == 0 | (Ze | 0) == (A | 0) ? C : Ze, A)
                      B = B << 1;
                    else {
                      A = C, Ze = 61;
                      break;
                    }
                  }
              while (!1);
              if ((Ze | 0) == 61) {
                if ((A | 0) == 0 & (h | 0) == 0) {
                  if (h = 2 << F, h = (h | 0 - h) & b, !h) {
                    ue = z;
                    break;
                  }
                  ue = (h & 0 - h) + -1 | 0, I = ue >>> 12 & 16, ue = ue >>> I, C = ue >>> 5 & 8, ue = ue >>> C, B = ue >>> 2 & 4, ue = ue >>> B, F = ue >>> 1 & 2, ue = ue >>> F, A = ue >>> 1 & 1, h = 0, A = d[28212 + ((C | I | B | F | A) + (ue >>> A) << 2) >> 2] | 0;
                }
                A ? Ze = 65 : (B = h, I = T);
              }
              if ((Ze | 0) == 65)
                for (C = A; ; )
                  if (ue = (d[C + 4 >> 2] & -8) - z | 0, A = ue >>> 0 < T >>> 0, T = A ? ue : T, h = A ? C : h, A = d[C + 16 >> 2] | 0, A || (A = d[C + 20 >> 2] | 0), A)
                    C = A;
                  else {
                    B = h, I = T;
                    break;
                  }
              if ((B | 0) != 0 && I >>> 0 < ((d[6979] | 0) - z | 0) >>> 0 && (W = B + z | 0, W >>> 0 > B >>> 0)) {
                C = d[B + 24 >> 2] | 0, f = d[B + 12 >> 2] | 0;
                do
                  if ((f | 0) == (B | 0)) {
                    if (h = B + 20 | 0, f = d[h >> 2] | 0, !f && (h = B + 16 | 0, f = d[h >> 2] | 0, !f)) {
                      f = 0;
                      break;
                    }
                    for (; ; )
                      if (T = f + 20 | 0, A = d[T >> 2] | 0, A)
                        f = A, h = T;
                      else if (T = f + 16 | 0, A = d[T >> 2] | 0, A)
                        f = A, h = T;
                      else
                        break;
                    d[h >> 2] = 0;
                  } else
                    $e = d[B + 8 >> 2] | 0, d[$e + 12 >> 2] = f, d[f + 8 >> 2] = $e;
                while (!1);
                do
                  if (C) {
                    if (h = d[B + 28 >> 2] | 0, A = 28212 + (h << 2) | 0, (B | 0) == (d[A >> 2] | 0)) {
                      if (d[A >> 2] = f, !f) {
                        b = b & ~(1 << h), d[6978] = b;
                        break;
                      }
                    } else if ($e = C + 16 | 0, d[((d[$e >> 2] | 0) == (B | 0) ? $e : C + 20 | 0) >> 2] = f, !f)
                      break;
                    d[f + 24 >> 2] = C, h = d[B + 16 >> 2] | 0, h | 0 && (d[f + 16 >> 2] = h, d[h + 24 >> 2] = f), h = d[B + 20 >> 2] | 0, h && (d[f + 20 >> 2] = h, d[h + 24 >> 2] = f);
                  }
                while (!1);
                e: do
                  if (I >>> 0 < 16)
                    $e = I + z | 0, d[B + 4 >> 2] = $e | 3, $e = B + $e + 4 | 0, d[$e >> 2] = d[$e >> 2] | 1;
                  else {
                    if (d[B + 4 >> 2] = z | 3, d[W + 4 >> 2] = I | 1, d[W + I >> 2] = I, f = I >>> 3, I >>> 0 < 256) {
                      A = 27948 + (f << 1 << 2) | 0, h = d[6977] | 0, f = 1 << f, h & f ? (h = A + 8 | 0, f = d[h >> 2] | 0) : (d[6977] = h | f, f = A, h = A + 8 | 0), d[h >> 2] = W, d[f + 12 >> 2] = W, d[W + 8 >> 2] = f, d[W + 12 >> 2] = A;
                      break;
                    }
                    if (f = I >>> 8, f ? I >>> 0 > 16777215 ? A = 31 : (Je = (f + 1048320 | 0) >>> 16 & 8, $e = f << Je, et = ($e + 520192 | 0) >>> 16 & 4, $e = $e << et, A = ($e + 245760 | 0) >>> 16 & 2, A = 14 - (et | Je | A) + ($e << A >>> 15) | 0, A = I >>> (A + 7 | 0) & 1 | A << 1) : A = 0, f = 28212 + (A << 2) | 0, d[W + 28 >> 2] = A, h = W + 16 | 0, d[h + 4 >> 2] = 0, d[h >> 2] = 0, h = 1 << A, !(b & h)) {
                      d[6978] = b | h, d[f >> 2] = W, d[W + 24 >> 2] = f, d[W + 12 >> 2] = W, d[W + 8 >> 2] = W;
                      break;
                    }
                    f = d[f >> 2] | 0;
                    t: do
                      if ((d[f + 4 >> 2] & -8 | 0) != (I | 0)) {
                        for (b = I << ((A | 0) == 31 ? 0 : 25 - (A >>> 1) | 0); A = f + 16 + (b >>> 31 << 2) | 0, h = d[A >> 2] | 0, !!h; )
                          if ((d[h + 4 >> 2] & -8 | 0) == (I | 0)) {
                            f = h;
                            break t;
                          } else
                            b = b << 1, f = h;
                        d[A >> 2] = W, d[W + 24 >> 2] = f, d[W + 12 >> 2] = W, d[W + 8 >> 2] = W;
                        break e;
                      }
                    while (!1);
                    Je = f + 8 | 0, $e = d[Je >> 2] | 0, d[$e + 12 >> 2] = W, d[Je >> 2] = W, d[W + 8 >> 2] = $e, d[W + 12 >> 2] = f, d[W + 24 >> 2] = 0;
                  }
                while (!1);
                return $e = B + 8 | 0, Ae = Bt, $e | 0;
              } else
                ue = z;
            } else
              ue = z;
          else
            ue = -1;
        while (!1);
        if (A = d[6979] | 0, A >>> 0 >= ue >>> 0)
          return f = A - ue | 0, h = d[6982] | 0, f >>> 0 > 15 ? ($e = h + ue | 0, d[6982] = $e, d[6979] = f, d[$e + 4 >> 2] = f | 1, d[h + A >> 2] = f, d[h + 4 >> 2] = ue | 3) : (d[6979] = 0, d[6982] = 0, d[h + 4 >> 2] = A | 3, $e = h + A + 4 | 0, d[$e >> 2] = d[$e >> 2] | 1), $e = h + 8 | 0, Ae = Bt, $e | 0;
        if (I = d[6980] | 0, I >>> 0 > ue >>> 0)
          return et = I - ue | 0, d[6980] = et, $e = d[6983] | 0, Je = $e + ue | 0, d[6983] = Je, d[Je + 4 >> 2] = et | 1, d[$e + 4 >> 2] = ue | 3, $e = $e + 8 | 0, Ae = Bt, $e | 0;
        if (d[7095] | 0 ? h = d[7097] | 0 : (d[7097] = 4096, d[7096] = 4096, d[7098] = -1, d[7099] = -1, d[7100] = 0, d[7088] = 0, d[7095] = Ie & -16 ^ 1431655768, h = 4096), B = ue + 48 | 0, F = ue + 47 | 0, C = h + F | 0, T = 0 - h | 0, z = C & T, z >>> 0 <= ue >>> 0 || (h = d[7087] | 0, h | 0 && (W = d[7085] | 0, Ie = W + z | 0, Ie >>> 0 <= W >>> 0 | Ie >>> 0 > h >>> 0)))
          return $e = 0, Ae = Bt, $e | 0;
        e: do
          if (d[7088] & 4)
            f = 0, Ze = 143;
          else {
            A = d[6983] | 0;
            t: do
              if (A) {
                for (b = 28356; Ie = d[b >> 2] | 0, !(Ie >>> 0 <= A >>> 0 && (Ie + (d[b + 4 >> 2] | 0) | 0) >>> 0 > A >>> 0); )
                  if (h = d[b + 8 >> 2] | 0, h)
                    b = h;
                  else {
                    Ze = 128;
                    break t;
                  }
                if (f = C - I & T, f >>> 0 < 2147483647)
                  if (h = ze(f | 0) | 0, (h | 0) == ((d[b >> 2] | 0) + (d[b + 4 >> 2] | 0) | 0)) {
                    if ((h | 0) != -1) {
                      I = f, C = h, Ze = 145;
                      break e;
                    }
                  } else
                    b = h, Ze = 136;
                else
                  f = 0;
              } else
                Ze = 128;
            while (!1);
            do
              if ((Ze | 0) == 128)
                if (A = ze(0) | 0, (A | 0) != -1 && (f = A, Re = d[7096] | 0, Be = Re + -1 | 0, f = ((Be & f | 0) == 0 ? 0 : (Be + f & 0 - Re) - f | 0) + z | 0, Re = d[7085] | 0, Be = f + Re | 0, f >>> 0 > ue >>> 0 & f >>> 0 < 2147483647)) {
                  if (Ie = d[7087] | 0, Ie | 0 && Be >>> 0 <= Re >>> 0 | Be >>> 0 > Ie >>> 0) {
                    f = 0;
                    break;
                  }
                  if (h = ze(f | 0) | 0, (h | 0) == (A | 0)) {
                    I = f, C = A, Ze = 145;
                    break e;
                  } else
                    b = h, Ze = 136;
                } else
                  f = 0;
            while (!1);
            do
              if ((Ze | 0) == 136) {
                if (A = 0 - f | 0, !(B >>> 0 > f >>> 0 & (f >>> 0 < 2147483647 & (b | 0) != -1)))
                  if ((b | 0) == -1) {
                    f = 0;
                    break;
                  } else {
                    I = f, C = b, Ze = 145;
                    break e;
                  }
                if (h = d[7097] | 0, h = F - f + h & 0 - h, h >>> 0 >= 2147483647) {
                  I = f, C = b, Ze = 145;
                  break e;
                }
                if ((ze(h | 0) | 0) == -1) {
                  ze(A | 0) | 0, f = 0;
                  break;
                } else {
                  I = h + f | 0, C = b, Ze = 145;
                  break e;
                }
              }
            while (!1);
            d[7088] = d[7088] | 4, Ze = 143;
          }
        while (!1);
        if ((Ze | 0) == 143 && z >>> 0 < 2147483647 && (et = ze(z | 0) | 0, Be = ze(0) | 0, We = Be - et | 0, rt = We >>> 0 > (ue + 40 | 0) >>> 0, !((et | 0) == -1 | rt ^ 1 | et >>> 0 < Be >>> 0 & ((et | 0) != -1 & (Be | 0) != -1) ^ 1)) && (I = rt ? We : f, C = et, Ze = 145), (Ze | 0) == 145) {
          f = (d[7085] | 0) + I | 0, d[7085] = f, f >>> 0 > (d[7086] | 0) >>> 0 && (d[7086] = f), F = d[6983] | 0;
          e: do
            if (F) {
              for (f = 28356; ; ) {
                if (h = d[f >> 2] | 0, A = d[f + 4 >> 2] | 0, (C | 0) == (h + A | 0)) {
                  Ze = 154;
                  break;
                }
                if (b = d[f + 8 >> 2] | 0, b)
                  f = b;
                else
                  break;
              }
              if ((Ze | 0) == 154 && (Je = f + 4 | 0, (d[f + 12 >> 2] & 8 | 0) == 0) && C >>> 0 > F >>> 0 & h >>> 0 <= F >>> 0) {
                d[Je >> 2] = A + I, $e = (d[6980] | 0) + I | 0, et = F + 8 | 0, et = (et & 7 | 0) == 0 ? 0 : 0 - et & 7, Je = F + et | 0, et = $e - et | 0, d[6983] = Je, d[6980] = et, d[Je + 4 >> 2] = et | 1, d[F + $e + 4 >> 2] = 40, d[6984] = d[7099];
                break;
              }
              for (C >>> 0 < (d[6981] | 0) >>> 0 && (d[6981] = C), A = C + I | 0, f = 28356; ; ) {
                if ((d[f >> 2] | 0) == (A | 0)) {
                  Ze = 162;
                  break;
                }
                if (h = d[f + 8 >> 2] | 0, h)
                  f = h;
                else
                  break;
              }
              if ((Ze | 0) == 162 && (d[f + 12 >> 2] & 8 | 0) == 0) {
                d[f >> 2] = C, W = f + 4 | 0, d[W >> 2] = (d[W >> 2] | 0) + I, W = C + 8 | 0, W = C + ((W & 7 | 0) == 0 ? 0 : 0 - W & 7) | 0, f = A + 8 | 0, f = A + ((f & 7 | 0) == 0 ? 0 : 0 - f & 7) | 0, z = W + ue | 0, B = f - W - ue | 0, d[W + 4 >> 2] = ue | 3;
                t: do
                  if ((F | 0) == (f | 0))
                    $e = (d[6980] | 0) + B | 0, d[6980] = $e, d[6983] = z, d[z + 4 >> 2] = $e | 1;
                  else {
                    if ((d[6982] | 0) == (f | 0)) {
                      $e = (d[6979] | 0) + B | 0, d[6979] = $e, d[6982] = z, d[z + 4 >> 2] = $e | 1, d[z + $e >> 2] = $e;
                      break;
                    }
                    if (h = d[f + 4 >> 2] | 0, (h & 3 | 0) == 1) {
                      I = h & -8, b = h >>> 3;
                      r: do
                        if (h >>> 0 < 256)
                          if (h = d[f + 8 >> 2] | 0, A = d[f + 12 >> 2] | 0, (A | 0) == (h | 0)) {
                            d[6977] = d[6977] & ~(1 << b);
                            break;
                          } else {
                            d[h + 12 >> 2] = A, d[A + 8 >> 2] = h;
                            break;
                          }
                        else {
                          C = d[f + 24 >> 2] | 0, h = d[f + 12 >> 2] | 0;
                          do
                            if ((h | 0) == (f | 0)) {
                              if (A = f + 16 | 0, b = A + 4 | 0, h = d[b >> 2] | 0, h)
                                A = b;
                              else if (h = d[A >> 2] | 0, !h) {
                                h = 0;
                                break;
                              }
                              for (; ; )
                                if (T = h + 20 | 0, b = d[T >> 2] | 0, b)
                                  h = b, A = T;
                                else if (T = h + 16 | 0, b = d[T >> 2] | 0, b)
                                  h = b, A = T;
                                else
                                  break;
                              d[A >> 2] = 0;
                            } else
                              $e = d[f + 8 >> 2] | 0, d[$e + 12 >> 2] = h, d[h + 8 >> 2] = $e;
                          while (!1);
                          if (!C)
                            break;
                          A = d[f + 28 >> 2] | 0, b = 28212 + (A << 2) | 0;
                          do
                            if ((d[b >> 2] | 0) != (f | 0)) {
                              if ($e = C + 16 | 0, d[((d[$e >> 2] | 0) == (f | 0) ? $e : C + 20 | 0) >> 2] = h, !h)
                                break r;
                            } else {
                              if (d[b >> 2] = h, h | 0)
                                break;
                              d[6978] = d[6978] & ~(1 << A);
                              break r;
                            }
                          while (!1);
                          if (d[h + 24 >> 2] = C, A = f + 16 | 0, b = d[A >> 2] | 0, b | 0 && (d[h + 16 >> 2] = b, d[b + 24 >> 2] = h), A = d[A + 4 >> 2] | 0, !A)
                            break;
                          d[h + 20 >> 2] = A, d[A + 24 >> 2] = h;
                        }
                      while (!1);
                      f = f + I | 0, T = I + B | 0;
                    } else
                      T = B;
                    if (f = f + 4 | 0, d[f >> 2] = d[f >> 2] & -2, d[z + 4 >> 2] = T | 1, d[z + T >> 2] = T, f = T >>> 3, T >>> 0 < 256) {
                      A = 27948 + (f << 1 << 2) | 0, h = d[6977] | 0, f = 1 << f, h & f ? (h = A + 8 | 0, f = d[h >> 2] | 0) : (d[6977] = h | f, f = A, h = A + 8 | 0), d[h >> 2] = z, d[f + 12 >> 2] = z, d[z + 8 >> 2] = f, d[z + 12 >> 2] = A;
                      break;
                    }
                    f = T >>> 8;
                    do
                      if (!f)
                        b = 0;
                      else {
                        if (T >>> 0 > 16777215) {
                          b = 31;
                          break;
                        }
                        Je = (f + 1048320 | 0) >>> 16 & 8, $e = f << Je, et = ($e + 520192 | 0) >>> 16 & 4, $e = $e << et, b = ($e + 245760 | 0) >>> 16 & 2, b = 14 - (et | Je | b) + ($e << b >>> 15) | 0, b = T >>> (b + 7 | 0) & 1 | b << 1;
                      }
                    while (!1);
                    if (f = 28212 + (b << 2) | 0, d[z + 28 >> 2] = b, h = z + 16 | 0, d[h + 4 >> 2] = 0, d[h >> 2] = 0, h = d[6978] | 0, A = 1 << b, !(h & A)) {
                      d[6978] = h | A, d[f >> 2] = z, d[z + 24 >> 2] = f, d[z + 12 >> 2] = z, d[z + 8 >> 2] = z;
                      break;
                    }
                    f = d[f >> 2] | 0;
                    r: do
                      if ((d[f + 4 >> 2] & -8 | 0) != (T | 0)) {
                        for (b = T << ((b | 0) == 31 ? 0 : 25 - (b >>> 1) | 0); A = f + 16 + (b >>> 31 << 2) | 0, h = d[A >> 2] | 0, !!h; )
                          if ((d[h + 4 >> 2] & -8 | 0) == (T | 0)) {
                            f = h;
                            break r;
                          } else
                            b = b << 1, f = h;
                        d[A >> 2] = z, d[z + 24 >> 2] = f, d[z + 12 >> 2] = z, d[z + 8 >> 2] = z;
                        break t;
                      }
                    while (!1);
                    Je = f + 8 | 0, $e = d[Je >> 2] | 0, d[$e + 12 >> 2] = z, d[Je >> 2] = z, d[z + 8 >> 2] = $e, d[z + 12 >> 2] = f, d[z + 24 >> 2] = 0;
                  }
                while (!1);
                return $e = W + 8 | 0, Ae = Bt, $e | 0;
              }
              for (f = 28356; h = d[f >> 2] | 0, !(h >>> 0 <= F >>> 0 && ($e = h + (d[f + 4 >> 2] | 0) | 0, $e >>> 0 > F >>> 0)); )
                f = d[f + 8 >> 2] | 0;
              T = $e + -47 | 0, h = T + 8 | 0, h = T + ((h & 7 | 0) == 0 ? 0 : 0 - h & 7) | 0, T = F + 16 | 0, h = h >>> 0 < T >>> 0 ? F : h, f = h + 8 | 0, A = I + -40 | 0, et = C + 8 | 0, et = (et & 7 | 0) == 0 ? 0 : 0 - et & 7, Je = C + et | 0, et = A - et | 0, d[6983] = Je, d[6980] = et, d[Je + 4 >> 2] = et | 1, d[C + A + 4 >> 2] = 40, d[6984] = d[7099], A = h + 4 | 0, d[A >> 2] = 27, d[f >> 2] = d[7089], d[f + 4 >> 2] = d[7090], d[f + 8 >> 2] = d[7091], d[f + 12 >> 2] = d[7092], d[7089] = C, d[7090] = I, d[7092] = 0, d[7091] = f, f = h + 24 | 0;
              do
                Je = f, f = f + 4 | 0, d[f >> 2] = 7;
              while ((Je + 8 | 0) >>> 0 < $e >>> 0);
              if ((h | 0) != (F | 0)) {
                if (C = h - F | 0, d[A >> 2] = d[A >> 2] & -2, d[F + 4 >> 2] = C | 1, d[h >> 2] = C, f = C >>> 3, C >>> 0 < 256) {
                  A = 27948 + (f << 1 << 2) | 0, h = d[6977] | 0, f = 1 << f, h & f ? (h = A + 8 | 0, f = d[h >> 2] | 0) : (d[6977] = h | f, f = A, h = A + 8 | 0), d[h >> 2] = F, d[f + 12 >> 2] = F, d[F + 8 >> 2] = f, d[F + 12 >> 2] = A;
                  break;
                }
                if (f = C >>> 8, f ? C >>> 0 > 16777215 ? b = 31 : (Je = (f + 1048320 | 0) >>> 16 & 8, $e = f << Je, et = ($e + 520192 | 0) >>> 16 & 4, $e = $e << et, b = ($e + 245760 | 0) >>> 16 & 2, b = 14 - (et | Je | b) + ($e << b >>> 15) | 0, b = C >>> (b + 7 | 0) & 1 | b << 1) : b = 0, A = 28212 + (b << 2) | 0, d[F + 28 >> 2] = b, d[F + 20 >> 2] = 0, d[T >> 2] = 0, f = d[6978] | 0, h = 1 << b, !(f & h)) {
                  d[6978] = f | h, d[A >> 2] = F, d[F + 24 >> 2] = A, d[F + 12 >> 2] = F, d[F + 8 >> 2] = F;
                  break;
                }
                f = d[A >> 2] | 0;
                t: do
                  if ((d[f + 4 >> 2] & -8 | 0) != (C | 0)) {
                    for (b = C << ((b | 0) == 31 ? 0 : 25 - (b >>> 1) | 0); A = f + 16 + (b >>> 31 << 2) | 0, h = d[A >> 2] | 0, !!h; )
                      if ((d[h + 4 >> 2] & -8 | 0) == (C | 0)) {
                        f = h;
                        break t;
                      } else
                        b = b << 1, f = h;
                    d[A >> 2] = F, d[F + 24 >> 2] = f, d[F + 12 >> 2] = F, d[F + 8 >> 2] = F;
                    break e;
                  }
                while (!1);
                Je = f + 8 | 0, $e = d[Je >> 2] | 0, d[$e + 12 >> 2] = F, d[Je >> 2] = F, d[F + 8 >> 2] = $e, d[F + 12 >> 2] = f, d[F + 24 >> 2] = 0;
              }
            } else
              $e = d[6981] | 0, ($e | 0) == 0 | C >>> 0 < $e >>> 0 && (d[6981] = C), d[7089] = C, d[7090] = I, d[7092] = 0, d[6986] = d[7095], d[6985] = -1, d[6990] = 27948, d[6989] = 27948, d[6992] = 27956, d[6991] = 27956, d[6994] = 27964, d[6993] = 27964, d[6996] = 27972, d[6995] = 27972, d[6998] = 27980, d[6997] = 27980, d[7e3] = 27988, d[6999] = 27988, d[7002] = 27996, d[7001] = 27996, d[7004] = 28004, d[7003] = 28004, d[7006] = 28012, d[7005] = 28012, d[7008] = 28020, d[7007] = 28020, d[7010] = 28028, d[7009] = 28028, d[7012] = 28036, d[7011] = 28036, d[7014] = 28044, d[7013] = 28044, d[7016] = 28052, d[7015] = 28052, d[7018] = 28060, d[7017] = 28060, d[7020] = 28068, d[7019] = 28068, d[7022] = 28076, d[7021] = 28076, d[7024] = 28084, d[7023] = 28084, d[7026] = 28092, d[7025] = 28092, d[7028] = 28100, d[7027] = 28100, d[7030] = 28108, d[7029] = 28108, d[7032] = 28116, d[7031] = 28116, d[7034] = 28124, d[7033] = 28124, d[7036] = 28132, d[7035] = 28132, d[7038] = 28140, d[7037] = 28140, d[7040] = 28148, d[7039] = 28148, d[7042] = 28156, d[7041] = 28156, d[7044] = 28164, d[7043] = 28164, d[7046] = 28172, d[7045] = 28172, d[7048] = 28180, d[7047] = 28180, d[7050] = 28188, d[7049] = 28188, d[7052] = 28196, d[7051] = 28196, $e = I + -40 | 0, et = C + 8 | 0, et = (et & 7 | 0) == 0 ? 0 : 0 - et & 7, Je = C + et | 0, et = $e - et | 0, d[6983] = Je, d[6980] = et, d[Je + 4 >> 2] = et | 1, d[C + $e + 4 >> 2] = 40, d[6984] = d[7099];
          while (!1);
          if (f = d[6980] | 0, f >>> 0 > ue >>> 0)
            return et = f - ue | 0, d[6980] = et, $e = d[6983] | 0, Je = $e + ue | 0, d[6983] = Je, d[Je + 4 >> 2] = et | 1, d[$e + 4 >> 2] = ue | 3, $e = $e + 8 | 0, Ae = Bt, $e | 0;
        }
        return $e = xf() | 0, d[$e >> 2] = 12, $e = 0, Ae = Bt, $e | 0;
      }
      function Ur(h) {
        h = h | 0;
        var f = 0, A = 0, b = 0, T = 0, C = 0, I = 0, B = 0, F = 0;
        if (h) {
          A = h + -8 | 0, T = d[6981] | 0, h = d[h + -4 >> 2] | 0, f = h & -8, F = A + f | 0;
          do
            if (h & 1)
              B = A, I = A;
            else {
              if (b = d[A >> 2] | 0, !(h & 3) || (I = A + (0 - b) | 0, C = b + f | 0, I >>> 0 < T >>> 0))
                return;
              if ((d[6982] | 0) == (I | 0)) {
                if (h = F + 4 | 0, f = d[h >> 2] | 0, (f & 3 | 0) != 3) {
                  B = I, f = C;
                  break;
                }
                d[6979] = C, d[h >> 2] = f & -2, d[I + 4 >> 2] = C | 1, d[I + C >> 2] = C;
                return;
              }
              if (A = b >>> 3, b >>> 0 < 256)
                if (h = d[I + 8 >> 2] | 0, f = d[I + 12 >> 2] | 0, (f | 0) == (h | 0)) {
                  d[6977] = d[6977] & ~(1 << A), B = I, f = C;
                  break;
                } else {
                  d[h + 12 >> 2] = f, d[f + 8 >> 2] = h, B = I, f = C;
                  break;
                }
              T = d[I + 24 >> 2] | 0, h = d[I + 12 >> 2] | 0;
              do
                if ((h | 0) == (I | 0)) {
                  if (f = I + 16 | 0, A = f + 4 | 0, h = d[A >> 2] | 0, h)
                    f = A;
                  else if (h = d[f >> 2] | 0, !h) {
                    h = 0;
                    break;
                  }
                  for (; ; )
                    if (b = h + 20 | 0, A = d[b >> 2] | 0, A)
                      h = A, f = b;
                    else if (b = h + 16 | 0, A = d[b >> 2] | 0, A)
                      h = A, f = b;
                    else
                      break;
                  d[f >> 2] = 0;
                } else
                  B = d[I + 8 >> 2] | 0, d[B + 12 >> 2] = h, d[h + 8 >> 2] = B;
              while (!1);
              if (T) {
                if (f = d[I + 28 >> 2] | 0, A = 28212 + (f << 2) | 0, (d[A >> 2] | 0) == (I | 0)) {
                  if (d[A >> 2] = h, !h) {
                    d[6978] = d[6978] & ~(1 << f), B = I, f = C;
                    break;
                  }
                } else if (B = T + 16 | 0, d[((d[B >> 2] | 0) == (I | 0) ? B : T + 20 | 0) >> 2] = h, !h) {
                  B = I, f = C;
                  break;
                }
                d[h + 24 >> 2] = T, f = I + 16 | 0, A = d[f >> 2] | 0, A | 0 && (d[h + 16 >> 2] = A, d[A + 24 >> 2] = h), f = d[f + 4 >> 2] | 0, f ? (d[h + 20 >> 2] = f, d[f + 24 >> 2] = h, B = I, f = C) : (B = I, f = C);
              } else
                B = I, f = C;
            }
          while (!1);
          if (!(I >>> 0 >= F >>> 0) && (h = F + 4 | 0, b = d[h >> 2] | 0, !!(b & 1))) {
            if (b & 2)
              d[h >> 2] = b & -2, d[B + 4 >> 2] = f | 1, d[I + f >> 2] = f, T = f;
            else {
              if ((d[6983] | 0) == (F | 0)) {
                if (F = (d[6980] | 0) + f | 0, d[6980] = F, d[6983] = B, d[B + 4 >> 2] = F | 1, (B | 0) != (d[6982] | 0))
                  return;
                d[6982] = 0, d[6979] = 0;
                return;
              }
              if ((d[6982] | 0) == (F | 0)) {
                F = (d[6979] | 0) + f | 0, d[6979] = F, d[6982] = I, d[B + 4 >> 2] = F | 1, d[I + F >> 2] = F;
                return;
              }
              T = (b & -8) + f | 0, A = b >>> 3;
              do
                if (b >>> 0 < 256)
                  if (f = d[F + 8 >> 2] | 0, h = d[F + 12 >> 2] | 0, (h | 0) == (f | 0)) {
                    d[6977] = d[6977] & ~(1 << A);
                    break;
                  } else {
                    d[f + 12 >> 2] = h, d[h + 8 >> 2] = f;
                    break;
                  }
                else {
                  C = d[F + 24 >> 2] | 0, h = d[F + 12 >> 2] | 0;
                  do
                    if ((h | 0) == (F | 0)) {
                      if (f = F + 16 | 0, A = f + 4 | 0, h = d[A >> 2] | 0, h)
                        f = A;
                      else if (h = d[f >> 2] | 0, !h) {
                        A = 0;
                        break;
                      }
                      for (; ; )
                        if (b = h + 20 | 0, A = d[b >> 2] | 0, A)
                          h = A, f = b;
                        else if (b = h + 16 | 0, A = d[b >> 2] | 0, A)
                          h = A, f = b;
                        else
                          break;
                      d[f >> 2] = 0, A = h;
                    } else
                      A = d[F + 8 >> 2] | 0, d[A + 12 >> 2] = h, d[h + 8 >> 2] = A, A = h;
                  while (!1);
                  if (C | 0) {
                    if (h = d[F + 28 >> 2] | 0, f = 28212 + (h << 2) | 0, (d[f >> 2] | 0) == (F | 0)) {
                      if (d[f >> 2] = A, !A) {
                        d[6978] = d[6978] & ~(1 << h);
                        break;
                      }
                    } else if (b = C + 16 | 0, d[((d[b >> 2] | 0) == (F | 0) ? b : C + 20 | 0) >> 2] = A, !A)
                      break;
                    d[A + 24 >> 2] = C, h = F + 16 | 0, f = d[h >> 2] | 0, f | 0 && (d[A + 16 >> 2] = f, d[f + 24 >> 2] = A), h = d[h + 4 >> 2] | 0, h | 0 && (d[A + 20 >> 2] = h, d[h + 24 >> 2] = A);
                  }
                }
              while (!1);
              if (d[B + 4 >> 2] = T | 1, d[I + T >> 2] = T, (B | 0) == (d[6982] | 0)) {
                d[6979] = T;
                return;
              }
            }
            if (h = T >>> 3, T >>> 0 < 256) {
              A = 27948 + (h << 1 << 2) | 0, f = d[6977] | 0, h = 1 << h, f & h ? (f = A + 8 | 0, h = d[f >> 2] | 0) : (d[6977] = f | h, h = A, f = A + 8 | 0), d[f >> 2] = B, d[h + 12 >> 2] = B, d[B + 8 >> 2] = h, d[B + 12 >> 2] = A;
              return;
            }
            h = T >>> 8, h ? T >>> 0 > 16777215 ? b = 31 : (I = (h + 1048320 | 0) >>> 16 & 8, F = h << I, C = (F + 520192 | 0) >>> 16 & 4, F = F << C, b = (F + 245760 | 0) >>> 16 & 2, b = 14 - (C | I | b) + (F << b >>> 15) | 0, b = T >>> (b + 7 | 0) & 1 | b << 1) : b = 0, h = 28212 + (b << 2) | 0, d[B + 28 >> 2] = b, d[B + 20 >> 2] = 0, d[B + 16 >> 2] = 0, f = d[6978] | 0, A = 1 << b;
            e: do
              if (!(f & A))
                d[6978] = f | A, d[h >> 2] = B, d[B + 24 >> 2] = h, d[B + 12 >> 2] = B, d[B + 8 >> 2] = B;
              else {
                h = d[h >> 2] | 0;
                t: do
                  if ((d[h + 4 >> 2] & -8 | 0) != (T | 0)) {
                    for (b = T << ((b | 0) == 31 ? 0 : 25 - (b >>> 1) | 0); A = h + 16 + (b >>> 31 << 2) | 0, f = d[A >> 2] | 0, !!f; )
                      if ((d[f + 4 >> 2] & -8 | 0) == (T | 0)) {
                        h = f;
                        break t;
                      } else
                        b = b << 1, h = f;
                    d[A >> 2] = B, d[B + 24 >> 2] = h, d[B + 12 >> 2] = B, d[B + 8 >> 2] = B;
                    break e;
                  }
                while (!1);
                I = h + 8 | 0, F = d[I >> 2] | 0, d[F + 12 >> 2] = B, d[I >> 2] = B, d[B + 8 >> 2] = F, d[B + 12 >> 2] = h, d[B + 24 >> 2] = 0;
              }
            while (!1);
            if (F = (d[6985] | 0) + -1 | 0, d[6985] = F, !(F | 0)) {
              for (h = 28364; h = d[h >> 2] | 0, h; )
                h = h + 8 | 0;
              d[6985] = -1;
            }
          }
        }
      }
      function Ii(h, f) {
        h = h | 0, f = f | 0;
        var A = 0;
        return h ? (A = Qr(f, h) | 0, (f | h) >>> 0 > 65535 && (A = ((A >>> 0) / (h >>> 0) | 0 | 0) == (f | 0) ? A : -1)) : A = 0, h = ss(A) | 0, !h || !(d[h + -4 >> 2] & 3) || Oe(h | 0, 0, A | 0) | 0, h | 0;
      }
      function Er(h, f, A, b) {
        return h = h | 0, f = f | 0, A = A | 0, b = b | 0, A = h + A >>> 0, hr(f + b + (A >>> 0 < h >>> 0 | 0) >>> 0 | 0), A | 0 | 0;
      }
      function Vi(h, f, A, b) {
        return h = h | 0, f = f | 0, A = A | 0, b = b | 0, b = f - b - (A >>> 0 > h >>> 0 | 0) >>> 0, hr(b | 0), h - A >>> 0 | 0 | 0;
      }
      function zl(h) {
        return h = h | 0, (h ? 31 - (Kr(h ^ h - 1) | 0) | 0 : 32) | 0;
      }
      function Pc(h, f, A, b, T) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0, T = T | 0;
        var C = 0, I = 0, B = 0, F = 0, z = 0, W = 0, ue = 0, Ie = 0, Re = 0, Be = 0;
        if (W = h, F = f, z = F, I = A, Ie = b, B = Ie, !z)
          return C = (T | 0) != 0, B ? C ? (d[T >> 2] = h | 0, d[T + 4 >> 2] = f & 0, Ie = 0, T = 0, hr(Ie | 0), T | 0) : (Ie = 0, T = 0, hr(Ie | 0), T | 0) : (C && (d[T >> 2] = (W >>> 0) % (I >>> 0), d[T + 4 >> 2] = 0), Ie = 0, T = (W >>> 0) / (I >>> 0) >>> 0, hr(Ie | 0), T | 0);
        C = (B | 0) == 0;
        do
          if (I) {
            if (!C) {
              if (C = (Kr(B | 0) | 0) - (Kr(z | 0) | 0) | 0, C >>> 0 <= 31) {
                ue = C + 1 | 0, B = 31 - C | 0, f = C - 31 >> 31, I = ue, h = W >>> (ue >>> 0) & f | z << B, f = z >>> (ue >>> 0) & f, C = 0, B = W << B;
                break;
              }
              return T ? (d[T >> 2] = h | 0, d[T + 4 >> 2] = F | f & 0, Ie = 0, T = 0, hr(Ie | 0), T | 0) : (Ie = 0, T = 0, hr(Ie | 0), T | 0);
            }
            if (C = I - 1 | 0, C & I | 0) {
              B = (Kr(I | 0) | 0) + 33 - (Kr(z | 0) | 0) | 0, Be = 64 - B | 0, ue = 32 - B | 0, F = ue >> 31, Re = B - 32 | 0, f = Re >> 31, I = B, h = ue - 1 >> 31 & z >>> (Re >>> 0) | (z << ue | W >>> (B >>> 0)) & f, f = f & z >>> (B >>> 0), C = W << Be & F, B = (z << Be | W >>> (Re >>> 0)) & F | W << ue & B - 33 >> 31;
              break;
            }
            return T | 0 && (d[T >> 2] = C & W, d[T + 4 >> 2] = 0), (I | 0) == 1 ? (Re = F | f & 0, Be = h | 0 | 0, hr(Re | 0), Be | 0) : (Be = zl(I | 0) | 0, Re = z >>> (Be >>> 0) | 0, Be = z << 32 - Be | W >>> (Be >>> 0) | 0, hr(Re | 0), Be | 0);
          } else {
            if (C)
              return T | 0 && (d[T >> 2] = (z >>> 0) % (I >>> 0), d[T + 4 >> 2] = 0), Re = 0, Be = (z >>> 0) / (I >>> 0) >>> 0, hr(Re | 0), Be | 0;
            if (!W)
              return T | 0 && (d[T >> 2] = 0, d[T + 4 >> 2] = (z >>> 0) % (B >>> 0)), Re = 0, Be = (z >>> 0) / (B >>> 0) >>> 0, hr(Re | 0), Be | 0;
            if (C = B - 1 | 0, !(C & B))
              return T | 0 && (d[T >> 2] = h | 0, d[T + 4 >> 2] = C & z | f & 0), Re = 0, Be = z >>> ((zl(B | 0) | 0) >>> 0), hr(Re | 0), Be | 0;
            if (C = (Kr(B | 0) | 0) - (Kr(z | 0) | 0) | 0, C >>> 0 <= 30) {
              f = C + 1 | 0, B = 31 - C | 0, I = f, h = z << B | W >>> (f >>> 0), f = z >>> (f >>> 0), C = 0, B = W << B;
              break;
            }
            return T ? (d[T >> 2] = h | 0, d[T + 4 >> 2] = F | f & 0, Re = 0, Be = 0, hr(Re | 0), Be | 0) : (Re = 0, Be = 0, hr(Re | 0), Be | 0);
          }
        while (!1);
        if (!I)
          z = B, F = 0, B = 0;
        else {
          ue = A | 0 | 0, W = Ie | b & 0, z = Er(ue | 0, W | 0, -1, -1) | 0, A = ye() | 0, F = B, B = 0;
          do
            b = F, F = C >>> 31 | F << 1, C = B | C << 1, b = h << 1 | b >>> 31 | 0, Ie = h >>> 31 | f << 1 | 0, Vi(z | 0, A | 0, b | 0, Ie | 0) | 0, Be = ye() | 0, Re = Be >> 31 | ((Be | 0) < 0 ? -1 : 0) << 1, B = Re & 1, h = Vi(b | 0, Ie | 0, Re & ue | 0, (((Be | 0) < 0 ? -1 : 0) >> 31 | ((Be | 0) < 0 ? -1 : 0) << 1) & W | 0) | 0, f = ye() | 0, I = I - 1 | 0;
          while ((I | 0) != 0);
          z = F, F = 0;
        }
        return I = 0, T | 0 && (d[T >> 2] = h, d[T + 4 >> 2] = f), Re = (C | 0) >>> 31 | (z | I) << 1 | (I << 1 | C >>> 31) & 0 | F, Be = (C << 1 | 0) & -2 | B, hr(Re | 0), Be | 0;
      }
      function Mo(h, f, A, b) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0;
        var T = 0, C = 0, I = 0, B = 0, F = 0, z = 0;
        return z = f >> 31 | ((f | 0) < 0 ? -1 : 0) << 1, F = ((f | 0) < 0 ? -1 : 0) >> 31 | ((f | 0) < 0 ? -1 : 0) << 1, C = b >> 31 | ((b | 0) < 0 ? -1 : 0) << 1, T = ((b | 0) < 0 ? -1 : 0) >> 31 | ((b | 0) < 0 ? -1 : 0) << 1, B = Vi(z ^ h | 0, F ^ f | 0, z | 0, F | 0) | 0, I = ye() | 0, h = C ^ z, f = T ^ F, Vi((Pc(B, I, Vi(C ^ A | 0, T ^ b | 0, C | 0, T | 0) | 0, ye() | 0, 0) | 0) ^ h | 0, (ye() | 0) ^ f | 0, h | 0, f | 0) | 0;
      }
      function g(h, f) {
        h = h | 0, f = f | 0;
        var A = 0, b = 0, T = 0, C = 0;
        return C = h & 65535, T = f & 65535, A = Qr(T, C) | 0, b = h >>> 16, h = (A >>> 16) + (Qr(T, b) | 0) | 0, T = f >>> 16, f = Qr(T, C) | 0, hr((h >>> 16) + (Qr(T, b) | 0) + (((h & 65535) + f | 0) >>> 16) | 0), h + f << 16 | A & 65535 | 0 | 0;
      }
      function v(h, f, A, b) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0;
        var T = 0, C = 0;
        return T = h, C = A, A = g(T, C) | 0, h = ye() | 0, hr((Qr(f, C) | 0) + (Qr(b, T) | 0) + h | h & 0 | 0), A | 0 | 0 | 0;
      }
      function _(h, f, A, b) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0;
        var T = 0, C = 0, I = 0, B = 0, F = 0, z = 0;
        return T = Ae, Ae = Ae + 16 | 0, B = T | 0, I = f >> 31 | ((f | 0) < 0 ? -1 : 0) << 1, C = ((f | 0) < 0 ? -1 : 0) >> 31 | ((f | 0) < 0 ? -1 : 0) << 1, z = b >> 31 | ((b | 0) < 0 ? -1 : 0) << 1, F = ((b | 0) < 0 ? -1 : 0) >> 31 | ((b | 0) < 0 ? -1 : 0) << 1, h = Vi(I ^ h | 0, C ^ f | 0, I | 0, C | 0) | 0, f = ye() | 0, Pc(h, f, Vi(z ^ A | 0, F ^ b | 0, z | 0, F | 0) | 0, ye() | 0, B) | 0, b = Vi(d[B >> 2] ^ I | 0, d[B + 4 >> 2] ^ C | 0, I | 0, C | 0) | 0, A = ye() | 0, Ae = T, hr(A | 0), b | 0;
      }
      function w(h, f, A, b) {
        h = h | 0, f = f | 0, A = A | 0, b = b | 0;
        var T = 0, C = 0;
        return C = Ae, Ae = Ae + 16 | 0, T = C | 0, Pc(h, f, A, b, T) | 0, Ae = C, hr(d[T + 4 >> 2] | 0), d[T >> 2] | 0 | 0;
      }
      function R(h, f, A) {
        return h = h | 0, f = f | 0, A = A | 0, (A | 0) < 32 ? (hr(f >> A | 0), h >>> A | (f & (1 << A) - 1) << 32 - A) : (hr(((f | 0) < 0 ? -1 : 0) | 0), f >> A - 32 | 0);
      }
      function D(h, f, A) {
        return h = h | 0, f = f | 0, A = A | 0, (A | 0) < 32 ? (hr(f >>> A | 0), h >>> A | (f & (1 << A) - 1) << 32 - A) : (hr(0), f >>> A - 32 | 0);
      }
      function k(h, f, A) {
        return h = h | 0, f = f | 0, A = A | 0, (A | 0) < 32 ? (hr(f << A | (h & (1 << A) - 1 << 32 - A) >>> 32 - A | 0), h << A) : (hr(h << A - 32 | 0), 0);
      }
      function H(h, f, A) {
        return h = h | 0, f = f | 0, f = Kr(f) | 0, (f | 0) == 32 && (f = f + (Kr(h) | 0) | 0), hr(0), f | 0;
      }
      function J(h, f) {
        return h = +h, f = +f, h != h ? +f : f != f ? +h : +Ai(+h, +f);
      }
      function oe(h, f) {
        return h = +h, f = +f, h != h ? +f : f != f ? +h : +$r(+h, +f);
      }
      function Ce(h) {
        return h = +h, h >= 0 ? +Mt(h + 0.5) : +Yr(h - 0.5);
      }
      function Se(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0;
        var b = 0, T = 0, C = 0;
        if ((A | 0) >= 8192)
          return ma(h | 0, f | 0, A | 0) | 0, h | 0;
        if (C = h | 0, T = h + A | 0, (h & 3) == (f & 3)) {
          for (; h & 3; ) {
            if (!A)
              return C | 0;
            ge[h >> 0] = ge[f >> 0] | 0, h = h + 1 | 0, f = f + 1 | 0, A = A - 1 | 0;
          }
          for (A = T & -4 | 0, b = A - 64 | 0; (h | 0) <= (b | 0); )
            d[h >> 2] = d[f >> 2], d[h + 4 >> 2] = d[f + 4 >> 2], d[h + 8 >> 2] = d[f + 8 >> 2], d[h + 12 >> 2] = d[f + 12 >> 2], d[h + 16 >> 2] = d[f + 16 >> 2], d[h + 20 >> 2] = d[f + 20 >> 2], d[h + 24 >> 2] = d[f + 24 >> 2], d[h + 28 >> 2] = d[f + 28 >> 2], d[h + 32 >> 2] = d[f + 32 >> 2], d[h + 36 >> 2] = d[f + 36 >> 2], d[h + 40 >> 2] = d[f + 40 >> 2], d[h + 44 >> 2] = d[f + 44 >> 2], d[h + 48 >> 2] = d[f + 48 >> 2], d[h + 52 >> 2] = d[f + 52 >> 2], d[h + 56 >> 2] = d[f + 56 >> 2], d[h + 60 >> 2] = d[f + 60 >> 2], h = h + 64 | 0, f = f + 64 | 0;
          for (; (h | 0) < (A | 0); )
            d[h >> 2] = d[f >> 2], h = h + 4 | 0, f = f + 4 | 0;
        } else
          for (A = T - 4 | 0; (h | 0) < (A | 0); )
            ge[h >> 0] = ge[f >> 0] | 0, ge[h + 1 >> 0] = ge[f + 1 >> 0] | 0, ge[h + 2 >> 0] = ge[f + 2 >> 0] | 0, ge[h + 3 >> 0] = ge[f + 3 >> 0] | 0, h = h + 4 | 0, f = f + 4 | 0;
        for (; (h | 0) < (T | 0); )
          ge[h >> 0] = ge[f >> 0] | 0, h = h + 1 | 0, f = f + 1 | 0;
        return C | 0;
      }
      function Oe(h, f, A) {
        h = h | 0, f = f | 0, A = A | 0;
        var b = 0, T = 0, C = 0, I = 0;
        if (C = h + A | 0, f = f & 255, (A | 0) >= 67) {
          for (; h & 3; )
            ge[h >> 0] = f, h = h + 1 | 0;
          for (b = C & -4 | 0, I = f | f << 8 | f << 16 | f << 24, T = b - 64 | 0; (h | 0) <= (T | 0); )
            d[h >> 2] = I, d[h + 4 >> 2] = I, d[h + 8 >> 2] = I, d[h + 12 >> 2] = I, d[h + 16 >> 2] = I, d[h + 20 >> 2] = I, d[h + 24 >> 2] = I, d[h + 28 >> 2] = I, d[h + 32 >> 2] = I, d[h + 36 >> 2] = I, d[h + 40 >> 2] = I, d[h + 44 >> 2] = I, d[h + 48 >> 2] = I, d[h + 52 >> 2] = I, d[h + 56 >> 2] = I, d[h + 60 >> 2] = I, h = h + 64 | 0;
          for (; (h | 0) < (b | 0); )
            d[h >> 2] = I, h = h + 4 | 0;
        }
        for (; (h | 0) < (C | 0); )
          ge[h >> 0] = f, h = h + 1 | 0;
        return C - A | 0;
      }
      function He(h) {
        return h = +h, h >= 0 ? +Mt(h + 0.5) : +Yr(h - 0.5);
      }
      function ze(h) {
        h = h | 0;
        var f = 0, A = 0, b = 0;
        return b = Wi() | 0, A = d[nt >> 2] | 0, f = A + h | 0, (h | 0) > 0 & (f | 0) < (A | 0) | (f | 0) < 0 ? (Xn(f | 0) | 0, sn(12), -1) : (f | 0) > (b | 0) && !(ui(f | 0) | 0) ? (sn(12), -1) : (d[nt >> 2] = f, A | 0);
      }
      return {
        ___divdi3: Mo,
        ___muldi3: v,
        ___remdi3: _,
        ___uremdi3: w,
        _areNeighborCells: Ph,
        _bitshift64Ashr: R,
        _bitshift64Lshr: D,
        _bitshift64Shl: k,
        _calloc: Ii,
        _cellAreaKm2: Uh,
        _cellAreaM2: wi,
        _cellAreaRads2: Ya,
        _cellToBoundary: Za,
        _cellToCenterChild: Xa,
        _cellToChildPos: vc,
        _cellToChildren: gu,
        _cellToChildrenSize: jo,
        _cellToLatLng: wa,
        _cellToLocalIj: yf,
        _cellToParent: Pl,
        _cellToVertex: Ns,
        _cellToVertexes: sa,
        _cellsToDirectedEdge: Mh,
        _cellsToLinkedMultiPolygon: bi,
        _childPosToCell: Fh,
        _compactCells: Lh,
        _destroyLinkedMultiPolygon: bs,
        _directedEdgeToBoundary: mc,
        _directedEdgeToCells: ba,
        _edgeLengthKm: Ds,
        _edgeLengthM: vu,
        _edgeLengthRads: ur,
        _emscripten_replace_memory: Ko,
        _free: Ur,
        _getBaseCellNumber: df,
        _getDirectedEdgeDestination: Bh,
        _getDirectedEdgeOrigin: Rh,
        _getHexagonAreaAvgKm2: Nh,
        _getHexagonAreaAvgM2: Wp,
        _getHexagonEdgeLengthAvgKm: wc,
        _getHexagonEdgeLengthAvgM: Tc,
        _getIcosahedronFaces: yu,
        _getNumCells: ao,
        _getPentagons: yc,
        _getRes0Cells: oo,
        _getResolution: Il,
        _greatCircleDistanceKm: ns,
        _greatCircleDistanceM: bc,
        _greatCircleDistanceRads: zn,
        _gridDisk: Fn,
        _gridDiskDistances: ms,
        _gridDistance: Ls,
        _gridPathCells: xu,
        _gridPathCellsSize: bu,
        _gridRing: lf,
        _gridRingUnsafe: Ee,
        _i64Add: Er,
        _i64Subtract: Vi,
        _isPentagon: Bn,
        _isResClassIII: kh,
        _isValidCell: pf,
        _isValidDirectedEdge: Ga,
        _isValidVertex: Fl,
        _latLngToCell: gf,
        _llvm_ctlz_i64: H,
        _llvm_maxnum_f64: J,
        _llvm_minnum_f64: oe,
        _llvm_round_f64: Ce,
        _localIjToCell: lo,
        _malloc: ss,
        _maxFaceCount: _u,
        _maxGridDiskSize: Ci,
        _maxPolygonToCellsSize: bt,
        _maxPolygonToCellsSizeExperimental: Eo,
        _memcpy: Se,
        _memset: Oe,
        _originToDirectedEdges: Wa,
        _pentagonCount: mf,
        _polygonToCells: Tr,
        _polygonToCellsExperimental: vf,
        _readInt64AsDoubleFromPointer: Xi,
        _res0CellCount: cu,
        _round: He,
        _sbrk: ze,
        _sizeOfCellBoundary: Mr,
        _sizeOfCoordIJ: So,
        _sizeOfGeoLoop: Ar,
        _sizeOfGeoPolygon: Tu,
        _sizeOfH3Index: cs,
        _sizeOfLatLng: Cc,
        _sizeOfLinkedGeoPolygon: us,
        _uncompactCells: Rl,
        _uncompactCellsSize: vo,
        _vertexToLatLng: Us,
        establishStackSpace: fi,
        stackAlloc: Zn,
        stackRestore: Oi,
        stackSave: Qo
      };
    })(_e, Xt, me)
  );
  e.___divdi3 = Ct.___divdi3, e.___muldi3 = Ct.___muldi3, e.___remdi3 = Ct.___remdi3, e.___uremdi3 = Ct.___uremdi3, e._areNeighborCells = Ct._areNeighborCells, e._bitshift64Ashr = Ct._bitshift64Ashr, e._bitshift64Lshr = Ct._bitshift64Lshr, e._bitshift64Shl = Ct._bitshift64Shl, e._calloc = Ct._calloc, e._cellAreaKm2 = Ct._cellAreaKm2, e._cellAreaM2 = Ct._cellAreaM2, e._cellAreaRads2 = Ct._cellAreaRads2, e._cellToBoundary = Ct._cellToBoundary, e._cellToCenterChild = Ct._cellToCenterChild, e._cellToChildPos = Ct._cellToChildPos, e._cellToChildren = Ct._cellToChildren, e._cellToChildrenSize = Ct._cellToChildrenSize, e._cellToLatLng = Ct._cellToLatLng, e._cellToLocalIj = Ct._cellToLocalIj, e._cellToParent = Ct._cellToParent, e._cellToVertex = Ct._cellToVertex, e._cellToVertexes = Ct._cellToVertexes, e._cellsToDirectedEdge = Ct._cellsToDirectedEdge, e._cellsToLinkedMultiPolygon = Ct._cellsToLinkedMultiPolygon, e._childPosToCell = Ct._childPosToCell, e._compactCells = Ct._compactCells, e._destroyLinkedMultiPolygon = Ct._destroyLinkedMultiPolygon, e._directedEdgeToBoundary = Ct._directedEdgeToBoundary, e._directedEdgeToCells = Ct._directedEdgeToCells, e._edgeLengthKm = Ct._edgeLengthKm, e._edgeLengthM = Ct._edgeLengthM, e._edgeLengthRads = Ct._edgeLengthRads;
  var $ = e._emscripten_replace_memory = Ct._emscripten_replace_memory;
  e._free = Ct._free, e._getBaseCellNumber = Ct._getBaseCellNumber, e._getDirectedEdgeDestination = Ct._getDirectedEdgeDestination, e._getDirectedEdgeOrigin = Ct._getDirectedEdgeOrigin, e._getHexagonAreaAvgKm2 = Ct._getHexagonAreaAvgKm2, e._getHexagonAreaAvgM2 = Ct._getHexagonAreaAvgM2, e._getHexagonEdgeLengthAvgKm = Ct._getHexagonEdgeLengthAvgKm, e._getHexagonEdgeLengthAvgM = Ct._getHexagonEdgeLengthAvgM, e._getIcosahedronFaces = Ct._getIcosahedronFaces, e._getNumCells = Ct._getNumCells, e._getPentagons = Ct._getPentagons, e._getRes0Cells = Ct._getRes0Cells, e._getResolution = Ct._getResolution, e._greatCircleDistanceKm = Ct._greatCircleDistanceKm, e._greatCircleDistanceM = Ct._greatCircleDistanceM, e._greatCircleDistanceRads = Ct._greatCircleDistanceRads, e._gridDisk = Ct._gridDisk, e._gridDiskDistances = Ct._gridDiskDistances, e._gridDistance = Ct._gridDistance, e._gridPathCells = Ct._gridPathCells, e._gridPathCellsSize = Ct._gridPathCellsSize, e._gridRing = Ct._gridRing, e._gridRingUnsafe = Ct._gridRingUnsafe, e._i64Add = Ct._i64Add, e._i64Subtract = Ct._i64Subtract, e._isPentagon = Ct._isPentagon, e._isResClassIII = Ct._isResClassIII, e._isValidCell = Ct._isValidCell, e._isValidDirectedEdge = Ct._isValidDirectedEdge, e._isValidVertex = Ct._isValidVertex, e._latLngToCell = Ct._latLngToCell, e._llvm_ctlz_i64 = Ct._llvm_ctlz_i64, e._llvm_maxnum_f64 = Ct._llvm_maxnum_f64, e._llvm_minnum_f64 = Ct._llvm_minnum_f64, e._llvm_round_f64 = Ct._llvm_round_f64, e._localIjToCell = Ct._localIjToCell, e._malloc = Ct._malloc, e._maxFaceCount = Ct._maxFaceCount, e._maxGridDiskSize = Ct._maxGridDiskSize, e._maxPolygonToCellsSize = Ct._maxPolygonToCellsSize, e._maxPolygonToCellsSizeExperimental = Ct._maxPolygonToCellsSizeExperimental, e._memcpy = Ct._memcpy, e._memset = Ct._memset, e._originToDirectedEdges = Ct._originToDirectedEdges, e._pentagonCount = Ct._pentagonCount, e._polygonToCells = Ct._polygonToCells, e._polygonToCellsExperimental = Ct._polygonToCellsExperimental, e._readInt64AsDoubleFromPointer = Ct._readInt64AsDoubleFromPointer, e._res0CellCount = Ct._res0CellCount, e._round = Ct._round, e._sbrk = Ct._sbrk, e._sizeOfCellBoundary = Ct._sizeOfCellBoundary, e._sizeOfCoordIJ = Ct._sizeOfCoordIJ, e._sizeOfGeoLoop = Ct._sizeOfGeoLoop, e._sizeOfGeoPolygon = Ct._sizeOfGeoPolygon, e._sizeOfH3Index = Ct._sizeOfH3Index, e._sizeOfLatLng = Ct._sizeOfLatLng, e._sizeOfLinkedGeoPolygon = Ct._sizeOfLinkedGeoPolygon, e._uncompactCells = Ct._uncompactCells, e._uncompactCellsSize = Ct._uncompactCellsSize, e._vertexToLatLng = Ct._vertexToLatLng, e.establishStackSpace = Ct.establishStackSpace;
  var Et = e.stackAlloc = Ct.stackAlloc, Rt = e.stackRestore = Ct.stackRestore, Pe = e.stackSave = Ct.stackSave;
  if (e.asm = Ct, e.cwrap = Y, e.setValue = L, e.getValue = U, wn) {
    qn(wn) || (wn = s(wn));
    {
      ci();
      var tt = function(pe) {
        pe.byteLength && (pe = new Uint8Array(pe)), re.set(pe, P), e.memoryInitializerRequest && delete e.memoryInitializerRequest.response, Jn();
      }, At = function() {
        o(wn, tt, function() {
          throw "could not load memory initializer " + wn;
        });
      }, Q = Ft(wn);
      if (Q)
        tt(Q.buffer);
      else if (e.memoryInitializerRequest) {
        var ie = function() {
          var pe = e.memoryInitializerRequest, Te = pe.response;
          if (pe.status !== 200 && pe.status !== 0) {
            var le = Ft(e.memoryInitializerRequestURL);
            if (le)
              Te = le.buffer;
            else {
              console.warn("a problem seems to have happened with Module.memoryInitializerRequest, status: " + pe.status + ", retrying " + wn), At();
              return;
            }
          }
          tt(Te);
        };
        e.memoryInitializerRequest.response ? setTimeout(ie, 0) : e.memoryInitializerRequest.addEventListener("load", ie);
      } else
        At();
    }
  }
  var ce;
  zr = function pe() {
    ce || we(), ce || (zr = pe);
  };
  function we(pe) {
    if (gn > 0 || (sr(), gn > 0))
      return;
    function Te() {
      ce || (ce = !0, !V && (tr(), Wt(), e.onRuntimeInitialized && e.onRuntimeInitialized(), yr()));
    }
    e.setStatus ? (e.setStatus("Running..."), setTimeout(function() {
      setTimeout(function() {
        e.setStatus("");
      }, 1), Te();
    }, 1)) : Te();
  }
  e.run = we;
  function Ne(pe) {
    throw e.onAbort && e.onAbort(pe), pe += "", l(pe), u(pe), V = !0, "abort(" + pe + "). Build with -s ASSERTIONS=1 for more info.";
  }
  if (e.abort = Ne, e.preInit)
    for (typeof e.preInit == "function" && (e.preInit = [e.preInit]); e.preInit.length > 0; )
      e.preInit.pop()();
  return we(), r;
})(typeof Vr == "object" ? Vr : {}), pn = "number", tn = pn, xA = pn, hn = pn, dn = pn, Gs = pn, kr = pn, zle = [
  // The size functions are inserted via build/sizes.h
  ["sizeOfH3Index", pn],
  ["sizeOfLatLng", pn],
  ["sizeOfCellBoundary", pn],
  ["sizeOfGeoLoop", pn],
  ["sizeOfGeoPolygon", pn],
  ["sizeOfLinkedGeoPolygon", pn],
  ["sizeOfCoordIJ", pn],
  ["readInt64AsDoubleFromPointer", pn],
  // The remaining functions are defined in the core lib in h3Api.h
  ["isValidCell", xA, [hn, dn]],
  ["latLngToCell", tn, [pn, pn, Gs, kr]],
  ["cellToLatLng", tn, [hn, dn, kr]],
  ["cellToBoundary", tn, [hn, dn, kr]],
  ["maxGridDiskSize", tn, [pn, kr]],
  ["gridDisk", tn, [hn, dn, pn, kr]],
  ["gridDiskDistances", tn, [hn, dn, pn, kr, kr]],
  ["gridRing", tn, [hn, dn, pn, kr]],
  ["gridRingUnsafe", tn, [hn, dn, pn, kr]],
  ["maxPolygonToCellsSize", tn, [kr, Gs, pn, kr]],
  ["polygonToCells", tn, [kr, Gs, pn, kr]],
  ["maxPolygonToCellsSizeExperimental", tn, [kr, Gs, pn, kr]],
  ["polygonToCellsExperimental", tn, [kr, Gs, pn, pn, pn, kr]],
  ["cellsToLinkedMultiPolygon", tn, [kr, pn, kr]],
  ["destroyLinkedMultiPolygon", null, [kr]],
  ["compactCells", tn, [kr, kr, pn, pn]],
  ["uncompactCells", tn, [kr, pn, pn, kr, pn, Gs]],
  ["uncompactCellsSize", tn, [kr, pn, pn, Gs, kr]],
  ["isPentagon", xA, [hn, dn]],
  ["isResClassIII", xA, [hn, dn]],
  ["getBaseCellNumber", pn, [hn, dn]],
  ["getResolution", pn, [hn, dn]],
  ["maxFaceCount", tn, [hn, dn, kr]],
  ["getIcosahedronFaces", tn, [hn, dn, kr]],
  ["cellToParent", tn, [hn, dn, Gs, kr]],
  ["cellToChildren", tn, [hn, dn, Gs, kr]],
  ["cellToCenterChild", tn, [hn, dn, Gs, kr]],
  ["cellToChildrenSize", tn, [hn, dn, Gs, kr]],
  ["cellToChildPos", tn, [hn, dn, Gs, kr]],
  ["childPosToCell", tn, [pn, pn, hn, dn, Gs, kr]],
  ["areNeighborCells", tn, [hn, dn, hn, dn, kr]],
  ["cellsToDirectedEdge", tn, [hn, dn, hn, dn, kr]],
  ["getDirectedEdgeOrigin", tn, [hn, dn, kr]],
  ["getDirectedEdgeDestination", tn, [hn, dn, kr]],
  ["isValidDirectedEdge", xA, [hn, dn]],
  ["directedEdgeToCells", tn, [hn, dn, kr]],
  ["originToDirectedEdges", tn, [hn, dn, kr]],
  ["directedEdgeToBoundary", tn, [hn, dn, kr]],
  ["gridDistance", tn, [hn, dn, hn, dn, kr]],
  ["gridPathCells", tn, [hn, dn, hn, dn, kr]],
  ["gridPathCellsSize", tn, [hn, dn, hn, dn, kr]],
  ["cellToLocalIj", tn, [hn, dn, hn, dn, pn, kr]],
  ["localIjToCell", tn, [hn, dn, kr, pn, kr]],
  ["getHexagonAreaAvgM2", tn, [Gs, kr]],
  ["getHexagonAreaAvgKm2", tn, [Gs, kr]],
  ["getHexagonEdgeLengthAvgM", tn, [Gs, kr]],
  ["getHexagonEdgeLengthAvgKm", tn, [Gs, kr]],
  ["greatCircleDistanceM", pn, [kr, kr]],
  ["greatCircleDistanceKm", pn, [kr, kr]],
  ["greatCircleDistanceRads", pn, [kr, kr]],
  ["cellAreaM2", tn, [hn, dn, kr]],
  ["cellAreaKm2", tn, [hn, dn, kr]],
  ["cellAreaRads2", tn, [hn, dn, kr]],
  ["edgeLengthM", tn, [hn, dn, kr]],
  ["edgeLengthKm", tn, [hn, dn, kr]],
  ["edgeLengthRads", tn, [hn, dn, kr]],
  ["getNumCells", tn, [Gs, kr]],
  ["getRes0Cells", tn, [kr]],
  ["res0CellCount", pn],
  ["getPentagons", tn, [pn, kr]],
  ["pentagonCount", pn],
  ["cellToVertex", tn, [hn, dn, pn, kr]],
  ["cellToVertexes", tn, [hn, dn, kr]],
  ["vertexToLatLng", tn, [hn, dn, kr]],
  ["isValidVertex", xA, [hn, dn]]
], Vle = 0, jle = 1, Hle = 2, Gle = 3, FL = 4, Wle = 5, $le = 6, qle = 7, Xle = 8, Zle = 9, Yle = 10, Kle = 11, Qle = 12, Jle = 13, ece = 14, tce = 15, so = {};
so[Vle] = "Success";
so[jle] = "The operation failed but a more specific error is not available";
so[Hle] = "Argument was outside of acceptable range";
so[Gle] = "Latitude or longitude arguments were outside of acceptable range";
so[FL] = "Resolution argument was outside of acceptable range";
so[Wle] = "Cell argument was not valid";
so[$le] = "Directed edge argument was not valid";
so[qle] = "Undirected edge argument was not valid";
so[Xle] = "Vertex argument was not valid";
so[Zle] = "Pentagon distortion was encountered";
so[Yle] = "Duplicate input";
so[Kle] = "Cell arguments were not neighbors";
so[Qle] = "Cell arguments had incompatible resolutions";
so[Jle] = "Memory allocation failed";
so[ece] = "Bounds of provided memory were insufficient";
so[tce] = "Mode or flags argument was not valid";
var Rw = 1e3, NL = 1001, UL = 1002, ny = {};
ny[Rw] = "Unknown unit";
ny[NL] = "Array length out of bounds";
ny[UL] = "Got unexpected null value for H3 index";
var rce = "Unknown error";
function zL(r, e, t) {
  var n = t && "value" in t, i = new Error((r[e] || rce) + " (code: " + e + (n ? ", value: " + t.value : "") + ")");
  return i.code = e, i;
}
function VL(r, e) {
  var t = arguments.length === 2 ? {
    value: e
  } : {};
  return zL(so, r, t);
}
function iy(r, e) {
  var t = arguments.length === 2 ? {
    value: e
  } : {};
  return zL(ny, r, t);
}
function io(r) {
  if (r !== 0)
    throw VL(r);
}
var ni = {};
zle.forEach(function(e) {
  ni[e[0]] = Vr.cwrap.apply(Vr, e);
});
var Jd = 16, Cp = 4, jP = 4, uc = 8, sy = 8, Qu = ni.sizeOfH3Index(), Bw = ni.sizeOfLatLng(), nce = ni.sizeOfCellBoundary(), ice = ni.sizeOfGeoPolygon(), QA = ni.sizeOfGeoLoop(), sce = ni.sizeOfLinkedGeoPolygon();
ni.sizeOfCoordIJ();
var pp = {
  m: "m",
  m2: "m2",
  km: "km",
  km2: "km2",
  rads: "rads",
  rads2: "rads2"
};
function Ow(r) {
  if (typeof r != "number" || r < 0 || r > 15 || Math.floor(r) !== r)
    throw VL(FL, r);
  return r;
}
function jL(r) {
  if (!r)
    throw iy(UL);
  return r;
}
var oce = Math.pow(2, 32) - 1;
function HL(r) {
  if (r > oce)
    throw iy(NL, r);
  return r;
}
var ace = /[^0-9a-fA-F]/;
function bl(r) {
  if (Array.isArray(r) && r.length === 2 && Number.isInteger(r[0]) && Number.isInteger(r[1]))
    return r;
  if (typeof r != "string" || ace.test(r))
    return [0, 0];
  var e = parseInt(r.substring(0, r.length - 8), Jd), t = parseInt(r.substring(r.length - 8), Jd);
  return [t, e];
}
function HP(r) {
  if (r >= 0)
    return r.toString(Jd);
  r = r & 2147483647;
  var e = WL(8, r.toString(Jd)), t = (parseInt(e[0], Jd) + 8).toString(Jd);
  return e = t + e.substring(1), e;
}
function lce(r, e) {
  return HP(e) + WL(8, HP(r));
}
function WL(r, e) {
  for (var t = r - e.length, n = "", i = 0; i < t; i++)
    n += "0";
  return n = n + e, n;
}
function GP(r, e, t) {
  for (var n = r.length, i = Vr._calloc(n, Bw), s = t ? 1 : 0, o = t ? 0 : 1, l = 0; l < n * 2; l += 2)
    Vr.HEAPF64.set([r[l / 2][s], r[l / 2][o]].map(KL), i / uc + l);
  return Vr.HEAPU32.set([n, i], e / Cp), e;
}
function cce(r, e) {
  var t = r.length - 1, n = Vr._calloc(ice), i = 0, s = i + QA, o = s + Cp;
  GP(r[0], n + i, e);
  var l;
  if (t > 0) {
    l = Vr._calloc(t, QA);
    for (var u = 0; u < t; u++)
      GP(r[u + 1], l + QA * u, e);
  }
  return Vr.setValue(n + s, t, "i32"), Vr.setValue(n + o, l, "i32"), n;
}
function uce(r) {
  var e = 0, t = e + QA, n = t + Cp, i = Cp;
  Vr._free(Vr.getValue(r + e + i, "i8*"));
  var s = Vr.getValue(r + t, "i32");
  if (s > 0) {
    for (var o = Vr.getValue(r + n, "i32"), l = 0; l < s; l++)
      Vr._free(Vr.getValue(o + QA * l + i, "i8*"));
    Vr._free(o);
  }
  Vr._free(r);
}
function Dw(r, e) {
  e === void 0 && (e = 0);
  var t = Vr.getValue(r + Qu * e, "i32"), n = Vr.getValue(r + Qu * e + Cp, "i32");
  return n ? lce(t, n) : null;
}
function $L(r, e) {
  return e === void 0 && (e = 0), Vr.getValue(r + uc * e, "double");
}
function oy(r) {
  return ni.readInt64AsDoubleFromPointer(r);
}
function fce(r, e, t) {
  Vr.HEAPU32.set(bl(r), e / Cp + 2 * t);
}
function Lw(r, e) {
  for (var t = [], n = 0; n < e; n++) {
    var i = Dw(r, n);
    i !== null && t.push(i);
  }
  return t;
}
function hce(r, e) {
  for (var t = e.length, n = 0; n < t; n++)
    fce(e[n], r, n);
}
function b_(r) {
  return Tce(Vr.getValue(r, "double"));
}
function qL(r) {
  return [b_(r), b_(r + uc)];
}
function XL(r) {
  return [b_(r + uc), b_(r)];
}
function dce(r, e, t) {
  for (var n = Vr.getValue(r, "i32"), i = r + uc, s = [], o = e ? XL : qL, l = 0; l < n * 2; l += 2)
    s.push(o(i + uc * l));
  return t && s.push(s[0]), s;
}
function pce(r, e) {
  for (var t = [], n = XL, i, s, o, l; r; ) {
    for (t.push(i = []), s = Vr.getValue(r, "i8*"); s; ) {
      for (i.push(o = []), l = Vr.getValue(s, "i8*"); l; )
        o.push(n(l)), l = Vr.getValue(l + uc * 2, "i8*");
      o.push(o[0]), s = Vr.getValue(s + jP * 2, "i8*");
    }
    r = Vr.getValue(r + jP * 2, "i8*");
  }
  return t;
}
function Ace(r) {
  var e = bl(r), t = e[0], n = e[1];
  return !!ni.isPentagon(t, n);
}
function lh(r) {
  var e = bl(r), t = e[0], n = e[1];
  return ni.isValidCell(t, n) ? ni.getResolution(t, n) : -1;
}
function kw(r, e, t) {
  var n = Vr._malloc(Bw);
  Vr.HEAPF64.set([r, e].map(KL), n / uc);
  var i = Vr._malloc(Qu);
  try {
    return io(ni.latLngToCell(n, t, i)), jL(Dw(i));
  } finally {
    Vr._free(i), Vr._free(n);
  }
}
function ay(r) {
  var e = Vr._malloc(Bw), t = bl(r), n = t[0], i = t[1];
  try {
    return io(ni.cellToLatLng(n, i, e)), qL(e);
  } finally {
    Vr._free(e);
  }
}
function ZL(r, e) {
  var t = Vr._malloc(nce), n = bl(r), i = n[0], s = n[1];
  try {
    return io(ni.cellToBoundary(i, s, t)), dce(t, e, e);
  } finally {
    Vr._free(t);
  }
}
function YL(r, e) {
  var t = bl(r), n = t[0], i = t[1], s = Vr._malloc(Qu);
  try {
    return io(ni.cellToParent(n, i, e, s)), jL(Dw(s));
  } finally {
    Vr._free(s);
  }
}
function gce(r, e) {
  var t = bl(r), n = t[0], i = t[1], s = Vr._malloc(sy);
  try {
    io(ni.maxGridDiskSize(e, s));
    var o = HL(oy(s)), l = Vr._calloc(o, Qu);
    try {
      return io(ni.gridDisk(n, i, e, l)), Lw(l, o);
    } finally {
      Vr._free(l);
    }
  } finally {
    Vr._free(s);
  }
}
function mce(r, e, t) {
  if (Ow(e), t = !!t, r.length === 0 || r[0].length === 0)
    return [];
  var n = typeof r[0][0] == "number" ? [r] : r, i = cce(
    // @ts-expect-error - There's no way to convince TS that polygon is now number[][][]
    n,
    t
  ), s = Vr._malloc(sy);
  try {
    io(ni.maxPolygonToCellsSize(i, e, 0, s));
    var o = HL(oy(s)), l = Vr._calloc(o, Qu);
    try {
      return io(ni.polygonToCells(i, e, 0, l)), Lw(l, o);
    } finally {
      Vr._free(l);
    }
  } finally {
    Vr._free(s), uce(i);
  }
}
function _ce(r, e) {
  if (!r || !r.length)
    return [];
  var t = r.length, n = Vr._calloc(t, Qu);
  hce(n, r);
  var i = Vr._calloc(sce);
  try {
    return io(ni.cellsToLinkedMultiPolygon(n, t, i)), pce(i, e);
  } finally {
    ni.destroyLinkedMultiPolygon(i), Vr._free(i), Vr._free(n);
  }
}
function yce(r) {
  var e = bl(r), t = e[0], n = e[1], i = 6, s = Vr._calloc(i, Qu);
  try {
    return io(ni.originToDirectedEdges(t, n, s)), Lw(s, i);
  } finally {
    Vr._free(s);
  }
}
function vce(r, e) {
  var t = bl(r), n = t[0], i = t[1], s = bl(e), o = s[0], l = s[1], u = Vr._malloc(sy);
  try {
    return io(ni.gridDistance(n, i, o, l, u)), oy(u);
  } finally {
    Vr._free(u);
  }
}
function bce(r, e) {
  var t = bl(r), n = t[0], i = t[1], s = Vr._malloc(uc);
  try {
    switch (e) {
      case pp.m:
        io(ni.edgeLengthM(n, i, s));
        break;
      case pp.km:
        io(ni.edgeLengthKm(n, i, s));
        break;
      case pp.rads:
        io(ni.edgeLengthRads(n, i, s));
        break;
      default:
        throw iy(Rw, e);
    }
    return $L(s);
  } finally {
    Vr._free(s);
  }
}
function xce(r, e) {
  Ow(r);
  var t = Vr._malloc(uc);
  try {
    switch (e) {
      case pp.m:
        io(ni.getHexagonEdgeLengthAvgM(r, t));
        break;
      case pp.km:
        io(ni.getHexagonEdgeLengthAvgKm(r, t));
        break;
      default:
        throw iy(Rw, e);
    }
    return $L(t);
  } finally {
    Vr._free(t);
  }
}
function wce(r) {
  Ow(r);
  var e = Vr._malloc(sy);
  try {
    return io(ni.getNumCells(r, e)), oy(e);
  } finally {
    Vr._free(e);
  }
}
function KL(r) {
  return r * Math.PI / 180;
}
function Tce(r) {
  return r * 180 / Math.PI;
}
function Fw(r, e) {
  e = e === void 0 ? r[0][0] : e;
  for (const t of r) {
    const n = t[0] - e;
    n > 180 ? t[0] -= 360 : n < -180 && (t[0] += 360);
  }
}
function Ece(r, e, t) {
  const [n, i] = ay(r), s = e.length;
  Fw(e, i);
  const o = e[0] === e[s - 1] ? s - 1 : s;
  for (let l = 0; l < o; l++)
    e[l][0] = ml(i, e[l][0], t), e[l][1] = ml(n, e[l][1], t);
}
function Cce(r, e, t) {
  const n = r(e, t), [i, s] = ay(n);
  return [s, i];
}
function WP(r, e = 1) {
  const t = ZL(r, !0);
  return e !== 1 ? Ece(r, t, e) : Fw(t), t;
}
function QL(r) {
  const e = new Float64Array(r.length * 2);
  let t = 0;
  for (const n of r)
    e[t++] = n[0], e[t++] = n[1];
  return e;
}
const Sce = {
  getPentagon: { type: "accessor", value: (r) => r.pentagon }
};
class Nw extends su {
  indexToBounds() {
    const { data: e, getPentagon: t } = this.props;
    return {
      data: e,
      _normalize: !1,
      _windingOrder: "CCW",
      positionFormat: "XY",
      getPolygon: (n, i) => {
        const s = t(n, i), o = Nle(typeof s == "string" ? Ule(s) : s, { closedRing: !0, segments: "auto" });
        return QL(o);
      }
    };
  }
}
Nw.layerName = "A5Layer";
Nw.defaultProps = Sce;
function Ice(r) {
  return typeof r == "string" ? r.charAt(0).toLowerCase() + r.slice(1) : r;
}
function I2(r) {
  if (Array.isArray(r))
    return r.map((e) => I2(e));
  if (r && typeof r == "object") {
    const e = {};
    for (const [t, n] of Object.entries(r))
      e[Ice(t)] = I2(n);
    return e;
  }
  return r;
}
var y1 = {}, v1 = {}, $P;
function Uw() {
  return $P || ($P = 1, (function(r) {
    const e = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", t = e + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040", n = "[" + e + "][" + t + "]*", i = new RegExp("^" + n + "$"), s = function(l, u) {
      const m = [];
      let y = u.exec(l);
      for (; y; ) {
        const E = [];
        E.startIndex = u.lastIndex - y[0].length;
        const P = y.length;
        for (let L = 0; L < P; L++)
          E.push(y[L]);
        m.push(E), y = u.exec(l);
      }
      return m;
    }, o = function(l) {
      const u = i.exec(l);
      return !(u === null || typeof u > "u");
    };
    r.isExist = function(l) {
      return typeof l < "u";
    }, r.isEmptyObject = function(l) {
      return Object.keys(l).length === 0;
    }, r.merge = function(l, u, m) {
      if (u) {
        const y = Object.keys(u), E = y.length;
        for (let P = 0; P < E; P++)
          m === "strict" ? l[y[P]] = [u[y[P]]] : l[y[P]] = u[y[P]];
      }
    }, r.getValue = function(l) {
      return r.isExist(l) ? l : "";
    }, r.isName = o, r.getAllMatches = s, r.nameRegexp = n;
  })(v1)), v1;
}
var qP;
function JL() {
  if (qP) return y1;
  qP = 1;
  const r = Uw(), e = {
    allowBooleanAttributes: !1,
    //A tag can have attributes without any value
    unpairedTags: []
  };
  y1.validate = function(j, K) {
    K = Object.assign({}, e, K);
    const Y = [];
    let de = !1, ne = !1;
    j[0] === "\uFEFF" && (j = j.substr(1));
    for (let ae = 0; ae < j.length; ae++)
      if (j[ae] === "<" && j[ae + 1] === "?") {
        if (ae += 2, ae = n(j, ae), ae.err) return ae;
      } else if (j[ae] === "<") {
        let De = ae;
        if (ae++, j[ae] === "!") {
          ae = i(j, ae);
          continue;
        } else {
          let Ge = !1;
          j[ae] === "/" && (Ge = !0, ae++);
          let fe = "";
          for (; ae < j.length && j[ae] !== ">" && j[ae] !== " " && j[ae] !== "	" && j[ae] !== `
` && j[ae] !== "\r"; ae++)
            fe += j[ae];
          if (fe = fe.trim(), fe[fe.length - 1] === "/" && (fe = fe.substring(0, fe.length - 1), ae--), !U(fe)) {
            let X;
            return fe.trim().length === 0 ? X = "Invalid space after '<'." : X = "Tag '" + fe + "' is an invalid name.", P("InvalidTag", X, V(j, ae));
          }
          const ve = l(j, ae);
          if (ve === !1)
            return P("InvalidAttr", "Attributes for '" + fe + "' have open quote.", V(j, ae));
          let me = ve.value;
          if (ae = ve.index, me[me.length - 1] === "/") {
            const X = ae - me.length;
            me = me.substring(0, me.length - 1);
            const re = m(me, K);
            if (re === !0)
              de = !0;
            else
              return P(re.err.code, re.err.msg, V(j, X + re.err.line));
          } else if (Ge)
            if (ve.tagClosed) {
              if (me.trim().length > 0)
                return P("InvalidTag", "Closing tag '" + fe + "' can't have attributes or invalid starting.", V(j, De));
              if (Y.length === 0)
                return P("InvalidTag", "Closing tag '" + fe + "' has not been opened.", V(j, De));
              {
                const X = Y.pop();
                if (fe !== X.tagName) {
                  let re = V(j, X.tagStartPos);
                  return P(
                    "InvalidTag",
                    "Expected closing tag '" + X.tagName + "' (opened in line " + re.line + ", col " + re.col + ") instead of closing tag '" + fe + "'.",
                    V(j, De)
                  );
                }
                Y.length == 0 && (ne = !0);
              }
            } else return P("InvalidTag", "Closing tag '" + fe + "' doesn't have proper closing.", V(j, ae));
          else {
            const X = m(me, K);
            if (X !== !0)
              return P(X.err.code, X.err.msg, V(j, ae - me.length + X.err.line));
            if (ne === !0)
              return P("InvalidXml", "Multiple possible root nodes found.", V(j, ae));
            K.unpairedTags.indexOf(fe) !== -1 || Y.push({ tagName: fe, tagStartPos: De }), de = !0;
          }
          for (ae++; ae < j.length; ae++)
            if (j[ae] === "<")
              if (j[ae + 1] === "!") {
                ae++, ae = i(j, ae);
                continue;
              } else if (j[ae + 1] === "?") {
                if (ae = n(j, ++ae), ae.err) return ae;
              } else
                break;
            else if (j[ae] === "&") {
              const X = E(j, ae);
              if (X == -1)
                return P("InvalidChar", "char '&' is not expected.", V(j, ae));
              ae = X;
            } else if (ne === !0 && !t(j[ae]))
              return P("InvalidXml", "Extra text at the end", V(j, ae));
          j[ae] === "<" && ae--;
        }
      } else {
        if (t(j[ae]))
          continue;
        return P("InvalidChar", "char '" + j[ae] + "' is not expected.", V(j, ae));
      }
    if (de) {
      if (Y.length == 1)
        return P("InvalidTag", "Unclosed tag '" + Y[0].tagName + "'.", V(j, Y[0].tagStartPos));
      if (Y.length > 0)
        return P("InvalidXml", "Invalid '" + JSON.stringify(Y.map((ae) => ae.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
    } else return P("InvalidXml", "Start tag expected.", 1);
    return !0;
  };
  function t(j) {
    return j === " " || j === "	" || j === `
` || j === "\r";
  }
  function n(j, K) {
    const Y = K;
    for (; K < j.length; K++)
      if (j[K] == "?" || j[K] == " ") {
        const de = j.substr(Y, K - Y);
        if (K > 5 && de === "xml")
          return P("InvalidXml", "XML declaration allowed only at the start of the document.", V(j, K));
        if (j[K] == "?" && j[K + 1] == ">") {
          K++;
          break;
        } else
          continue;
      }
    return K;
  }
  function i(j, K) {
    if (j.length > K + 5 && j[K + 1] === "-" && j[K + 2] === "-") {
      for (K += 3; K < j.length; K++)
        if (j[K] === "-" && j[K + 1] === "-" && j[K + 2] === ">") {
          K += 2;
          break;
        }
    } else if (j.length > K + 8 && j[K + 1] === "D" && j[K + 2] === "O" && j[K + 3] === "C" && j[K + 4] === "T" && j[K + 5] === "Y" && j[K + 6] === "P" && j[K + 7] === "E") {
      let Y = 1;
      for (K += 8; K < j.length; K++)
        if (j[K] === "<")
          Y++;
        else if (j[K] === ">" && (Y--, Y === 0))
          break;
    } else if (j.length > K + 9 && j[K + 1] === "[" && j[K + 2] === "C" && j[K + 3] === "D" && j[K + 4] === "A" && j[K + 5] === "T" && j[K + 6] === "A" && j[K + 7] === "[") {
      for (K += 8; K < j.length; K++)
        if (j[K] === "]" && j[K + 1] === "]" && j[K + 2] === ">") {
          K += 2;
          break;
        }
    }
    return K;
  }
  const s = '"', o = "'";
  function l(j, K) {
    let Y = "", de = "", ne = !1;
    for (; K < j.length; K++) {
      if (j[K] === s || j[K] === o)
        de === "" ? de = j[K] : de !== j[K] || (de = "");
      else if (j[K] === ">" && de === "") {
        ne = !0;
        break;
      }
      Y += j[K];
    }
    return de !== "" ? !1 : {
      value: Y,
      index: K,
      tagClosed: ne
    };
  }
  const u = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
  function m(j, K) {
    const Y = r.getAllMatches(j, u), de = {};
    for (let ne = 0; ne < Y.length; ne++) {
      if (Y[ne][1].length === 0)
        return P("InvalidAttr", "Attribute '" + Y[ne][2] + "' has no space in starting.", q(Y[ne]));
      if (Y[ne][3] !== void 0 && Y[ne][4] === void 0)
        return P("InvalidAttr", "Attribute '" + Y[ne][2] + "' is without value.", q(Y[ne]));
      if (Y[ne][3] === void 0 && !K.allowBooleanAttributes)
        return P("InvalidAttr", "boolean attribute '" + Y[ne][2] + "' is not allowed.", q(Y[ne]));
      const ae = Y[ne][2];
      if (!L(ae))
        return P("InvalidAttr", "Attribute '" + ae + "' is an invalid name.", q(Y[ne]));
      if (!de.hasOwnProperty(ae))
        de[ae] = 1;
      else
        return P("InvalidAttr", "Attribute '" + ae + "' is repeated.", q(Y[ne]));
    }
    return !0;
  }
  function y(j, K) {
    let Y = /\d/;
    for (j[K] === "x" && (K++, Y = /[\da-fA-F]/); K < j.length; K++) {
      if (j[K] === ";")
        return K;
      if (!j[K].match(Y))
        break;
    }
    return -1;
  }
  function E(j, K) {
    if (K++, j[K] === ";")
      return -1;
    if (j[K] === "#")
      return K++, y(j, K);
    let Y = 0;
    for (; K < j.length; K++, Y++)
      if (!(j[K].match(/\w/) && Y < 20)) {
        if (j[K] === ";")
          break;
        return -1;
      }
    return K;
  }
  function P(j, K, Y) {
    return {
      err: {
        code: j,
        msg: K,
        line: Y.line || Y,
        col: Y.col
      }
    };
  }
  function L(j) {
    return r.isName(j);
  }
  function U(j) {
    return r.isName(j);
  }
  function V(j, K) {
    const Y = j.substring(0, K).split(/\r?\n/);
    return {
      line: Y.length,
      // column number is last line's length + 1, because column numbering starts at 1:
      col: Y[Y.length - 1].length + 1
    };
  }
  function q(j) {
    return j.startIndex + j[1].length;
  }
  return y1;
}
var Zg = {}, XP;
function Pce() {
  if (XP) return Zg;
  XP = 1;
  const r = {
    preserveOrder: !1,
    attributeNamePrefix: "@_",
    attributesGroupName: !1,
    textNodeName: "#text",
    ignoreAttributes: !0,
    removeNSPrefix: !1,
    // remove NS from tag name or attribute name if true
    allowBooleanAttributes: !1,
    //a tag can have attributes without any value
    //ignoreRootElement : false,
    parseTagValue: !0,
    parseAttributeValue: !1,
    trimValues: !0,
    //Trim string values of tag and attributes
    cdataPropName: !1,
    numberParseOptions: {
      hex: !0,
      leadingZeros: !0,
      eNotation: !0
    },
    tagValueProcessor: function(t, n) {
      return n;
    },
    attributeValueProcessor: function(t, n) {
      return n;
    },
    stopNodes: [],
    //nested tags will not be parsed even for errors
    alwaysCreateTextNode: !1,
    isArray: () => !1,
    commentPropName: !1,
    unpairedTags: [],
    processEntities: !0,
    htmlEntities: !1,
    ignoreDeclaration: !1,
    ignorePiTags: !1,
    transformTagName: !1,
    transformAttributeName: !1,
    updateTag: function(t, n, i) {
      return t;
    }
    // skipEmptyListItem: false
  }, e = function(t) {
    return Object.assign({}, r, t);
  };
  return Zg.buildOptions = e, Zg.defaultOptions = r, Zg;
}
var b1, ZP;
function Mce() {
  if (ZP) return b1;
  ZP = 1;
  class r {
    constructor(t) {
      this.tagname = t, this.child = [], this[":@"] = {};
    }
    add(t, n) {
      t === "__proto__" && (t = "#__proto__"), this.child.push({ [t]: n });
    }
    addChild(t) {
      t.tagname === "__proto__" && (t.tagname = "#__proto__"), t[":@"] && Object.keys(t[":@"]).length > 0 ? this.child.push({ [t.tagname]: t.child, ":@": t[":@"] }) : this.child.push({ [t.tagname]: t.child });
    }
  }
  return b1 = r, b1;
}
var x1, YP;
function Rce() {
  if (YP) return x1;
  YP = 1;
  const r = Uw();
  function e(m, y) {
    const E = {};
    if (m[y + 3] === "O" && m[y + 4] === "C" && m[y + 5] === "T" && m[y + 6] === "Y" && m[y + 7] === "P" && m[y + 8] === "E") {
      y = y + 9;
      let P = 1, L = !1, U = !1, V = "";
      for (; y < m.length; y++)
        if (m[y] === "<" && !U) {
          if (L && i(m, y)) {
            y += 7;
            let q, j;
            [q, j, y] = t(m, y + 1), j.indexOf("&") === -1 && (E[u(q)] = {
              regx: RegExp(`&${q};`, "g"),
              val: j
            });
          } else if (L && s(m, y)) y += 8;
          else if (L && o(m, y)) y += 8;
          else if (L && l(m, y)) y += 9;
          else if (n) U = !0;
          else throw new Error("Invalid DOCTYPE");
          P++, V = "";
        } else if (m[y] === ">") {
          if (U ? m[y - 1] === "-" && m[y - 2] === "-" && (U = !1, P--) : P--, P === 0)
            break;
        } else m[y] === "[" ? L = !0 : V += m[y];
      if (P !== 0)
        throw new Error("Unclosed DOCTYPE");
    } else
      throw new Error("Invalid Tag instead of DOCTYPE");
    return { entities: E, i: y };
  }
  function t(m, y) {
    let E = "";
    for (; y < m.length && m[y] !== "'" && m[y] !== '"'; y++)
      E += m[y];
    if (E = E.trim(), E.indexOf(" ") !== -1) throw new Error("External entites are not supported");
    const P = m[y++];
    let L = "";
    for (; y < m.length && m[y] !== P; y++)
      L += m[y];
    return [E, L, y];
  }
  function n(m, y) {
    return m[y + 1] === "!" && m[y + 2] === "-" && m[y + 3] === "-";
  }
  function i(m, y) {
    return m[y + 1] === "!" && m[y + 2] === "E" && m[y + 3] === "N" && m[y + 4] === "T" && m[y + 5] === "I" && m[y + 6] === "T" && m[y + 7] === "Y";
  }
  function s(m, y) {
    return m[y + 1] === "!" && m[y + 2] === "E" && m[y + 3] === "L" && m[y + 4] === "E" && m[y + 5] === "M" && m[y + 6] === "E" && m[y + 7] === "N" && m[y + 8] === "T";
  }
  function o(m, y) {
    return m[y + 1] === "!" && m[y + 2] === "A" && m[y + 3] === "T" && m[y + 4] === "T" && m[y + 5] === "L" && m[y + 6] === "I" && m[y + 7] === "S" && m[y + 8] === "T";
  }
  function l(m, y) {
    return m[y + 1] === "!" && m[y + 2] === "N" && m[y + 3] === "O" && m[y + 4] === "T" && m[y + 5] === "A" && m[y + 6] === "T" && m[y + 7] === "I" && m[y + 8] === "O" && m[y + 9] === "N";
  }
  function u(m) {
    if (r.isName(m))
      return m;
    throw new Error(`Invalid entity name ${m}`);
  }
  return x1 = e, x1;
}
var w1, KP;
function Bce() {
  if (KP) return w1;
  KP = 1;
  const r = /^[-+]?0x[a-fA-F0-9]+$/, e = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/, t = {
    hex: !0,
    // oct: false,
    leadingZeros: !0,
    decimalPoint: ".",
    eNotation: !0
    //skipLike: /regex/
  };
  function n(o, l = {}) {
    if (l = Object.assign({}, t, l), !o || typeof o != "string") return o;
    let u = o.trim();
    if (l.skipLike !== void 0 && l.skipLike.test(u)) return o;
    if (o === "0") return 0;
    if (l.hex && r.test(u))
      return s(u, 16);
    if (u.search(/[eE]/) !== -1) {
      const m = u.match(/^([-\+])?(0*)([0-9]*(\.[0-9]*)?[eE][-\+]?[0-9]+)$/);
      if (m) {
        if (l.leadingZeros)
          u = (m[1] || "") + m[3];
        else if (!(m[2] === "0" && m[3][0] === ".")) return o;
        return l.eNotation ? Number(u) : o;
      } else
        return o;
    } else {
      const m = e.exec(u);
      if (m) {
        const y = m[1], E = m[2];
        let P = i(m[3]);
        if (!l.leadingZeros && E.length > 0 && y && u[2] !== ".") return o;
        if (!l.leadingZeros && E.length > 0 && !y && u[1] !== ".") return o;
        if (l.leadingZeros && E === o) return 0;
        {
          const L = Number(u), U = "" + L;
          return U.search(/[eE]/) !== -1 ? l.eNotation ? L : o : u.indexOf(".") !== -1 ? U === "0" && P === "" || U === P || y && U === "-" + P ? L : o : E ? P === U || y + P === U ? L : o : u === U || u === y + U ? L : o;
        }
      } else
        return o;
    }
  }
  function i(o) {
    return o && o.indexOf(".") !== -1 && (o = o.replace(/0+$/, ""), o === "." ? o = "0" : o[0] === "." ? o = "0" + o : o[o.length - 1] === "." && (o = o.substr(0, o.length - 1))), o;
  }
  function s(o, l) {
    if (parseInt) return parseInt(o, l);
    if (Number.parseInt) return Number.parseInt(o, l);
    if (window && window.parseInt) return window.parseInt(o, l);
    throw new Error("parseInt, Number.parseInt, window.parseInt are not supported");
  }
  return w1 = n, w1;
}
var T1, QP;
function ek() {
  if (QP) return T1;
  QP = 1;
  function r(e) {
    return typeof e == "function" ? e : Array.isArray(e) ? (t) => {
      for (const n of e)
        if (typeof n == "string" && t === n || n instanceof RegExp && n.test(t))
          return !0;
    } : () => !1;
  }
  return T1 = r, T1;
}
var E1, JP;
function Oce() {
  if (JP) return E1;
  JP = 1;
  const r = Uw(), e = Mce(), t = Rce(), n = Bce(), i = ek();
  class s {
    constructor(ae) {
      this.options = ae, this.currentNode = null, this.tagsNodeStack = [], this.docTypeEntities = {}, this.lastEntities = {
        apos: { regex: /&(apos|#39|#x27);/g, val: "'" },
        gt: { regex: /&(gt|#62|#x3E);/g, val: ">" },
        lt: { regex: /&(lt|#60|#x3C);/g, val: "<" },
        quot: { regex: /&(quot|#34|#x22);/g, val: '"' }
      }, this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" }, this.htmlEntities = {
        space: { regex: /&(nbsp|#160);/g, val: " " },
        // "lt" : { regex: /&(lt|#60);/g, val: "<" },
        // "gt" : { regex: /&(gt|#62);/g, val: ">" },
        // "amp" : { regex: /&(amp|#38);/g, val: "&" },
        // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
        // "apos" : { regex: /&(apos|#39);/g, val: "'" },
        cent: { regex: /&(cent|#162);/g, val: "" },
        pound: { regex: /&(pound|#163);/g, val: "" },
        yen: { regex: /&(yen|#165);/g, val: "" },
        euro: { regex: /&(euro|#8364);/g, val: "" },
        copyright: { regex: /&(copy|#169);/g, val: "" },
        reg: { regex: /&(reg|#174);/g, val: "" },
        inr: { regex: /&(inr|#8377);/g, val: "" },
        num_dec: { regex: /&#([0-9]{1,7});/g, val: (De, Ge) => String.fromCharCode(Number.parseInt(Ge, 10)) },
        num_hex: { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (De, Ge) => String.fromCharCode(Number.parseInt(Ge, 16)) }
      }, this.addExternalEntities = o, this.parseXml = E, this.parseTextData = l, this.resolveNameSpace = u, this.buildAttributesMap = y, this.isItStopNode = V, this.replaceEntitiesValue = L, this.readStopNodeData = Y, this.saveTextToParentTag = U, this.addChild = P, this.ignoreAttributesFn = i(this.options.ignoreAttributes);
    }
  }
  function o(ne) {
    const ae = Object.keys(ne);
    for (let De = 0; De < ae.length; De++) {
      const Ge = ae[De];
      this.lastEntities[Ge] = {
        regex: new RegExp("&" + Ge + ";", "g"),
        val: ne[Ge]
      };
    }
  }
  function l(ne, ae, De, Ge, fe, ve, me) {
    if (ne !== void 0 && (this.options.trimValues && !Ge && (ne = ne.trim()), ne.length > 0)) {
      me || (ne = this.replaceEntitiesValue(ne));
      const X = this.options.tagValueProcessor(ae, ne, De, fe, ve);
      return X == null ? ne : typeof X != typeof ne || X !== ne ? X : this.options.trimValues ? de(ne, this.options.parseTagValue, this.options.numberParseOptions) : ne.trim() === ne ? de(ne, this.options.parseTagValue, this.options.numberParseOptions) : ne;
    }
  }
  function u(ne) {
    if (this.options.removeNSPrefix) {
      const ae = ne.split(":"), De = ne.charAt(0) === "/" ? "/" : "";
      if (ae[0] === "xmlns")
        return "";
      ae.length === 2 && (ne = De + ae[1]);
    }
    return ne;
  }
  const m = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
  function y(ne, ae, De) {
    if (this.options.ignoreAttributes !== !0 && typeof ne == "string") {
      const Ge = r.getAllMatches(ne, m), fe = Ge.length, ve = {};
      for (let me = 0; me < fe; me++) {
        const X = this.resolveNameSpace(Ge[me][1]);
        if (this.ignoreAttributesFn(X, ae))
          continue;
        let re = Ge[me][4], Me = this.options.attributeNamePrefix + X;
        if (X.length)
          if (this.options.transformAttributeName && (Me = this.options.transformAttributeName(Me)), Me === "__proto__" && (Me = "#__proto__"), re !== void 0) {
            this.options.trimValues && (re = re.trim()), re = this.replaceEntitiesValue(re);
            const ot = this.options.attributeValueProcessor(X, re, ae);
            ot == null ? ve[Me] = re : typeof ot != typeof re || ot !== re ? ve[Me] = ot : ve[Me] = de(
              re,
              this.options.parseAttributeValue,
              this.options.numberParseOptions
            );
          } else this.options.allowBooleanAttributes && (ve[Me] = !0);
      }
      if (!Object.keys(ve).length)
        return;
      if (this.options.attributesGroupName) {
        const me = {};
        return me[this.options.attributesGroupName] = ve, me;
      }
      return ve;
    }
  }
  const E = function(ne) {
    ne = ne.replace(/\r\n?/g, `
`);
    const ae = new e("!xml");
    let De = ae, Ge = "", fe = "";
    for (let ve = 0; ve < ne.length; ve++)
      if (ne[ve] === "<")
        if (ne[ve + 1] === "/") {
          const X = j(ne, ">", ve, "Closing Tag is not closed.");
          let re = ne.substring(ve + 2, X).trim();
          if (this.options.removeNSPrefix) {
            const be = re.indexOf(":");
            be !== -1 && (re = re.substr(be + 1));
          }
          this.options.transformTagName && (re = this.options.transformTagName(re)), De && (Ge = this.saveTextToParentTag(Ge, De, fe));
          const Me = fe.substring(fe.lastIndexOf(".") + 1);
          if (re && this.options.unpairedTags.indexOf(re) !== -1)
            throw new Error(`Unpaired tag can not be used as closing tag: </${re}>`);
          let ot = 0;
          Me && this.options.unpairedTags.indexOf(Me) !== -1 ? (ot = fe.lastIndexOf(".", fe.lastIndexOf(".") - 1), this.tagsNodeStack.pop()) : ot = fe.lastIndexOf("."), fe = fe.substring(0, ot), De = this.tagsNodeStack.pop(), Ge = "", ve = X;
        } else if (ne[ve + 1] === "?") {
          let X = K(ne, ve, !1, "?>");
          if (!X) throw new Error("Pi Tag is not closed.");
          if (Ge = this.saveTextToParentTag(Ge, De, fe), !(this.options.ignoreDeclaration && X.tagName === "?xml" || this.options.ignorePiTags)) {
            const re = new e(X.tagName);
            re.add(this.options.textNodeName, ""), X.tagName !== X.tagExp && X.attrExpPresent && (re[":@"] = this.buildAttributesMap(X.tagExp, fe, X.tagName)), this.addChild(De, re, fe);
          }
          ve = X.closeIndex + 1;
        } else if (ne.substr(ve + 1, 3) === "!--") {
          const X = j(ne, "-->", ve + 4, "Comment is not closed.");
          if (this.options.commentPropName) {
            const re = ne.substring(ve + 4, X - 2);
            Ge = this.saveTextToParentTag(Ge, De, fe), De.add(this.options.commentPropName, [{ [this.options.textNodeName]: re }]);
          }
          ve = X;
        } else if (ne.substr(ve + 1, 2) === "!D") {
          const X = t(ne, ve);
          this.docTypeEntities = X.entities, ve = X.i;
        } else if (ne.substr(ve + 1, 2) === "![") {
          const X = j(ne, "]]>", ve, "CDATA is not closed.") - 2, re = ne.substring(ve + 9, X);
          Ge = this.saveTextToParentTag(Ge, De, fe);
          let Me = this.parseTextData(re, De.tagname, fe, !0, !1, !0, !0);
          Me == null && (Me = ""), this.options.cdataPropName ? De.add(this.options.cdataPropName, [{ [this.options.textNodeName]: re }]) : De.add(this.options.textNodeName, Me), ve = X + 2;
        } else {
          let X = K(ne, ve, this.options.removeNSPrefix), re = X.tagName;
          const Me = X.rawTagName;
          let ot = X.tagExp, be = X.attrExpPresent, Ue = X.closeIndex;
          this.options.transformTagName && (re = this.options.transformTagName(re)), De && Ge && De.tagname !== "!xml" && (Ge = this.saveTextToParentTag(Ge, De, fe, !1));
          const Xe = De;
          if (Xe && this.options.unpairedTags.indexOf(Xe.tagname) !== -1 && (De = this.tagsNodeStack.pop(), fe = fe.substring(0, fe.lastIndexOf("."))), re !== ae.tagname && (fe += fe ? "." + re : re), this.isItStopNode(this.options.stopNodes, fe, re)) {
            let lt = "";
            if (ot.length > 0 && ot.lastIndexOf("/") === ot.length - 1)
              re[re.length - 1] === "/" ? (re = re.substr(0, re.length - 1), fe = fe.substr(0, fe.length - 1), ot = re) : ot = ot.substr(0, ot.length - 1), ve = X.closeIndex;
            else if (this.options.unpairedTags.indexOf(re) !== -1)
              ve = X.closeIndex;
            else {
              const ct = this.readStopNodeData(ne, Me, Ue + 1);
              if (!ct) throw new Error(`Unexpected end of ${Me}`);
              ve = ct.i, lt = ct.tagContent;
            }
            const at = new e(re);
            re !== ot && be && (at[":@"] = this.buildAttributesMap(ot, fe, re)), lt && (lt = this.parseTextData(lt, re, fe, !0, be, !0, !0)), fe = fe.substr(0, fe.lastIndexOf(".")), at.add(this.options.textNodeName, lt), this.addChild(De, at, fe);
          } else {
            if (ot.length > 0 && ot.lastIndexOf("/") === ot.length - 1) {
              re[re.length - 1] === "/" ? (re = re.substr(0, re.length - 1), fe = fe.substr(0, fe.length - 1), ot = re) : ot = ot.substr(0, ot.length - 1), this.options.transformTagName && (re = this.options.transformTagName(re));
              const lt = new e(re);
              re !== ot && be && (lt[":@"] = this.buildAttributesMap(ot, fe, re)), this.addChild(De, lt, fe), fe = fe.substr(0, fe.lastIndexOf("."));
            } else {
              const lt = new e(re);
              this.tagsNodeStack.push(De), re !== ot && be && (lt[":@"] = this.buildAttributesMap(ot, fe, re)), this.addChild(De, lt, fe), De = lt;
            }
            Ge = "", ve = Ue;
          }
        }
      else
        Ge += ne[ve];
    return ae.child;
  };
  function P(ne, ae, De) {
    const Ge = this.options.updateTag(ae.tagname, De, ae[":@"]);
    Ge === !1 || (typeof Ge == "string" && (ae.tagname = Ge), ne.addChild(ae));
  }
  const L = function(ne) {
    if (this.options.processEntities) {
      for (let ae in this.docTypeEntities) {
        const De = this.docTypeEntities[ae];
        ne = ne.replace(De.regx, De.val);
      }
      for (let ae in this.lastEntities) {
        const De = this.lastEntities[ae];
        ne = ne.replace(De.regex, De.val);
      }
      if (this.options.htmlEntities)
        for (let ae in this.htmlEntities) {
          const De = this.htmlEntities[ae];
          ne = ne.replace(De.regex, De.val);
        }
      ne = ne.replace(this.ampEntity.regex, this.ampEntity.val);
    }
    return ne;
  };
  function U(ne, ae, De, Ge) {
    return ne && (Ge === void 0 && (Ge = ae.child.length === 0), ne = this.parseTextData(
      ne,
      ae.tagname,
      De,
      !1,
      ae[":@"] ? Object.keys(ae[":@"]).length !== 0 : !1,
      Ge
    ), ne !== void 0 && ne !== "" && ae.add(this.options.textNodeName, ne), ne = ""), ne;
  }
  function V(ne, ae, De) {
    const Ge = "*." + De;
    for (const fe in ne) {
      const ve = ne[fe];
      if (Ge === ve || ae === ve) return !0;
    }
    return !1;
  }
  function q(ne, ae, De = ">") {
    let Ge, fe = "";
    for (let ve = ae; ve < ne.length; ve++) {
      let me = ne[ve];
      if (Ge)
        me === Ge && (Ge = "");
      else if (me === '"' || me === "'")
        Ge = me;
      else if (me === De[0])
        if (De[1]) {
          if (ne[ve + 1] === De[1])
            return {
              data: fe,
              index: ve
            };
        } else
          return {
            data: fe,
            index: ve
          };
      else me === "	" && (me = " ");
      fe += me;
    }
  }
  function j(ne, ae, De, Ge) {
    const fe = ne.indexOf(ae, De);
    if (fe === -1)
      throw new Error(Ge);
    return fe + ae.length - 1;
  }
  function K(ne, ae, De, Ge = ">") {
    const fe = q(ne, ae + 1, Ge);
    if (!fe) return;
    let ve = fe.data;
    const me = fe.index, X = ve.search(/\s/);
    let re = ve, Me = !0;
    X !== -1 && (re = ve.substring(0, X), ve = ve.substring(X + 1).trimStart());
    const ot = re;
    if (De) {
      const be = re.indexOf(":");
      be !== -1 && (re = re.substr(be + 1), Me = re !== fe.data.substr(be + 1));
    }
    return {
      tagName: re,
      tagExp: ve,
      closeIndex: me,
      attrExpPresent: Me,
      rawTagName: ot
    };
  }
  function Y(ne, ae, De) {
    const Ge = De;
    let fe = 1;
    for (; De < ne.length; De++)
      if (ne[De] === "<")
        if (ne[De + 1] === "/") {
          const ve = j(ne, ">", De, `${ae} is not closed`);
          if (ne.substring(De + 2, ve).trim() === ae && (fe--, fe === 0))
            return {
              tagContent: ne.substring(Ge, De),
              i: ve
            };
          De = ve;
        } else if (ne[De + 1] === "?")
          De = j(ne, "?>", De + 1, "StopNode is not closed.");
        else if (ne.substr(De + 1, 3) === "!--")
          De = j(ne, "-->", De + 3, "StopNode is not closed.");
        else if (ne.substr(De + 1, 2) === "![")
          De = j(ne, "]]>", De, "StopNode is not closed.") - 2;
        else {
          const ve = K(ne, De, ">");
          ve && ((ve && ve.tagName) === ae && ve.tagExp[ve.tagExp.length - 1] !== "/" && fe++, De = ve.closeIndex);
        }
  }
  function de(ne, ae, De) {
    if (ae && typeof ne == "string") {
      const Ge = ne.trim();
      return Ge === "true" ? !0 : Ge === "false" ? !1 : n(ne, De);
    } else
      return r.isExist(ne) ? ne : "";
  }
  return E1 = s, E1;
}
var C1 = {}, eM;
function Dce() {
  if (eM) return C1;
  eM = 1;
  function r(s, o) {
    return e(s, o);
  }
  function e(s, o, l) {
    let u;
    const m = {};
    for (let y = 0; y < s.length; y++) {
      const E = s[y], P = t(E);
      let L = "";
      if (l === void 0 ? L = P : L = l + "." + P, P === o.textNodeName)
        u === void 0 ? u = E[P] : u += "" + E[P];
      else {
        if (P === void 0)
          continue;
        if (E[P]) {
          let U = e(E[P], o, L);
          const V = i(U, o);
          E[":@"] ? n(U, E[":@"], L, o) : Object.keys(U).length === 1 && U[o.textNodeName] !== void 0 && !o.alwaysCreateTextNode ? U = U[o.textNodeName] : Object.keys(U).length === 0 && (o.alwaysCreateTextNode ? U[o.textNodeName] = "" : U = ""), m[P] !== void 0 && m.hasOwnProperty(P) ? (Array.isArray(m[P]) || (m[P] = [m[P]]), m[P].push(U)) : o.isArray(P, L, V) ? m[P] = [U] : m[P] = U;
        }
      }
    }
    return typeof u == "string" ? u.length > 0 && (m[o.textNodeName] = u) : u !== void 0 && (m[o.textNodeName] = u), m;
  }
  function t(s) {
    const o = Object.keys(s);
    for (let l = 0; l < o.length; l++) {
      const u = o[l];
      if (u !== ":@") return u;
    }
  }
  function n(s, o, l, u) {
    if (o) {
      const m = Object.keys(o), y = m.length;
      for (let E = 0; E < y; E++) {
        const P = m[E];
        u.isArray(P, l + "." + P, !0, !0) ? s[P] = [o[P]] : s[P] = o[P];
      }
    }
  }
  function i(s, o) {
    const { textNodeName: l } = o, u = Object.keys(s).length;
    return !!(u === 0 || u === 1 && (s[l] || typeof s[l] == "boolean" || s[l] === 0));
  }
  return C1.prettify = r, C1;
}
var S1, tM;
function Lce() {
  if (tM) return S1;
  tM = 1;
  const { buildOptions: r } = Pce(), e = Oce(), { prettify: t } = Dce(), n = JL();
  class i {
    constructor(o) {
      this.externalEntities = {}, this.options = r(o);
    }
    /**
     * Parse XML dats to JS object 
     * @param {string|Buffer} xmlData 
     * @param {boolean|Object} validationOption 
     */
    parse(o, l) {
      if (typeof o != "string") if (o.toString)
        o = o.toString();
      else
        throw new Error("XML data is accepted in String or Bytes[] form.");
      if (l) {
        l === !0 && (l = {});
        const y = n.validate(o, l);
        if (y !== !0)
          throw Error(`${y.err.msg}:${y.err.line}:${y.err.col}`);
      }
      const u = new e(this.options);
      u.addExternalEntities(this.externalEntities);
      const m = u.parseXml(o);
      return this.options.preserveOrder || m === void 0 ? m : t(m, this.options);
    }
    /**
     * Add Entity which is not by default supported by this library
     * @param {string} key 
     * @param {string} value 
     */
    addEntity(o, l) {
      if (l.indexOf("&") !== -1)
        throw new Error("Entity value can't have '&'");
      if (o.indexOf("&") !== -1 || o.indexOf(";") !== -1)
        throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
      if (l === "&")
        throw new Error("An entity with value '&' is not permitted");
      this.externalEntities[o] = l;
    }
  }
  return S1 = i, S1;
}
var I1, rM;
function kce() {
  if (rM) return I1;
  rM = 1;
  const r = `
`;
  function e(l, u) {
    let m = "";
    return u.format && u.indentBy.length > 0 && (m = r), t(l, u, "", m);
  }
  function t(l, u, m, y) {
    let E = "", P = !1;
    for (let L = 0; L < l.length; L++) {
      const U = l[L], V = n(U);
      if (V === void 0) continue;
      let q = "";
      if (m.length === 0 ? q = V : q = `${m}.${V}`, V === u.textNodeName) {
        let ne = U[V];
        s(q, u) || (ne = u.tagValueProcessor(V, ne), ne = o(ne, u)), P && (E += y), E += ne, P = !1;
        continue;
      } else if (V === u.cdataPropName) {
        P && (E += y), E += `<![CDATA[${U[V][0][u.textNodeName]}]]>`, P = !1;
        continue;
      } else if (V === u.commentPropName) {
        E += y + `<!--${U[V][0][u.textNodeName]}-->`, P = !0;
        continue;
      } else if (V[0] === "?") {
        const ne = i(U[":@"], u), ae = V === "?xml" ? "" : y;
        let De = U[V][0][u.textNodeName];
        De = De.length !== 0 ? " " + De : "", E += ae + `<${V}${De}${ne}?>`, P = !0;
        continue;
      }
      let j = y;
      j !== "" && (j += u.indentBy);
      const K = i(U[":@"], u), Y = y + `<${V}${K}`, de = t(U[V], u, q, j);
      u.unpairedTags.indexOf(V) !== -1 ? u.suppressUnpairedNode ? E += Y + ">" : E += Y + "/>" : (!de || de.length === 0) && u.suppressEmptyNode ? E += Y + "/>" : de && de.endsWith(">") ? E += Y + `>${de}${y}</${V}>` : (E += Y + ">", de && y !== "" && (de.includes("/>") || de.includes("</")) ? E += y + u.indentBy + de + y : E += de, E += `</${V}>`), P = !0;
    }
    return E;
  }
  function n(l) {
    const u = Object.keys(l);
    for (let m = 0; m < u.length; m++) {
      const y = u[m];
      if (l.hasOwnProperty(y) && y !== ":@")
        return y;
    }
  }
  function i(l, u) {
    let m = "";
    if (l && !u.ignoreAttributes)
      for (let y in l) {
        if (!l.hasOwnProperty(y)) continue;
        let E = u.attributeValueProcessor(y, l[y]);
        E = o(E, u), E === !0 && u.suppressBooleanAttributes ? m += ` ${y.substr(u.attributeNamePrefix.length)}` : m += ` ${y.substr(u.attributeNamePrefix.length)}="${E}"`;
      }
    return m;
  }
  function s(l, u) {
    l = l.substr(0, l.length - u.textNodeName.length - 1);
    let m = l.substr(l.lastIndexOf(".") + 1);
    for (let y in u.stopNodes)
      if (u.stopNodes[y] === l || u.stopNodes[y] === "*." + m) return !0;
    return !1;
  }
  function o(l, u) {
    if (l && l.length > 0 && u.processEntities)
      for (let m = 0; m < u.entities.length; m++) {
        const y = u.entities[m];
        l = l.replace(y.regex, y.val);
      }
    return l;
  }
  return I1 = e, I1;
}
var P1, nM;
function Fce() {
  if (nM) return P1;
  nM = 1;
  const r = kce(), e = ek(), t = {
    attributeNamePrefix: "@_",
    attributesGroupName: !1,
    textNodeName: "#text",
    ignoreAttributes: !0,
    cdataPropName: !1,
    format: !1,
    indentBy: "  ",
    suppressEmptyNode: !1,
    suppressUnpairedNode: !0,
    suppressBooleanAttributes: !0,
    tagValueProcessor: function(l, u) {
      return u;
    },
    attributeValueProcessor: function(l, u) {
      return u;
    },
    preserveOrder: !1,
    commentPropName: !1,
    unpairedTags: [],
    entities: [
      { regex: new RegExp("&", "g"), val: "&amp;" },
      //it must be on top
      { regex: new RegExp(">", "g"), val: "&gt;" },
      { regex: new RegExp("<", "g"), val: "&lt;" },
      { regex: new RegExp("'", "g"), val: "&apos;" },
      { regex: new RegExp('"', "g"), val: "&quot;" }
    ],
    processEntities: !0,
    stopNodes: [],
    // transformTagName: false,
    // transformAttributeName: false,
    oneListGroup: !1
  };
  function n(l) {
    this.options = Object.assign({}, t, l), this.options.ignoreAttributes === !0 || this.options.attributesGroupName ? this.isAttribute = function() {
      return !1;
    } : (this.ignoreAttributesFn = e(this.options.ignoreAttributes), this.attrPrefixLen = this.options.attributeNamePrefix.length, this.isAttribute = o), this.processTextOrObjNode = i, this.options.format ? (this.indentate = s, this.tagEndChar = `>
`, this.newLine = `
`) : (this.indentate = function() {
      return "";
    }, this.tagEndChar = ">", this.newLine = "");
  }
  n.prototype.build = function(l) {
    return this.options.preserveOrder ? r(l, this.options) : (Array.isArray(l) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1 && (l = {
      [this.options.arrayNodeName]: l
    }), this.j2x(l, 0, []).val);
  }, n.prototype.j2x = function(l, u, m) {
    let y = "", E = "";
    const P = m.join(".");
    for (let L in l)
      if (Object.prototype.hasOwnProperty.call(l, L))
        if (typeof l[L] > "u")
          this.isAttribute(L) && (E += "");
        else if (l[L] === null)
          this.isAttribute(L) || L === this.options.cdataPropName ? E += "" : L[0] === "?" ? E += this.indentate(u) + "<" + L + "?" + this.tagEndChar : E += this.indentate(u) + "<" + L + "/" + this.tagEndChar;
        else if (l[L] instanceof Date)
          E += this.buildTextValNode(l[L], L, "", u);
        else if (typeof l[L] != "object") {
          const U = this.isAttribute(L);
          if (U && !this.ignoreAttributesFn(U, P))
            y += this.buildAttrPairStr(U, "" + l[L]);
          else if (!U)
            if (L === this.options.textNodeName) {
              let V = this.options.tagValueProcessor(L, "" + l[L]);
              E += this.replaceEntitiesValue(V);
            } else
              E += this.buildTextValNode(l[L], L, "", u);
        } else if (Array.isArray(l[L])) {
          const U = l[L].length;
          let V = "", q = "";
          for (let j = 0; j < U; j++) {
            const K = l[L][j];
            if (!(typeof K > "u")) if (K === null)
              L[0] === "?" ? E += this.indentate(u) + "<" + L + "?" + this.tagEndChar : E += this.indentate(u) + "<" + L + "/" + this.tagEndChar;
            else if (typeof K == "object")
              if (this.options.oneListGroup) {
                const Y = this.j2x(K, u + 1, m.concat(L));
                V += Y.val, this.options.attributesGroupName && K.hasOwnProperty(this.options.attributesGroupName) && (q += Y.attrStr);
              } else
                V += this.processTextOrObjNode(K, L, u, m);
            else if (this.options.oneListGroup) {
              let Y = this.options.tagValueProcessor(L, K);
              Y = this.replaceEntitiesValue(Y), V += Y;
            } else
              V += this.buildTextValNode(K, L, "", u);
          }
          this.options.oneListGroup && (V = this.buildObjectNode(V, L, q, u)), E += V;
        } else if (this.options.attributesGroupName && L === this.options.attributesGroupName) {
          const U = Object.keys(l[L]), V = U.length;
          for (let q = 0; q < V; q++)
            y += this.buildAttrPairStr(U[q], "" + l[L][U[q]]);
        } else
          E += this.processTextOrObjNode(l[L], L, u, m);
    return { attrStr: y, val: E };
  }, n.prototype.buildAttrPairStr = function(l, u) {
    return u = this.options.attributeValueProcessor(l, "" + u), u = this.replaceEntitiesValue(u), this.options.suppressBooleanAttributes && u === "true" ? " " + l : " " + l + '="' + u + '"';
  };
  function i(l, u, m, y) {
    const E = this.j2x(l, m + 1, y.concat(u));
    return l[this.options.textNodeName] !== void 0 && Object.keys(l).length === 1 ? this.buildTextValNode(l[this.options.textNodeName], u, E.attrStr, m) : this.buildObjectNode(E.val, u, E.attrStr, m);
  }
  n.prototype.buildObjectNode = function(l, u, m, y) {
    if (l === "")
      return u[0] === "?" ? this.indentate(y) + "<" + u + m + "?" + this.tagEndChar : this.indentate(y) + "<" + u + m + this.closeTag(u) + this.tagEndChar;
    {
      let E = "</" + u + this.tagEndChar, P = "";
      return u[0] === "?" && (P = "?", E = ""), (m || m === "") && l.indexOf("<") === -1 ? this.indentate(y) + "<" + u + m + P + ">" + l + E : this.options.commentPropName !== !1 && u === this.options.commentPropName && P.length === 0 ? this.indentate(y) + `<!--${l}-->` + this.newLine : this.indentate(y) + "<" + u + m + P + this.tagEndChar + l + this.indentate(y) + E;
    }
  }, n.prototype.closeTag = function(l) {
    let u = "";
    return this.options.unpairedTags.indexOf(l) !== -1 ? this.options.suppressUnpairedNode || (u = "/") : this.options.suppressEmptyNode ? u = "/" : u = `></${l}`, u;
  }, n.prototype.buildTextValNode = function(l, u, m, y) {
    if (this.options.cdataPropName !== !1 && u === this.options.cdataPropName)
      return this.indentate(y) + `<![CDATA[${l}]]>` + this.newLine;
    if (this.options.commentPropName !== !1 && u === this.options.commentPropName)
      return this.indentate(y) + `<!--${l}-->` + this.newLine;
    if (u[0] === "?")
      return this.indentate(y) + "<" + u + m + "?" + this.tagEndChar;
    {
      let E = this.options.tagValueProcessor(u, l);
      return E = this.replaceEntitiesValue(E), E === "" ? this.indentate(y) + "<" + u + m + this.closeTag(u) + this.tagEndChar : this.indentate(y) + "<" + u + m + ">" + E + "</" + u + this.tagEndChar;
    }
  }, n.prototype.replaceEntitiesValue = function(l) {
    if (l && l.length > 0 && this.options.processEntities)
      for (let u = 0; u < this.options.entities.length; u++) {
        const m = this.options.entities[u];
        l = l.replace(m.regex, m.val);
      }
    return l;
  };
  function s(l) {
    return this.options.indentBy.repeat(l);
  }
  function o(l) {
    return l.startsWith(this.options.attributeNamePrefix) && l !== this.options.textNodeName ? l.substr(this.attrPrefixLen) : !1;
  }
  return P1 = n, P1;
}
var M1, iM;
function Nce() {
  if (iM) return M1;
  iM = 1;
  const r = JL(), e = Lce(), t = Fce();
  return M1 = {
    XMLParser: e,
    XMLValidator: r,
    XMLBuilder: t
  }, M1;
}
var Uce = Nce();
function sM(r, e) {
  if (e?._parser && e._parser !== "fast-xml-parser")
    throw new Error(e?._parser);
  const t = {
    // Default FastXML options
    // https://github.com/NaturalIntelligence/fast-xml-parser/blob/master/docs/v4/2.XMLparseOptions.md#allowbooleanattributes
    allowBooleanAttributes: !0,
    // https://github.com/NaturalIntelligence/fast-xml-parser/blob/master/docs/v4/2.XMLparseOptions.md#ignoredeclaration
    ignoreDeclaration: !0,
    // https://github.com/NaturalIntelligence/fast-xml-parser/blob/master/docs/v4/2.XMLparseOptions.md#removensprefix
    removeNSPrefix: e?.removeNSPrefix,
    // https://github.com/NaturalIntelligence/fast-xml-parser/blob/master/docs/v4/2.XMLparseOptions.md#textnodename
    textNodeName: e?.textNodeName,
    // Let's application specify keys that are always arrays
    isArray: (i, s, o, l) => !!e?.arrayPaths?.some((m) => s === m),
    // Application overrides
    ...e?._fastXML
  }, n = zce(r, t);
  return e?.uncapitalizeKeys ? I2(n) : n;
}
function zce(r, e) {
  return new Uce.XMLParser({
    ignoreAttributes: !1,
    attributeNamePrefix: "",
    ...e
  }).parse(r);
}
const Vce = "4.3.3", Sp = {
  dataType: null,
  batchType: null,
  name: "XML",
  id: "xml",
  module: "xml",
  version: Vce,
  worker: !1,
  extensions: ["xml"],
  mimeTypes: ["application/xml", "text/xml"],
  testText: jce,
  options: {
    xml: {
      _parser: "fast-xml-parser",
      uncapitalizeKeys: !1,
      removeNSPrefix: !1,
      textNodeName: "value",
      arrayPaths: []
    }
  },
  parse: async (r, e) => sM(new TextDecoder().decode(r), {
    ...Sp.options.xml,
    ...e?.xml
  }),
  parseTextSync: (r, e) => sM(r, { ...Sp.options.xml, ...e?.xml })
};
function jce(r) {
  return r.startsWith("<?xml");
}
function Hce(r, e) {
  const t = Sp.parseTextSync?.(r, e), n = t?.ServiceExceptionReport?.ServiceException || t?.["ogc:ServiceExceptionReport"]?.["ogc:ServiceException"];
  return typeof n == "string" ? n : n.value || n.code || "Unknown error";
}
const Gce = "4.3.3", Lm = {
  dataType: null,
  batchType: null,
  id: "wms-error",
  name: "WMS Error",
  module: "wms",
  version: Gce,
  worker: !1,
  extensions: ["xml"],
  mimeTypes: ["application/vnd.ogc.se_xml", "application/xml", "text/xml"],
  testText: Wce,
  options: {
    wms: {
      throwOnError: !1
    }
  },
  parse: async (r, e) => R1(new TextDecoder().decode(r), e),
  parseSync: (r, e) => R1(new TextDecoder().decode(r), e),
  parseTextSync: (r, e) => R1(r, e)
};
function Wce(r) {
  return r.startsWith("<?xml");
}
function R1(r, e) {
  const t = { ...Lm.options.wms, ...e?.wms }, n = Hce(r, t), i = t.minimalErrors ? n : `WMS Service error: ${n}`;
  if (t.throwOnError)
    throw new Error(i);
  return i;
}
function Ip(r) {
  return Array.isArray(r) ? r : r ? [r] : [];
}
function ly(r) {
  const e = Ip(r);
  return e.length > 0 && e.every((t) => typeof t == "string") ? e : [];
}
function Yg(r, e = void 0) {
  switch (typeof r) {
    case "number":
      return r;
    case "string":
      return parseFloat(r);
    default:
      return;
  }
}
function B1(r, e = void 0) {
  switch (typeof r) {
    case "number":
      return r;
    case "string":
      return parseInt(r, 10);
    default:
      return;
  }
}
function Ap(r) {
  switch (r) {
    case "true":
      return !0;
    case "false":
      return !1;
    case "1":
      return !0;
    case "0":
      return !1;
    default:
      return !1;
  }
}
function oM(r, e) {
  const t = Sp.parseTextSync?.(r, e), n = t.WMT_MS_Capabilities || t.WMS_Capabilities || t, i = $ce(n);
  if (e?.inheritedLayerProps)
    for (const s of i.layers)
      rk(s, null);
  return e?.includeRawJSON && (i.json = n), e?.includeXMLText && (i.xml = r), i;
}
function $ce(r) {
  const e = {
    version: String(r.version || ""),
    name: String(r.Service?.Name || "unnamed"),
    title: r.Service?.Title ? String(r.Service?.Title) : void 0,
    abstract: r.Service?.Abstract ? String(r.Service?.Abstract) : void 0,
    keywords: ly(r.Service?.KeywordList?.Keyword),
    fees: r.Service?.Fees ? JSON.stringify(r.Service?.Fees) : void 0,
    accessConstraints: r.Service?.AccessConstraints ? JSON.stringify(r.Service?.AccessConstraints) : void 0,
    layerLimit: B1(r.Service?.LayerLimit),
    maxWidth: B1(r.Service?.maxWidth),
    maxHeight: B1(r.Service?.maxHeight),
    layers: [],
    requests: qce(r.Capability?.Request),
    exceptions: Xce(r.Exception)
    // contact field is a mess of largely irrelevant information, put it last
    // contact: xml.Service?.Contact ? JSON.stringify(xml.Service?.Contact) : undefined,
  }, t = Ip(r.Capability?.Layer);
  for (const n of t)
    e.layers.push(tk(n));
  for (const [n, i] of Object.entries(e))
    i === void 0 && delete e[n];
  return e;
}
function qce(r) {
  const e = {};
  for (const [t, n] of Object.entries(r || {})) {
    const i = ly(n?.Format);
    e[t] = { mimeTypes: i };
  }
  return e;
}
function Xce(r) {
  if (Ip(r?.Format).length > 0)
    return {
      mimeTypes: ly(r)
    };
}
function tk(r) {
  const e = {
    // All layers must have a title
    title: String(r?.Title || ""),
    // Name is required only if renderable
    name: r?.Name && String(r?.Name),
    abstract: r?.Name && String(r?.Abstract),
    keywords: ly(r.KeywordList?.Keyword)
  }, t = r?.CRS || r?.SRS;
  t && Array.isArray(t) && t.every((m) => typeof m == "string") && (e.crs = t);
  let n = r?.EX_GeographicBoundingBox && Zce(r?.EX_GeographicBoundingBox);
  n && (e.geographicBoundingBox = n), n = r?.LatLonBoundingBox && Yce(r?.LatLonBoundingBox), n && (e.geographicBoundingBox = n);
  const i = r?.BoundingBox && Kce(r?.BoundingBox);
  i && i.length > 0 && (e.boundingBoxes = i);
  const o = Ip(r?.Dimension).map((m) => Jce(m));
  o.length && (e.dimensions = o), r?.opaque && (e.opaque = Ap(r?.opaque)), r?.cascaded && (e.cascaded = Ap(r?.cascaded)), r?.queryable && (e.queryable = Ap(r?.queryable));
  const l = Ip(r?.Layer), u = [];
  for (const m of l)
    u.push(tk(m));
  u.length > 0 && (e.layers = u);
  for (const [m, y] of Object.entries(e))
    y === void 0 && delete e[m];
  return e;
}
function Zce(r) {
  const { westBoundLongitude: e, northBoundLatitude: t, eastBoundLongitude: n, southBoundLatitude: i } = r;
  return [
    [e, i],
    [n, t]
  ];
}
function Yce(r) {
  const { minx: e, miny: t, maxx: n, maxy: i } = r;
  return [
    [e, t],
    [n, i]
  ];
}
function Kce(r) {
  return Ip(r).map((t) => Qce(t));
}
function Qce(r) {
  const { CRS: e, SRS: t, minx: n, miny: i, maxx: s, maxy: o, resx: l, resy: u } = r, m = {
    // CRS in 1.3.0, SRS in 1.1.1
    crs: e || t,
    boundingBox: [
      [Yg(n), Yg(i)],
      [Yg(s), Yg(o)]
    ]
  };
  return l && (m.xResolution = l), u && (m.yResolution = u), m;
}
function Jce(r) {
  const { name: e, units: t, value: n } = r, i = { name: e, units: t, extent: n };
  return r.unitSymbol && (i.unitSymbol = r.unitSymbol), r.default && (i.defaultValue = r.default), r.multipleValues && (i.multipleValues = Ap(r.multipleValues)), r.nearestValue && (i.nearestValue = Ap(r.nearestValue)), r.current && (i.current = Ap(r.current)), i;
}
function rk(r, e) {
  e?.geographicBoundingBox && !r.geographicBoundingBox && (r.geographicBoundingBox = [...e.geographicBoundingBox]), e?.crs && !r.crs && (r.crs = [...e.crs]), e?.boundingBoxes && !r.boundingBoxes && (r.boundingBoxes = [...e.boundingBoxes]), e?.dimensions && !r.dimensions && (r.dimensions = [...e.dimensions]);
  for (const t of r.layers || [])
    rk(t, r);
}
const eue = "4.3.3", zw = {
  dataType: null,
  batchType: null,
  id: "wms-capabilities",
  name: "WMS Capabilities",
  module: "wms",
  version: eue,
  worker: !1,
  extensions: ["xml"],
  mimeTypes: ["application/vnd.ogc.wms_xml", "application/xml", "text/xml"],
  testText: tue,
  options: {
    wms: {}
  },
  parse: async (r, e) => (
    // TODO pass in XML options
    oM(new TextDecoder().decode(r), e?.wms)
  ),
  parseTextSync: (r, e) => (
    // TODO pass in XML options
    oM(r, e?.wms)
  )
};
function tue(r) {
  return r.startsWith("<?xml");
}
function aM(r, e) {
  const n = (Sp.parseTextSync?.(r, e)).FeatureInfoResponse?.FIELDS || [];
  return {
    features: (Array.isArray(n) ? n : [n]).map((s) => rue(s))
  };
}
function rue(r) {
  return {
    attributes: r || {},
    type: "",
    bounds: { bottom: 0, top: 0, left: 0, right: 0 }
  };
}
const nue = {
  ...zw,
  dataType: null,
  id: "wms-feature-info",
  name: "WMS FeatureInfo",
  parse: async (r, e) => aM(new TextDecoder().decode(r), e),
  parseTextSync: (r, e) => aM(r, e)
};
function lM(r, e) {
  return Sp.parseTextSync?.(r, e);
}
const iue = {
  ...zw,
  dataType: null,
  id: "wms-layer-description",
  name: "WMS DescribeLayer",
  parse: async (r, e) => lM(new TextDecoder().decode(r), e),
  parseTextSync: (r, e) => lM(r, e)
}, sue = {
  name: "Web Map Service (OGC WMS)",
  id: "wms",
  module: "wms",
  version: "0.0.0",
  extensions: [],
  mimeTypes: [],
  options: {
    wms: {
      // TODO - add options here
    }
  },
  type: "wms",
  fromUrl: !0,
  fromBlob: !1,
  testURL: (r) => r.toLowerCase().includes("wms"),
  createDataSource: (r, e) => new oue(r, e)
};
class oue extends ex {
  /** Base URL to the service */
  url;
  data;
  /** In WMS 1.3.0, replaces references to EPSG:4326 with CRS:84. But not always supported. Default: false */
  substituteCRS84;
  /** In WMS 1.3.0, flips x,y (lng, lat) coordinates for the supplied coordinate systems. Default: ['ESPG:4326'] */
  flipCRS;
  /** Default static WMS parameters */
  wmsParameters;
  /** Default static vendor parameters */
  vendorParameters;
  capabilities = null;
  /** Create a WMSImageSource */
  constructor(e, t) {
    super(t), this.url = e, this.data = e, this.substituteCRS84 = t.wms?.substituteCRS84 ?? t.substituteCRS84 ?? !1, this.flipCRS = ["EPSG:4326"], this.wmsParameters = {
      layers: void 0,
      query_layers: void 0,
      styles: void 0,
      version: "1.3.0",
      crs: "EPSG:4326",
      format: "image/png",
      info_format: "text/plain",
      transparent: void 0,
      time: void 0,
      elevation: void 0,
      ...t.wmsParameters,
      // deprecated
      ...t.wms?.wmsParameters
    }, this.vendorParameters = t.wms?.vendorParameters || t.vendorParameters || {};
  }
  // ImageSource implementation
  async getMetadata() {
    const e = await this.getCapabilities();
    return this.normalizeMetadata(e);
  }
  async getImage(e) {
    const { boundingBox: t, bbox: n, ...i } = e, s = {
      bbox: t ? [...t[0], ...t[1]] : n,
      ...i
    };
    return await this.getMap(s);
  }
  normalizeMetadata(e) {
    return e;
  }
  // WMS Service API Stubs
  /** Get Capabilities */
  async getCapabilities(e, t) {
    const n = this.getCapabilitiesURL(e, t), i = await this.fetch(n), s = await i.arrayBuffer();
    this._checkResponse(i, s);
    const o = await zw.parse(s, this.loadOptions);
    return this.capabilities = o, o;
  }
  /** Get a map image */
  async getMap(e, t) {
    const n = this.getMapURL(e, t), i = await this.fetch(n), s = await i.arrayBuffer();
    this._checkResponse(i, s);
    try {
      return await Gm.parse(s, this.loadOptions);
    } catch {
      throw this._parseError(s);
    }
  }
  /** Get Feature Info for a coordinate */
  async getFeatureInfo(e, t) {
    const n = this.getFeatureInfoURL(e, t), i = await this.fetch(n), s = await i.arrayBuffer();
    return this._checkResponse(i, s), await nue.parse(s, this.loadOptions);
  }
  /** Get Feature Info for a coordinate */
  async getFeatureInfoText(e, t) {
    const n = this.getFeatureInfoURL(e, t), i = await this.fetch(n), s = await i.arrayBuffer();
    return this._checkResponse(i, s), new TextDecoder().decode(s);
  }
  /** Get more information about a layer */
  async describeLayer(e, t) {
    const n = this.describeLayerURL(e, t), i = await this.fetch(n), s = await i.arrayBuffer();
    return this._checkResponse(i, s), await iue.parse(s, this.loadOptions);
  }
  /** Get an image with a semantic legend */
  async getLegendGraphic(e, t) {
    const n = this.getLegendGraphicURL(e, t), i = await this.fetch(n), s = await i.arrayBuffer();
    this._checkResponse(i, s);
    try {
      return await Gm.parse(s, this.loadOptions);
    } catch {
      throw this._parseError(s);
    }
  }
  // Typed URL creators
  // For applications that want full control of fetching and parsing
  /** Generate a URL for the GetCapabilities request */
  getCapabilitiesURL(e, t) {
    const n = {
      version: this.wmsParameters.version,
      ...e
    };
    return this._getWMSUrl("GetCapabilities", n, t);
  }
  /** Generate a URL for the GetMap request */
  getMapURL(e, t) {
    e = this._getWMS130Parameters(e);
    const n = {
      version: this.wmsParameters.version,
      format: this.wmsParameters.format,
      transparent: this.wmsParameters.transparent,
      time: this.wmsParameters.time,
      elevation: this.wmsParameters.elevation,
      layers: this.wmsParameters.layers,
      styles: this.wmsParameters.styles,
      crs: this.wmsParameters.crs,
      // bbox: [-77.87304, 40.78975, -77.85828, 40.80228],
      // width: 1200,
      // height: 900,
      ...e
    };
    return this._getWMSUrl("GetMap", n, t);
  }
  /** Generate a URL for the GetFeatureInfo request */
  getFeatureInfoURL(e, t) {
    e = this._getWMS130Parameters(e);
    const { boundingBox: n, bbox: i } = e;
    e.bbox = n ? [...n[0], ...n[1]] : i;
    const s = {
      version: this.wmsParameters.version,
      // query_layers: [],
      // format: this.wmsParameters.format,
      info_format: this.wmsParameters.info_format,
      layers: this.wmsParameters.layers,
      query_layers: this.wmsParameters.query_layers,
      styles: this.wmsParameters.styles,
      crs: this.wmsParameters.crs,
      // bbox: [-77.87304, 40.78975, -77.85828, 40.80228],
      // width: 1200,
      // height: 900,
      // x: undefined!,
      // y: undefined!,
      ...e
    };
    return this._getWMSUrl("GetFeatureInfo", s, t);
  }
  /** Generate a URL for the GetFeatureInfo request */
  describeLayerURL(e, t) {
    const n = {
      version: this.wmsParameters.version,
      ...e
    };
    return this._getWMSUrl("DescribeLayer", n, t);
  }
  getLegendGraphicURL(e, t) {
    const n = {
      version: this.wmsParameters.version,
      // format?
      ...e
    };
    return this._getWMSUrl("GetLegendGraphic", n, t);
  }
  // INTERNAL METHODS
  _parseWMSUrl(e) {
    const [t, n] = e.split("?"), i = n.split("&"), s = {};
    for (const o of i) {
      const [l, u] = o.split("=");
      s[l] = u;
    }
    return { url: t, parameters: s };
  }
  /**
   * Generate a URL with parameters
   * @note case _getWMSUrl may need to be overridden to handle certain backends?
   * @note at the moment, only URLs with parameters are supported (no XML payloads)
   * */
  _getWMSUrl(e, t, n) {
    let i = this.url, s = !0;
    const o = {
      service: "WMS",
      version: t.version,
      request: e,
      ...t,
      ...this.vendorParameters,
      ...n
    }, l = ["transparent", "time", "elevation"];
    for (const [u, m] of Object.entries(o))
      (!l.includes(u) || m) && (i += s ? "?" : "&", s = !1, i += this._getURLParameter(u, m, t));
    return encodeURI(i);
  }
  _getWMS130Parameters(e) {
    const t = { ...e };
    return t.srs && (t.crs = t.crs || t.srs, delete t.srs), t;
  }
  // eslint-disable-next-line complexity
  _getURLParameter(e, t, n) {
    switch (e) {
      case "crs":
        n.version !== "1.3.0" ? e = "srs" : this.substituteCRS84 && t === "EPSG:4326" && (t = "CRS:84");
        break;
      case "srs":
        n.version === "1.3.0" && (e = "crs");
        break;
      case "bbox":
        const i = this._flipBoundingBox(t, n);
        i && (t = i);
        break;
      case "x":
        n.version === "1.3.0" && (e = "i");
        break;
      case "y":
        n.version === "1.3.0" && (e = "j");
        break;
    }
    return e = e.toUpperCase(), Array.isArray(t) ? `${e}=${t.join(",")}` : `${e}=${t ? String(t) : ""}`;
  }
  /** Coordinate order is flipped for certain CRS in WMS 1.3.0 */
  _flipBoundingBox(e, t) {
    if (!Array.isArray(e) || e.length !== 4)
      return null;
    const n = (
      // Only affects WMS 1.3.0
      t.version === "1.3.0" && // Flip if we are dealing with a CRS that was flipped in 1.3.0
      this.flipCRS.includes(t.crs || "") && // Don't flip if we are substituting EPSG:4326 with CRS:84
      !(this.substituteCRS84 && t.crs === "EPSG:4326")
    ), i = e;
    return n ? [i[1], i[0], i[3], i[2]] : i;
  }
  /** Fetches an array buffer and checks the response (boilerplate reduction) */
  async _fetchArrayBuffer(e) {
    const t = await this.fetch(e), n = await t.arrayBuffer();
    return this._checkResponse(t, n), n;
  }
  /** Checks for and parses a WMS XML formatted ServiceError and throws an exception */
  _checkResponse(e, t) {
    const n = e.headers["content-type"];
    if (!e.ok || Lm.mimeTypes.includes(n)) {
      const i = rB(this.loadOptions, {
        wms: { throwOnError: !0 }
      }), s = Lm.parseSync?.(t, i);
      throw new Error(s);
    }
  }
  /** Error situation detected */
  _parseError(e) {
    const t = Lm.parseSync?.(e, this.loadOptions);
    return new Error(t);
  }
}
const aue = {
  name: "ArcGISImageServer",
  id: "arcgis-image-server",
  module: "wms",
  version: "0.0.0",
  extensions: [],
  mimeTypes: [],
  options: {
    "arcgis-image-server": {
      // TODO - add options here
    }
  },
  type: "arcgis-image-server",
  fromUrl: !0,
  fromBlob: !1,
  testURL: (r) => r.toLowerCase().includes("ImageServer"),
  createDataSource: (r, e) => new lue(r, e)
};
class lue extends ex {
  url;
  data;
  constructor(e, t) {
    super(t), this.url = e, this.data = e;
  }
  // ImageSource (normalized endpoints)
  async getMetadata() {
    return await this.metadata();
  }
  async getImage(e) {
    throw new Error("not implemented");
  }
  // ImageServer endpoints
  async metadata() {
    throw new Error("not implemented");
  }
  /**
   * Form a URL to an ESRI ImageServer
   // https://sampleserver6.arcgisonline.com/arcgis/rest/services/NLCDLandCover2001/ImageServer/exportImage?bbox=${bounds[0]},${bounds[1]},${bounds[2]},${bounds[3]}&bboxSR=4326&size=${width},${height}&imageSR=102100&time=&format=jpgpng&pixelType=U8&noData=&noDataInterpretation=esriNoDataMatchAny&interpolation=+RSP_NearestNeighbor&compression=&compressionQuality=&bandIds=&mosaicRule=&renderingRule=&f=image`,
   */
  exportImage(e) {
    throw new Error("not implemented");
  }
  // URL creators
  metadataURL(e) {
    return `${this.url}?f=pjson`;
  }
  /**
   * Form a URL to an ESRI ImageServer
   // https://sampleserver6.arcgisonline.com/arcgis/rest/services/NLCDLandCover2001/ImageServer/exportImage?
   //   bbox=${bounds[0]},${bounds[1]},${bounds[2]},${bounds[3]}&bboxSR=4326&
   //   size=${width},${height}&imageSR=102100&time=&format=jpgpng&pixelType=U8&
   //   noData=&noDataInterpretation=esriNoDataMatchAny&interpolation=+RSP_NearestNeighbor&compression=&
   //   compressionQuality=&bandIds=&mosaicRule=&renderingRule=&
   //   f=image
   */
  exportImageURL(e) {
    const t = `bbox=${e.bbox[0]},${e.bbox[1]},${e.bbox[2]},${e.bbox[3]}`, n = `size=${e.width},${e.height}`, i = { ...e, bbox: t, size: n };
    return delete i.width, delete i.height, this.getUrl("exportImage", i);
  }
  // INTERNAL METHODS
  /**
   * @note protected, since perhaps getWMSUrl may need to be overridden to handle certain backends?
   * @note if override is common, maybe add a callback prop?
   * */
  getUrl(e, t, n) {
    let i = `${this.url}/${e}`, s = !0;
    for (const [o, l] of Object.entries(t))
      i += s ? "?" : "&", s = !1, Array.isArray(l) ? i += `${o.toUpperCase()}=${l.join(",")}` : i += `${o.toUpperCase()}=${l ? String(l) : ""}`;
    return i;
  }
  /** Checks for and parses a WMS XML formatted ServiceError and throws an exception */
  async checkResponse(e) {
    if (!e.ok)
      throw new Error("error");
  }
}
const cue = [sue, aue];
function uue(r, e = cue) {
  const { type: t = "auto" } = r, n = t === "auto" ? hue(r.url, e) : fue(t, e);
  if (!n)
    throw new Error("Not a valid image source type");
  return n.createDataSource(r.url, r);
}
function fue(r, e) {
  for (const t of e)
    if (t.type === r)
      return t;
  return null;
}
function hue(r, e) {
  for (const t of e)
    if (t.testURL && t.testURL(r))
      return t;
  return null;
}
const cM = 6378137 * Math.PI;
function uM(r) {
  const e = Jc(r);
  return e[0] = (e[0] / 256 - 1) * cM, e[1] = (e[1] / 256 - 1) * cM, e;
}
const due = {
  id: "imagery-layer",
  data: "",
  serviceType: "auto",
  srs: "auto",
  layers: { type: "array", compare: !0, value: [] },
  onMetadataLoad: { type: "function", value: () => {
  } },
  // eslint-disable-next-line
  onMetadataLoadError: { type: "function", value: console.error },
  onImageLoadStart: { type: "function", value: () => {
  } },
  onImageLoad: { type: "function", value: () => {
  } },
  onImageLoadError: {
    type: "function",
    compare: !1,
    // eslint-disable-next-line
    value: (r, e) => console.error(e, r)
  }
};
class Vw extends Ps {
  /** Returns true if all async resources are loaded */
  get isLoaded() {
    return this.state?.loadCounter === 0 && super.isLoaded;
  }
  /** Lets deck.gl know that we want viewport change events */
  shouldUpdateState() {
    return !0;
  }
  initializeState() {
    this.state._nextRequestId = 0, this.state.lastRequestId = -1, this.state.loadCounter = 0;
  }
  updateState({ changeFlags: e, props: t, oldProps: n }) {
    const { viewport: i } = this.context;
    e.dataChanged || t.serviceType !== n.serviceType ? (this.state.imageSource = this._createImageSource(t), this._loadMetadata(), this.debounce(() => this.loadImage(i, "image source changed"), 0)) : Fi(t.layers, n.layers, 1) ? e.viewportChanged && this.debounce(() => this.loadImage(i, "viewport changed")) : this.debounce(() => this.loadImage(i, "layers changed"), 0);
  }
  finalizeState() {
  }
  renderLayers() {
    const { bounds: e, image: t, lastRequestParameters: n } = this.state;
    return t && new K_({
      ...this.getSubLayerProps({ id: "bitmap" }),
      _imageCoordinateSystem: n.srs === "EPSG:4326" ? rn.LNGLAT : rn.CARTESIAN,
      bounds: e,
      image: t
    });
  }
  async getFeatureInfoText(e, t) {
    const { lastRequestParameters: n } = this.state;
    return n ? await this.state.imageSource.getFeatureInfoText?.({
      ...n,
      query_layers: n.layers,
      x: e,
      y: t,
      info_format: "application/vnd.ogc.gml"
    }) : "";
  }
  _createImageSource(e) {
    if (e.data instanceof ex)
      return e.data;
    if (typeof e.data == "string")
      return uue({
        url: e.data,
        loadOptions: e.loadOptions,
        type: e.serviceType
      });
    throw new Error("invalid image source in props.data");
  }
  /** Run a getMetadata on the image service */
  async _loadMetadata() {
    const { imageSource: e } = this.state;
    try {
      this.state.loadCounter++;
      const t = await e.getMetadata();
      this.state.imageSource === e && this.getCurrentLayer()?.props.onMetadataLoad(t);
    } catch (t) {
      this.getCurrentLayer()?.props.onMetadataLoadError(t);
    } finally {
      this.state.loadCounter--;
    }
  }
  /** Load an image */
  async loadImage(e, t) {
    const { layers: n, serviceType: i } = this.props;
    if (i === "wms" && n.length === 0)
      return;
    const s = e.getBounds(), { width: o, height: l } = e, u = this.getRequestId();
    let { srs: m } = this.props;
    m === "auto" && (m = e.resolution ? "EPSG:4326" : "EPSG:3857");
    const y = {
      width: o,
      height: l,
      boundingBox: [
        [s[0], s[1]],
        [s[2], s[3]]
      ],
      layers: n,
      crs: m
    };
    if (m === "EPSG:3857") {
      const E = uM([s[0], s[1]]), P = uM([s[2], s[3]]);
      y.boundingBox = [E, P];
    }
    try {
      this.state.loadCounter++, this.props.onImageLoadStart(u);
      const E = await this.state.imageSource.getImage(y);
      this.state.lastRequestId < u && (this.getCurrentLayer()?.props.onImageLoad(u), this.setState({
        image: E,
        bounds: s,
        lastRequestParameters: y,
        lastRequestId: u
      }));
    } catch (E) {
      this.raiseError(E, "Load image"), this.getCurrentLayer()?.props.onImageLoadError(u, E);
    } finally {
      this.state.loadCounter--;
    }
  }
  // HELPERS
  /** Global counter for issuing unique request ids */
  getRequestId() {
    return this.state._nextRequestId++;
  }
  /** Runs an action in the future, cancels it if the new action is issued before it executes */
  debounce(e, t = 500) {
    clearTimeout(this.state._timeoutId), this.state._timeoutId = setTimeout(() => e(), t);
  }
}
Vw.layerName = "WMSLayer";
Vw.defaultProps = due;
const pue = {
  getHeight: { type: "accessor", value: 0 },
  greatCircle: !0
};
class jw extends x0 {
}
jw.layerName = "GreatCircleLayer";
jw.defaultProps = pue;
function Aue(r) {
  throw new Error('Could not dynamically require "' + r + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var km = { exports: {} }, gue = km.exports, fM;
function mue() {
  return fM || (fM = 1, (function(r) {
    (function(e, t) {
      typeof Aue == "function" && r && r.exports ? r.exports = t() : (e.dcodeIO = e.dcodeIO || {}).Long = t();
    })(gue, function() {
      function e(ve, me, X) {
        this.low = ve | 0, this.high = me | 0, this.unsigned = !!X;
      }
      e.prototype.__isLong__, Object.defineProperty(e.prototype, "__isLong__", {
        value: !0,
        enumerable: !1,
        configurable: !1
      });
      function t(ve) {
        return (ve && ve.__isLong__) === !0;
      }
      e.isLong = t;
      var n = {}, i = {};
      function s(ve, me) {
        var X, re, Me;
        return me ? (ve >>>= 0, (Me = 0 <= ve && ve < 256) && (re = i[ve], re) ? re : (X = l(ve, (ve | 0) < 0 ? -1 : 0, !0), Me && (i[ve] = X), X)) : (ve |= 0, (Me = -128 <= ve && ve < 128) && (re = n[ve], re) ? re : (X = l(ve, ve < 0 ? -1 : 0, !1), Me && (n[ve] = X), X));
      }
      e.fromInt = s;
      function o(ve, me) {
        if (isNaN(ve) || !isFinite(ve))
          return me ? K : j;
        if (me) {
          if (ve < 0)
            return K;
          if (ve >= U)
            return De;
        } else {
          if (ve <= -V)
            return Ge;
          if (ve + 1 >= V)
            return ae;
        }
        return ve < 0 ? o(-ve, me).neg() : l(ve % L | 0, ve / L | 0, me);
      }
      e.fromNumber = o;
      function l(ve, me, X) {
        return new e(ve, me, X);
      }
      e.fromBits = l;
      var u = Math.pow;
      function m(ve, me, X) {
        if (ve.length === 0)
          throw Error("empty string");
        if (ve === "NaN" || ve === "Infinity" || ve === "+Infinity" || ve === "-Infinity")
          return j;
        if (typeof me == "number" ? (X = me, me = !1) : me = !!me, X = X || 10, X < 2 || 36 < X)
          throw RangeError("radix");
        var re;
        if ((re = ve.indexOf("-")) > 0)
          throw Error("interior hyphen");
        if (re === 0)
          return m(ve.substring(1), me, X).neg();
        for (var Me = o(u(X, 8)), ot = j, be = 0; be < ve.length; be += 8) {
          var Ue = Math.min(8, ve.length - be), Xe = parseInt(ve.substring(be, be + Ue), X);
          if (Ue < 8) {
            var lt = o(u(X, Ue));
            ot = ot.mul(lt).add(o(Xe));
          } else
            ot = ot.mul(Me), ot = ot.add(o(Xe));
        }
        return ot.unsigned = me, ot;
      }
      e.fromString = m;
      function y(ve) {
        return ve instanceof e ? ve : typeof ve == "number" ? o(ve) : typeof ve == "string" ? m(ve) : l(ve.low, ve.high, ve.unsigned);
      }
      e.fromValue = y;
      var E = 65536, P = 1 << 24, L = E * E, U = L * L, V = U / 2, q = s(P), j = s(0);
      e.ZERO = j;
      var K = s(0, !0);
      e.UZERO = K;
      var Y = s(1);
      e.ONE = Y;
      var de = s(1, !0);
      e.UONE = de;
      var ne = s(-1);
      e.NEG_ONE = ne;
      var ae = l(-1, 2147483647, !1);
      e.MAX_VALUE = ae;
      var De = l(-1, -1, !0);
      e.MAX_UNSIGNED_VALUE = De;
      var Ge = l(0, -2147483648, !1);
      e.MIN_VALUE = Ge;
      var fe = e.prototype;
      return fe.toInt = function() {
        return this.unsigned ? this.low >>> 0 : this.low;
      }, fe.toNumber = function() {
        return this.unsigned ? (this.high >>> 0) * L + (this.low >>> 0) : this.high * L + (this.low >>> 0);
      }, fe.toString = function(me) {
        if (me = me || 10, me < 2 || 36 < me)
          throw RangeError("radix");
        if (this.isZero())
          return "0";
        if (this.isNegative())
          if (this.eq(Ge)) {
            var X = o(me), re = this.div(X), Me = re.mul(X).sub(this);
            return re.toString(me) + Me.toInt().toString(me);
          } else
            return "-" + this.neg().toString(me);
        for (var ot = o(u(me, 6), this.unsigned), be = this, Ue = ""; ; ) {
          var Xe = be.div(ot), lt = be.sub(Xe.mul(ot)).toInt() >>> 0, at = lt.toString(me);
          if (be = Xe, be.isZero())
            return at + Ue;
          for (; at.length < 6; )
            at = "0" + at;
          Ue = "" + at + Ue;
        }
      }, fe.getHighBits = function() {
        return this.high;
      }, fe.getHighBitsUnsigned = function() {
        return this.high >>> 0;
      }, fe.getLowBits = function() {
        return this.low;
      }, fe.getLowBitsUnsigned = function() {
        return this.low >>> 0;
      }, fe.getNumBitsAbs = function() {
        if (this.isNegative())
          return this.eq(Ge) ? 64 : this.neg().getNumBitsAbs();
        for (var me = this.high != 0 ? this.high : this.low, X = 31; X > 0 && (me & 1 << X) == 0; X--)
          ;
        return this.high != 0 ? X + 33 : X + 1;
      }, fe.isZero = function() {
        return this.high === 0 && this.low === 0;
      }, fe.isNegative = function() {
        return !this.unsigned && this.high < 0;
      }, fe.isPositive = function() {
        return this.unsigned || this.high >= 0;
      }, fe.isOdd = function() {
        return (this.low & 1) === 1;
      }, fe.isEven = function() {
        return (this.low & 1) === 0;
      }, fe.equals = function(me) {
        return t(me) || (me = y(me)), this.unsigned !== me.unsigned && this.high >>> 31 === 1 && me.high >>> 31 === 1 ? !1 : this.high === me.high && this.low === me.low;
      }, fe.eq = fe.equals, fe.notEquals = function(me) {
        return !this.eq(
          /* validates */
          me
        );
      }, fe.neq = fe.notEquals, fe.lessThan = function(me) {
        return this.comp(
          /* validates */
          me
        ) < 0;
      }, fe.lt = fe.lessThan, fe.lessThanOrEqual = function(me) {
        return this.comp(
          /* validates */
          me
        ) <= 0;
      }, fe.lte = fe.lessThanOrEqual, fe.greaterThan = function(me) {
        return this.comp(
          /* validates */
          me
        ) > 0;
      }, fe.gt = fe.greaterThan, fe.greaterThanOrEqual = function(me) {
        return this.comp(
          /* validates */
          me
        ) >= 0;
      }, fe.gte = fe.greaterThanOrEqual, fe.compare = function(me) {
        if (t(me) || (me = y(me)), this.eq(me))
          return 0;
        var X = this.isNegative(), re = me.isNegative();
        return X && !re ? -1 : !X && re ? 1 : this.unsigned ? me.high >>> 0 > this.high >>> 0 || me.high === this.high && me.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(me).isNegative() ? -1 : 1;
      }, fe.comp = fe.compare, fe.negate = function() {
        return !this.unsigned && this.eq(Ge) ? Ge : this.not().add(Y);
      }, fe.neg = fe.negate, fe.add = function(me) {
        t(me) || (me = y(me));
        var X = this.high >>> 16, re = this.high & 65535, Me = this.low >>> 16, ot = this.low & 65535, be = me.high >>> 16, Ue = me.high & 65535, Xe = me.low >>> 16, lt = me.low & 65535, at = 0, ct = 0, gt = 0, St = 0;
        return St += ot + lt, gt += St >>> 16, St &= 65535, gt += Me + Xe, ct += gt >>> 16, gt &= 65535, ct += re + Ue, at += ct >>> 16, ct &= 65535, at += X + be, at &= 65535, l(gt << 16 | St, at << 16 | ct, this.unsigned);
      }, fe.subtract = function(me) {
        return t(me) || (me = y(me)), this.add(me.neg());
      }, fe.sub = fe.subtract, fe.multiply = function(me) {
        if (this.isZero() || (t(me) || (me = y(me)), me.isZero()))
          return j;
        if (this.eq(Ge))
          return me.isOdd() ? Ge : j;
        if (me.eq(Ge))
          return this.isOdd() ? Ge : j;
        if (this.isNegative())
          return me.isNegative() ? this.neg().mul(me.neg()) : this.neg().mul(me).neg();
        if (me.isNegative())
          return this.mul(me.neg()).neg();
        if (this.lt(q) && me.lt(q))
          return o(this.toNumber() * me.toNumber(), this.unsigned);
        var X = this.high >>> 16, re = this.high & 65535, Me = this.low >>> 16, ot = this.low & 65535, be = me.high >>> 16, Ue = me.high & 65535, Xe = me.low >>> 16, lt = me.low & 65535, at = 0, ct = 0, gt = 0, St = 0;
        return St += ot * lt, gt += St >>> 16, St &= 65535, gt += Me * lt, ct += gt >>> 16, gt &= 65535, gt += ot * Xe, ct += gt >>> 16, gt &= 65535, ct += re * lt, at += ct >>> 16, ct &= 65535, ct += Me * Xe, at += ct >>> 16, ct &= 65535, ct += ot * Ue, at += ct >>> 16, ct &= 65535, at += X * lt + re * Xe + Me * Ue + ot * be, at &= 65535, l(gt << 16 | St, at << 16 | ct, this.unsigned);
      }, fe.mul = fe.multiply, fe.divide = function(me) {
        if (t(me) || (me = y(me)), me.isZero())
          throw Error("division by zero");
        if (this.isZero())
          return this.unsigned ? K : j;
        var X, re, Me;
        if (this.unsigned) {
          if (me.unsigned || (me = me.toUnsigned()), me.gt(this))
            return K;
          if (me.gt(this.shru(1)))
            return de;
          Me = K;
        } else {
          if (this.eq(Ge)) {
            if (me.eq(Y) || me.eq(ne))
              return Ge;
            if (me.eq(Ge))
              return Y;
            var ot = this.shr(1);
            return X = ot.div(me).shl(1), X.eq(j) ? me.isNegative() ? Y : ne : (re = this.sub(me.mul(X)), Me = X.add(re.div(me)), Me);
          } else if (me.eq(Ge))
            return this.unsigned ? K : j;
          if (this.isNegative())
            return me.isNegative() ? this.neg().div(me.neg()) : this.neg().div(me).neg();
          if (me.isNegative())
            return this.div(me.neg()).neg();
          Me = j;
        }
        for (re = this; re.gte(me); ) {
          X = Math.max(1, Math.floor(re.toNumber() / me.toNumber()));
          for (var be = Math.ceil(Math.log(X) / Math.LN2), Ue = be <= 48 ? 1 : u(2, be - 48), Xe = o(X), lt = Xe.mul(me); lt.isNegative() || lt.gt(re); )
            X -= Ue, Xe = o(X, this.unsigned), lt = Xe.mul(me);
          Xe.isZero() && (Xe = Y), Me = Me.add(Xe), re = re.sub(lt);
        }
        return Me;
      }, fe.div = fe.divide, fe.modulo = function(me) {
        return t(me) || (me = y(me)), this.sub(this.div(me).mul(me));
      }, fe.mod = fe.modulo, fe.not = function() {
        return l(~this.low, ~this.high, this.unsigned);
      }, fe.and = function(me) {
        return t(me) || (me = y(me)), l(this.low & me.low, this.high & me.high, this.unsigned);
      }, fe.or = function(me) {
        return t(me) || (me = y(me)), l(this.low | me.low, this.high | me.high, this.unsigned);
      }, fe.xor = function(me) {
        return t(me) || (me = y(me)), l(this.low ^ me.low, this.high ^ me.high, this.unsigned);
      }, fe.shiftLeft = function(me) {
        return t(me) && (me = me.toInt()), (me &= 63) === 0 ? this : me < 32 ? l(this.low << me, this.high << me | this.low >>> 32 - me, this.unsigned) : l(0, this.low << me - 32, this.unsigned);
      }, fe.shl = fe.shiftLeft, fe.shiftRight = function(me) {
        return t(me) && (me = me.toInt()), (me &= 63) === 0 ? this : me < 32 ? l(this.low >>> me | this.high << 32 - me, this.high >> me, this.unsigned) : l(this.high >> me - 32, this.high >= 0 ? 0 : -1, this.unsigned);
      }, fe.shr = fe.shiftRight, fe.shiftRightUnsigned = function(me) {
        if (t(me) && (me = me.toInt()), me &= 63, me === 0)
          return this;
        var X = this.high;
        if (me < 32) {
          var re = this.low;
          return l(re >>> me | X << 32 - me, X >>> me, this.unsigned);
        } else return me === 32 ? l(X, 0, this.unsigned) : l(X >>> me - 32, 0, this.unsigned);
      }, fe.shru = fe.shiftRightUnsigned, fe.toSigned = function() {
        return this.unsigned ? l(this.low, this.high, !1) : this;
      }, fe.toUnsigned = function() {
        return this.unsigned ? this : l(this.low, this.high, !0);
      }, fe.toBytes = function(ve) {
        return ve ? this.toBytesLE() : this.toBytesBE();
      }, fe.toBytesLE = function() {
        var ve = this.high, me = this.low;
        return [
          me & 255,
          me >>> 8 & 255,
          me >>> 16 & 255,
          me >>> 24 & 255,
          ve & 255,
          ve >>> 8 & 255,
          ve >>> 16 & 255,
          ve >>> 24 & 255
        ];
      }, fe.toBytesBE = function() {
        var ve = this.high, me = this.low;
        return [
          ve >>> 24 & 255,
          ve >>> 16 & 255,
          ve >>> 8 & 255,
          ve & 255,
          me >>> 24 & 255,
          me >>> 16 & 255,
          me >>> 8 & 255,
          me & 255
        ];
      }, e;
    });
  })(km)), km.exports;
}
var _ue = mue();
const Fm = /* @__PURE__ */ dh(_ue), yue = 3, vue = 30, bue = 2 * vue + 1, hM = 180 / Math.PI;
function xue(r, e, t) {
  const n = 1 << e;
  return [(r[0] + t[0]) / n, (r[1] + t[1]) / n];
}
function dM(r) {
  return r >= 0.5 ? 1 / 3 * (4 * r * r - 1) : 1 / 3 * (1 - 4 * (1 - r) * (1 - r));
}
function wue(r) {
  return [dM(r[0]), dM(r[1])];
}
function Tue(r, [e, t]) {
  switch (r) {
    case 0:
      return [1, e, t];
    case 1:
      return [-e, 1, t];
    case 2:
      return [-e, -t, 1];
    case 3:
      return [-1, -t, -e];
    case 4:
      return [t, -1, -e];
    case 5:
      return [t, e, -1];
    default:
      throw new Error("Invalid face");
  }
}
function Eue([r, e, t]) {
  const n = Math.atan2(t, Math.sqrt(r * r + e * e));
  return [Math.atan2(e, r) * hM, n * hM];
}
function Cue(r) {
  let e = Fm.fromString(r, !0, 10).toString(2);
  for (; e.length < yue + bue; )
    e = "0" + e;
  const t = e.lastIndexOf("1"), n = e.substring(0, 3), i = e.substring(3, t), s = i.length / 2, o = Fm.fromString(n, !0, 2).toString(10);
  let l = Fm.fromString(i, !0, 2).toString(4);
  for (; l.length < s; )
    l = "0" + l;
  return `${o}/${l}`;
}
function Sue(r, e, t, n) {
  if (n === 0) {
    t === 1 && (e[0] = r - 1 - e[0], e[1] = r - 1 - e[1]);
    const i = e[0];
    e[0] = e[1], e[1] = i;
  }
}
function Iue(r) {
  const e = r.split("/"), t = parseInt(e[0], 10), n = e[1], i = n.length, s = [0, 0];
  let o;
  for (let l = i - 1; l >= 0; l--) {
    o = i - l;
    const u = n[l];
    let m = 0, y = 0;
    u === "1" ? y = 1 : u === "2" ? (m = 1, y = 1) : u === "3" && (m = 1);
    const E = Math.pow(2, o - 1);
    Sue(E, s, m, y), s[0] += E * m, s[1] += E * y;
  }
  if (t % 2 === 1) {
    const l = s[0];
    s[0] = s[1], s[1] = l;
  }
  return { face: t, ij: s, level: o };
}
function Pue(r) {
  const e = r.padEnd(16, "0");
  return Fm.fromString(e, 16);
}
const Mue = 100;
function Rue({ face: r, ij: e, level: t }) {
  const n = [
    [0, 0],
    [0, 1],
    [1, 1],
    [1, 0],
    [0, 0]
  ], i = Math.max(1, Math.ceil(Mue * Math.pow(2, -t))), s = new Float64Array(4 * i * 2 + 2);
  let o = 0, l = 0;
  for (let u = 0; u < 4; u++) {
    const m = n[u].slice(0), y = n[u + 1], E = (y[0] - m[0]) / i, P = (y[1] - m[1]) / i;
    for (let L = 0; L < i; L++) {
      m[0] += E, m[1] += P;
      const U = xue(e, t, m), V = wue(U), q = Tue(r, V), j = Eue(q);
      Math.abs(j[1]) > 89.999 && (j[0] = l);
      const K = j[0] - l;
      j[0] += K > 180 ? -360 : K < -180 ? 360 : 0, s[o++] = j[0], s[o++] = j[1], l = j[0];
    }
  }
  return s[o++] = s[0], s[o++] = s[1], s;
}
function Bue(r) {
  if (typeof r == "string") {
    if (r.indexOf("/") > 0)
      return r;
    r = Pue(r);
  }
  return Cue(r.toString());
}
function Oue(r) {
  const e = Bue(r), t = Iue(e);
  return Rue(t);
}
const Due = {
  getS2Token: { type: "accessor", value: (r) => r.token }
};
class cy extends su {
  indexToBounds() {
    const { data: e, getS2Token: t } = this.props;
    return {
      data: e,
      _normalize: !1,
      positionFormat: "XY",
      getPolygon: (n, i) => Oue(t(n, i))
    };
  }
}
cy.layerName = "S2Layer";
cy.defaultProps = Due;
const O1 = 512;
function Lue(r, e) {
  let t = 0, n = 0, i = 1 << r.length;
  const s = i / O1;
  for (let o = 0; o < r.length; o++) {
    i >>= 1;
    const l = parseInt(r[o]);
    l % 2 && (t |= i), l > 1 && (n |= i);
  }
  return [
    [t / s, O1 - n / s],
    [(t + e) / s, O1 - (n + e) / s]
  ];
}
function kue(r, e = 1) {
  const [t, n] = Lue(r, e), [i, s] = lc(t), [o, l] = lc(n);
  return [o, s, o, l, i, l, i, s, o, s];
}
const Fue = {
  getQuadkey: { type: "accessor", value: (r) => r.quadkey }
};
class uy extends su {
  indexToBounds() {
    const { data: e, extruded: t, getQuadkey: n } = this.props, i = t ? 0.99 : 1;
    return {
      data: e,
      _normalize: !1,
      positionFormat: "XY",
      getPolygon: (s, o) => kue(n(s, o), i),
      updateTriggers: { getPolygon: i }
    };
  }
}
uy.layerName = "QuadkeyLayer";
uy.defaultProps = Fue;
class nk {
  constructor(e) {
    this.index = e, this.isVisible = !1, this.isSelected = !1, this.parent = null, this.children = [], this.content = null, this._loader = void 0, this._abortController = null, this._loaderId = 0, this._isLoaded = !1, this._isCancelled = !1, this._needsReload = !1;
  }
  /** @deprecated use `boundingBox` instead */
  get bbox() {
    return this._bbox;
  }
  // TODO - remove in v9
  set bbox(e) {
    this._bbox || (this._bbox = e, "west" in e ? this.boundingBox = [
      [e.west, e.south],
      [e.east, e.north]
    ] : this.boundingBox = [
      [e.left, e.top],
      [e.right, e.bottom]
    ]);
  }
  get data() {
    return this.isLoading && this._loader ? this._loader.then(() => this.data) : this.content;
  }
  get isLoaded() {
    return this._isLoaded && !this._needsReload;
  }
  get isLoading() {
    return !!this._loader && !this._isCancelled;
  }
  get needsReload() {
    return this._needsReload || this._isCancelled;
  }
  get byteLength() {
    const e = this.content ? this.content.byteLength : 0;
    return Number.isFinite(e) || console.error("byteLength not defined in tile data"), e;
  }
  /* eslint-disable max-statements */
  async _loadData({ getData: e, requestScheduler: t, onLoad: n, onError: i }) {
    const { index: s, id: o, bbox: l, userData: u, zoom: m } = this, y = this._loaderId;
    this._abortController = new AbortController();
    const { signal: E } = this._abortController, P = await t.scheduleRequest(this, (V) => V.isSelected ? 1 : -1);
    if (!P) {
      this._isCancelled = !0;
      return;
    }
    if (this._isCancelled) {
      P.done();
      return;
    }
    let L = null, U;
    try {
      L = await e({ index: s, id: o, bbox: l, userData: u, zoom: m, signal: E });
    } catch (V) {
      U = V || !0;
    } finally {
      P.done();
    }
    if (y === this._loaderId) {
      if (this._loader = void 0, this.content = L, this._isCancelled && !L) {
        this._isLoaded = !1;
        return;
      }
      this._isLoaded = !0, this._isCancelled = !1, U ? i(U, this) : n(this);
    }
  }
  loadData(e) {
    return this._isLoaded = !1, this._isCancelled = !1, this._needsReload = !1, this._loaderId++, this._loader = this._loadData(e), this._loader;
  }
  setNeedsReload() {
    this.isLoading && (this.abort(), this._loader = void 0), this._needsReload = !0;
  }
  abort() {
    this.isLoaded || (this._isCancelled = !0, this._abortController?.abort());
  }
}
const mo = {
  OUTSIDE: -1,
  // Represents that an object is not contained within the frustum.
  INTERSECTING: 0,
  // Represents that an object intersects one of the frustum's planes.
  INSIDE: 1
  // Represents that an object is fully within the frustum.
}, pM = new yt(), Nue = new yt();
class Hw {
  /**
   * Creates an instance of an AxisAlignedBoundingBox from the minimum and maximum points along the x, y, and z axes.
   * @param minimum=[0, 0, 0] The minimum point along the x, y, and z axes.
   * @param maximum=[0, 0, 0] The maximum point along the x, y, and z axes.
   * @param center The center of the box; automatically computed if not supplied.
   */
  constructor(e = [0, 0, 0], t = [0, 0, 0], n) {
    n = n || pM.copy(e).add(t).scale(0.5), this.center = new yt(n), this.halfDiagonal = new yt(t).subtract(this.center), this.minimum = new yt(e), this.maximum = new yt(t);
  }
  /**
   * Duplicates a AxisAlignedBoundingBox instance.
   *
   * @returns {AxisAlignedBoundingBox} A new AxisAlignedBoundingBox instance.
   */
  clone() {
    return new Hw(this.minimum, this.maximum, this.center);
  }
  /**
   * Compares the provided AxisAlignedBoundingBox componentwise and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   *
   * @param {AxisAlignedBoundingBox} [right] The second AxisAlignedBoundingBox to compare with.
   * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(e) {
    return this === e || !!e && this.minimum.equals(e.minimum) && this.maximum.equals(e.maximum);
  }
  /**
   * Applies a 4x4 affine transformation matrix to a bounding sphere.
   * @param transform The transformation matrix to apply to the bounding sphere.
   * @returns itself, i.e. the modified BoundingVolume.
   */
  transform(e) {
    return this.center.transformAsPoint(e), this.halfDiagonal.transform(e), this.minimum.transform(e), this.maximum.transform(e), this;
  }
  /**
   * Determines which side of a plane a box is located.
   */
  intersectPlane(e) {
    const { halfDiagonal: t } = this, n = Nue.from(e.normal), i = t.x * Math.abs(n.x) + t.y * Math.abs(n.y) + t.z * Math.abs(n.z), s = this.center.dot(n) + e.distance;
    return s - i > 0 ? mo.INSIDE : s + i < 0 ? mo.OUTSIDE : mo.INTERSECTING;
  }
  /** Computes the estimated distance from the closest point on a bounding box to a point. */
  distanceTo(e) {
    return Math.sqrt(this.distanceSquaredTo(e));
  }
  /** Computes the estimated distance squared from the closest point on a bounding box to a point. */
  distanceSquaredTo(e) {
    const t = pM.from(e).subtract(this.center), { halfDiagonal: n } = this;
    let i = 0, s;
    return s = Math.abs(t.x) - n.x, s > 0 && (i += s * s), s = Math.abs(t.y) - n.y, s > 0 && (i += s * s), s = Math.abs(t.z) - n.z, s > 0 && (i += s * s), i;
  }
}
const wA = new yt(), AM = new yt();
class S0 {
  /** Creates a bounding sphere */
  constructor(e = [0, 0, 0], t = 0) {
    this.radius = -0, this.center = new yt(), this.fromCenterRadius(e, t);
  }
  /** Sets the bounding sphere from `center` and `radius`. */
  fromCenterRadius(e, t) {
    return this.center.from(e), this.radius = t, this;
  }
  /**
   * Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere
   * tightly and fully encompasses the box.
   */
  fromCornerPoints(e, t) {
    return t = wA.from(t), this.center = new yt().from(e).add(t).scale(0.5), this.radius = this.center.distance(t), this;
  }
  /** Compares the provided BoundingSphere component wise */
  equals(e) {
    return this === e || !!e && this.center.equals(e.center) && this.radius === e.radius;
  }
  /** Duplicates a BoundingSphere instance. */
  clone() {
    return new S0(this.center, this.radius);
  }
  /** Computes a bounding sphere that contains both the left and right bounding spheres. */
  union(e) {
    const t = this.center, n = this.radius, i = e.center, s = e.radius, o = wA.copy(i).subtract(t), l = o.magnitude();
    if (n >= l + s)
      return this.clone();
    if (s >= l + n)
      return e.clone();
    const u = (n + l + s) * 0.5;
    return AM.copy(o).scale((-n + u) / l).add(t), this.center.copy(AM), this.radius = u, this;
  }
  /** Computes a bounding sphere by enlarging the provided sphere to contain the provided point. */
  expand(e) {
    const n = wA.from(e).subtract(this.center).magnitude();
    return n > this.radius && (this.radius = n), this;
  }
  // BoundingVolume interface
  /**
   * Applies a 4x4 affine transformation matrix to a bounding sphere.
   * @param sphere The bounding sphere to apply the transformation to.
   * @param transform The transformation matrix to apply to the bounding sphere.
   * @returns self.
   */
  transform(e) {
    this.center.transform(e);
    const t = OV(wA, e);
    return this.radius = Math.max(t[0], Math.max(t[1], t[2])) * this.radius, this;
  }
  /** Computes the estimated distance squared from the closest point on a bounding sphere to a point. */
  distanceSquaredTo(e) {
    const t = this.distanceTo(e);
    return t * t;
  }
  /** Computes the estimated distance from the closest point on a bounding sphere to a point. */
  distanceTo(e) {
    const n = wA.from(e).subtract(this.center);
    return Math.max(0, n.len() - this.radius);
  }
  /** Determines which side of a plane a sphere is located. */
  intersectPlane(e) {
    const t = this.center, n = this.radius, s = e.normal.dot(t) + e.distance;
    return s < -n ? mo.OUTSIDE : s < n ? mo.INTERSECTING : mo.INSIDE;
  }
}
const Uue = new yt(), zue = new yt(), Kg = new yt(), Qg = new yt(), Jg = new yt(), Vue = new yt(), jue = new yt(), zc = {
  COLUMN0ROW0: 0,
  COLUMN0ROW1: 1,
  COLUMN0ROW2: 2,
  COLUMN1ROW0: 3,
  COLUMN1ROW1: 4,
  COLUMN1ROW2: 5,
  COLUMN2ROW0: 6,
  COLUMN2ROW1: 7,
  COLUMN2ROW2: 8
};
class I0 {
  constructor(e = [0, 0, 0], t = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {
    this.center = new yt().from(e), this.halfAxes = new es(t);
  }
  /** Returns an array with three halfSizes for the bounding box */
  get halfSize() {
    const e = this.halfAxes.getColumn(0), t = this.halfAxes.getColumn(1), n = this.halfAxes.getColumn(2);
    return [new yt(e).len(), new yt(t).len(), new yt(n).len()];
  }
  /** Returns a quaternion describing the orientation of the bounding box */
  get quaternion() {
    const e = this.halfAxes.getColumn(0), t = this.halfAxes.getColumn(1), n = this.halfAxes.getColumn(2), i = new yt(e).normalize(), s = new yt(t).normalize(), o = new yt(n).normalize();
    return new r0().fromMatrix3(new es([...i, ...s, ...o]));
  }
  /**
   * Create OrientedBoundingBox from quaternion based OBB,
   */
  fromCenterHalfSizeQuaternion(e, t, n) {
    const i = new r0(n), s = new es().fromQuaternion(i);
    return s[0] = s[0] * t[0], s[1] = s[1] * t[0], s[2] = s[2] * t[0], s[3] = s[3] * t[1], s[4] = s[4] * t[1], s[5] = s[5] * t[1], s[6] = s[6] * t[2], s[7] = s[7] * t[2], s[8] = s[8] * t[2], this.center = new yt().from(e), this.halfAxes = s, this;
  }
  /** Duplicates a OrientedBoundingBox instance. */
  clone() {
    return new I0(this.center, this.halfAxes);
  }
  /** Compares the provided OrientedBoundingBox component wise and returns */
  equals(e) {
    return this === e || !!e && this.center.equals(e.center) && this.halfAxes.equals(e.halfAxes);
  }
  /** Computes a tight-fitting bounding sphere enclosing the provided oriented bounding box. */
  getBoundingSphere(e = new S0()) {
    const t = this.halfAxes, n = t.getColumn(0, Kg), i = t.getColumn(1, Qg), s = t.getColumn(2, Jg), o = Uue.copy(n).add(i).add(s);
    return e.center.copy(this.center), e.radius = o.magnitude(), e;
  }
  /** Determines which side of a plane the oriented bounding box is located. */
  intersectPlane(e) {
    const t = this.center, n = e.normal, i = this.halfAxes, s = n.x, o = n.y, l = n.z, u = Math.abs(s * i[zc.COLUMN0ROW0] + o * i[zc.COLUMN0ROW1] + l * i[zc.COLUMN0ROW2]) + Math.abs(s * i[zc.COLUMN1ROW0] + o * i[zc.COLUMN1ROW1] + l * i[zc.COLUMN1ROW2]) + Math.abs(s * i[zc.COLUMN2ROW0] + o * i[zc.COLUMN2ROW1] + l * i[zc.COLUMN2ROW2]), m = n.dot(t) + e.distance;
    return m <= -u ? mo.OUTSIDE : m >= u ? mo.INSIDE : mo.INTERSECTING;
  }
  /** Computes the estimated distance from the closest point on a bounding box to a point. */
  distanceTo(e) {
    return Math.sqrt(this.distanceSquaredTo(e));
  }
  /**
   * Computes the estimated distance squared from the closest point
   * on a bounding box to a point.
   * See Geometric Tools for Computer Graphics 10.4.2
   */
  distanceSquaredTo(e) {
    const t = zue.from(e).subtract(this.center), n = this.halfAxes, i = n.getColumn(0, Kg), s = n.getColumn(1, Qg), o = n.getColumn(2, Jg), l = i.magnitude(), u = s.magnitude(), m = o.magnitude();
    i.normalize(), s.normalize(), o.normalize();
    let y = 0, E;
    return E = Math.abs(t.dot(i)) - l, E > 0 && (y += E * E), E = Math.abs(t.dot(s)) - u, E > 0 && (y += E * E), E = Math.abs(t.dot(o)) - m, E > 0 && (y += E * E), y;
  }
  /**
   * The distances calculated by the vector from the center of the bounding box
   * to position projected onto direction.
   *
   * - If you imagine the infinite number of planes with normal direction,
   *   this computes the smallest distance to the closest and farthest planes
   *   from `position` that intersect the bounding box.
   *
   * @param position The position to calculate the distance from.
   * @param direction The direction from position.
   * @param result An Interval (array of length 2) to store the nearest and farthest distances.
   * @returns Interval (array of length 2) with nearest and farthest distances
   *   on the bounding box from position in direction.
   */
  // eslint-disable-next-line max-statements
  computePlaneDistances(e, t, n = [-0, -0]) {
    let i = Number.POSITIVE_INFINITY, s = Number.NEGATIVE_INFINITY;
    const o = this.center, l = this.halfAxes, u = l.getColumn(0, Kg), m = l.getColumn(1, Qg), y = l.getColumn(2, Jg), E = Vue.copy(u).add(m).add(y).add(o), P = jue.copy(E).subtract(e);
    let L = t.dot(P);
    return i = Math.min(L, i), s = Math.max(L, s), E.copy(o).add(u).add(m).subtract(y), P.copy(E).subtract(e), L = t.dot(P), i = Math.min(L, i), s = Math.max(L, s), E.copy(o).add(u).subtract(m).add(y), P.copy(E).subtract(e), L = t.dot(P), i = Math.min(L, i), s = Math.max(L, s), E.copy(o).add(u).subtract(m).subtract(y), P.copy(E).subtract(e), L = t.dot(P), i = Math.min(L, i), s = Math.max(L, s), o.copy(E).subtract(u).add(m).add(y), P.copy(E).subtract(e), L = t.dot(P), i = Math.min(L, i), s = Math.max(L, s), o.copy(E).subtract(u).add(m).subtract(y), P.copy(E).subtract(e), L = t.dot(P), i = Math.min(L, i), s = Math.max(L, s), o.copy(E).subtract(u).subtract(m).add(y), P.copy(E).subtract(e), L = t.dot(P), i = Math.min(L, i), s = Math.max(L, s), o.copy(E).subtract(u).subtract(m).subtract(y), P.copy(E).subtract(e), L = t.dot(P), i = Math.min(L, i), s = Math.max(L, s), n[0] = i, n[1] = s, n;
  }
  /**
   * Applies a 4x4 affine transformation matrix to a bounding sphere.
   * @param transform The transformation matrix to apply to the bounding sphere.
   * @returns itself, i.e. the modified BoundingVolume.
   */
  transform(e) {
    this.center.transformAsPoint(e);
    const t = this.halfAxes.getColumn(0, Kg);
    t.transformAsPoint(e);
    const n = this.halfAxes.getColumn(1, Qg);
    n.transformAsPoint(e);
    const i = this.halfAxes.getColumn(2, Jg);
    return i.transformAsPoint(e), this.halfAxes = new es([...t, ...n, ...i]), this;
  }
  getTransform() {
    throw new Error("not implemented");
  }
}
const gM = new yt(), mM = new yt();
class ul {
  constructor(e = [0, 0, 1], t = 0) {
    this.normal = new yt(), this.distance = -0, this.fromNormalDistance(e, t);
  }
  /** Creates a plane from a normal and a distance from the origin. */
  fromNormalDistance(e, t) {
    return fl(Number.isFinite(t)), this.normal.from(e).normalize(), this.distance = t, this;
  }
  /** Creates a plane from a normal and a point on the plane. */
  fromPointNormal(e, t) {
    e = gM.from(e), this.normal.from(t).normalize();
    const n = -this.normal.dot(e);
    return this.distance = n, this;
  }
  /** Creates a plane from the general equation */
  fromCoefficients(e, t, n, i) {
    return this.normal.set(e, t, n), fl(Aa(this.normal.len(), 1)), this.distance = i, this;
  }
  /** Duplicates a Plane instance. */
  clone() {
    return new ul(this.normal, this.distance);
  }
  /** Compares the provided Planes by normal and distance */
  equals(e) {
    return Aa(this.distance, e.distance) && Aa(this.normal, e.normal);
  }
  /** Computes the signed shortest distance of a point to a plane.
   * The sign of the distance determines which side of the plane the point is on.
   */
  getPointDistance(e) {
    return this.normal.dot(e) + this.distance;
  }
  /** Transforms the plane by the given transformation matrix. */
  transform(e) {
    const t = mM.copy(this.normal).transformAsVector(e).normalize(), n = this.normal.scale(-this.distance).transform(e);
    return this.fromPointNormal(n, t);
  }
  projectPointOntoPlane(e, t = [0, 0, 0]) {
    const n = gM.from(e), i = this.getPointDistance(n), s = mM.copy(this.normal).scale(i);
    return n.subtract(s).to(t);
  }
}
const _M = [new yt([1, 0, 0]), new yt([0, 1, 0]), new yt([0, 0, 1])], yM = new yt(), Hue = new yt();
class pa {
  /**
   * Create a new `CullingVolume` bounded by an array of clipping planed
   * @param planes Array of clipping planes.
   * */
  constructor(e = []) {
    this.planes = e;
  }
  /**
   * Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.
   * The planes are aligned to the x, y, and z axes in world coordinates.
   */
  fromBoundingSphere(e) {
    this.planes.length = 2 * _M.length;
    const t = e.center, n = e.radius;
    let i = 0;
    for (const s of _M) {
      let o = this.planes[i], l = this.planes[i + 1];
      o || (o = this.planes[i] = new ul()), l || (l = this.planes[i + 1] = new ul());
      const u = yM.copy(s).scale(-n).add(t);
      o.fromPointNormal(u, s);
      const m = yM.copy(s).scale(n).add(t), y = Hue.copy(s).negate();
      l.fromPointNormal(m, y), i += 2;
    }
    return this;
  }
  /** Determines whether a bounding volume intersects the culling volume. */
  computeVisibility(e) {
    let t = mo.INSIDE;
    for (const n of this.planes)
      switch (e.intersectPlane(n)) {
        case mo.OUTSIDE:
          return mo.OUTSIDE;
        case mo.INTERSECTING:
          t = mo.INTERSECTING;
          break;
      }
    return t;
  }
  /**
   * Determines whether a bounding volume intersects the culling volume.
   *
   * @param parentPlaneMask A bit mask from the boundingVolume's parent's check against the same culling
   *   volume, such that if (planeMask & (1 << planeIndex) === 0), for k < 31, then
   *   the parent (and therefore this) volume is completely inside plane[planeIndex]
   *   and that plane check can be skipped.
   */
  computeVisibilityWithPlaneMask(e, t) {
    if (fl(Number.isFinite(t), "parentPlaneMask is required."), t === pa.MASK_OUTSIDE || t === pa.MASK_INSIDE)
      return t;
    let n = pa.MASK_INSIDE;
    const i = this.planes;
    for (let s = 0; s < this.planes.length; ++s) {
      const o = s < 31 ? 1 << s : 0;
      if (s < 31 && (t & o) === 0)
        continue;
      const l = i[s], u = e.intersectPlane(l);
      if (u === mo.OUTSIDE)
        return pa.MASK_OUTSIDE;
      u === mo.INTERSECTING && (n |= o);
    }
    return n;
  }
}
pa.MASK_OUTSIDE = 4294967295;
pa.MASK_INSIDE = 0;
pa.MASK_INDETERMINATE = 2147483647;
new yt();
new yt();
new yt();
new yt();
new yt();
new yt();
new yt();
new yt();
new yt();
new yt();
new yt();
new yt();
new yt();
new yt();
new yt();
new yt();
new yt();
const Ql = new es(), Gue = new es(), Wue = new es(), em = new es(), vM = new es();
function $ue(r, e = {}) {
  const t = _j, n = 10;
  let i = 0, s = 0;
  const o = Gue, l = Wue;
  o.identity(), l.copy(r);
  const u = t * que(l);
  for (; s < n && Xue(l) > u; )
    Zue(l, em), vM.copy(em).transpose(), l.multiplyRight(em), l.multiplyLeft(vM), o.multiplyRight(em), ++i > 2 && (++s, i = 0);
  return e.unitary = o.toTarget(e.unitary), e.diagonal = l.toTarget(e.diagonal), e;
}
function que(r) {
  let e = 0;
  for (let t = 0; t < 9; ++t) {
    const n = r[t];
    e += n * n;
  }
  return Math.sqrt(e);
}
const P2 = [1, 0, 0], M2 = [2, 2, 1];
function Xue(r) {
  let e = 0;
  for (let t = 0; t < 3; ++t) {
    const n = r[Ql.getElementIndex(M2[t], P2[t])];
    e += 2 * n * n;
  }
  return Math.sqrt(e);
}
function Zue(r, e) {
  const t = RO;
  let n = 0, i = 1;
  for (let m = 0; m < 3; ++m) {
    const y = Math.abs(r[Ql.getElementIndex(M2[m], P2[m])]);
    y > n && (i = m, n = y);
  }
  const s = P2[i], o = M2[i];
  let l = 1, u = 0;
  if (Math.abs(r[Ql.getElementIndex(o, s)]) > t) {
    const m = r[Ql.getElementIndex(o, o)], y = r[Ql.getElementIndex(s, s)], E = r[Ql.getElementIndex(o, s)], P = (m - y) / 2 / E;
    let L;
    P < 0 ? L = -1 / (-P + Math.sqrt(1 + P * P)) : L = 1 / (P + Math.sqrt(1 + P * P)), l = 1 / Math.sqrt(1 + L * L), u = L * l;
  }
  return es.IDENTITY.to(e), e[Ql.getElementIndex(s, s)] = e[Ql.getElementIndex(o, o)] = l, e[Ql.getElementIndex(o, s)] = u, e[Ql.getElementIndex(s, o)] = -u, e;
}
const Fu = new yt(), Yue = new yt(), Kue = new yt(), Que = new yt(), Jue = new yt(), efe = new es(), tfe = {
  diagonal: new es(),
  unitary: new es()
};
function ik(r, e = new I0()) {
  if (!r || r.length === 0)
    return e.halfAxes = new es([0, 0, 0, 0, 0, 0, 0, 0, 0]), e.center = new yt(), e;
  const t = r.length, n = new yt(0, 0, 0);
  for (const fe of r)
    n.add(fe);
  const i = 1 / t;
  n.multiplyByScalar(i);
  let s = 0, o = 0, l = 0, u = 0, m = 0, y = 0;
  for (const fe of r) {
    const ve = Fu.copy(fe).subtract(n);
    s += ve.x * ve.x, o += ve.x * ve.y, l += ve.x * ve.z, u += ve.y * ve.y, m += ve.y * ve.z, y += ve.z * ve.z;
  }
  s *= i, o *= i, l *= i, u *= i, m *= i, y *= i;
  const E = efe;
  E[0] = s, E[1] = o, E[2] = l, E[3] = o, E[4] = u, E[5] = m, E[6] = l, E[7] = m, E[8] = y;
  const { unitary: P } = $ue(E, tfe), L = e.halfAxes.copy(P);
  let U = L.getColumn(0, Kue), V = L.getColumn(1, Que), q = L.getColumn(2, Jue), j = -Number.MAX_VALUE, K = -Number.MAX_VALUE, Y = -Number.MAX_VALUE, de = Number.MAX_VALUE, ne = Number.MAX_VALUE, ae = Number.MAX_VALUE;
  for (const fe of r)
    Fu.copy(fe), j = Math.max(Fu.dot(U), j), K = Math.max(Fu.dot(V), K), Y = Math.max(Fu.dot(q), Y), de = Math.min(Fu.dot(U), de), ne = Math.min(Fu.dot(V), ne), ae = Math.min(Fu.dot(q), ae);
  U = U.multiplyByScalar(0.5 * (de + j)), V = V.multiplyByScalar(0.5 * (ne + K)), q = q.multiplyByScalar(0.5 * (ae + Y)), e.center.copy(U).add(V).add(q);
  const De = Yue.set(j - de, K - ne, Y - ae).multiplyByScalar(0.5), Ge = new es([De[0], 0, 0, 0, De[1], 0, 0, 0, De[2]]);
  return e.halfAxes.multiplyRight(Ge), e;
}
const ep = 512, bM = 3, sk = [
  [0.5, 0.5],
  [0, 0],
  [0, 1],
  [1, 0],
  [1, 1]
], ok = sk.concat([
  [0, 0.5],
  [0.5, 0],
  [1, 0.5],
  [0.5, 1]
]), rfe = ok.concat([
  [0.25, 0.5],
  [0.75, 0.5]
]);
class tp {
  constructor(e, t, n) {
    this.x = e, this.y = t, this.z = n;
  }
  get children() {
    if (!this._children) {
      const e = this.x * 2, t = this.y * 2, n = this.z + 1;
      this._children = [
        new tp(e, t, n),
        new tp(e, t + 1, n),
        new tp(e + 1, t, n),
        new tp(e + 1, t + 1, n)
      ];
    }
    return this._children;
  }
  // eslint-disable-next-line complexity
  update(e) {
    const { viewport: t, cullingVolume: n, elevationBounds: i, minZ: s, maxZ: o, bounds: l, offset: u, project: m } = e, y = this.getBoundingVolume(i, u, m);
    if (l && !this.insideBounds(l) || n.computeVisibility(y) < 0)
      return !1;
    if (!this.childVisible) {
      let { z: P } = this;
      if (P < o && P >= s) {
        const L = y.distanceTo(t.cameraPosition) * t.scale / t.height;
        P += Math.floor(Math.log2(L));
      }
      if (P >= o)
        return this.selected = !0, !0;
    }
    this.selected = !1, this.childVisible = !0;
    for (const P of this.children)
      P.update(e);
    return !0;
  }
  getSelected(e = []) {
    if (this.selected && e.push(this), this._children)
      for (const t of this._children)
        t.getSelected(e);
    return e;
  }
  insideBounds([e, t, n, i]) {
    const s = Math.pow(2, this.z), o = ep / s;
    return this.x * o < n && this.y * o < i && (this.x + 1) * o > e && (this.y + 1) * o > t;
  }
  getBoundingVolume(e, t, n) {
    if (n) {
      const u = this.z < 1 ? rfe : this.z < 2 ? ok : sk, m = [];
      for (const y of u) {
        const E = B2(this.x + y[0], this.y + y[1], this.z);
        E[2] = e[0], m.push(n(E)), e[0] !== e[1] && (E[2] = e[1], m.push(n(E)));
      }
      return ik(m);
    }
    const i = Math.pow(2, this.z), s = ep / i, o = this.x * s + t * ep, l = ep - (this.y + 1) * s;
    return new Hw([o, l, e[0]], [o + s, l + s, e[1]]);
  }
}
function nfe(r, e, t, n) {
  const i = r instanceof GZ && r.resolution ? (
    // eslint-disable-next-line @typescript-eslint/unbound-method
    r.projectPosition
  ) : null, s = Object.values(r.getFrustumPlanes()).map(({ normal: L, distance: U }) => new ul(L.clone().negate(), U)), o = new pa(s), l = r.distanceScales.unitsPerMeter[2], u = t && t[0] * l || 0, m = t && t[1] * l || 0, y = r instanceof s0 && r.pitch <= 60 ? e : 0;
  if (n) {
    const [L, U, V, q] = n, j = Jc([L, q]), K = Jc([V, U]);
    n = [j[0], ep - j[1], K[0], ep - K[1]];
  }
  const E = new tp(0, 0, 0), P = {
    viewport: r,
    project: i,
    cullingVolume: o,
    elevationBounds: [u, m],
    minZ: y,
    maxZ: e,
    bounds: n,
    // num. of worlds from the center. For repeated maps
    offset: 0
  };
  if (E.update(P), r instanceof s0 && r.subViewports && r.subViewports.length > 1) {
    for (P.offset = -1; E.update(P) && !(--P.offset < -bM); )
      ;
    for (P.offset = 1; E.update(P) && !(++P.offset > bM); )
      ;
  }
  return E.getSelected();
}
const eu = 512, ife = [-1 / 0, -1 / 0, 1 / 0, 1 / 0], x_ = {
  type: "object",
  value: null,
  validate: (r, e) => e.optional && r === null || typeof r == "string" || Array.isArray(r) && r.every((t) => typeof t == "string"),
  equal: (r, e) => {
    if (r === e)
      return !0;
    if (!Array.isArray(r) || !Array.isArray(e))
      return !1;
    const t = r.length;
    if (t !== e.length)
      return !1;
    for (let n = 0; n < t; n++)
      if (r[n] !== e[n])
        return !1;
    return !0;
  }
};
function Gw(r, e) {
  const t = [
    // top-left
    e.transformAsPoint([r[0], r[1]]),
    // top-right
    e.transformAsPoint([r[2], r[1]]),
    // bottom-left
    e.transformAsPoint([r[0], r[3]]),
    // bottom-right
    e.transformAsPoint([r[2], r[3]])
  ];
  return [
    // Minimum x coord
    Math.min(...t.map((i) => i[0])),
    // Minimum y coord
    Math.min(...t.map((i) => i[1])),
    // Max x coord
    Math.max(...t.map((i) => i[0])),
    // Max y coord
    Math.max(...t.map((i) => i[1]))
  ];
}
function sfe(r) {
  return Math.abs(r.split("").reduce((e, t) => (e << 5) - e + t.charCodeAt(0) | 0, 0));
}
function ch(r, e) {
  if (!r || !r.length)
    return null;
  const { index: t, id: n } = e;
  if (Array.isArray(r)) {
    const s = sfe(n) % r.length;
    r = r[s];
  }
  let i = r;
  for (const s of Object.keys(t)) {
    const o = new RegExp(`{${s}}`, "g");
    i = i.replace(o, String(t[s]));
  }
  return Number.isInteger(t.y) && Number.isInteger(t.z) && (i = i.replace(/\{-y\}/g, String(Math.pow(2, t.z) - t.y - 1))), i;
}
function ofe(r, e, t) {
  let n;
  return n = r.getBounds(), r.isGeospatial ? [
    Math.max(n[0], t[0]),
    Math.max(n[1], t[1]),
    Math.min(n[2], t[2]),
    Math.min(n[3], t[3])
  ] : [
    // Top corner should not be more then bottom corner in either direction
    Math.max(Math.min(n[0], t[2]), t[0]),
    Math.max(Math.min(n[1], t[3]), t[1]),
    // Bottom corner should not be less then top corner in either direction
    Math.min(Math.max(n[2], t[0]), t[2]),
    Math.min(Math.max(n[3], t[1]), t[3])
  ];
}
function afe({ viewport: r, z: e, cullRect: t }) {
  return (r.subViewports || [r]).map((i) => R2(i, e || 0, t));
}
function R2(r, e, t) {
  if (!Array.isArray(e)) {
    const s = t.x - r.x, o = t.y - r.y, { width: l, height: u } = t, m = { targetZ: e }, y = r.unproject([s, o], m), E = r.unproject([s + l, o], m), P = r.unproject([s, o + u], m), L = r.unproject([s + l, o + u], m);
    return [
      Math.min(y[0], E[0], P[0], L[0]),
      Math.min(y[1], E[1], P[1], L[1]),
      Math.max(y[0], E[0], P[0], L[0]),
      Math.max(y[1], E[1], P[1], L[1])
    ];
  }
  const n = R2(r, e[0], t), i = R2(r, e[1], t);
  return [
    Math.min(n[0], i[0]),
    Math.min(n[1], i[1]),
    Math.max(n[2], i[2]),
    Math.max(n[3], i[3])
  ];
}
function lfe(r, e, t) {
  return t ? Gw(r, t).map((i) => i * e / eu) : r.map((n) => n * e / eu);
}
function Ww(r, e) {
  return Math.pow(2, r) * eu / e;
}
function B2(r, e, t) {
  const n = Ww(t, eu), i = r / n * 360 - 180, s = Math.PI - 2 * Math.PI * e / n, o = 180 / Math.PI * Math.atan(0.5 * (Math.exp(s) - Math.exp(-s)));
  return [i, o];
}
function xM(r, e, t, n) {
  const i = Ww(t, n);
  return [r / i * eu, e / i * eu];
}
function cfe(r, e, t, n, i = eu) {
  if (r.isGeospatial) {
    const [m, y] = B2(e, t, n), [E, P] = B2(e + 1, t + 1, n);
    return { west: m, north: y, east: E, south: P };
  }
  const [s, o] = xM(e, t, n, i), [l, u] = xM(e + 1, t + 1, n, i);
  return { left: s, top: o, right: l, bottom: u };
}
function ufe(r, e, t, n, i) {
  const s = ofe(r, null, n), o = Ww(e, t), [l, u, m, y] = lfe(s, o, i), E = [];
  for (let P = Math.floor(l); P < m; P++)
    for (let L = Math.floor(u); L < y; L++)
      E.push({ x: P, y: L, z: e });
  return E;
}
function ffe({ viewport: r, maxZoom: e, minZoom: t, zRange: n, extent: i, tileSize: s = eu, modelMatrix: o, modelMatrixInverse: l, zoomOffset: u = 0 }) {
  let m = r.isGeospatial ? Math.round(r.zoom + Math.log2(eu / s)) + u : Math.ceil(r.zoom) + u;
  if (typeof t == "number" && Number.isFinite(t) && m < t) {
    if (!i)
      return [];
    m = t;
  }
  typeof e == "number" && Number.isFinite(e) && m > e && (m = e);
  let y = i;
  return o && l && i && !r.isGeospatial && (y = Gw(i, o)), r.isGeospatial ? nfe(r, m, n, i) : ufe(r, m, s, y || ife, l);
}
function hfe(r) {
  return /(?=.*{z})(?=.*{x})(?=.*({y}|{-y}))/.test(r);
}
function dfe(r) {
  return Number.isFinite(r.west) && Number.isFinite(r.north) && Number.isFinite(r.east) && Number.isFinite(r.south);
}
function pfe(r) {
  let e = {}, t;
  return (n) => {
    for (const i in n)
      if (!Afe(n[i], e[i])) {
        t = r(n), e = n;
        break;
      }
    return t;
  };
}
function Afe(r, e) {
  if (r === e)
    return !0;
  if (Array.isArray(r)) {
    const t = r.length;
    if (!e || e.length !== t)
      return !1;
    for (let n = 0; n < t; n++)
      if (r[n] !== e[n])
        return !1;
    return !0;
  }
  return !1;
}
const wM = 1, fy = 2, gfe = "never", mfe = "no-overlap", $w = "best-available", _fe = 5, yfe = {
  [$w]: bfe,
  [mfe]: xfe,
  [gfe]: () => {
  }
}, vfe = {
  extent: null,
  tileSize: 512,
  maxZoom: null,
  minZoom: null,
  maxCacheSize: null,
  maxCacheByteSize: null,
  refinementStrategy: "best-available",
  zRange: null,
  maxRequests: 6,
  debounceTime: 0,
  zoomOffset: 0,
  // onTileLoad: (tile: Tile2DHeader) => void,  // onTileUnload: (tile: Tile2DHeader) => void,  // onTileError: (error: any, tile: Tile2DHeader) => void,  /** Called when all tiles in the current viewport are loaded. */
  // onViewportLoad: ((tiles: Tile2DHeader<DataT>[]) => void) | null,
  onTileLoad: () => {
  },
  onTileUnload: () => {
  },
  onTileError: () => {
  }
};
class hy {
  /**
   * Takes in a function that returns tile data, a cache size, and a max and a min zoom level.
   * Cache size defaults to 5 * number of tiles in the current viewport
   */
  constructor(e) {
    this._getCullBounds = pfe(afe), this.opts = { ...vfe, ...e }, this.setOptions(this.opts), this.onTileLoad = (t) => {
      this.opts.onTileLoad?.(t), this.opts.maxCacheByteSize !== null && (this._cacheByteSize += t.byteLength, this._resizeCache());
    }, this._requestScheduler = new aB({
      throttleRequests: this.opts.maxRequests > 0 || this.opts.debounceTime > 0,
      maxRequests: this.opts.maxRequests,
      debounceTime: this.opts.debounceTime
    }), this._cache = /* @__PURE__ */ new Map(), this._tiles = [], this._dirty = !1, this._cacheByteSize = 0, this._viewport = null, this._zRange = null, this._selectedTiles = null, this._frameNumber = 0, this._modelMatrix = new xn(), this._modelMatrixInverse = new xn();
  }
  /* Public API */
  get tiles() {
    return this._tiles;
  }
  get selectedTiles() {
    return this._selectedTiles;
  }
  get isLoaded() {
    return this._selectedTiles !== null && this._selectedTiles.every((e) => e.isLoaded);
  }
  get needsReload() {
    return this._selectedTiles !== null && this._selectedTiles.some((e) => e.needsReload);
  }
  setOptions(e) {
    Object.assign(this.opts, e), Number.isFinite(e.maxZoom) && (this._maxZoom = Math.floor(e.maxZoom)), Number.isFinite(e.minZoom) && (this._minZoom = Math.ceil(e.minZoom));
  }
  // Clean up any outstanding tile requests.
  finalize() {
    for (const e of this._cache.values())
      e.isLoading && e.abort();
    this._cache.clear(), this._tiles = [], this._selectedTiles = null;
  }
  reloadAll() {
    for (const e of this._cache.keys()) {
      const t = this._cache.get(e);
      !this._selectedTiles || !this._selectedTiles.includes(t) ? this._cache.delete(e) : t.setNeedsReload();
    }
  }
  /**
   * Update the cache with the given viewport and model matrix and triggers callback onUpdate.
   */
  update(e, { zRange: t, modelMatrix: n } = {
    zRange: null,
    modelMatrix: null
  }) {
    const i = n ? new xn(n) : new xn(), s = !i.equals(this._modelMatrix);
    if (!this._viewport || !e.equals(this._viewport) || !Aa(this._zRange, t) || s) {
      s && (this._modelMatrixInverse = i.clone().invert(), this._modelMatrix = i), this._viewport = e, this._zRange = t;
      const l = this.getTileIndices({
        viewport: e,
        maxZoom: this._maxZoom,
        minZoom: this._minZoom,
        zRange: t,
        modelMatrix: this._modelMatrix,
        modelMatrixInverse: this._modelMatrixInverse
      });
      this._selectedTiles = l.map((u) => this._getTile(u, !0)), this._dirty && this._rebuildTree();
    } else this.needsReload && (this._selectedTiles = this._selectedTiles.map((l) => this._getTile(l.index, !0)));
    const o = this.updateTileStates();
    return this._pruneRequests(), this._dirty && this._resizeCache(), o && this._frameNumber++, this._frameNumber;
  }
  // eslint-disable-next-line complexity
  isTileVisible(e, t, n) {
    if (!e.isVisible)
      return !1;
    if (t && this._viewport) {
      const i = this._getCullBounds({
        viewport: this._viewport,
        z: this._zRange,
        cullRect: t
      });
      let { bbox: s } = e;
      for (const [o, l, u, m] of i) {
        let y;
        if ("west" in s)
          y = s.west < u && s.east > o && s.south < m && s.north > l;
        else {
          if (n && !xn.IDENTITY.equals(n)) {
            const [L, U, V, q] = Gw([s.left, s.top, s.right, s.bottom], n);
            s = { left: L, top: U, right: V, bottom: q };
          }
          const E = Math.min(s.top, s.bottom), P = Math.max(s.top, s.bottom);
          y = s.left < u && s.right > o && E < m && P > l;
        }
        if (y)
          return !0;
      }
      return !1;
    }
    return !0;
  }
  /* Public interface for subclassing */
  /** Returns array of tile indices in the current viewport */
  getTileIndices({ viewport: e, maxZoom: t, minZoom: n, zRange: i, modelMatrix: s, modelMatrixInverse: o }) {
    const { tileSize: l, extent: u, zoomOffset: m } = this.opts;
    return ffe({
      viewport: e,
      maxZoom: t,
      minZoom: n,
      zRange: i,
      tileSize: l,
      extent: u,
      modelMatrix: s,
      modelMatrixInverse: o,
      zoomOffset: m
    });
  }
  /** Returns unique string key for a tile index */
  getTileId(e) {
    return `${e.x}-${e.y}-${e.z}`;
  }
  /** Returns a zoom level for a tile index */
  getTileZoom(e) {
    return e.z;
  }
  /** Returns additional metadata to add to tile, bbox by default */
  getTileMetadata(e) {
    const { tileSize: t } = this.opts;
    return { bbox: cfe(this._viewport, e.x, e.y, e.z, t) };
  }
  /** Returns index of the parent tile */
  getParentIndex(e) {
    const t = Math.floor(e.x / 2), n = Math.floor(e.y / 2), i = e.z - 1;
    return { x: t, y: n, z: i };
  }
  // Returns true if any tile's visibility changed
  updateTileStates() {
    const e = this.opts.refinementStrategy || $w, t = new Array(this._cache.size);
    let n = 0;
    for (const i of this._cache.values())
      t[n++] = i.isVisible, i.isSelected = !1, i.isVisible = !1;
    for (const i of this._selectedTiles)
      i.isSelected = !0, i.isVisible = !0;
    (typeof e == "function" ? e : yfe[e])(Array.from(this._cache.values())), n = 0;
    for (const i of this._cache.values())
      if (t[n++] !== i.isVisible)
        return !0;
    return !1;
  }
  _pruneRequests() {
    const { maxRequests: e = 0 } = this.opts, t = [];
    let n = 0;
    for (const i of this._cache.values())
      i.isLoading && (n++, !i.isSelected && !i.isVisible && t.push(i));
    for (; e > 0 && n > e && t.length > 0; )
      t.shift().abort(), n--;
  }
  // This needs to be called every time some tiles have been added/removed from cache
  _rebuildTree() {
    const { _cache: e } = this;
    for (const t of e.values())
      t.parent = null, t.children && (t.children.length = 0);
    for (const t of e.values()) {
      const n = this._getNearestAncestor(t);
      t.parent = n, n?.children && n.children.push(t);
    }
  }
  /**
   * Clear tiles that are not visible when the cache is full
   */
  /* eslint-disable complexity */
  _resizeCache() {
    const { _cache: e, opts: t } = this, n = t.maxCacheSize ?? // @ts-expect-error called only when selectedTiles is initialized
    (t.maxCacheByteSize !== null ? 1 / 0 : _fe * this.selectedTiles.length), i = t.maxCacheByteSize ?? 1 / 0;
    if (e.size > n || this._cacheByteSize > i) {
      for (const [o, l] of e)
        if (!l.isVisible && !l.isSelected && (this._cacheByteSize -= t.maxCacheByteSize !== null ? l.byteLength : 0, e.delete(o), this.opts.onTileUnload?.(l)), e.size <= n && this._cacheByteSize <= i)
          break;
      this._rebuildTree(), this._dirty = !0;
    }
    this._dirty && (this._tiles = Array.from(this._cache.values()).sort((o, l) => o.zoom - l.zoom), this._dirty = !1);
  }
  _getTile(e, t) {
    const n = this.getTileId(e);
    let i = this._cache.get(n), s = !1;
    return !i && t ? (i = new nk(e), Object.assign(i, this.getTileMetadata(i.index)), Object.assign(i, { id: n, zoom: this.getTileZoom(i.index) }), s = !0, this._cache.set(n, i), this._dirty = !0) : i && i.needsReload && (s = !0), i && s && i.loadData({
      getData: this.opts.getTileData,
      requestScheduler: this._requestScheduler,
      onLoad: this.onTileLoad,
      onError: this.opts.onTileError
    }), i;
  }
  _getNearestAncestor(e) {
    const { _minZoom: t = 0 } = this;
    let n = e.index;
    for (; this.getTileZoom(n) > t; ) {
      n = this.getParentIndex(n);
      const i = this._getTile(n);
      if (i)
        return i;
    }
    return null;
  }
}
function bfe(r) {
  for (const e of r)
    e.state = 0;
  for (const e of r)
    e.isSelected && !ak(e) && qw(e);
  for (const e of r)
    e.isVisible = !!(e.state & fy);
}
function xfe(r) {
  for (const t of r)
    t.state = 0;
  for (const t of r)
    t.isSelected && ak(t);
  const e = Array.from(r).sort((t, n) => t.zoom - n.zoom);
  for (const t of e)
    if (t.isVisible = !!(t.state & fy), t.children && (t.isVisible || t.state & wM))
      for (const n of t.children)
        n.state = wM;
    else t.isSelected && qw(t);
}
function ak(r) {
  let e = r;
  for (; e; ) {
    if (e.isLoaded || e.content)
      return e.state |= fy, !0;
    e = e.parent;
  }
  return !1;
}
function qw(r) {
  for (const e of r.children)
    e.isLoaded || e.content ? e.state |= fy : qw(e);
}
const wfe = {
  TilesetClass: hy,
  data: { type: "data", value: [] },
  dataComparator: x_.equal,
  renderSubLayers: { type: "function", value: (r) => new iu(r) },
  getTileData: { type: "function", optional: !0, value: null },
  // TODO - change to onViewportLoad to align with Tile3DLayer
  onViewportLoad: { type: "function", optional: !0, value: null },
  onTileLoad: { type: "function", value: (r) => {
  } },
  onTileUnload: { type: "function", value: (r) => {
  } },
  // eslint-disable-next-line
  onTileError: { type: "function", value: (r) => console.error(r) },
  extent: { type: "array", optional: !0, value: null, compare: !0 },
  tileSize: 512,
  maxZoom: null,
  minZoom: 0,
  maxCacheSize: null,
  maxCacheByteSize: null,
  refinementStrategy: $w,
  zRange: null,
  maxRequests: 6,
  debounceTime: 0,
  zoomOffset: 0
};
class ou extends Ps {
  initializeState() {
    this.state = {
      tileset: null,
      isLoaded: !1
    };
  }
  finalizeState() {
    this.state?.tileset?.finalize();
  }
  get isLoaded() {
    return !!this.state?.tileset?.selectedTiles?.every((e) => e.isLoaded && e.layers && e.layers.every((t) => t.isLoaded));
  }
  shouldUpdateState({ changeFlags: e }) {
    return e.somethingChanged;
  }
  updateState({ changeFlags: e }) {
    let { tileset: t } = this.state;
    const n = e.propsOrDataChanged || e.updateTriggersChanged, i = e.dataChanged || e.updateTriggersChanged && (e.updateTriggersChanged.all || e.updateTriggersChanged.getTileData);
    t ? n && (t.setOptions(this._getTilesetOptions()), i ? t.reloadAll() : t.tiles.forEach((s) => {
      s.layers = null;
    })) : (t = new this.props.TilesetClass(this._getTilesetOptions()), this.setState({ tileset: t })), this._updateTileset();
  }
  _getTilesetOptions() {
    const { tileSize: e, maxCacheSize: t, maxCacheByteSize: n, refinementStrategy: i, extent: s, maxZoom: o, minZoom: l, maxRequests: u, debounceTime: m, zoomOffset: y } = this.props;
    return {
      maxCacheSize: t,
      maxCacheByteSize: n,
      maxZoom: o,
      minZoom: l,
      tileSize: e,
      refinementStrategy: i,
      extent: s,
      maxRequests: u,
      debounceTime: m,
      zoomOffset: y,
      getTileData: this.getTileData.bind(this),
      onTileLoad: this._onTileLoad.bind(this),
      onTileError: this._onTileError.bind(this),
      onTileUnload: this._onTileUnload.bind(this)
    };
  }
  _updateTileset() {
    const e = this.state.tileset, { zRange: t, modelMatrix: n } = this.props, i = e.update(this.context.viewport, { zRange: t, modelMatrix: n }), { isLoaded: s } = e, o = this.state.isLoaded !== s, l = this.state.frameNumber !== i;
    s && (o || l) && this._onViewportLoad(), l && this.setState({ frameNumber: i }), this.state.isLoaded = s;
  }
  _onViewportLoad() {
    const { tileset: e } = this.state, { onViewportLoad: t } = this.props;
    t && t(e.selectedTiles);
  }
  _onTileLoad(e) {
    this.props.onTileLoad(e), e.layers = null, this.setNeedsUpdate();
  }
  _onTileError(e, t) {
    this.props.onTileError(e), t.layers = null, this.setNeedsUpdate();
  }
  _onTileUnload(e) {
    this.props.onTileUnload(e);
  }
  // Methods for subclass to override
  getTileData(e) {
    const { data: t, getTileData: n, fetch: i } = this.props, { signal: s } = e;
    return e.url = typeof t == "string" || Array.isArray(t) ? ch(t, e) : null, n ? n(e) : i && e.url ? i(e.url, { propName: "data", layer: this, signal: s }) : null;
  }
  renderSubLayers(e) {
    return this.props.renderSubLayers(e);
  }
  getSubLayerPropsByTile(e) {
    return null;
  }
  getPickingInfo(e) {
    const t = e.sourceLayer, n = t.props.tile, i = e.info;
    return i.picked && (i.tile = n), i.sourceTile = n, i.sourceTileSubLayer = t, i;
  }
  _updateAutoHighlight(e) {
    e.sourceTileSubLayer.updateAutoHighlight(e);
  }
  renderLayers() {
    return this.state.tileset.tiles.map((e) => {
      const t = this.getSubLayerPropsByTile(e);
      if (!(!e.isLoaded && !e.content)) if (e.layers)
        t && e.layers[0] && Object.keys(t).some((n) => e.layers[0].props[n] !== t[n]) && (e.layers = e.layers.map((n) => n.clone(t)));
      else {
        const n = this.renderSubLayers({
          ...this.props,
          ...this.getSubLayerProps({
            id: e.id,
            updateTriggers: this.props.updateTriggers
          }),
          data: e.content,
          _offset: 0,
          tile: e
        });
        e.layers = z_(n, Boolean).map((i) => i.clone({
          tile: e,
          ...t
        }));
      }
      return e.layers;
    });
  }
  filterSubLayer({ layer: e, cullRect: t }) {
    const { tile: n } = e.props, { modelMatrix: i } = this.props;
    return this.state.tileset.isTileVisible(n, t, i ? new xn(i) : null);
  }
}
ou.defaultProps = wfe;
ou.layerName = "TileLayer";
const TM = `uniform tripsUniforms {
  bool fadeTrail;
  float trailLength;
  float currentTime;
} trips;
`, Tfe = {
  name: "trips",
  vs: TM,
  fs: TM,
  uniformTypes: {
    fadeTrail: "f32",
    trailLength: "f32",
    currentTime: "f32"
  }
}, Efe = {
  fadeTrail: !0,
  trailLength: { type: "number", value: 120, min: 0 },
  currentTime: { type: "number", value: 0, min: 0 },
  getTimestamps: { type: "accessor", value: (r) => r.timestamps }
};
class dy extends nf {
  getShaders() {
    const e = super.getShaders();
    return e.inject = {
      "vs:#decl": `in float instanceTimestamps;
in float instanceNextTimestamps;
out float vTime;
`,
      // Timestamp of the vertex
      "vs:#main-end": `vTime = instanceTimestamps + (instanceNextTimestamps - instanceTimestamps) * vPathPosition.y / vPathLength;
`,
      "fs:#decl": `in float vTime;
`,
      // Drop the segments outside of the time window
      "fs:#main-start": `if(vTime > trips.currentTime || (trips.fadeTrail && (vTime < trips.currentTime - trips.trailLength))) {
  discard;
}
`,
      // Fade the color (currentTime - 100%, end of trail - 0%)
      "fs:DECKGL_FILTER_COLOR": `if(trips.fadeTrail) {
  color.a *= 1.0 - (trips.currentTime - vTime) / trips.trailLength;
}
`
    }, e.modules = [...e.modules, Tfe], e;
  }
  initializeState() {
    super.initializeState(), this.getAttributeManager().addInstanced({
      timestamps: {
        size: 1,
        accessor: "getTimestamps",
        shaderAttributes: {
          instanceTimestamps: {
            vertexOffset: 0
          },
          instanceNextTimestamps: {
            vertexOffset: 1
          }
        }
      }
    });
  }
  draw(e) {
    const { fadeTrail: t, trailLength: n, currentTime: i } = this.props, s = { fadeTrail: t, trailLength: n, currentTime: i };
    this.state.model.shaderInputs.setProps({ trips: s }), super.draw(e);
  }
}
dy.layerName = "TripsLayer";
dy.defaultProps = Efe;
const Cfe = 10;
function Sfe(r, e) {
  let t;
  return r == null ? t = e : typeof r == "object" ? t = { ...r, coverage: e } : t = { getHexagon: r, coverage: e }, t;
}
const Ife = {
  ...of.defaultProps,
  highPrecision: "auto",
  coverage: { type: "number", min: 0, max: 1, value: 1 },
  centerHexagon: null,
  getHexagon: { type: "accessor", value: (r) => r.hexagon },
  extruded: !0
};
class pc extends Ps {
  initializeState() {
    pc._checkH3Lib(), this.state = {
      edgeLengthKM: 0,
      resolution: -1
    };
  }
  shouldUpdateState({ changeFlags: e }) {
    return this._shouldUseHighPrecision() ? e.propsOrDataChanged : e.somethingChanged;
  }
  updateState({ props: e, changeFlags: t }) {
    if (e.highPrecision !== !0 && (t.dataChanged || t.updateTriggersChanged && t.updateTriggersChanged.getHexagon)) {
      const n = this._calculateH3DataProps();
      this.setState(n);
    }
    this._updateVertices(this.context.viewport);
  }
  _calculateH3DataProps() {
    let e = -1, t = !1, n = !1;
    const { iterable: i, objectInfo: s } = hc(this.props.data);
    for (const o of i) {
      s.index++;
      const l = this.props.getHexagon(o, s), u = lh(l);
      if (e < 0) {
        if (e = u, !this.props.highPrecision)
          break;
      } else if (e !== u) {
        n = !0;
        break;
      }
      if (Ace(l)) {
        t = !0;
        break;
      }
    }
    return {
      resolution: e,
      edgeLengthKM: e >= 0 ? xce(e, "km") : 0,
      hasMultipleRes: n,
      hasPentagon: t
    };
  }
  _shouldUseHighPrecision() {
    if (this.props.highPrecision === "auto") {
      const { resolution: e, hasPentagon: t, hasMultipleRes: n } = this.state, { viewport: i } = this.context;
      return !!i?.resolution || n || t || e >= 0 && e <= 5;
    }
    return this.props.highPrecision;
  }
  _updateVertices(e) {
    if (this._shouldUseHighPrecision())
      return;
    const { resolution: t, edgeLengthKM: n, centerHex: i } = this.state;
    if (t < 0)
      return;
    const s = this.props.centerHexagon || kw(e.latitude, e.longitude, t);
    if (i === s)
      return;
    if (i)
      try {
        if (vce(i, s) * n < Cfe)
          return;
      } catch {
      }
    const { unitsPerMeter: o } = e.distanceScales;
    let l = WP(s);
    const [u, m] = ay(s), [y, E] = e.projectFlat([m, u]);
    l = l.map((P) => {
      const L = e.projectFlat(P);
      return [
        (L[0] - y) / o[0],
        (L[1] - E) / o[1]
      ];
    }), this.setState({ centerHex: s, vertices: l });
  }
  renderLayers() {
    return this._shouldUseHighPrecision() ? this._renderPolygonLayer() : this._renderColumnLayer();
  }
  _getForwardProps() {
    const { elevationScale: e, material: t, coverage: n, extruded: i, wireframe: s, stroked: o, filled: l, lineWidthUnits: u, lineWidthScale: m, lineWidthMinPixels: y, lineWidthMaxPixels: E, getFillColor: P, getElevation: L, getLineColor: U, getLineWidth: V, transitions: q, updateTriggers: j } = this.props;
    return {
      elevationScale: e,
      extruded: i,
      coverage: n,
      wireframe: s,
      stroked: o,
      filled: l,
      lineWidthUnits: u,
      lineWidthScale: m,
      lineWidthMinPixels: y,
      lineWidthMaxPixels: E,
      material: t,
      getElevation: L,
      getFillColor: P,
      getLineColor: U,
      getLineWidth: V,
      transitions: q,
      updateTriggers: {
        getFillColor: j.getFillColor,
        getElevation: j.getElevation,
        getLineColor: j.getLineColor,
        getLineWidth: j.getLineWidth
      }
    };
  }
  _renderPolygonLayer() {
    const { data: e, getHexagon: t, updateTriggers: n, coverage: i } = this.props, s = this.getSubLayerClass("hexagon-cell-hifi", of), o = this._getForwardProps();
    return o.updateTriggers.getPolygon = Sfe(n.getHexagon, i), new s(o, this.getSubLayerProps({
      id: "hexagon-cell-hifi",
      updateTriggers: o.updateTriggers
    }), {
      data: e,
      _normalize: !1,
      _windingOrder: "CCW",
      positionFormat: "XY",
      getPolygon: (l, u) => {
        const m = t(l, u);
        return QL(WP(m, i));
      }
    });
  }
  _renderColumnLayer() {
    const { data: e, getHexagon: t, updateTriggers: n } = this.props, i = this.getSubLayerClass("hexagon-cell", dc), s = this._getForwardProps();
    return s.updateTriggers.getPosition = n.getHexagon, new i(s, this.getSubLayerProps({
      id: "hexagon-cell",
      flatShading: !0,
      updateTriggers: s.updateTriggers
    }), {
      data: e,
      diskResolution: 6,
      // generate an extruded hexagon as the base geometry
      radius: 1,
      vertices: this.state.vertices,
      getPosition: Cce.bind(null, t)
    });
  }
}
pc.defaultProps = Ife;
pc.layerName = "H3HexagonLayer";
pc._checkH3Lib = () => {
};
const Pfe = {
  getHexagons: { type: "accessor", value: (r) => r.hexagons }
};
class py extends su {
  initializeState() {
    pc._checkH3Lib();
  }
  updateState({ props: e, changeFlags: t }) {
    if (t.dataChanged || t.updateTriggersChanged && t.updateTriggersChanged.getHexagons) {
      const { data: n, getHexagons: i } = e, s = [], { iterable: o, objectInfo: l } = hc(n);
      for (const u of o) {
        l.index++;
        const m = i(u, l), y = _ce(m, !0);
        for (const E of y) {
          for (const P of E)
            Fw(P);
          s.push(this.getSubLayerRow({ polygon: E }, u, l.index));
        }
      }
      this.setState({ polygons: s });
    }
  }
  indexToBounds() {
    const { getElevation: e, getFillColor: t, getLineColor: n, getLineWidth: i } = this.props;
    return {
      data: this.state.polygons,
      getPolygon: (s) => s.polygon,
      getElevation: this.getSubLayerAccessor(e),
      getFillColor: this.getSubLayerAccessor(t),
      getLineColor: this.getSubLayerAccessor(n),
      getLineWidth: this.getSubLayerAccessor(i)
    };
  }
}
py.layerName = "H3ClusterLayer";
py.defaultProps = Pfe;
const D1 = Math.PI / 180, tm = new Float32Array(16), EM = new Float32Array(12);
function CM(r, e, t) {
  const n = e[0] * D1, i = e[1] * D1, s = e[2] * D1, o = Math.sin(s), l = Math.sin(n), u = Math.sin(i), m = Math.cos(s), y = Math.cos(n), E = Math.cos(i), P = t[0], L = t[1], U = t[2];
  r[0] = P * E * y, r[1] = P * u * y, r[2] = P * -l, r[3] = L * (-u * m + E * l * o), r[4] = L * (E * m + u * l * o), r[5] = L * y * o, r[6] = U * (u * o + E * l * m), r[7] = U * (-E * o + u * l * m), r[8] = U * y * m;
}
function SM(r) {
  return r[0] = r[0], r[1] = r[1], r[2] = r[2], r[3] = r[4], r[4] = r[5], r[5] = r[6], r[6] = r[8], r[7] = r[9], r[8] = r[10], r[9] = r[12], r[10] = r[13], r[11] = r[14], r.subarray(0, 12);
}
const lk = {
  size: 12,
  accessor: ["getOrientation", "getScale", "getTranslation", "getTransformMatrix"],
  shaderAttributes: {
    instanceModelMatrixCol0: {
      size: 3,
      elementOffset: 0
    },
    instanceModelMatrixCol1: {
      size: 3,
      elementOffset: 3
    },
    instanceModelMatrixCol2: {
      size: 3,
      elementOffset: 6
    },
    instanceTranslation: {
      size: 3,
      elementOffset: 9
    }
  },
  update(r, { startRow: e, endRow: t }) {
    const { data: n, getOrientation: i, getScale: s, getTranslation: o, getTransformMatrix: l } = this.props, u = Array.isArray(l), m = u && l.length === 16, y = Array.isArray(s), E = Array.isArray(i), P = Array.isArray(o), L = m || !u && !!l(n[0]);
    L ? r.constant = m : r.constant = E && y && P;
    const U = r.value;
    if (r.constant) {
      let V;
      L ? (tm.set(l), V = SM(tm)) : (V = EM, CM(V, i, s), V.set(o, 9)), r.value = new Float32Array(V);
    } else {
      let V = e * r.size;
      const { iterable: q, objectInfo: j } = hc(n, e, t);
      for (const K of q) {
        j.index++;
        let Y;
        if (L)
          tm.set(m ? l : l(K, j)), Y = SM(tm);
        else {
          Y = EM;
          const de = E ? i : i(K, j), ne = y ? s : s(K, j);
          CM(Y, de, ne), Y.set(P ? o : o(K, j), 9);
        }
        U[V++] = Y[0], U[V++] = Y[1], U[V++] = Y[2], U[V++] = Y[3], U[V++] = Y[4], U[V++] = Y[5], U[V++] = Y[6], U[V++] = Y[7], U[V++] = Y[8], U[V++] = Y[9], U[V++] = Y[10], U[V++] = Y[11];
      }
    }
  }
};
function ck(r, e) {
  return e === rn.CARTESIAN || e === rn.METER_OFFSETS || e === rn.DEFAULT && !r.isGeospatial;
}
const IM = `uniform simpleMeshUniforms {
  float sizeScale;
  bool composeModelMatrix;
  bool hasTexture;
  bool flatShading;
} simpleMesh;
`, Mfe = {
  name: "simpleMesh",
  vs: IM,
  fs: IM,
  uniformTypes: {
    sizeScale: "f32",
    composeModelMatrix: "f32",
    hasTexture: "f32",
    flatShading: "f32"
  }
}, Rfe = `#version 300 es
#define SHADER_NAME simple-mesh-layer-vs
in vec3 positions;
in vec3 normals;
in vec3 colors;
in vec2 texCoords;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;
in vec3 instanceTranslation;
out vec2 vTexCoord;
out vec3 cameraPosition;
out vec3 normals_commonspace;
out vec4 position_commonspace;
out vec4 vColor;
void main(void) {
geometry.worldPosition = instancePositions;
geometry.uv = texCoords;
geometry.pickingColor = instancePickingColors;
vTexCoord = texCoords;
cameraPosition = project.cameraPosition;
vColor = vec4(colors * instanceColors.rgb, instanceColors.a);
mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);
vec3 pos = (instanceModelMatrix * positions) * simpleMesh.sizeScale + instanceTranslation;
if (simpleMesh.composeModelMatrix) {
DECKGL_FILTER_SIZE(pos, geometry);
normals_commonspace = project_normal(instanceModelMatrix * normals);
geometry.worldPosition += pos;
gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), position_commonspace);
geometry.position = position_commonspace;
}
else {
pos = project_size(pos);
DECKGL_FILTER_SIZE(pos, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, position_commonspace);
geometry.position = position_commonspace;
normals_commonspace = project_normal(instanceModelMatrix * normals);
}
geometry.normal = normals_commonspace;
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, Bfe = `#version 300 es
#define SHADER_NAME simple-mesh-layer-fs
precision highp float;
uniform sampler2D sampler;
in vec2 vTexCoord;
in vec3 cameraPosition;
in vec3 normals_commonspace;
in vec4 position_commonspace;
in vec4 vColor;
out vec4 fragColor;
void main(void) {
geometry.uv = vTexCoord;
vec3 normal;
if (simpleMesh.flatShading) {
normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
} else {
normal = normals_commonspace;
}
vec4 color = simpleMesh.hasTexture ? texture(sampler, vTexCoord) : vColor;
DECKGL_FILTER_COLOR(color, geometry);
vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);
fragColor = vec4(lightColor, color.a * layer.opacity);
}
`;
function L1(r) {
  const e = r.positions || r.POSITION;
  Jr.assert(e, 'no "postions" or "POSITION" attribute in mesh');
  const t = e.value.length / e.size;
  let n = r.COLOR_0 || r.colors;
  n || (n = { size: 3, value: new Float32Array(t * 3).fill(1) });
  let i = r.NORMAL || r.normals;
  i || (i = { size: 3, value: new Float32Array(t * 3).fill(0) });
  let s = r.TEXCOORD_0 || r.texCoords;
  return s || (s = { size: 2, value: new Float32Array(t * 2).fill(0) }), {
    positions: e,
    colors: n,
    normals: i,
    texCoords: s
  };
}
function PM(r) {
  return r instanceof no ? (r.attributes = L1(r.attributes), r) : r.attributes ? new no({
    ...r,
    topology: "triangle-list",
    attributes: L1(r.attributes)
  }) : new no({
    topology: "triangle-list",
    attributes: L1(r)
  });
}
const Ofe = [0, 0, 0, 255], Dfe = {
  mesh: { type: "object", value: null, async: !0 },
  texture: { type: "image", value: null, async: !0 },
  sizeScale: { type: "number", value: 1, min: 0 },
  // _instanced is a hack to use world position instead of meter offsets in mesh
  // TODO - formalize API
  _instanced: !0,
  // NOTE(Tarek): Quick and dirty wireframe. Just draws
  // the same mesh with LINE_STRIPS. Won't follow edges
  // of the original mesh.
  wireframe: !1,
  // Optional material for 'lighting' shader module
  material: !0,
  getPosition: { type: "accessor", value: (r) => r.position },
  getColor: { type: "accessor", value: Ofe },
  // yaw, pitch and roll are in degrees
  // https://en.wikipedia.org/wiki/Euler_angles
  // [pitch, yaw, roll]
  getOrientation: { type: "accessor", value: [0, 0, 0] },
  getScale: { type: "accessor", value: [1, 1, 1] },
  getTranslation: { type: "accessor", value: [0, 0, 0] },
  // 4x4 matrix
  getTransformMatrix: { type: "accessor", value: [] },
  textureParameters: { type: "object", ignore: !0, value: null }
};
class uh extends Is {
  getShaders() {
    return super.getShaders({
      vs: Rfe,
      fs: Bfe,
      modules: [Ws, kx, ga, Mfe]
    });
  }
  getBounds() {
    if (this.props._instanced)
      return super.getBounds();
    let e = this.state.positionBounds;
    if (e)
      return e;
    const { mesh: t } = this.props;
    if (!t)
      return null;
    if (e = t.header?.boundingBox, !e) {
      const { attributes: n } = PM(t);
      n.POSITION = n.POSITION || n.positions, e = TB(n);
    }
    return this.state.positionBounds = e, e;
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        transition: !0,
        type: "float64",
        fp64: this.use64bitPositions(),
        size: 3,
        accessor: "getPosition"
      },
      instanceColors: {
        type: "unorm8",
        transition: !0,
        size: this.props.colorFormat.length,
        accessor: "getColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceModelMatrix: lk
    }), this.setState({
      // Avoid luma.gl's missing uniform warning
      // TODO - add feature to luma.gl to specify ignored uniforms?
      emptyTexture: this.context.device.createTexture({
        data: new Uint8Array(4),
        width: 1,
        height: 1
      })
    });
  }
  updateState(e) {
    super.updateState(e);
    const { props: t, oldProps: n, changeFlags: i } = e;
    if (t.mesh !== n.mesh || i.extensionsChanged) {
      if (this.state.positionBounds = null, this.state.model?.destroy(), t.mesh) {
        this.state.model = this.getModel(t.mesh);
        const s = t.mesh.attributes || t.mesh;
        this.setState({
          hasNormals: !!(s.NORMAL || s.normals)
        });
      }
      this.getAttributeManager().invalidateAll();
    }
    t.texture !== n.texture && t.texture instanceof ps && this.setTexture(t.texture), this.state.model && this.state.model.setTopology(this.props.wireframe ? "line-strip" : "triangle-list");
  }
  finalizeState(e) {
    super.finalizeState(e), this.state.emptyTexture.delete();
  }
  draw({ uniforms: e }) {
    const { model: t } = this.state;
    if (!t)
      return;
    const { viewport: n, renderPass: i } = this.context, { sizeScale: s, coordinateSystem: o, _instanced: l } = this.props, u = {
      sizeScale: s,
      composeModelMatrix: !l || ck(n, o),
      flatShading: !this.state.hasNormals
    };
    t.shaderInputs.setProps({ simpleMesh: u }), t.draw(i);
  }
  get isLoaded() {
    return !!(this.state?.model && super.isLoaded);
  }
  getModel(e) {
    const t = new Bi(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: PM(e),
      isInstanced: !0
    }), { texture: n } = this.props, { emptyTexture: i } = this.state, s = {
      sampler: n || i,
      hasTexture: !!n
    };
    return t.shaderInputs.setProps({ simpleMesh: s }), t;
  }
  setTexture(e) {
    const { emptyTexture: t, model: n } = this.state;
    if (n) {
      const i = {
        sampler: e || t,
        hasTexture: !!e
      };
      n.shaderInputs.setProps({ simpleMesh: i });
    }
  }
}
uh.defaultProps = Dfe;
uh.layerName = "SimpleMeshLayer";
function Lfe(r) {
  return {
    addressModeU: MM(r.wrapS),
    addressModeV: MM(r.wrapT),
    magFilter: kfe(r.magFilter),
    ...Ffe(r.minFilter)
  };
}
function MM(r) {
  switch (r) {
    case 33071:
      return "clamp-to-edge";
    case 10497:
      return "repeat";
    case 33648:
      return "mirror-repeat";
    default:
      return;
  }
}
function kfe(r) {
  switch (r) {
    case 9728:
      return "nearest";
    case 9729:
      return "linear";
    default:
      return;
  }
}
function Ffe(r) {
  switch (r) {
    case 9728:
      return { minFilter: "nearest" };
    case 9729:
      return { minFilter: "linear" };
    case 9984:
      return { minFilter: "nearest", mipmapFilter: "nearest" };
    case 9985:
      return { minFilter: "linear", mipmapFilter: "nearest" };
    case 9986:
      return { minFilter: "nearest", mipmapFilter: "linear" };
    case 9987:
      return { minFilter: "linear", mipmapFilter: "linear" };
    default:
      return {};
  }
}
function uk(r, e, t, n) {
  const i = {
    defines: {
      // TODO: Use EXT_sRGB if available (Standard in WebGL 2.0)
      MANUAL_SRGB: !0,
      SRGB_FAST_APPROXIMATION: !0
    },
    bindings: {},
    uniforms: {
      // TODO: find better values?
      camera: [0, 0, 0],
      // Model should override
      metallicRoughnessValues: [1, 1]
      // Default is 1 and 1
    },
    parameters: {},
    glParameters: {},
    generatedTextures: []
  };
  i.defines.USE_TEX_LOD = !0;
  const { imageBasedLightingEnvironment: s } = n;
  return s && (i.bindings.pbr_diffuseEnvSampler = s.diffuseEnvSampler.texture, i.bindings.pbr_specularEnvSampler = s.specularEnvSampler.texture, i.bindings.pbr_BrdfLUT = s.brdfLutTexture.texture, i.uniforms.scaleIBLAmbient = [1, 1]), n?.pbrDebug && (i.defines.PBR_DEBUG = !0, i.uniforms.scaleDiffBaseMR = [0, 0, 0, 0], i.uniforms.scaleFGDSpec = [0, 0, 0, 0]), t.NORMAL && (i.defines.HAS_NORMALS = !0), t.TANGENT && n?.useTangents && (i.defines.HAS_TANGENTS = !0), t.TEXCOORD_0 && (i.defines.HAS_UV = !0), n?.imageBasedLightingEnvironment && (i.defines.USE_IBL = !0), n?.lights && (i.defines.USE_LIGHTS = !0), e && Nfe(r, e, i), i;
}
function Nfe(r, e, t) {
  if (t.uniforms.unlit = !!e.unlit, e.pbrMetallicRoughness && Ufe(r, e.pbrMetallicRoughness, t), e.normalTexture) {
    JA(r, e.normalTexture, "pbr_normalSampler", "HAS_NORMALMAP", t);
    const { scale: n = 1 } = e.normalTexture;
    t.uniforms.normalScale = n;
  }
  if (e.occlusionTexture) {
    JA(r, e.occlusionTexture, "pbr_occlusionSampler", "HAS_OCCLUSIONMAP", t);
    const { strength: n = 1 } = e.occlusionTexture;
    t.uniforms.occlusionStrength = n;
  }
  switch (e.emissiveTexture && (JA(r, e.emissiveTexture, "pbr_emissiveSampler", "HAS_EMISSIVEMAP", t), t.uniforms.emissiveFactor = e.emissiveFactor || [0, 0, 0]), e.alphaMode || "MASK") {
    case "MASK":
      const { alphaCutoff: n = 0.5 } = e;
      t.defines.ALPHA_CUTOFF = !0, t.uniforms.alphaCutoff = n;
      break;
    case "BLEND":
      qt.warn("glTF BLEND alphaMode might not work well because it requires mesh sorting")(), t.parameters.blend = !0, t.parameters.blendColorOperation = "add", t.parameters.blendColorSrcFactor = "src-alpha", t.parameters.blendColorDstFactor = "one-minus-src-alpha", t.parameters.blendAlphaOperation = "add", t.parameters.blendAlphaSrcFactor = "one", t.parameters.blendAlphaDstFactor = "one-minus-src-alpha", t.glParameters.blend = !0, t.glParameters.blendEquation = 32774, t.glParameters.blendFunc = [
        770,
        771,
        1,
        771
      ];
      break;
  }
}
function Ufe(r, e, t) {
  e.baseColorTexture && JA(r, e.baseColorTexture, "pbr_baseColorSampler", "HAS_BASECOLORMAP", t), t.uniforms.baseColorFactor = e.baseColorFactor || [1, 1, 1, 1], e.metallicRoughnessTexture && JA(r, e.metallicRoughnessTexture, "pbr_metallicRoughnessSampler", "HAS_METALROUGHNESSMAP", t);
  const { metallicFactor: n = 1, roughnessFactor: i = 1 } = e;
  t.uniforms.metallicRoughnessValues = [n, i];
}
function JA(r, e, t, n, i) {
  const s = e.texture.source.image;
  let o;
  s.compressed ? o = s : o = { data: s };
  const l = {
    wrapS: 10497,
    // default REPEAT S (U) wrapping mode.
    wrapT: 10497,
    // default REPEAT T (V) wrapping mode.
    ...e?.texture?.sampler
  }, u = r.createTexture({
    id: e.uniformName || e.id,
    sampler: Lfe(l),
    ...o
  });
  i.bindings[t] = u, n && (i.defines[n] = !0), i.generatedTextures.push(u);
}
var jf;
(function(r) {
  r[r.POINTS = 0] = "POINTS", r[r.LINES = 1] = "LINES", r[r.LINE_LOOP = 2] = "LINE_LOOP", r[r.LINE_STRIP = 3] = "LINE_STRIP", r[r.TRIANGLES = 4] = "TRIANGLES", r[r.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", r[r.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
})(jf || (jf = {}));
function zfe(r) {
  switch (r) {
    case jf.POINTS:
      return "point-list";
    case jf.LINES:
      return "line-list";
    case jf.LINE_STRIP:
      return "line-strip";
    case jf.TRIANGLES:
      return "triangle-list";
    case jf.TRIANGLE_STRIP:
      return "triangle-strip";
    default:
      throw new Error(String(r));
  }
}
const Vfe = (
  /* WGSL */
  `
layout(0) positions: vec4; // in vec4 POSITION;

  #ifdef HAS_NORMALS
    in vec4 normals; // in vec4 NORMAL;
  #endif

  #ifdef HAS_TANGENTS
    in vec4 TANGENT;
  #endif

  #ifdef HAS_UV
    // in vec2 TEXCOORD_0;
    in vec2 texCoords;
  #endif

@vertex
  void main(void) {
    vec4 _NORMAL = vec4(0.);
    vec4 _TANGENT = vec4(0.);
    vec2 _TEXCOORD_0 = vec2(0.);

    #ifdef HAS_NORMALS
      _NORMAL = normals;
    #endif

    #ifdef HAS_TANGENTS
      _TANGENT = TANGENT;
    #endif

    #ifdef HAS_UV
      _TEXCOORD_0 = texCoords;
    #endif

    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);
    gl_Position = u_MVPMatrix * positions;
  }

@fragment
  out vec4 fragmentColor;

  void main(void) {
    vec3 pos = pbr_vPosition;
    fragmentColor = pbr_filterColor(vec4(1.0));
  }
`
), jfe = (
  /* glsl */
  `#version 300 es

  // in vec4 POSITION;
  in vec4 positions;

  #ifdef HAS_NORMALS
    // in vec4 NORMAL;
    in vec4 normals;
  #endif

  #ifdef HAS_TANGENTS
    in vec4 TANGENT;
  #endif

  #ifdef HAS_UV
    // in vec2 TEXCOORD_0;
    in vec2 texCoords;
  #endif

  void main(void) {
    vec4 _NORMAL = vec4(0.);
    vec4 _TANGENT = vec4(0.);
    vec2 _TEXCOORD_0 = vec2(0.);

    #ifdef HAS_NORMALS
      _NORMAL = normals;
    #endif

    #ifdef HAS_TANGENTS
      _TANGENT = TANGENT;
    #endif

    #ifdef HAS_UV
      _TEXCOORD_0 = texCoords;
    #endif

    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);
    gl_Position = pbrProjection.modelViewProjectionMatrix * positions;
  }
`
), Hfe = (
  /* glsl */
  `#version 300 es
  out vec4 fragmentColor;

  void main(void) {
    vec3 pos = pbr_vPosition;
    fragmentColor = pbr_filterColor(vec4(1.0));
  }
`
);
function Gfe(r, e) {
  const { id: t, geometry: n, parsedPPBRMaterial: i, vertexCount: s, modelOptions: o = {} } = e;
  qt.info(4, "createGLTFModel defines: ", i.defines)();
  const l = [], u = {
    depthWriteEnabled: !0,
    depthCompare: "less",
    depthFormat: "depth24plus",
    cullMode: "back"
  }, m = {
    id: t,
    source: Vfe,
    vs: jfe,
    fs: Hfe,
    geometry: n,
    topology: n.topology,
    vertexCount: s,
    modules: [Fx],
    ...o,
    defines: { ...i.defines, ...o.defines },
    parameters: { ...u, ...i.parameters, ...o.parameters }
  }, y = new Bi(r, m), { camera: E, ...P } = {
    ...i.uniforms,
    ...o.uniforms,
    ...i.bindings,
    ...o.bindings
  };
  return y.shaderInputs.setProps({ pbrMaterial: P, pbrProjection: { camera: E } }), new jb({ managedResources: l, model: y });
}
const Wfe = {
  modelOptions: {},
  pbrDebug: !1,
  imageBasedLightingEnvironment: void 0,
  lights: !0,
  useTangents: !1
};
function $fe(r, e, t = {}) {
  const n = { ...Wfe, ...t };
  return e.scenes.map((s) => qfe(r, s, e.nodes, n));
}
function qfe(r, e, t, n) {
  const s = (e.nodes || []).map((l) => fk(r, l, t, n));
  return new Lp({
    id: e.name || e.id,
    children: s
  });
}
function fk(r, e, t, n) {
  if (!e._node) {
    const o = (e.children || []).map((u) => fk(r, u, t, n));
    e.mesh && o.push(Xfe(r, e.mesh, n));
    const l = new Lp({
      id: e.name || e.id,
      children: o
    });
    if (e.matrix)
      l.setMatrix(e.matrix);
    else {
      if (l.matrix.identity(), e.translation && l.matrix.translate(e.translation), e.rotation) {
        const u = new xn().fromQuaternion(e.rotation);
        l.matrix.multiplyRight(u);
      }
      e.scale && l.matrix.scale(e.scale);
    }
    e._node = l;
  }
  const i = t.find((s) => s.id === e.id);
  return i._node = e._node, e._node;
}
function Xfe(r, e, t) {
  if (!e._mesh) {
    const i = (e.primitives || []).map((o, l) => Zfe(r, o, l, e, t)), s = new Lp({
      id: e.name || e.id,
      children: i
    });
    e._mesh = s;
  }
  return e._mesh;
}
function Zfe(r, e, t, n, i) {
  const s = e.name || `${n.name || n.id}-primitive-${t}`, o = zfe(e.mode || 4), l = e.indices ? e.indices.count : Yfe(e.attributes), u = RM(s, e, o), m = uk(r, e.material, u.attributes, i), y = Gfe(r, {
    id: s,
    geometry: RM(s, e, o),
    parsedPPBRMaterial: m,
    modelOptions: i.modelOptions,
    vertexCount: l
  });
  return y.bounds = [e.attributes.POSITION.min, e.attributes.POSITION.max], y;
}
function Yfe(r) {
  throw new Error("getVertexCount not implemented");
}
function RM(r, e, t) {
  const n = {};
  for (const [i, s] of Object.entries(e.attributes)) {
    const { components: o, size: l, value: u } = s;
    n[i] = { size: l ?? o, value: u };
  }
  return new no({
    id: r,
    topology: t,
    indices: e.indices.value,
    attributes: n
  });
}
const k1 = new r0();
function Kfe(r, { input: e, interpolation: t, output: n }, i, s) {
  const o = e[e.length - 1], l = r % o, u = e.findIndex((P) => P >= l), m = Math.max(0, u - 1);
  if (!Array.isArray(i[s]))
    switch (s) {
      case "translation":
        i[s] = [0, 0, 0];
        break;
      case "rotation":
        i[s] = [0, 0, 0, 1];
        break;
      case "scale":
        i[s] = [1, 1, 1];
        break;
      default:
        qt.warn(`Bad animation path ${s}`)();
    }
  const y = e[m], E = e[u];
  switch (t) {
    case "STEP":
      ehe(i, s, n[m]);
      break;
    case "LINEAR":
      if (E > y) {
        const P = (l - y) / (E - y);
        Qfe(i, s, n[m], n[u], P);
      }
      break;
    case "CUBICSPLINE":
      if (E > y) {
        const P = (l - y) / (E - y), L = E - y, U = n[3 * m + 1], V = n[3 * m + 2], q = n[3 * u + 0], j = n[3 * u + 1];
        Jfe(i, s, { p0: U, outTangent0: V, inTangent1: q, p1: j, tDiff: L, ratio: P });
      }
      break;
    default:
      qt.warn(`Interpolation ${t} not supported`)();
      break;
  }
}
function Qfe(r, e, t, n, i) {
  if (!r[e])
    throw new Error();
  if (e === "rotation") {
    k1.slerp({ start: t, target: n, ratio: i });
    for (let s = 0; s < k1.length; s++)
      r[e][s] = k1[s];
  } else
    for (let s = 0; s < t.length; s++)
      r[e][s] = i * n[s] + (1 - i) * t[s];
}
function Jfe(r, e, { p0: t, outTangent0: n, inTangent1: i, p1: s, tDiff: o, ratio: l }) {
  if (!r[e])
    throw new Error();
  for (let u = 0; u < r[e].length; u++) {
    const m = n[u] * o, y = i[u] * o;
    r[e][u] = (2 * Math.pow(l, 3) - 3 * Math.pow(l, 2) + 1) * t[u] + (Math.pow(l, 3) - 2 * Math.pow(l, 2) + l) * m + (-2 * Math.pow(l, 3) + 3 * Math.pow(l, 2)) * s[u] + (Math.pow(l, 3) - Math.pow(l, 2)) * y;
  }
}
function ehe(r, e, t) {
  if (!r[e])
    throw new Error();
  for (let n = 0; n < t.length; n++)
    r[e][n] = t[n];
}
class the {
  animation;
  startTime = 0;
  playing = !0;
  speed = 1;
  constructor(e) {
    this.animation = e.animation, this.animation.name ||= "unnamed", Object.assign(this, e);
  }
  setTime(e) {
    if (!this.playing)
      return;
    const n = (e / 1e3 - this.startTime) * this.speed;
    this.animation.channels.forEach(({ sampler: i, target: s, path: o }) => {
      Kfe(n, i, s, o), ihe(s, s._node);
    });
  }
}
class rhe {
  animations;
  constructor(e) {
    this.animations = e.animations.map((t, n) => {
      const i = t.name || `Animation-${n}`;
      return new the({
        animation: { name: i, channels: t.channels }
      });
    });
  }
  /** @deprecated Use .setTime(). Will be removed (deck.gl is using this) */
  animate(e) {
    qt.warn("GLTFAnimator#animate is deprecated. Use GLTFAnimator#setTime instead")(), this.setTime(e);
  }
  setTime(e) {
    this.animations.forEach((t) => t.setTime(e));
  }
  getAnimations() {
    return this.animations;
  }
}
const nhe = new xn();
function ihe(r, e) {
  if (e.matrix.identity(), r.translation && e.matrix.translate(r.translation), r.rotation) {
    const t = nhe.fromQuaternion(r.rotation);
    e.matrix.multiplyRight(t);
  }
  r.scale && e.matrix.scale(r.scale);
}
const she = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, ohe = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
function ahe(r) {
  const e = ohe[r.componentType], t = she[r.type], n = t * r.count, { buffer: i, byteOffset: s = 0 } = r.bufferView?.data ?? {};
  return { typedArray: new e(i, s + (r.byteOffset || 0), n), components: t };
}
function lhe(r) {
  return (r.animations || []).map((t, n) => {
    const i = t.name || `Animation-${n}`, s = t.samplers.map(({ input: l, interpolation: u = "LINEAR", output: m }) => ({
      input: BM(r.accessors[l]),
      interpolation: u,
      output: BM(r.accessors[m])
    })), o = t.channels.map(({ sampler: l, target: u }) => ({
      sampler: s[l],
      target: r.nodes[u.node ?? 0],
      path: u.path
    }));
    return { name: i, channels: o };
  });
}
function BM(r) {
  if (!r._animation) {
    const { typedArray: e, components: t } = ahe(r);
    if (t === 1)
      r._animation = Array.from(e);
    else {
      const n = [];
      for (let i = 0; i < e.length; i += t)
        n.push(Array.from(e.slice(i, i + t)));
      r._animation = n;
    }
  }
  return r._animation;
}
function O2(r) {
  if (ArrayBuffer.isView(r) || r instanceof ArrayBuffer || r instanceof ImageBitmap)
    return r;
  if (Array.isArray(r))
    return r.map(O2);
  if (r && typeof r == "object") {
    const e = {};
    for (const t in r)
      e[t] = O2(r[t]);
    return e;
  }
  return r;
}
function che(r, e, t) {
  e = O2(e);
  const n = $fe(r, e, t), i = lhe(e), s = new rhe({ animations: i });
  return { scenes: n, animator: s };
}
async function uhe(r) {
  const e = [];
  return r.scenes.forEach((t) => {
    t.traverse((n) => {
    });
  }), await fhe(() => e.some((t) => !t.loaded));
}
async function fhe(r) {
  for (; r(); )
    await new Promise((e) => requestAnimationFrame(e));
}
const OM = `uniform scenegraphUniforms {
  float sizeScale;
  float sizeMinPixels;
  float sizeMaxPixels;
  mat4 sceneModelMatrix;
  bool composeModelMatrix;
} scenegraph;
`, hhe = {
  name: "scenegraph",
  vs: OM,
  fs: OM,
  uniformTypes: {
    sizeScale: "f32",
    sizeMinPixels: "f32",
    sizeMaxPixels: "f32",
    sceneModelMatrix: "mat4x4<f32>",
    composeModelMatrix: "f32"
  }
}, dhe = `#version 300 es
#define SHADER_NAME scenegraph-layer-vertex-shader
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;
in vec3 instanceTranslation;
in vec3 positions;
#ifdef HAS_UV
in vec2 texCoords;
#endif
#ifdef LIGHTING_PBR
#ifdef HAS_NORMALS
in vec3 normals;
#endif
#endif
out vec4 vColor;
#ifndef LIGHTING_PBR
#ifdef HAS_UV
out vec2 vTEXCOORD_0;
#endif
#endif
void main(void) {
#if defined(HAS_UV) && !defined(LIGHTING_PBR)
vTEXCOORD_0 = texCoords;
geometry.uv = texCoords;
#endif
geometry.worldPosition = instancePositions;
geometry.pickingColor = instancePickingColors;
mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);
vec3 normal = vec3(0.0, 0.0, 1.0);
#ifdef LIGHTING_PBR
#ifdef HAS_NORMALS
normal = instanceModelMatrix * (scenegraph.sceneModelMatrix * vec4(normals, 0.0)).xyz;
#endif
#endif
float originalSize = project_size_to_pixel(scenegraph.sizeScale);
float clampedSize = clamp(originalSize, scenegraph.sizeMinPixels, scenegraph.sizeMaxPixels);
vec3 pos = (instanceModelMatrix * (scenegraph.sceneModelMatrix * vec4(positions, 1.0)).xyz) * scenegraph.sizeScale * (clampedSize / originalSize) + instanceTranslation;
if(scenegraph.composeModelMatrix) {
DECKGL_FILTER_SIZE(pos, geometry);
geometry.normal = project_normal(normal);
geometry.worldPosition += pos;
gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
}
else {
pos = project_size(pos);
DECKGL_FILTER_SIZE(pos, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, geometry.position);
geometry.normal = project_normal(normal);
}
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
#ifdef LIGHTING_PBR
pbr_vPosition = geometry.position.xyz;
#ifdef HAS_NORMALS
pbr_vNormal = geometry.normal;
#endif
#ifdef HAS_UV
pbr_vUV = texCoords;
#else
pbr_vUV = vec2(0., 0.);
#endif
geometry.uv = pbr_vUV;
#endif
vColor = instanceColors;
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, phe = `#version 300 es
#define SHADER_NAME scenegraph-layer-fragment-shader
in vec4 vColor;
out vec4 fragColor;
#ifndef LIGHTING_PBR
#if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
in vec2 vTEXCOORD_0;
uniform sampler2D pbr_baseColorSampler;
#endif
#endif
void main(void) {
#ifdef LIGHTING_PBR
fragColor = vColor * pbr_filterColor(vec4(0));
geometry.uv = pbr_vUV;
#else
#if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
fragColor = vColor * texture(pbr_baseColorSampler, vTEXCOORD_0);
geometry.uv = vTEXCOORD_0;
#else
fragColor = vColor;
#endif
#endif
fragColor.a *= layer.opacity;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`, hk = [255, 255, 255, 255], Ahe = {
  scenegraph: { type: "object", value: null, async: !0 },
  getScene: (r) => r && r.scenes ? typeof r.scene == "object" ? r.scene : r.scenes[r.scene || 0] : r,
  getAnimator: (r) => r && r.animator,
  _animations: null,
  sizeScale: { type: "number", value: 1, min: 0 },
  sizeMinPixels: { type: "number", min: 0, value: 0 },
  sizeMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
  getPosition: { type: "accessor", value: (r) => r.position },
  getColor: { type: "accessor", value: hk },
  // flat or pbr
  _lighting: "flat",
  // _lighting must be pbr for this to work
  _imageBasedLightingEnvironment: void 0,
  // yaw, pitch and roll are in degrees
  // https://en.wikipedia.org/wiki/Euler_angles
  // [pitch, yaw, roll]
  getOrientation: { type: "accessor", value: [0, 0, 0] },
  getScale: { type: "accessor", value: [1, 1, 1] },
  getTranslation: { type: "accessor", value: [0, 0, 0] },
  // 4x4 matrix
  getTransformMatrix: { type: "accessor", value: [] },
  loaders: [Tp]
};
class P0 extends Is {
  getShaders() {
    const e = {};
    let t;
    this.props._lighting === "pbr" ? (t = Fx, e.LIGHTING_PBR = 1) : t = { name: "pbrMaterial" };
    const n = [Ws, ga, hhe, t];
    return super.getShaders({ defines: e, vs: dhe, fs: phe, modules: n });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        accessor: "getPosition",
        transition: !0
      },
      instanceColors: {
        type: "unorm8",
        size: this.props.colorFormat.length,
        accessor: "getColor",
        defaultValue: hk,
        transition: !0
      },
      instanceModelMatrix: lk
    });
  }
  updateState(e) {
    super.updateState(e);
    const { props: t, oldProps: n } = e;
    t.scenegraph !== n.scenegraph ? this._updateScenegraph() : t._animations !== n._animations && this._applyAnimationsProp(this.state.animator, t._animations);
  }
  finalizeState(e) {
    super.finalizeState(e), this.state.scenegraph?.destroy();
  }
  get isLoaded() {
    return !!(this.state?.scenegraph && super.isLoaded);
  }
  _updateScenegraph() {
    const e = this.props, { device: t } = this.context;
    let n = null;
    if (e.scenegraph instanceof i_)
      n = { scenes: [e.scenegraph] };
    else if (e.scenegraph && typeof e.scenegraph == "object") {
      const l = e.scenegraph, u = l.json ? lw(l) : l, m = che(t, u, this._getModelOptions());
      n = { gltf: u, ...m }, uhe(m).then(() => {
        this.setNeedsRedraw();
      }).catch((y) => {
        this.raiseError(y, "loading glTF");
      });
    }
    const i = { layer: this, device: this.context.device }, s = e.getScene(n, i), o = e.getAnimator(n, i);
    if (s instanceof Lp) {
      this.state.scenegraph?.destroy(), this._applyAnimationsProp(o, e._animations);
      const l = [];
      s.traverse((u) => {
        u instanceof jb && l.push(u.model);
      }), this.setState({ scenegraph: s, animator: o, models: l }), this.getAttributeManager().invalidateAll();
    } else s !== null && Jr.warn("invalid scenegraph:", s)();
  }
  _applyAnimationsProp(e, t) {
    if (!e || !t)
      return;
    const n = e.getAnimations();
    Object.keys(t).sort().forEach((i) => {
      const s = t[i];
      if (i === "*")
        n.forEach((o) => {
          Object.assign(o, s);
        });
      else if (Number.isFinite(Number(i))) {
        const o = Number(i);
        o >= 0 && o < n.length ? Object.assign(n[o], s) : Jr.warn(`animation ${i} not found`)();
      } else {
        const o = n.find(({ animation: l }) => l.name === i);
        o ? Object.assign(o, s) : Jr.warn(`animation ${i} not found`)();
      }
    });
  }
  _getModelOptions() {
    const { _imageBasedLightingEnvironment: e } = this.props;
    let t;
    return e && (typeof e == "function" ? t = e({ gl: this.context.gl, layer: this }) : t = e), {
      imageBasedLightingEnvironment: t,
      modelOptions: {
        id: this.props.id,
        isInstanced: !0,
        bufferLayout: this.getAttributeManager().getBufferLayouts(),
        ...this.getShaders()
      },
      // tangents are not supported
      useTangents: !1
    };
  }
  draw({ context: e }) {
    if (!this.state.scenegraph)
      return;
    this.props._animations && this.state.animator && (this.state.animator.animate(e.timeline.getTime()), this.setNeedsRedraw());
    const { viewport: t, renderPass: n } = this.context, { sizeScale: i, sizeMinPixels: s, sizeMaxPixels: o, coordinateSystem: l } = this.props, u = {
      camera: t.cameraPosition
    }, m = this.getNumInstances();
    this.state.scenegraph.traverse((y, { worldMatrix: E }) => {
      if (y instanceof jb) {
        const { model: P } = y;
        P.setInstanceCount(m);
        const L = {
          sizeScale: i,
          sizeMinPixels: s,
          sizeMaxPixels: o,
          composeModelMatrix: ck(t, l),
          sceneModelMatrix: E
        };
        P.shaderInputs.setProps({
          pbrProjection: u,
          scenegraph: L
        }), P.draw(n);
      }
    });
  }
}
P0.defaultProps = Ahe;
P0.layerName = "ScenegraphLayer";
const ghe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ScenegraphLayer: P0,
  SimpleMeshLayer: uh
}, Symbol.toStringTag, { value: "Module" })), DM = `uniform meshUniforms {
  bool pickFeatureIds;
} mesh;
`, mhe = {
  name: "mesh",
  vs: DM,
  fs: DM,
  uniformTypes: {
    pickFeatureIds: "f32"
  }
}, _he = `#version 300 es
#define SHADER_NAME simple-mesh-layer-vs
in vec3 positions;
in vec3 normals;
in vec3 colors;
in vec2 texCoords;
in vec4 uvRegions;
in vec3 featureIdsPickingColors;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;
out vec2 vTexCoord;
out vec3 cameraPosition;
out vec3 normals_commonspace;
out vec4 position_commonspace;
out vec4 vColor;
vec2 applyUVRegion(vec2 uv) {
#ifdef HAS_UV_REGIONS
return fract(uv) * (uvRegions.zw - uvRegions.xy) + uvRegions.xy;
#else
return uv;
#endif
}
void main(void) {
vec2 uv = applyUVRegion(texCoords);
geometry.uv = uv;
if (mesh.pickFeatureIds) {
geometry.pickingColor = featureIdsPickingColors;
} else {
geometry.pickingColor = instancePickingColors;
}
mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);
vTexCoord = uv;
cameraPosition = project.cameraPosition;
vColor = vec4(colors * instanceColors.rgb, instanceColors.a);
vec3 pos = (instanceModelMatrix * positions) * simpleMesh.sizeScale;
vec3 projectedPosition = project_position(positions);
position_commonspace = vec4(projectedPosition, 1.0);
gl_Position = project_common_position_to_clipspace(position_commonspace);
geometry.position = position_commonspace;
normals_commonspace = project_normal(instanceModelMatrix * normals);
geometry.normal = normals_commonspace;
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
#ifdef MODULE_PBRMATERIAL
pbr_vPosition = geometry.position.xyz;
#ifdef HAS_NORMALS
pbr_vNormal = geometry.normal;
#endif
#ifdef HAS_UV
pbr_vUV = uv;
#else
pbr_vUV = vec2(0., 0.);
#endif
geometry.uv = pbr_vUV;
#endif
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, yhe = `#version 300 es
#define SHADER_NAME simple-mesh-layer-fs
precision highp float;
uniform sampler2D sampler;
in vec2 vTexCoord;
in vec3 cameraPosition;
in vec3 normals_commonspace;
in vec4 position_commonspace;
in vec4 vColor;
out vec4 fragColor;
void main(void) {
#ifdef MODULE_PBRMATERIAL
fragColor = vColor * pbr_filterColor(vec4(0));
geometry.uv = pbr_vUV;
fragColor.a *= layer.opacity;
#else
geometry.uv = vTexCoord;
vec3 normal;
if (simpleMesh.flatShading) {
normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
} else {
normal = normals_commonspace;
}
vec4 color = simpleMesh.hasTexture ? texture(sampler, vTexCoord) : vColor;
vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);
fragColor = vec4(lightColor, color.a * layer.opacity);
#endif
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;
function vhe(r) {
  const e = r.positions || r.POSITION, t = e.value.length / e.size;
  r.COLOR_0 || r.colors || (r.colors = {
    size: 4,
    value: new Uint8Array(t * 4).fill(255),
    normalized: !0
  });
}
const bhe = {
  pbrMaterial: { type: "object", value: null },
  featureIds: { type: "array", value: null, optional: !0 }
};
class Xw extends uh {
  getShaders() {
    const e = super.getShaders();
    return e.modules.push(Fx, mhe), { ...e, vs: _he, fs: yhe };
  }
  initializeState() {
    const { featureIds: e } = this.props;
    super.initializeState();
    const t = this.getAttributeManager();
    e && t.add({
      featureIdsPickingColors: {
        type: "uint8",
        size: 3,
        noAlloc: !0,
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculateFeatureIdsPickingColors
      }
    });
  }
  updateState(e) {
    super.updateState(e);
    const { props: t, oldProps: n } = e;
    t.pbrMaterial !== n.pbrMaterial && this.updatePbrMaterialUniforms(t.pbrMaterial);
  }
  draw(e) {
    const { featureIds: t } = this.props, { model: n } = this.state;
    if (!n)
      return;
    const i = {
      pickFeatureIds: !!t
    }, s = {
      camera: this.context.viewport.cameraPosition
    };
    n.shaderInputs.setProps({
      pbrProjection: s,
      mesh: i
    }), super.draw(e);
  }
  getModel(e) {
    const { id: t } = this.props, n = this.parseMaterial(this.props.pbrMaterial, e);
    this.setState({ parsedPBRMaterial: n });
    const i = this.getShaders();
    return vhe(e.attributes), new Bi(this.context.device, {
      ...this.getShaders(),
      id: t,
      geometry: e,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      defines: {
        ...i.defines,
        ...n?.defines,
        HAS_UV_REGIONS: e.attributes.uvRegions ? 1 : 0
      },
      parameters: n?.parameters,
      isInstanced: !0
    });
  }
  updatePbrMaterialUniforms(e) {
    const { model: t } = this.state;
    if (t) {
      const { mesh: n } = this.props, i = this.parseMaterial(e, n);
      this.setState({ parsedPBRMaterial: i });
      const { pbr_baseColorSampler: s } = i.bindings, { emptyTexture: o } = this.state, l = {
        sampler: s || o,
        hasTexture: !!s
      }, { camera: u, ...m } = {
        ...i.bindings,
        ...i.uniforms
      };
      t.shaderInputs.setProps({ simpleMesh: l, pbrMaterial: m });
    }
  }
  parseMaterial(e, t) {
    const n = !!(e.pbrMetallicRoughness && e.pbrMetallicRoughness.baseColorTexture);
    return uk(this.context.device, { unlit: n, ...e }, { NORMAL: t.attributes.normals, TEXCOORD_0: t.attributes.texCoords }, {
      pbrDebug: !1,
      lights: !0,
      useTangents: !1
    });
  }
  calculateFeatureIdsPickingColors(e) {
    const t = this.props.featureIds, n = new Uint8ClampedArray(t.length * e.size), i = [];
    for (let s = 0; s < t.length; s++)
      this.encodePickingColor(t[s], i), n[s * 3] = i[0], n[s * 3 + 1] = i[1], n[s * 3 + 2] = i[2];
    e.value = n;
  }
  finalizeState(e) {
    super.finalizeState(e), this.state.parsedPBRMaterial?.generatedTextures.forEach((t) => t.destroy()), this.setState({ parsedPBRMaterial: null });
  }
}
Xw.layerName = "MeshLayer";
Xw.defaultProps = bhe;
const xhe = 6378137, whe = 6378137, The = 6356752314245179e-9;
function Ay(r) {
  return r;
}
new yt();
function Ehe(r, e = [], t = Ay) {
  return "longitude" in r ? (e[0] = t(r.longitude), e[1] = t(r.latitude), e[2] = r.height) : "x" in r ? (e[0] = t(r.x), e[1] = t(r.y), e[2] = r.z) : (e[0] = t(r[0]), e[1] = t(r[1]), e[2] = r[2]), e;
}
function Che(r, e = []) {
  return Ehe(r, e, Ss._cartographicRadians ? Ay : K7);
}
function She(r, e, t = Ay) {
  return "longitude" in e ? (e.longitude = t(r[0]), e.latitude = t(r[1]), e.height = r[2]) : "x" in e ? (e.x = t(r[0]), e.y = t(r[1]), e.z = r[2]) : (e[0] = t(r[0]), e[1] = t(r[1]), e[2] = r[2]), e;
}
function Ihe(r, e) {
  return She(r, e, Ss._cartographicRadians ? Ay : Q7);
}
const LM = 1e-14, Phe = new yt(), kM = {
  up: {
    south: "east",
    north: "west",
    west: "south",
    east: "north"
  },
  down: {
    south: "west",
    north: "east",
    west: "north",
    east: "south"
  },
  south: {
    up: "west",
    down: "east",
    west: "down",
    east: "up"
  },
  north: {
    up: "east",
    down: "west",
    west: "up",
    east: "down"
  },
  west: {
    up: "north",
    down: "south",
    north: "down",
    south: "up"
  },
  east: {
    up: "south",
    down: "north",
    north: "up",
    south: "down"
  }
}, F1 = {
  north: [-1, 0, 0],
  east: [0, 1, 0],
  up: [0, 0, 1],
  south: [1, 0, 0],
  west: [0, -1, 0],
  down: [0, 0, -1]
}, TA = {
  east: new yt(),
  north: new yt(),
  up: new yt(),
  west: new yt(),
  south: new yt(),
  down: new yt()
}, Mhe = new yt(), Rhe = new yt(), Bhe = new yt();
function FM(r, e, t, n, i, s) {
  const o = kM[e] && kM[e][t];
  fl(o && (!n || n === o));
  let l, u, m;
  const y = Phe.copy(i);
  if (Aa(y.x, 0, LM) && Aa(y.y, 0, LM)) {
    const P = Math.sign(y.z);
    l = Mhe.fromArray(F1[e]), e !== "east" && e !== "west" && l.scale(P), u = Rhe.fromArray(F1[t]), t !== "east" && t !== "west" && u.scale(P), m = Bhe.fromArray(F1[n]), n !== "east" && n !== "west" && m.scale(P);
  } else {
    const { up: P, east: L, north: U } = TA;
    L.set(-y.y, y.x, 0).normalize(), r.geodeticSurfaceNormal(y, P), U.copy(P).cross(L);
    const { down: V, west: q, south: j } = TA;
    V.copy(P).scale(-1), q.copy(L).scale(-1), j.copy(U).scale(-1), l = TA[e], u = TA[t], m = TA[n];
  }
  return s[0] = l.x, s[1] = l.y, s[2] = l.z, s[3] = 0, s[4] = u.x, s[5] = u.y, s[6] = u.z, s[7] = 0, s[8] = m.x, s[9] = m.y, s[10] = m.z, s[11] = 0, s[12] = y.x, s[13] = y.y, s[14] = y.z, s[15] = 1, s;
}
const Id = new yt(), Ohe = new yt(), Dhe = new yt();
function Lhe(r, e, t = []) {
  const { oneOverRadii: n, oneOverRadiiSquared: i, centerToleranceSquared: s } = e;
  Id.from(r);
  const o = Id.x, l = Id.y, u = Id.z, m = n.x, y = n.y, E = n.z, P = o * o * m * m, L = l * l * y * y, U = u * u * E * E, V = P + L + U, q = Math.sqrt(1 / V);
  if (!Number.isFinite(q))
    return;
  const j = Ohe;
  if (j.copy(r).scale(q), V < s)
    return j.to(t);
  const K = i.x, Y = i.y, de = i.z, ne = Dhe;
  ne.set(j.x * K * 2, j.y * Y * 2, j.z * de * 2);
  let ae = (1 - q) * Id.len() / (0.5 * ne.len()), De = 0, Ge, fe, ve, me;
  do {
    ae -= De, Ge = 1 / (1 + ae * K), fe = 1 / (1 + ae * Y), ve = 1 / (1 + ae * de);
    const X = Ge * Ge, re = fe * fe, Me = ve * ve, ot = X * Ge, be = re * fe, Ue = Me * ve;
    me = P * X + L * re + U * Me - 1;
    const lt = -2 * (P * ot * K + L * be * Y + U * Ue * de);
    De = me / lt;
  } while (Math.abs(me) > mj);
  return Id.scale([Ge, fe, ve]).to(t);
}
const rm = new yt(), NM = new yt(), khe = new yt(), il = new yt(), Fhe = new yt(), nm = new yt();
class yi {
  constructor(e = 0, t = 0, n = 0) {
    this.centerToleranceSquared = gj, fl(e >= 0), fl(t >= 0), fl(n >= 0), this.radii = new yt(e, t, n), this.radiiSquared = new yt(e * e, t * t, n * n), this.radiiToTheFourth = new yt(e * e * e * e, t * t * t * t, n * n * n * n), this.oneOverRadii = new yt(e === 0 ? 0 : 1 / e, t === 0 ? 0 : 1 / t, n === 0 ? 0 : 1 / n), this.oneOverRadiiSquared = new yt(e === 0 ? 0 : 1 / (e * e), t === 0 ? 0 : 1 / (t * t), n === 0 ? 0 : 1 / (n * n)), this.minimumRadius = Math.min(e, t, n), this.maximumRadius = Math.max(e, t, n), this.radiiSquared.z !== 0 && (this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z), Object.freeze(this);
  }
  /** Compares this Ellipsoid against the provided Ellipsoid componentwise */
  equals(e) {
    return this === e || !!(e && this.radii.equals(e.radii));
  }
  /** Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'. */
  toString() {
    return this.radii.toString();
  }
  cartographicToCartesian(e, t = [0, 0, 0]) {
    const n = NM, i = khe, [, , s] = e;
    this.geodeticSurfaceNormalCartographic(e, n), i.copy(this.radiiSquared).scale(n);
    const o = Math.sqrt(n.dot(i));
    return i.scale(1 / o), n.scale(s), i.add(n), i.to(t);
  }
  cartesianToCartographic(e, t = [0, 0, 0]) {
    nm.from(e);
    const n = this.scaleToGeodeticSurface(nm, il);
    if (!n)
      return;
    const i = this.geodeticSurfaceNormal(n, NM), s = Fhe;
    s.copy(nm).subtract(n);
    const o = Math.atan2(i.y, i.x), l = Math.asin(i.z), u = Math.sign(Rx(s, nm)) * vO(s);
    return Ihe([o, l, u], t);
  }
  eastNorthUpToFixedFrame(e, t = new xn()) {
    return FM(this, "east", "north", "up", e, t);
  }
  // Computes a 4x4 transformation matrix from a reference frame centered at
  // the provided origin to the ellipsoid's fixed reference frame.
  localFrameToFixedFrame(e, t, n, i, s = new xn()) {
    return FM(this, e, t, n, i, s);
  }
  geocentricSurfaceNormal(e, t = [0, 0, 0]) {
    return rm.from(e).normalize().to(t);
  }
  geodeticSurfaceNormalCartographic(e, t = [0, 0, 0]) {
    const n = Che(e), i = n[0], s = n[1], o = Math.cos(s);
    return rm.set(o * Math.cos(i), o * Math.sin(i), Math.sin(s)).normalize(), rm.to(t);
  }
  geodeticSurfaceNormal(e, t = [0, 0, 0]) {
    return rm.from(e).scale(this.oneOverRadiiSquared).normalize().to(t);
  }
  /** Scales the provided Cartesian position along the geodetic surface normal
   * so that it is on the surface of this ellipsoid.  If the position is
   * at the center of the ellipsoid, this function returns undefined. */
  scaleToGeodeticSurface(e, t) {
    return Lhe(e, this, t);
  }
  /** Scales the provided Cartesian position along the geocentric surface normal
   * so that it is on the surface of this ellipsoid. */
  scaleToGeocentricSurface(e, t = [0, 0, 0]) {
    il.from(e);
    const n = il.x, i = il.y, s = il.z, o = this.oneOverRadiiSquared, l = 1 / Math.sqrt(n * n * o.x + i * i * o.y + s * s * o.z);
    return il.multiplyScalar(l).to(t);
  }
  /** Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying
   * its components by the result of `Ellipsoid#oneOverRadii` */
  transformPositionToScaledSpace(e, t = [0, 0, 0]) {
    return il.from(e).scale(this.oneOverRadii).to(t);
  }
  /** Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying
   * its components by the result of `Ellipsoid#radii`. */
  transformPositionFromScaledSpace(e, t = [0, 0, 0]) {
    return il.from(e).scale(this.radii).to(t);
  }
  /** Computes a point which is the intersection of the surface normal with the z-axis. */
  getSurfaceNormalIntersectionWithZAxis(e, t = 0, n = [0, 0, 0]) {
    fl(Aa(this.radii.x, this.radii.y, RO)), fl(this.radii.z > 0), il.from(e);
    const i = il.z * (1 - this.squaredXOverSquaredZ);
    if (!(Math.abs(i) >= this.radii.z - t))
      return il.set(0, 0, i).to(n);
  }
}
yi.WGS84 = new yi(xhe, whe, The);
class Nhe {
  item;
  previous;
  next;
  constructor(e, t, n) {
    this.item = e, this.previous = t, this.next = n;
  }
}
class Uhe {
  head = null;
  tail = null;
  _length = 0;
  get length() {
    return this._length;
  }
  /**
   * Adds the item to the end of the list
   * @param {*} [item]
   * @return {DoublyLinkedListNode}
   */
  add(e) {
    const t = new Nhe(e, this.tail, null);
    return this.tail ? (this.tail.next = t, this.tail = t) : (this.head = t, this.tail = t), ++this._length, t;
  }
  /**
   * Removes the given node from the list
   * @param {DoublyLinkedListNode} node
   */
  remove(e) {
    e && (e.previous && e.next ? (e.previous.next = e.next, e.next.previous = e.previous) : e.previous ? (e.previous.next = null, this.tail = e.previous) : e.next ? (e.next.previous = null, this.head = e.next) : (this.head = null, this.tail = null), e.next = null, e.previous = null, --this._length);
  }
  /**
   * Moves nextNode after node
   * @param {DoublyLinkedListNode} node
   * @param {DoublyLinkedListNode} nextNode
   */
  splice(e, t) {
    e !== t && (this.remove(t), this._insert(e, t));
  }
  _insert(e, t) {
    const n = e.next;
    e.next = t, this.tail === e ? this.tail = t : n.previous = t, t.next = n, t.previous = e, ++this._length;
  }
}
class zhe {
  _list;
  _sentinel;
  _trimTiles;
  constructor() {
    this._list = new Uhe(), this._sentinel = this._list.add("sentinel"), this._trimTiles = !1;
  }
  reset() {
    this._list.splice(this._list.tail, this._sentinel);
  }
  touch(e) {
    const t = e._cacheNode;
    t && this._list.splice(this._sentinel, t);
  }
  add(e, t, n) {
    t._cacheNode || (t._cacheNode = this._list.add(t), n && n(e, t));
  }
  unloadTile(e, t, n) {
    const i = t._cacheNode;
    i && (this._list.remove(i), t._cacheNode = null, n && n(e, t));
  }
  unloadTiles(e, t) {
    const n = this._trimTiles;
    this._trimTiles = !1;
    const i = this._list, s = e.maximumMemoryUsage * 1024 * 1024, o = this._sentinel;
    let l = i.head;
    for (; l !== o && (e.gpuMemoryUsageInBytes > s || n); ) {
      const u = l.item;
      l = l.next, this.unloadTile(e, u, t);
    }
  }
  trim() {
    this._trimTiles = !0;
  }
}
function Vhe(r, e) {
  _i(r), _i(e);
  const { rtcCenter: t, gltfUpAxis: n } = e, { computedTransform: i, boundingVolume: { center: s } } = r;
  let o = new xn(i);
  switch (t && o.translate(t), n) {
    case "Z":
      break;
    case "Y":
      const E = new xn().rotateX(Math.PI / 2);
      o = o.multiplyRight(E);
      break;
    case "X":
      const P = new xn().rotateY(-Math.PI / 2);
      o = o.multiplyRight(P);
      break;
  }
  e.isQuantized && o.translate(e.quantizedVolumeOffset).scale(e.quantizedVolumeScale);
  const l = new yt(s);
  e.cartesianModelMatrix = o, e.cartesianOrigin = l;
  const u = yi.WGS84.cartesianToCartographic(l, new yt()), y = yi.WGS84.eastNorthUpToFixedFrame(l).invert();
  e.cartographicModelMatrix = y.multiplyRight(o), e.cartographicOrigin = u, e.coordinateSystem || (e.modelMatrix = e.cartographicModelMatrix);
}
const UM = new yt(), N1 = new yt(), D2 = new pa([
  new ul(),
  new ul(),
  new ul(),
  new ul(),
  new ul(),
  new ul()
]);
function jhe(r, e) {
  const { cameraDirection: t, cameraUp: n, height: i } = r, { metersPerUnit: s } = r.distanceScales, o = Nm(r, r.center), l = yi.WGS84.eastNorthUpToFixedFrame(o), u = r.unprojectPosition(r.cameraPosition), m = yi.WGS84.cartographicToCartesian(u, new yt()), y = new yt(
    // @ts-ignore
    l.transformAsVector(new yt(t).scale(s))
  ).normalize(), E = new yt(
    // @ts-ignore
    l.transformAsVector(new yt(n).scale(s))
  ).normalize();
  Ghe(r);
  const P = r.constructor, { longitude: L, latitude: U, width: V, bearing: q, zoom: j } = r, K = new P({
    longitude: L,
    latitude: U,
    height: i,
    width: V,
    bearing: q,
    zoom: j,
    pitch: 0
  });
  return {
    camera: {
      position: m,
      direction: y,
      up: E
    },
    viewport: r,
    topDownViewport: K,
    height: i,
    cullingVolume: D2,
    frameNumber: e,
    // TODO: This can be the same between updates, what number is unique for between updates?
    sseDenominator: 1.15
    // Assumes fovy = 60 degrees
  };
}
function Hhe(r, e, t) {
  if (t === 0 || r.length <= t)
    return [r, []];
  const n = [], { longitude: i, latitude: s } = e.viewport;
  for (const [m, y] of r.entries()) {
    const [E, P] = y.header.mbs, L = Math.abs(i - E), U = Math.abs(s - P), V = Math.sqrt(U * U + L * L);
    n.push([m, V]);
  }
  const o = n.sort((m, y) => m[1] - y[1]), l = [];
  for (let m = 0; m < t; m++)
    l.push(r[o[m][0]]);
  const u = [];
  for (let m = t; m < o.length; m++)
    u.push(r[o[m][0]]);
  return [l, u];
}
function Ghe(r) {
  const e = r.getFrustumPlanes(), t = zM(e.near, r.cameraPosition), n = Nm(r, t), i = Nm(r, r.cameraPosition, N1);
  let s = 0;
  D2.planes[s++].fromPointNormal(n, UM.copy(n).subtract(i));
  for (const o in e) {
    if (o === "near")
      continue;
    const l = e[o], u = zM(l, t, N1), m = Nm(r, u, N1);
    D2.planes[s++].fromPointNormal(
      m,
      // Want the normal to point into the frustum since that's what culling expects
      UM.copy(n).subtract(m)
    );
  }
}
function zM(r, e, t = new yt()) {
  const n = r.normal.dot(e);
  return t.copy(r.normal).scale(r.distance - n).add(e), t;
}
function Nm(r, e, t = new yt()) {
  const n = r.unprojectPosition(e);
  return yi.WGS84.cartographicToCartesian(n, t);
}
const Whe = 6378137, $he = 6378137, L2 = 6356752314245179e-9, rp = new yt();
function qhe(r, e) {
  if (r instanceof I0) {
    const { halfAxes: t } = r, n = Zhe(t);
    return Math.log2(L2 / (n + e[2]));
  } else if (r instanceof S0) {
    const { radius: t } = r;
    return Math.log2(L2 / (t + e[2]));
  } else if (r.width && r.height) {
    const { width: t, height: n } = r, i = Math.log2(Whe / t), s = Math.log2($he / n);
    return (i + s) / 2;
  }
  return 1;
}
function dk(r, e, t) {
  yi.WGS84.cartographicToCartesian([r.xmax, r.ymax, r.zmax], rp);
  const n = Math.sqrt(Math.pow(rp[0] - t[0], 2) + Math.pow(rp[1] - t[1], 2) + Math.pow(rp[2] - t[2], 2));
  return Math.log2(L2 / (n + e[2]));
}
function Xhe(r, e, t) {
  const [n, i, s, o] = r;
  return dk({ xmax: s, ymax: o, zmax: 0 }, e, t);
}
function Zhe(r) {
  r.getColumn(0, rp);
  const e = r.getColumn(1), t = r.getColumn(2);
  return rp.add(e).add(t).len();
}
const ca = {
  UNLOADED: 0,
  // Has never been requested
  LOADING: 1,
  // Is waiting on a pending request
  PROCESSING: 2,
  // Request received.  Contents are being processed for rendering.  Depending on the content, it might make its own requests for external data.
  READY: 3,
  // Ready to render.
  EXPIRED: 4,
  // Is expired and will be unloaded once new content is loaded.
  FAILED: 5
  // Request failed.
};
var yl;
(function(r) {
  r[r.ADD = 1] = "ADD", r[r.REPLACE = 2] = "REPLACE";
})(yl || (yl = {}));
var Xc;
(function(r) {
  r.EMPTY = "empty", r.SCENEGRAPH = "scenegraph", r.POINTCLOUD = "pointcloud", r.MESH = "mesh";
})(Xc || (Xc = {}));
var Xo;
(function(r) {
  r.I3S = "I3S", r.TILES3D = "TILES3D";
})(Xo || (Xo = {}));
var Pp;
(function(r) {
  r.GEOMETRIC_ERROR = "geometricError", r.MAX_SCREEN_THRESHOLD = "maxScreenThreshold";
})(Pp || (Pp = {}));
const Yhe = {
  USE_OPTIMIZATION: 1
};
function pk(r) {
  return r != null;
}
const _o = new yt(), Um = new yt(), Khe = new yt(), Qhe = new yt(), Ff = new yt(), VM = new yt(), jM = new yt(), HM = new yt();
function U1(r, e, t) {
  if (_i(r, "3D Tile: boundingVolume must be defined"), r.box)
    return Ak(r.box, e, t);
  if (r.region)
    return tde(r.region);
  if (r.sphere)
    return ede(r.sphere, e, t);
  throw new Error("3D Tile: boundingVolume must contain a sphere, region, or box");
}
function Jhe(r, e) {
  if (r.box)
    return rde(e);
  if (r.region) {
    const [t, n, i, s, o, l] = r.region;
    return [
      [cl(t), cl(n), o],
      [cl(i), cl(s), l]
    ];
  }
  if (r.sphere)
    return nde(e);
  throw new Error("Unkown boundingVolume type");
}
function Ak(r, e, t) {
  const n = new yt(r[0], r[1], r[2]);
  e.transform(n, n);
  let i = [];
  if (r.length === 10) {
    const m = r.slice(3, 6), y = new r0();
    y.fromArray(r, 6);
    const E = new yt([1, 0, 0]), P = new yt([0, 1, 0]), L = new yt([0, 0, 1]);
    E.transformByQuaternion(y), E.scale(m[0]), P.transformByQuaternion(y), P.scale(m[1]), L.transformByQuaternion(y), L.scale(m[2]), i = [...E.toArray(), ...P.toArray(), ...L.toArray()];
  } else
    i = [...r.slice(3, 6), ...r.slice(6, 9), ...r.slice(9, 12)];
  const s = e.transformAsVector(i.slice(0, 3)), o = e.transformAsVector(i.slice(3, 6)), l = e.transformAsVector(i.slice(6, 9)), u = new es([
    s[0],
    s[1],
    s[2],
    o[0],
    o[1],
    o[2],
    l[0],
    l[1],
    l[2]
  ]);
  return pk(t) ? (t.center = n, t.halfAxes = u, t) : new I0(n, u);
}
function ede(r, e, t) {
  const n = new yt(r[0], r[1], r[2]);
  e.transform(n, n);
  const i = e.getScale(Um), s = Math.max(Math.max(i[0], i[1]), i[2]), o = r[3] * s;
  return pk(t) ? (t.center = n, t.radius = o, t) : new S0(n, o);
}
function tde(r) {
  const [e, t, n, i, s, o] = r, l = yi.WGS84.cartographicToCartesian([cl(e), cl(i), s], Khe), u = yi.WGS84.cartographicToCartesian([cl(n), cl(t), o], Qhe), m = new yt().addVectors(l, u).multiplyByScalar(0.5);
  return yi.WGS84.cartesianToCartographic(m, Ff), yi.WGS84.cartographicToCartesian([cl(n), Ff[1], Ff[2]], VM), yi.WGS84.cartographicToCartesian([Ff[0], cl(i), Ff[2]], jM), yi.WGS84.cartographicToCartesian([Ff[0], Ff[1], o], HM), Ak([
    ...m,
    ...VM.subtract(m),
    ...jM.subtract(m),
    ...HM.subtract(m)
  ], new xn());
}
function rde(r) {
  const e = gk(), { halfAxes: t } = r, n = new yt(t.getColumn(0)), i = new yt(t.getColumn(1)), s = new yt(t.getColumn(2));
  for (let o = 0; o < 2; o++) {
    for (let l = 0; l < 2; l++) {
      for (let u = 0; u < 2; u++)
        _o.copy(r.center), _o.add(n), _o.add(i), _o.add(s), mk(e, _o), s.negate();
      i.negate();
    }
    n.negate();
  }
  return e;
}
function nde(r) {
  const e = gk(), { center: t, radius: n } = r, i = yi.WGS84.scaleToGeodeticSurface(t, _o);
  let s;
  i ? s = yi.WGS84.geodeticSurfaceNormal(i) : s = new yt(0, 0, 1);
  let o = new yt(s[2], -s[1], 0);
  o.len() > 0 ? o.normalize() : o = new yt(0, 1, 0);
  const l = o.clone().cross(s);
  for (const u of [o, l, s]) {
    Um.copy(u).scale(n);
    for (let m = 0; m < 2; m++)
      _o.copy(t), _o.add(Um), mk(e, _o), Um.negate();
  }
  return e;
}
function gk() {
  return [
    [1 / 0, 1 / 0, 1 / 0],
    [-1 / 0, -1 / 0, -1 / 0]
  ];
}
function mk(r, e) {
  yi.WGS84.cartesianToCartographic(e, _o), r[0][0] = Math.min(r[0][0], _o[0]), r[0][1] = Math.min(r[0][1], _o[1]), r[0][2] = Math.min(r[0][2], _o[2]), r[1][0] = Math.max(r[1][0], _o[0]), r[1][1] = Math.max(r[1][1], _o[1]), r[1][2] = Math.max(r[1][2], _o[2]);
}
new yt();
new yt();
new xn();
new yt();
new yt();
new yt();
function ide(r, e) {
  const t = r * e;
  return 1 - Math.exp(-(t * t));
}
function sde(r, e) {
  if (r.dynamicScreenSpaceError && r.dynamicScreenSpaceErrorComputedDensity) {
    const t = r.dynamicScreenSpaceErrorComputedDensity, n = r.dynamicScreenSpaceErrorFactor;
    return ide(e, t) * n;
  }
  return 0;
}
function ode(r, e, t) {
  const n = r.tileset, i = r.parent && r.parent.lodMetricValue || r.lodMetricValue, s = t ? i : r.lodMetricValue;
  if (s === 0)
    return 0;
  const o = Math.max(r._distanceToCamera, 1e-7), { height: l, sseDenominator: u } = e, { viewDistanceScale: m } = n.options;
  let y = s * l * (m || 1) / (o * u);
  return y -= sde(n, o), y;
}
const z1 = new yt(), GM = new yt(), Nu = new yt(), WM = new yt(), ade = new yt(), V1 = new xn(), $M = new xn();
function lde(r, e) {
  if (r.lodMetricValue === 0 || isNaN(r.lodMetricValue))
    return "DIG";
  const t = 2 * _k(r, e);
  return t < 2 ? "OUT" : !r.header.children || t <= r.lodMetricValue ? "DRAW" : r.header.children ? "DIG" : "OUT";
}
function _k(r, e) {
  const { topDownViewport: t } = e, n = r.header.mbs[1], i = r.header.mbs[0], s = r.header.mbs[2], o = r.header.mbs[3], l = [...r.boundingVolume.center], u = t.unprojectPosition(t.cameraPosition);
  yi.WGS84.cartographicToCartesian(u, z1), GM.copy(z1).subtract(l).normalize(), yi.WGS84.eastNorthUpToFixedFrame(l, V1), $M.copy(V1).invert(), Nu.copy(z1).transform($M);
  const m = Math.sqrt(Nu[0] * Nu[0] + Nu[1] * Nu[1]), y = m * m / Nu[2];
  WM.copy([Nu[0], Nu[1], y]);
  const P = WM.transform(V1).subtract(l).normalize(), U = GM.cross(P).normalize().scale(o).add(l), V = yi.WGS84.cartesianToCartographic(U), q = t.project([i, n, s]), j = t.project(V);
  return ade.copy(q).subtract(j).magnitude();
}
function cde(r) {
  return {
    assetGltfUpAxis: r.asset && r.asset.gltfUpAxis || "Y"
  };
}
class qM {
  _map = /* @__PURE__ */ new Map();
  _array;
  _length;
  constructor(e = 0) {
    this._array = new Array(e), this._length = e;
  }
  /**
   * Gets or sets the length of the array.
   * If the set length is greater than the length of the internal array, the internal array is resized.
   *
   * @memberof ManagedArray.prototype
   * @type Number
   */
  get length() {
    return this._length;
  }
  set length(e) {
    this._length = e, e > this._array.length && (this._array.length = e);
  }
  /**
   * Gets the internal array.
   *
   * @memberof ManagedArray.prototype
   * @type Array
   * @readonly
   */
  get values() {
    return this._array;
  }
  /**
   * Gets the element at an index.
   *
   * @param {Number} index The index to get.
   */
  get(e) {
    return _i(e < this._array.length), this._array[e];
  }
  /**
   * Sets the element at an index. Resizes the array if index is greater than the length of the array.
   *
   * @param {Number} index The index to set.
   * @param {*} element The element to set at index.
   */
  set(e, t) {
    _i(e >= 0), e >= this.length && (this.length = e + 1), this._map.has(this._array[e]) && this._map.delete(this._array[e]), this._array[e] = t, this._map.set(t, e);
  }
  delete(e) {
    const t = this._map.get(e);
    t >= 0 && (this._array.splice(t, 1), this._map.delete(e), this.length--);
  }
  /**
   * Returns the last element in the array without modifying the array.
   *
   * @returns {*} The last element in the array.
   */
  peek() {
    return this._array[this._length - 1];
  }
  /**
   * Push an element into the array.
   *
   * @param {*} element The element to push.
   */
  push(e) {
    if (!this._map.has(e)) {
      const t = this.length++;
      this._array[t] = e, this._map.set(e, t);
    }
  }
  /**
   * Pop an element from the array.
   *
   * @returns {*} The last element in the array.
   */
  pop() {
    const e = this._array[--this.length];
    return this._map.delete(e), e;
  }
  /**
   * Resize the internal array if length > _array.length.
   *
   * @param {Number} length The length.
   */
  reserve(e) {
    _i(e >= 0), e > this._array.length && (this._array.length = e);
  }
  /**
   * Resize the array.
   *
   * @param {Number} length The length.
   */
  resize(e) {
    _i(e >= 0), this.length = e;
  }
  /**
   * Trim the internal array to the specified length. Defaults to the current length.
   *
   * @param {Number} [length] The length.
   */
  trim(e) {
    e == null && (e = this.length), this._array.length = e;
  }
  reset() {
    this._array = [], this._map = /* @__PURE__ */ new Map(), this._length = 0;
  }
  find(e) {
    return this._map.has(e);
  }
}
const ude = {
  loadSiblings: !1,
  skipLevelOfDetail: !1,
  updateTransforms: !0,
  onTraversalEnd: () => {
  },
  viewportTraversersMap: {},
  basePath: ""
};
class gy {
  options;
  // fulfill in traverse call
  root = null;
  // tiles should be rendered
  selectedTiles = {};
  // tiles should be loaded from server
  requestedTiles = {};
  // tiles does not have render content
  emptyTiles = {};
  lastUpdate = (/* @__PURE__ */ new Date()).getTime();
  updateDebounceTime = 1e3;
  /** temporary storage to hold the traversed tiles during a traversal */
  _traversalStack = new qM();
  _emptyTraversalStack = new qM();
  /** set in every traverse cycle */
  _frameNumber = null;
  // RESULT
  traversalFinished(e) {
    return !0;
  }
  // TODO nested props
  constructor(e) {
    this.options = { ...ude, ...e };
  }
  // tiles should be visible
  traverse(e, t, n) {
    this.root = e, this.options = { ...this.options, ...n }, this.reset(), this.updateTile(e, t), this._frameNumber = t.frameNumber, this.executeTraversal(e, t);
  }
  reset() {
    this.requestedTiles = {}, this.selectedTiles = {}, this.emptyTiles = {}, this._traversalStack.reset(), this._emptyTraversalStack.reset();
  }
  /**
   * Execute traverse
   * Depth-first traversal that traverses all visible tiles and marks tiles for selection.
   * If skipLevelOfDetail is off then a tile does not refine until all children are loaded.
   * This is the traditional replacement refinement approach and is called the base traversal.
   * Tiles that have a greater screen space error than the base screen space error are part of the base traversal,
   * all other tiles are part of the skip traversal. The skip traversal allows for skipping levels of the tree
   * and rendering children and parent tiles simultaneously.
   */
  /* eslint-disable-next-line complexity, max-statements */
  executeTraversal(e, t) {
    const n = this._traversalStack;
    for (e._selectionDepth = 1, n.push(e); n.length > 0; ) {
      const s = n.pop();
      let o = !1;
      this.canTraverse(s, t) && (this.updateChildTiles(s, t), o = this.updateAndPushChildren(s, t, n, s.hasRenderContent ? s._selectionDepth + 1 : s._selectionDepth));
      const l = s.parent, u = !!(!l || l._shouldRefine), m = !o;
      s.hasRenderContent ? s.refine === yl.ADD ? (this.loadTile(s, t), this.selectTile(s, t)) : s.refine === yl.REPLACE && (this.loadTile(s, t), m && this.selectTile(s, t)) : (this.emptyTiles[s.id] = s, this.loadTile(s, t), m && this.selectTile(s, t)), this.touchTile(s, t), s._shouldRefine = o && u;
    }
    const i = (/* @__PURE__ */ new Date()).getTime();
    (this.traversalFinished(t) || i - this.lastUpdate > this.updateDebounceTime) && (this.lastUpdate = i, this.options.onTraversalEnd(t));
  }
  updateChildTiles(e, t) {
    const n = e.children;
    for (const i of n)
      this.updateTile(i, t);
  }
  /* eslint-disable complexity, max-statements */
  updateAndPushChildren(e, t, n, i) {
    const { loadSiblings: s, skipLevelOfDetail: o } = this.options, l = e.children;
    l.sort(this.compareDistanceToCamera.bind(this));
    const u = e.refine === yl.REPLACE && e.hasRenderContent && !o;
    let m = !1, y = !0;
    for (const E of l)
      if (E._selectionDepth = i, E.isVisibleAndInRequestVolume ? (n.find(E) && n.delete(E), n.push(E), m = !0) : (u || s) && (this.loadTile(E, t), this.touchTile(E, t)), u) {
        let P;
        if (E._inRequestVolume ? E.hasRenderContent ? P = E.contentAvailable : P = this.executeEmptyTraversal(E, t) : P = !1, y = y && P, !y)
          return !1;
      }
    return m || (y = !1), y;
  }
  /* eslint-enable complexity, max-statements */
  updateTile(e, t) {
    this.updateTileVisibility(e, t);
  }
  // tile to render in the browser
  selectTile(e, t) {
    this.shouldSelectTile(e) && (e._selectedFrame = t.frameNumber, this.selectedTiles[e.id] = e);
  }
  // tile to load from server
  loadTile(e, t) {
    this.shouldLoadTile(e) && (e._requestedFrame = t.frameNumber, e._priority = e._getPriority(), this.requestedTiles[e.id] = e);
  }
  // cache tile
  touchTile(e, t) {
    e.tileset._cache.touch(e), e._touchedFrame = t.frameNumber;
  }
  // tile should be visible
  // tile should have children
  // tile LoD (level of detail) is not sufficient under current viewport
  canTraverse(e, t) {
    return e.hasChildren ? e.hasTilesetContent ? !e.contentExpired : this.shouldRefine(e, t) : !1;
  }
  shouldLoadTile(e) {
    return e.hasUnloadedContent || e.contentExpired;
  }
  shouldSelectTile(e) {
    return e.contentAvailable && !this.options.skipLevelOfDetail;
  }
  /** Decide if tile LoD (level of detail) is not sufficient under current viewport */
  shouldRefine(e, t, n = !1) {
    let i = e._screenSpaceError;
    return n && (i = e.getScreenSpaceError(t, !0)), i > e.tileset.memoryAdjustedScreenSpaceError;
  }
  updateTileVisibility(e, t) {
    const n = [];
    if (this.options.viewportTraversersMap)
      for (const i in this.options.viewportTraversersMap)
        this.options.viewportTraversersMap[i] === t.viewport.id && n.push(i);
    else
      n.push(t.viewport.id);
    e.updateVisibility(t, n);
  }
  // UTILITIES
  compareDistanceToCamera(e, t) {
    return e._distanceToCamera - t._distanceToCamera;
  }
  anyChildrenVisible(e, t) {
    let n = !1;
    for (const i of e.children)
      i.updateVisibility(t), n = n || i.isVisibleAndInRequestVolume;
    return n;
  }
  // Depth-first traversal that checks if all nearest descendants with content are loaded.
  // Ignores visibility.
  executeEmptyTraversal(e, t) {
    let n = !0;
    const i = this._emptyTraversalStack;
    for (i.push(e); i.length > 0; ) {
      const s = i.pop(), o = !s.hasRenderContent && this.canTraverse(s, t), l = !s.hasRenderContent && s.children.length === 0;
      if (!o && !s.contentAvailable && !l && (n = !1), this.updateTile(s, t), s.isVisibleAndInRequestVolume || (this.loadTile(s, t), this.touchTile(s, t)), o) {
        const u = s.children;
        for (const m of u)
          i.push(m);
      }
    }
    return n;
  }
}
const XM = new yt();
function fde(r) {
  return r != null;
}
class k2 {
  tileset;
  header;
  id;
  url;
  parent;
  /* Specifies the type of refine that is used when traversing this tile for rendering. */
  refine;
  type;
  contentUrl;
  /** Different refinement algorithms used by I3S and 3D tiles */
  lodMetricType = "geometricError";
  /** The error, in meters, introduced if this tile is rendered and its children are not. */
  lodMetricValue = 0;
  /** @todo math.gl is not exporting BoundingVolume base type? */
  boundingVolume = null;
  /**
   * The tile's content.  This represents the actual tile's payload,
   * not the content's metadata in the tileset JSON file.
   */
  content = null;
  contentState = ca.UNLOADED;
  gpuMemoryUsageInBytes = 0;
  /** The tile's children - an array of Tile3D objects. */
  children = [];
  depth = 0;
  viewportIds = [];
  transform = new xn();
  extensions = null;
  /** TODO Cesium 3d tiles specific */
  implicitTiling = null;
  /** Container to store application specific data */
  userData = {};
  computedTransform;
  hasEmptyContent = !1;
  hasTilesetContent = !1;
  traverser = new gy({});
  /** Used by TilesetCache */
  _cacheNode = null;
  _frameNumber = null;
  // TODO Cesium 3d tiles specific
  _expireDate = null;
  _expiredContent = null;
  _boundingBox = void 0;
  /** updated every frame for tree traversal and rendering optimizations: */
  _distanceToCamera = 0;
  _screenSpaceError = 0;
  _visibilityPlaneMask;
  _visible = void 0;
  _contentBoundingVolume;
  _viewerRequestVolume;
  _initialTransform = new xn();
  // Used by traverser, cannot be marked private
  _priority = 0;
  _selectedFrame = 0;
  _requestedFrame = 0;
  _selectionDepth = 0;
  _touchedFrame = 0;
  _centerZDepth = 0;
  _shouldRefine = !1;
  _stackLength = 0;
  _visitedFrame = 0;
  _inRequestVolume = !1;
  _lodJudge = null;
  // TODO i3s specific, needs to remove
  /**
   * @constructs
   * Create a Tile3D instance
   * @param tileset - Tileset3D instance
   * @param header - tile header - JSON loaded from a dataset
   * @param parentHeader - parent Tile3D instance
   * @param extendedId - optional ID to separate copies of a tile for different viewports.
   *    const extendedId = `${tile.id}-${frameState.viewport.id}`;
   */
  // eslint-disable-next-line max-statements
  constructor(e, t, n, i = "") {
    this.header = t, this.tileset = e, this.id = i || t.id, this.url = t.url, this.parent = n, this.refine = this._getRefine(t.refine), this.type = t.type, this.contentUrl = t.contentUrl, this._initializeLodMetric(t), this._initializeTransforms(t), this._initializeBoundingVolumes(t), this._initializeContent(t), this._initializeRenderingState(t), Object.seal(this);
  }
  destroy() {
    this.header = null;
  }
  isDestroyed() {
    return this.header === null;
  }
  get selected() {
    return this._selectedFrame === this.tileset._frameNumber;
  }
  get isVisible() {
    return this._visible;
  }
  get isVisibleAndInRequestVolume() {
    return this._visible && this._inRequestVolume;
  }
  /** Returns true if tile is not an empty tile and not an external tileset */
  get hasRenderContent() {
    return !this.hasEmptyContent && !this.hasTilesetContent;
  }
  /** Returns true if tile has children */
  get hasChildren() {
    return this.children.length > 0 || this.header.children && this.header.children.length > 0;
  }
  /**
   * Determines if the tile's content is ready. This is automatically `true` for
   * tiles with empty content.
   */
  get contentReady() {
    return this.contentState === ca.READY || this.hasEmptyContent;
  }
  /**
   * Determines if the tile has available content to render.  `true` if the tile's
   * content is ready or if it has expired content this renders while new content loads; otherwise,
   */
  get contentAvailable() {
    return !!(this.contentReady && this.hasRenderContent || this._expiredContent && !this.contentFailed);
  }
  /** Returns true if tile has renderable content but it's unloaded */
  get hasUnloadedContent() {
    return this.hasRenderContent && this.contentUnloaded;
  }
  /**
   * Determines if the tile's content has not be requested. `true` if tile's
   * content has not be requested; otherwise, `false`.
   */
  get contentUnloaded() {
    return this.contentState === ca.UNLOADED;
  }
  /**
   * Determines if the tile's content is expired. `true` if tile's
   * content is expired; otherwise, `false`.
   */
  get contentExpired() {
    return this.contentState === ca.EXPIRED;
  }
  // Determines if the tile's content failed to load.  `true` if the tile's
  // content failed to load; otherwise, `false`.
  get contentFailed() {
    return this.contentState === ca.FAILED;
  }
  /**
   * Distance from the tile's bounding volume center to the camera
   */
  get distanceToCamera() {
    return this._distanceToCamera;
  }
  /**
   * Screen space error for LOD selection
   */
  get screenSpaceError() {
    return this._screenSpaceError;
  }
  /**
   * Get bounding box in cartographic coordinates
   * @returns [min, max] each in [longitude, latitude, altitude]
   */
  get boundingBox() {
    return this._boundingBox || (this._boundingBox = Jhe(this.header.boundingVolume, this.boundingVolume)), this._boundingBox;
  }
  /** Get the tile's screen space error. */
  getScreenSpaceError(e, t) {
    switch (this.tileset.type) {
      case Xo.I3S:
        return _k(this, e);
      case Xo.TILES3D:
        return ode(this, e, t);
      default:
        throw new Error("Unsupported tileset type");
    }
  }
  /**
   * Make tile unselected than means it won't be shown
   * but it can be still loaded in memory
   */
  unselect() {
    this._selectedFrame = 0;
  }
  /**
   * Memory usage of tile on GPU
   */
  _getGpuMemoryUsageInBytes() {
    return this.content.gpuMemoryUsageInBytes || this.content.byteLength || 0;
  }
  /*
   * If skipLevelOfDetail is off try to load child tiles as soon as possible so that their parent can refine sooner.
   * Tiles are prioritized by screen space error.
   */
  // eslint-disable-next-line complexity
  _getPriority() {
    const e = this.tileset._traverser, { skipLevelOfDetail: t } = e.options, n = this.refine === yl.ADD || t;
    if (n && !this.isVisible && this._visible !== void 0 || this.tileset._frameNumber - this._touchedFrame >= 1 || this.contentState === ca.UNLOADED)
      return -1;
    const i = this.parent, o = i && (!n || this._screenSpaceError === 0 || i.hasTilesetContent) ? i._screenSpaceError : this._screenSpaceError, l = e.root ? e.root._screenSpaceError : 0;
    return Math.max(l - o, 0);
  }
  /**
   *  Requests the tile's content.
   * The request may not be made if the Request Scheduler can't prioritize it.
   */
  // eslint-disable-next-line max-statements, complexity
  async loadContent() {
    if (this.hasEmptyContent)
      return !1;
    if (this.content)
      return !0;
    this.contentExpired && (this._expireDate = null), this.contentState = ca.LOADING;
    const t = await this.tileset._requestScheduler.scheduleRequest(this.id, this._getPriority.bind(this));
    if (!t)
      return this.contentState = ca.UNLOADED, !1;
    try {
      const n = this.tileset.getTileUrl(this.contentUrl), i = this.tileset.loader, s = {
        ...this.tileset.loadOptions,
        [i.id]: {
          // @ts-expect-error
          ...this.tileset.loadOptions[i.id],
          isTileset: this.type === "json",
          ...this._getLoaderSpecificOptions(i.id)
        }
      };
      return this.content = await Kc(n, i, s), this.tileset.options.contentLoader && await this.tileset.options.contentLoader(this), this._isTileset() && this.tileset._initializeTileHeaders(this.content, this), this.contentState = ca.READY, this._onContentLoaded(), !0;
    } catch (n) {
      throw this.contentState = ca.FAILED, n;
    } finally {
      t.done();
    }
  }
  // Unloads the tile's content.
  unloadContent() {
    return this.content && this.content.destroy && this.content.destroy(), this.content = null, this.header.content && this.header.content.destroy && this.header.content.destroy(), this.header.content = null, this.contentState = ca.UNLOADED, !0;
  }
  /**
   * Update the tile's visibility
   * @param {Object} frameState - frame state for tile culling
   * @param {string[]} viewportIds - a list of viewport ids that show this tile
   * @return {void}
   */
  updateVisibility(e, t) {
    if (this._frameNumber === e.frameNumber)
      return;
    const n = this.parent, i = n ? n._visibilityPlaneMask : pa.MASK_INDETERMINATE;
    if (this.tileset._traverser.options.updateTransforms) {
      const s = n ? n.computedTransform : this.tileset.modelMatrix;
      this._updateTransform(s);
    }
    this._distanceToCamera = this.distanceToTile(e), this._screenSpaceError = this.getScreenSpaceError(e, !1), this._visibilityPlaneMask = this.visibility(e, i), this._visible = this._visibilityPlaneMask !== pa.MASK_OUTSIDE, this._inRequestVolume = this.insideViewerRequestVolume(e), this._frameNumber = e.frameNumber, this.viewportIds = t;
  }
  // Determines whether the tile's bounding volume intersects the culling volume.
  // @param {FrameState} frameState The frame state.
  // @param {Number} parentVisibilityPlaneMask The parent's plane mask to speed up the visibility check.
  // @returns {Number} A plane mask as described above in {@link CullingVolume#computeVisibilityWithPlaneMask}.
  visibility(e, t) {
    const { cullingVolume: n } = e, { boundingVolume: i } = this;
    return n.computeVisibilityWithPlaneMask(i, t);
  }
  // Assuming the tile's bounding volume intersects the culling volume, determines
  // whether the tile's content's bounding volume intersects the culling volume.
  // @param {FrameState} frameState The frame state.
  // @returns {Intersect} The result of the intersection: the tile's content is completely outside, completely inside, or intersecting the culling volume.
  contentVisibility() {
    return !0;
  }
  /**
   * Computes the (potentially approximate) distance from the closest point of the tile's bounding volume to the camera.
   * @param frameState The frame state.
   * @returns {Number} The distance, in meters, or zero if the camera is inside the bounding volume.
   */
  distanceToTile(e) {
    const t = this.boundingVolume;
    return Math.sqrt(Math.max(t.distanceSquaredTo(e.camera.position), 0));
  }
  /**
   * Computes the tile's camera-space z-depth.
   * @param frameState The frame state.
   * @returns The distance, in meters.
   */
  cameraSpaceZDepth({ camera: e }) {
    const t = this.boundingVolume;
    return XM.subVectors(t.center, e.position), e.direction.dot(XM);
  }
  /**
   * Checks if the camera is inside the viewer request volume.
   * @param {FrameState} frameState The frame state.
   * @returns {Boolean} Whether the camera is inside the volume.
   */
  insideViewerRequestVolume(e) {
    const t = this._viewerRequestVolume;
    return !t || t.distanceSquaredTo(e.camera.position) <= 0;
  }
  // TODO Cesium specific
  // Update whether the tile has expired.
  updateExpiration() {
    if (fde(this._expireDate) && this.contentReady && !this.hasEmptyContent) {
      const e = Date.now();
      Date.lessThan(this._expireDate, e) && (this.contentState = ca.EXPIRED, this._expiredContent = this.content);
    }
  }
  get extras() {
    return this.header.extras;
  }
  // INTERNAL METHODS
  _initializeLodMetric(e) {
    "lodMetricType" in e ? this.lodMetricType = e.lodMetricType : (this.lodMetricType = this.parent && this.parent.lodMetricType || this.tileset.lodMetricType, console.warn("3D Tile: Required prop lodMetricType is undefined. Using parent lodMetricType")), "lodMetricValue" in e ? this.lodMetricValue = e.lodMetricValue : (this.lodMetricValue = this.parent && this.parent.lodMetricValue || this.tileset.lodMetricValue, console.warn("3D Tile: Required prop lodMetricValue is undefined. Using parent lodMetricValue"));
  }
  _initializeTransforms(e) {
    this.transform = e.transform ? new xn(e.transform) : new xn();
    const t = this.parent, n = this.tileset, i = t && t.computedTransform ? t.computedTransform.clone() : n.modelMatrix.clone();
    this.computedTransform = new xn(i).multiplyRight(this.transform);
    const s = t && t._initialTransform ? t._initialTransform.clone() : new xn();
    this._initialTransform = new xn(s).multiplyRight(this.transform);
  }
  _initializeBoundingVolumes(e) {
    this._contentBoundingVolume = null, this._viewerRequestVolume = null, this._updateBoundingVolume(e);
  }
  _initializeContent(e) {
    this.content = { _tileset: this.tileset, _tile: this }, this.hasEmptyContent = !0, this.contentState = ca.UNLOADED, this.hasTilesetContent = !1, e.contentUrl && (this.content = null, this.hasEmptyContent = !1);
  }
  // TODO - remove anything not related to basic visibility detection
  _initializeRenderingState(e) {
    this.depth = e.level || (this.parent ? this.parent.depth + 1 : 0), this._shouldRefine = !1, this._distanceToCamera = 0, this._centerZDepth = 0, this._screenSpaceError = 0, this._visibilityPlaneMask = pa.MASK_INDETERMINATE, this._visible = void 0, this._inRequestVolume = !1, this._stackLength = 0, this._selectionDepth = 0, this._frameNumber = 0, this._touchedFrame = 0, this._visitedFrame = 0, this._selectedFrame = 0, this._requestedFrame = 0, this._priority = 0;
  }
  _getRefine(e) {
    return e || this.parent && this.parent.refine || yl.REPLACE;
  }
  _isTileset() {
    return this.contentUrl.indexOf(".json") !== -1;
  }
  _onContentLoaded() {
    switch (this.content && this.content.type) {
      case "vctr":
      case "geom":
        this.tileset._traverser.disableSkipLevelOfDetail = !0;
        break;
    }
    this._isTileset() ? this.hasTilesetContent = !0 : this.gpuMemoryUsageInBytes = this._getGpuMemoryUsageInBytes();
  }
  _updateBoundingVolume(e) {
    this.boundingVolume = U1(e.boundingVolume, this.computedTransform, this.boundingVolume);
    const t = e.content;
    t && (t.boundingVolume && (this._contentBoundingVolume = U1(t.boundingVolume, this.computedTransform, this._contentBoundingVolume)), e.viewerRequestVolume && (this._viewerRequestVolume = U1(e.viewerRequestVolume, this.computedTransform, this._viewerRequestVolume)));
  }
  // Update the tile's transform. The transform is applied to the tile's bounding volumes.
  _updateTransform(e = new xn()) {
    const t = e.clone().multiplyRight(this.transform);
    t.equals(this.computedTransform) || (this.computedTransform = t, this._updateBoundingVolume(this.header));
  }
  // Get options which are applicable only for the particular loader
  _getLoaderSpecificOptions(e) {
    switch (e) {
      case "i3s":
        return {
          ...this.tileset.options.i3s,
          _tileOptions: {
            attributeUrls: this.header.attributeUrls,
            textureUrl: this.header.textureUrl,
            textureFormat: this.header.textureFormat,
            textureLoaderOptions: this.header.textureLoaderOptions,
            materialDefinition: this.header.materialDefinition,
            isDracoGeometry: this.header.isDracoGeometry,
            mbs: this.header.mbs
          },
          _tilesetOptions: {
            store: this.tileset.tileset.store,
            attributeStorageInfo: this.tileset.tileset.attributeStorageInfo,
            fields: this.tileset.tileset.fields
          },
          isTileHeader: !1
        };
      case "3d-tiles":
      case "cesium-ion":
      default:
        return cde(this.tileset.tileset);
    }
  }
}
class hde extends gy {
  compareDistanceToCamera(e, t) {
    return t._distanceToCamera === 0 && e._distanceToCamera === 0 ? t._centerZDepth - e._centerZDepth : t._distanceToCamera - e._distanceToCamera;
  }
  updateTileVisibility(e, t) {
    if (super.updateTileVisibility(e, t), !e.isVisibleAndInRequestVolume)
      return;
    const n = e.children.length > 0;
    if (e.hasTilesetContent && n) {
      const o = e.children[0];
      this.updateTileVisibility(o, t), e._visible = o._visible;
      return;
    }
    if (this.meetsScreenSpaceErrorEarly(e, t)) {
      e._visible = !1;
      return;
    }
    const i = e.refine === yl.REPLACE, s = e._optimChildrenWithinParent === Yhe.USE_OPTIMIZATION;
    if (i && s && n && !this.anyChildrenVisible(e, t)) {
      e._visible = !1;
      return;
    }
  }
  meetsScreenSpaceErrorEarly(e, t) {
    const { parent: n } = e;
    return !n || n.hasTilesetContent || n.refine !== yl.ADD ? !1 : !this.shouldRefine(e, t, !0);
  }
}
class dde {
  frameNumberMap = /* @__PURE__ */ new Map();
  /**
   * Register a new pending tile header for the particular frameNumber
   * @param viewportId
   * @param frameNumber
   */
  register(e, t) {
    const n = this.frameNumberMap.get(e) || /* @__PURE__ */ new Map(), i = n.get(t) || 0;
    n.set(t, i + 1), this.frameNumberMap.set(e, n);
  }
  /**
   * Deregister a pending tile header for the particular frameNumber
   * @param viewportId
   * @param frameNumber
   */
  deregister(e, t) {
    const n = this.frameNumberMap.get(e);
    if (!n)
      return;
    const i = n.get(t) || 1;
    n.set(t, i - 1);
  }
  /**
   * Check is there are no pending tile headers registered for the particular frameNumber
   * @param viewportId
   * @param frameNumber
   * @returns
   */
  isZero(e, t) {
    return (this.frameNumberMap.get(e)?.get(t) || 0) === 0;
  }
}
const j1 = {
  REQUESTED: "REQUESTED",
  COMPLETED: "COMPLETED",
  ERROR: "ERROR"
};
class pde {
  _statusMap;
  pendingTilesRegister = new dde();
  constructor() {
    this._statusMap = {};
  }
  /**
   * Add request to map
   * @param request - node metadata request
   * @param key - unique key
   * @param callback - callback after request completed
   * @param frameState - frameState data
   */
  add(e, t, n, i) {
    if (!this._statusMap[t]) {
      const { frameNumber: s, viewport: { id: o } } = i;
      this._statusMap[t] = { request: e, callback: n, key: t, frameState: i, status: j1.REQUESTED }, this.pendingTilesRegister.register(o, s), e().then((l) => {
        this._statusMap[t].status = j1.COMPLETED;
        const { frameNumber: u, viewport: { id: m } } = this._statusMap[t].frameState;
        this.pendingTilesRegister.deregister(m, u), this._statusMap[t].callback(l, i);
      }).catch((l) => {
        this._statusMap[t].status = j1.ERROR;
        const { frameNumber: u, viewport: { id: m } } = this._statusMap[t].frameState;
        this.pendingTilesRegister.deregister(m, u), n(l);
      });
    }
  }
  /**
   * Update request if it is still actual for the new frameState
   * @param key - unique key
   * @param frameState - frameState data
   */
  update(e, t) {
    if (this._statusMap[e]) {
      const { frameNumber: n, viewport: { id: i } } = this._statusMap[e].frameState;
      this.pendingTilesRegister.deregister(i, n);
      const { frameNumber: s, viewport: { id: o } } = t;
      this.pendingTilesRegister.register(o, s), this._statusMap[e].frameState = t;
    }
  }
  /**
   * Find request in the map
   * @param key - unique key
   * @returns
   */
  find(e) {
    return this._statusMap[e];
  }
  /**
   * Check it there are pending tile headers for the particular frameNumber
   * @param viewportId
   * @param frameNumber
   * @returns
   */
  hasPendingTiles(e, t) {
    return !this.pendingTilesRegister.isZero(e, t);
  }
}
class Ade extends gy {
  _tileManager;
  constructor(e) {
    super(e), this._tileManager = new pde();
  }
  /**
   * Check if there are no penging tile header requests,
   * that means the traversal is finished and we can call
   * following-up callbacks.
   */
  traversalFinished(e) {
    return !this._tileManager.hasPendingTiles(e.viewport.id, this._frameNumber || 0);
  }
  shouldRefine(e, t) {
    return e._lodJudge = lde(e, t), e._lodJudge === "DIG";
  }
  updateChildTiles(e, t) {
    const n = e.header.children || [], i = e.children, s = e.tileset;
    for (const o of n) {
      const l = `${o.id}-${t.viewport.id}`, u = i && i.find((m) => m.id === l);
      if (u)
        u && this.updateTile(u, t);
      else {
        let m = () => this._loadTile(o.id, s);
        this._tileManager.find(l) ? this._tileManager.update(l, t) : (s.tileset.nodePages && (m = () => s.tileset.nodePagesTile.formTileFromNodePages(o.id)), this._tileManager.add(m, l, (E) => this._onTileLoad(E, e, l), t));
      }
    }
    return !1;
  }
  async _loadTile(e, t) {
    const { loader: n } = t, i = t.getTileUrl(`${t.url}/nodes/${e}`), s = {
      ...t.loadOptions,
      i3s: {
        ...t.loadOptions.i3s,
        isTileHeader: !0
      }
    };
    return await Kc(i, n, s);
  }
  /**
   * The callback to init Tile3D instance after loading the tile JSON
   * @param {Object} header - the tile JSON from a dataset
   * @param {Tile3D} tile - the parent Tile3D instance
   * @param {string} extendedId - optional ID to separate copies of a tile for different viewports.
   *                              const extendedId = `${tile.id}-${frameState.viewport.id}`;
   * @return {void}
   */
  _onTileLoad(e, t, n) {
    const i = new k2(t.tileset, e, t, n);
    t.children.push(i);
    const s = this._tileManager.find(i.id).frameState;
    this.updateTile(i, s), this._frameNumber === s.frameNumber && (this.traversalFinished(s) || (/* @__PURE__ */ new Date()).getTime() - this.lastUpdate > this.updateDebounceTime) && this.executeTraversal(i, s);
  }
}
const gde = {
  description: "",
  ellipsoid: yi.WGS84,
  modelMatrix: new xn(),
  throttleRequests: !0,
  maxRequests: 64,
  /** Default memory values optimized for viewing mesh-based 3D Tiles on both mobile and desktop devices */
  maximumMemoryUsage: 32,
  memoryCacheOverflow: 1,
  maximumTilesSelected: 0,
  debounceTime: 0,
  onTileLoad: () => {
  },
  onTileUnload: () => {
  },
  onTileError: () => {
  },
  onTraversalComplete: (r) => r,
  contentLoader: void 0,
  viewDistanceScale: 1,
  maximumScreenSpaceError: 8,
  memoryAdjustedScreenSpaceError: !1,
  loadTiles: !0,
  updateTransforms: !0,
  viewportTraversersMap: null,
  loadOptions: { fetch: {} },
  attributions: [],
  basePath: "",
  i3s: {}
}, im = "Tiles In Tileset(s)", H1 = "Tiles In Memory", ZM = "Tiles In View", YM = "Tiles To Render", KM = "Tiles Loaded", G1 = "Tiles Loading", QM = "Tiles Unloaded", JM = "Failed Tile Loads", eR = "Points/Vertices", W1 = "Tile Memory Use", tR = "Maximum Screen Space Error";
class mde {
  // props: Tileset3DProps;
  options;
  loadOptions;
  type;
  tileset;
  loader;
  url;
  basePath;
  modelMatrix;
  ellipsoid;
  lodMetricType;
  lodMetricValue;
  refine;
  root = null;
  roots = {};
  /** @todo any->unknown */
  asset = {};
  // Metadata for the entire tileset
  description = "";
  properties;
  extras = null;
  attributions = {};
  credits = {};
  stats;
  /** flags that contain information about data types in nested tiles */
  contentFormats = { draco: !1, meshopt: !1, dds: !1, ktx2: !1 };
  // view props
  cartographicCenter = null;
  cartesianCenter = null;
  zoom = 1;
  boundingVolume = null;
  /** Updated based on the camera position and direction */
  dynamicScreenSpaceErrorComputedDensity = 0;
  // METRICS
  /**
   * The maximum amount of GPU memory (in MB) that may be used to cache tiles
   * Tiles not in view are unloaded to enforce private
   */
  maximumMemoryUsage = 32;
  /** The total amount of GPU memory in bytes used by the tileset. */
  gpuMemoryUsageInBytes = 0;
  /**
   * If loading the level of detail required by maximumScreenSpaceError
   * results in the memory usage exceeding maximumMemoryUsage (GPU), level of detail refinement
   * will instead use this (larger) adjusted screen space error to achieve the
   * best possible visual quality within the available memory.
   */
  memoryAdjustedScreenSpaceError = 0;
  _cacheBytes = 0;
  _cacheOverflowBytes = 0;
  /** Update tracker. increase in each update cycle. */
  _frameNumber = 0;
  _queryParams = {};
  _extensionsUsed = [];
  _tiles = {};
  /** counter for tracking tiles requests */
  _pendingCount = 0;
  /** Hold traversal results */
  selectedTiles = [];
  // TRAVERSAL
  traverseCounter = 0;
  geometricError = 0;
  lastUpdatedVieports = null;
  _requestedTiles = [];
  _emptyTiles = [];
  frameStateData = {};
  _traverser;
  _cache = new zhe();
  _requestScheduler;
  // Promise tracking
  updatePromise = null;
  tilesetInitializationPromise;
  /**
   * Create a new Tileset3D
   * @param json
   * @param props
   */
  // eslint-disable-next-line max-statements
  constructor(e, t) {
    this.options = { ...gde, ...t }, this.tileset = e, this.loader = e.loader, this.type = e.type, this.url = e.url, this.basePath = e.basePath || J2(this.url), this.modelMatrix = this.options.modelMatrix, this.ellipsoid = this.options.ellipsoid, this.lodMetricType = e.lodMetricType, this.lodMetricValue = e.lodMetricValue, this.refine = e.root.refine, this.loadOptions = this.options.loadOptions || {}, this._traverser = this._initializeTraverser(), this._requestScheduler = new aB({
      throttleRequests: this.options.throttleRequests,
      maxRequests: this.options.maxRequests
    }), this.memoryAdjustedScreenSpaceError = this.options.maximumScreenSpaceError, this._cacheBytes = this.options.maximumMemoryUsage * 1024 * 1024, this._cacheOverflowBytes = this.options.memoryCacheOverflow * 1024 * 1024, this.stats = new Bp({ id: this.url }), this._initializeStats(), this.tilesetInitializationPromise = this._initializeTileSet(e);
  }
  /** Release resources */
  destroy() {
    this._destroy();
  }
  /** Is the tileset loaded (update needs to have been called at least once) */
  isLoaded() {
    return this._pendingCount === 0 && this._frameNumber !== 0 && this._requestedTiles.length === 0;
  }
  get tiles() {
    return Object.values(this._tiles);
  }
  get frameNumber() {
    return this._frameNumber;
  }
  get queryParams() {
    return new URLSearchParams(this._queryParams).toString();
  }
  setProps(e) {
    this.options = { ...this.options, ...e };
  }
  /** @deprecated */
  // setOptions(options: Tileset3DProps): void {
  //   this.options = {...this.options, ...options};
  // }
  /**
   * Return a loadable tile url for a specific tile subpath
   * @param tilePath a tile subpath
   */
  getTileUrl(e) {
    if (e.startsWith("data:"))
      return e;
    let n = e;
    return this.queryParams.length && (n = `${e}${e.includes("?") ? "&" : "?"}${this.queryParams}`), n;
  }
  // TODO CESIUM specific
  hasExtension(e) {
    return this._extensionsUsed.indexOf(e) > -1;
  }
  /**
   * Update visible tiles relying on a list of viewports
   * @param viewports - list of viewports
   * @deprecated
   */
  update(e = null) {
    this.tilesetInitializationPromise.then(() => {
      !e && this.lastUpdatedVieports ? e = this.lastUpdatedVieports : this.lastUpdatedVieports = e, e && this.doUpdate(e);
    });
  }
  /**
   * Update visible tiles relying on a list of viewports.
   * Do it with debounce delay to prevent update spam
   * @param viewports viewports
   * @returns Promise of new frameNumber
   */
  async selectTiles(e = null) {
    return await this.tilesetInitializationPromise, e && (this.lastUpdatedVieports = e), this.updatePromise || (this.updatePromise = new Promise((t) => {
      setTimeout(() => {
        this.lastUpdatedVieports && this.doUpdate(this.lastUpdatedVieports), t(this._frameNumber), this.updatePromise = null;
      }, this.options.debounceTime);
    })), this.updatePromise;
  }
  adjustScreenSpaceError() {
    this.gpuMemoryUsageInBytes < this._cacheBytes ? this.memoryAdjustedScreenSpaceError = Math.max(this.memoryAdjustedScreenSpaceError / 1.02, this.options.maximumScreenSpaceError) : this.gpuMemoryUsageInBytes > this._cacheBytes + this._cacheOverflowBytes && (this.memoryAdjustedScreenSpaceError *= 1.02);
  }
  /**
   * Update visible tiles relying on a list of viewports
   * @param viewports viewports
   */
  // eslint-disable-next-line max-statements, complexity
  doUpdate(e) {
    if ("loadTiles" in this.options && !this.options.loadTiles || this.traverseCounter > 0)
      return;
    const t = e instanceof Array ? e : [e];
    this._cache.reset(), this._frameNumber++, this.traverseCounter = t.length;
    const n = [];
    for (const i of t) {
      const s = i.id;
      this._needTraverse(s) ? n.push(s) : this.traverseCounter--;
    }
    for (const i of t) {
      const s = i.id;
      if (this.roots[s] || (this.roots[s] = this._initializeTileHeaders(this.tileset, null)), !n.includes(s))
        continue;
      const o = jhe(i, this._frameNumber);
      this._traverser.traverse(this.roots[s], o, this.options);
    }
  }
  /**
   * Check if traversal is needed for particular viewport
   * @param {string} viewportId - id of a viewport
   * @return {boolean}
   */
  _needTraverse(e) {
    let t = e;
    return this.options.viewportTraversersMap && (t = this.options.viewportTraversersMap[e]), t === e;
  }
  /**
   * The callback to post-process tiles after traversal procedure
   * @param frameState - frame state for tile culling
   */
  _onTraversalEnd(e) {
    const t = e.viewport.id;
    this.frameStateData[t] || (this.frameStateData[t] = { selectedTiles: [], _requestedTiles: [], _emptyTiles: [] });
    const n = this.frameStateData[t], i = Object.values(this._traverser.selectedTiles), [s, o] = Hhe(i, e, this.options.maximumTilesSelected);
    n.selectedTiles = s;
    for (const l of o)
      l.unselect();
    n._requestedTiles = Object.values(this._traverser.requestedTiles), n._emptyTiles = Object.values(this._traverser.emptyTiles), this.traverseCounter--, !(this.traverseCounter > 0) && this._updateTiles();
  }
  /**
   * Update tiles relying on data from all traversers
   */
  _updateTiles() {
    this.selectedTiles = [], this._requestedTiles = [], this._emptyTiles = [];
    for (const e in this.frameStateData) {
      const t = this.frameStateData[e];
      this.selectedTiles = this.selectedTiles.concat(t.selectedTiles), this._requestedTiles = this._requestedTiles.concat(t._requestedTiles), this._emptyTiles = this._emptyTiles.concat(t._emptyTiles);
    }
    this.selectedTiles = this.options.onTraversalComplete(this.selectedTiles);
    for (const e of this.selectedTiles)
      this._tiles[e.id] = e;
    this._loadTiles(), this._unloadTiles(), this._updateStats();
  }
  _tilesChanged(e, t) {
    if (e.length !== t.length)
      return !0;
    const n = new Set(e.map((o) => o.id)), i = new Set(t.map((o) => o.id));
    let s = e.filter((o) => !i.has(o.id)).length > 0;
    return s = s || t.filter((o) => !n.has(o.id)).length > 0, s;
  }
  _loadTiles() {
    for (const e of this._requestedTiles)
      e.contentUnloaded && this._loadTile(e);
  }
  _unloadTiles() {
    this._cache.unloadTiles(this, (e, t) => e._unloadTile(t));
  }
  _updateStats() {
    let e = 0, t = 0;
    for (const n of this.selectedTiles)
      n.contentAvailable && n.content && (e++, n.content.pointCount ? t += n.content.pointCount : t += n.content.vertexCount);
    this.stats.get(ZM).count = this.selectedTiles.length, this.stats.get(YM).count = e, this.stats.get(eR).count = t, this.stats.get(tR).count = this.memoryAdjustedScreenSpaceError;
  }
  async _initializeTileSet(e) {
    this.type === Xo.I3S && (this.calculateViewPropsI3S(), e.root = await e.root), this.root = this._initializeTileHeaders(e, null), this.type === Xo.TILES3D && (this._initializeTiles3DTileset(e), this.calculateViewPropsTiles3D()), this.type === Xo.I3S && this._initializeI3STileset();
  }
  /**
   * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.
   * These metrics help apps center view on tileset
   * For I3S there is extent (<1.8 version) or fullExtent (>=1.8 version) to calculate view props
   * @returns
   */
  calculateViewPropsI3S() {
    const e = this.tileset.fullExtent;
    if (e) {
      const { xmin: n, xmax: i, ymin: s, ymax: o, zmin: l, zmax: u } = e;
      this.cartographicCenter = new yt(n + (i - n) / 2, s + (o - s) / 2, l + (u - l) / 2), this.cartesianCenter = new yt(), yi.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter), this.zoom = dk(e, this.cartographicCenter, this.cartesianCenter);
      return;
    }
    const t = this.tileset.store?.extent;
    if (t) {
      const [n, i, s, o] = t;
      this.cartographicCenter = new yt(n + (s - n) / 2, i + (o - i) / 2, 0), this.cartesianCenter = new yt(), yi.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter), this.zoom = Xhe(t, this.cartographicCenter, this.cartesianCenter);
      return;
    }
    console.warn("Extent is not defined in the tileset header"), this.cartographicCenter = new yt(), this.zoom = 1;
  }
  /**
   * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.
   * These metrics help apps center view on tileset.
   * For 3DTiles the root tile data is used to calculate view props.
   * @returns
   */
  calculateViewPropsTiles3D() {
    const e = this.root, { center: t } = e.boundingVolume;
    if (!t) {
      console.warn("center was not pre-calculated for the root tile"), this.cartographicCenter = new yt(), this.zoom = 1;
      return;
    }
    t[0] !== 0 || t[1] !== 0 || t[2] !== 0 ? (this.cartographicCenter = new yt(), yi.WGS84.cartesianToCartographic(t, this.cartographicCenter)) : this.cartographicCenter = new yt(0, 0, -yi.WGS84.radii[0]), this.cartesianCenter = t, this.zoom = qhe(e.boundingVolume, this.cartographicCenter);
  }
  _initializeStats() {
    this.stats.get(im), this.stats.get(G1), this.stats.get(H1), this.stats.get(ZM), this.stats.get(YM), this.stats.get(KM), this.stats.get(QM), this.stats.get(JM), this.stats.get(eR), this.stats.get(W1, "memory"), this.stats.get(tR);
  }
  // Installs the main tileset JSON file or a tileset JSON file referenced from a tile.
  // eslint-disable-next-line max-statements
  _initializeTileHeaders(e, t) {
    const n = new k2(this, e.root, t);
    if (t && (t.children.push(n), n.depth = t.depth + 1), this.type === Xo.TILES3D) {
      const i = [];
      for (i.push(n); i.length > 0; ) {
        const s = i.pop();
        this.stats.get(im).incrementCount();
        const o = s.header.children || [];
        for (const l of o) {
          const u = new k2(this, l, s);
          if (u.contentUrl?.includes("?session=")) {
            const y = new URL(u.contentUrl).searchParams.get("session");
            y && (this._queryParams.session = y);
          }
          s.children.push(u), u.depth = s.depth + 1, i.push(u);
        }
      }
    }
    return n;
  }
  _initializeTraverser() {
    let e;
    switch (this.type) {
      case Xo.TILES3D:
        e = hde;
        break;
      case Xo.I3S:
        e = Ade;
        break;
      default:
        e = gy;
    }
    return new e({
      basePath: this.basePath,
      onTraversalEnd: this._onTraversalEnd.bind(this)
    });
  }
  _destroyTileHeaders(e) {
    this._destroySubtree(e);
  }
  async _loadTile(e) {
    let t;
    try {
      this._onStartTileLoading(), t = await e.loadContent();
    } catch (n) {
      this._onTileLoadError(e, n instanceof Error ? n : new Error("load failed"));
    } finally {
      this._onEndTileLoading(), this._onTileLoad(e, t);
    }
  }
  _onTileLoadError(e, t) {
    this.stats.get(JM).incrementCount();
    const n = t.message || t.toString(), i = e.url;
    console.error(`A 3D tile failed to load: ${e.url} ${n}`), this.options.onTileError(e, n, i);
  }
  _onTileLoad(e, t) {
    if (t) {
      if (this.type === Xo.I3S) {
        const n = this.tileset?.nodePagesTile?.nodesInNodePages || 0;
        this.stats.get(im).reset(), this.stats.get(im).addCount(n);
      }
      e && e.content && Vhe(e, e.content), this.updateContentTypes(e), this._addTileToCache(e), this.options.onTileLoad(e);
    }
  }
  /**
   * Update information about data types in nested tiles
   * @param tile instance of a nested Tile3D
   */
  updateContentTypes(e) {
    if (this.type === Xo.I3S)
      switch (e.header.isDracoGeometry && (this.contentFormats.draco = !0), e.header.textureFormat) {
        case "dds":
          this.contentFormats.dds = !0;
          break;
        case "ktx2":
          this.contentFormats.ktx2 = !0;
          break;
      }
    else if (this.type === Xo.TILES3D) {
      const { extensionsRemoved: t = [] } = e.content?.gltf || {};
      t.includes("KHR_draco_mesh_compression") && (this.contentFormats.draco = !0), t.includes("EXT_meshopt_compression") && (this.contentFormats.meshopt = !0), t.includes("KHR_texture_basisu") && (this.contentFormats.ktx2 = !0);
    }
  }
  _onStartTileLoading() {
    this._pendingCount++, this.stats.get(G1).incrementCount();
  }
  _onEndTileLoading() {
    this._pendingCount--, this.stats.get(G1).decrementCount();
  }
  _addTileToCache(e) {
    this._cache.add(this, e, (t) => t._updateCacheStats(e));
  }
  _updateCacheStats(e) {
    this.stats.get(KM).incrementCount(), this.stats.get(H1).incrementCount(), this.gpuMemoryUsageInBytes += e.gpuMemoryUsageInBytes || 0, this.stats.get(W1).count = this.gpuMemoryUsageInBytes, this.options.memoryAdjustedScreenSpaceError && this.adjustScreenSpaceError();
  }
  _unloadTile(e) {
    this.gpuMemoryUsageInBytes -= e.gpuMemoryUsageInBytes || 0, this.stats.get(H1).decrementCount(), this.stats.get(QM).incrementCount(), this.stats.get(W1).count = this.gpuMemoryUsageInBytes, this.options.onTileUnload(e), e.unloadContent();
  }
  // Traverse the tree and destroy all tiles
  _destroy() {
    const e = [];
    for (this.root && e.push(this.root); e.length > 0; ) {
      const t = e.pop();
      for (const n of t.children)
        e.push(n);
      this._destroyTile(t);
    }
    this.root = null;
  }
  // Traverse the tree and destroy all sub tiles
  _destroySubtree(e) {
    const t = e, n = [];
    for (n.push(t); n.length > 0; ) {
      e = n.pop();
      for (const i of e.children)
        n.push(i);
      e !== t && this._destroyTile(e);
    }
    t.children = [];
  }
  _destroyTile(e) {
    this._cache.unloadTile(this, e), this._unloadTile(e), e.destroy();
  }
  _initializeTiles3DTileset(e) {
    if (e.queryString) {
      const t = new URLSearchParams(e.queryString), n = Object.fromEntries(t.entries());
      this._queryParams = { ...this._queryParams, ...n };
    }
    if (this.asset = e.asset, !this.asset)
      throw new Error("Tileset must have an asset property.");
    if (this.asset.version !== "0.0" && this.asset.version !== "1.0" && this.asset.version !== "1.1")
      throw new Error("The tileset must be 3D Tiles version either 0.0 or 1.0 or 1.1.");
    "tilesetVersion" in this.asset && (this._queryParams.v = this.asset.tilesetVersion), this.credits = {
      attributions: this.options.attributions || []
    }, this.description = this.options.description || "", this.properties = e.properties, this.geometricError = e.geometricError, this._extensionsUsed = e.extensionsUsed || [], this.extras = e.extras;
  }
  _initializeI3STileset() {
    this.loadOptions.i3s && "token" in this.loadOptions.i3s && (this._queryParams.token = this.loadOptions.i3s.token);
  }
}
const yk = "4.3.3", EA = {
  COMPOSITE: "cmpt",
  POINT_CLOUD: "pnts",
  BATCHED_3D_MODEL: "b3dm",
  INSTANCED_3D_MODEL: "i3dm",
  GLTF: "glTF"
};
function vk(r, e, t) {
  _i(r instanceof ArrayBuffer);
  const n = new TextDecoder("utf8"), i = new Uint8Array(r, e, t);
  return n.decode(i);
}
function _de(r, e = 0) {
  const t = new DataView(r);
  return `${String.fromCharCode(t.getUint8(e + 0))}${String.fromCharCode(t.getUint8(e + 1))}${String.fromCharCode(t.getUint8(e + 2))}${String.fromCharCode(t.getUint8(e + 3))}`;
}
const yde = {
  POINTS: 0,
  // Points. single points.
  LINES: 1,
  // Lines. Each vertex connects to the one after it.
  LINE_LOOP: 2,
  // Lines. Each set of two vertices is treated as a separate line segment.
  LINE_STRIP: 3,
  // Lines/ a connected group of line segments from the first vertex to the last
  TRIANGLES: 4,
  // Triangles. Each set of three vertices creates a separate triangle.
  TRIANGLE_STRIP: 5,
  // Triangles. A connected group of triangles.
  TRIANGLE_FAN: 6
  // Triangles. A connected group of triangles.
  // Each vertex connects to the previous and the first vertex in the fan.
}, ds = {
  BYTE: 5120,
  UNSIGNED_BYTE: 5121,
  SHORT: 5122,
  UNSIGNED_SHORT: 5123,
  INT: 5124,
  UNSIGNED_INT: 5125,
  FLOAT: 5126,
  DOUBLE: 5130
}, jn = {
  ...yde,
  ...ds
}, $1 = {
  [ds.DOUBLE]: Float64Array,
  [ds.FLOAT]: Float32Array,
  [ds.UNSIGNED_SHORT]: Uint16Array,
  [ds.UNSIGNED_INT]: Uint32Array,
  [ds.UNSIGNED_BYTE]: Uint8Array,
  [ds.BYTE]: Int8Array,
  [ds.SHORT]: Int16Array,
  [ds.INT]: Int32Array
}, vde = {
  DOUBLE: ds.DOUBLE,
  FLOAT: ds.FLOAT,
  UNSIGNED_SHORT: ds.UNSIGNED_SHORT,
  UNSIGNED_INT: ds.UNSIGNED_INT,
  UNSIGNED_BYTE: ds.UNSIGNED_BYTE,
  BYTE: ds.BYTE,
  SHORT: ds.SHORT,
  INT: ds.INT
}, q1 = "Failed to convert GL type";
class ic {
  // Signature: fromTypedArray(new Uint8Array())
  // Signature: fromTypedArray(Uint8Array)
  /**
   * Returns the size, in bytes, of the corresponding datatype
   * @param arrayOrType
   * @returns glType a a string
   */
  static fromTypedArray(e) {
    e = ArrayBuffer.isView(e) ? e.constructor : e;
    for (const t in $1)
      if ($1[t] === e)
        return t;
    throw new Error(q1);
  }
  /**
   * Extracts name for glType from array NAME_TO_GL_TYPE
   * @param name
   * @returns glType as a number
   */
  static fromName(e) {
    const t = vde[e];
    if (!t)
      throw new Error(q1);
    return t;
  }
  // Converts GL constant to corresponding typed array type
  // eslint-disable-next-line complexity
  static getArrayType(e) {
    switch (e) {
      /*eslint-disable*/
      // @ts-ignore
      case ds.UNSIGNED_SHORT_5_6_5:
      // @ts-ignore
      case ds.UNSIGNED_SHORT_4_4_4_4:
      // @ts-ignore
      case ds.UNSIGNED_SHORT_5_5_5_1:
        return Uint16Array;
      default:
        const t = $1[e];
        if (!t)
          throw new Error(q1);
        return t;
    }
  }
  /**
   * Returns the size in bytes of one element of the provided WebGL type
   * @param glType
   * @returns size of glType
   */
  static getByteSize(e) {
    return ic.getArrayType(e).BYTES_PER_ELEMENT;
  }
  /**
   * Returns `true` if `glType` is a valid WebGL data type.
   * @param glType
   * @returns boolean
   */
  static validate(e) {
    return !!ic.getArrayType(e);
  }
  /**
   * Creates a typed view of an array of bytes
   * @param glType The type of typed array (ArrayBuffer view) to create
   * @param buffer The buffer storage to use for the view.
   * @param byteOffset The offset, in bytes, to the first element in the view
   * @param length The number of elements in the view. Defaults to buffer length
   * @returns A typed array view of the buffer
   */
  static createTypedArray(e, t, n = 0, i) {
    i === void 0 && (i = (t.byteLength - n) / ic.getByteSize(e));
    const s = ic.getArrayType(e);
    return new s(t, n, i);
  }
}
function bde(r, e) {
  if (!r)
    throw new Error(`math.gl assertion failed. ${e}`);
}
function xde(r, e = [0, 0, 0]) {
  const t = r >> 11 & 31, n = r >> 5 & 63, i = r & 31;
  return e[0] = t << 3, e[1] = n << 2, e[2] = i << 3, e;
}
new Mx();
new yt();
new Mx();
new Mx();
function rR(r, e = 255) {
  return $c(r, 0, e) / e * 2 - 1;
}
function nR(r) {
  return r < 0 ? -1 : 1;
}
function wde(r, e, t, n) {
  if (bde(n), r < 0 || r > t || e < 0 || e > t)
    throw new Error(`x and y must be unsigned normalized integers between 0 and ${t}`);
  if (n.x = rR(r, t), n.y = rR(e, t), n.z = 1 - (Math.abs(n.x) + Math.abs(n.y)), n.z < 0) {
    const i = n.x;
    n.x = (1 - Math.abs(n.y)) * nR(i), n.y = (1 - Math.abs(i)) * nR(n.y);
  }
  return n.normalize();
}
function Tde(r, e, t) {
  return wde(r, e, 255, t);
}
class Zw {
  json;
  buffer;
  featuresLength = 0;
  _cachedTypedArrays = {};
  constructor(e, t) {
    this.json = e, this.buffer = t;
  }
  getExtension(e) {
    return this.json.extensions && this.json.extensions[e];
  }
  hasProperty(e) {
    return !!this.json[e];
  }
  getGlobalProperty(e, t = jn.UNSIGNED_INT, n = 1) {
    const i = this.json[e];
    return i && Number.isFinite(i.byteOffset) ? this._getTypedArrayFromBinary(e, t, n, 1, i.byteOffset) : i;
  }
  getPropertyArray(e, t, n) {
    const i = this.json[e];
    return i && Number.isFinite(i.byteOffset) ? ("componentType" in i && (t = ic.fromName(i.componentType)), this._getTypedArrayFromBinary(e, t, n, this.featuresLength, i.byteOffset)) : this._getTypedArrayFromArray(e, t, i);
  }
  getProperty(e, t, n, i, s) {
    const o = this.json[e];
    if (!o)
      return o;
    const l = this.getPropertyArray(e, t, n);
    if (n === 1)
      return l[i];
    for (let u = 0; u < n; ++u)
      s[u] = l[n * i + u];
    return s;
  }
  // HELPERS
  _getTypedArrayFromBinary(e, t, n, i, s) {
    const o = this._cachedTypedArrays;
    let l = o[e];
    return l || (l = ic.createTypedArray(t, this.buffer.buffer, this.buffer.byteOffset + s, i * n), o[e] = l), l;
  }
  _getTypedArrayFromArray(e, t, n) {
    const i = this._cachedTypedArrays;
    let s = i[e];
    return s || (s = ic.createTypedArray(t, n), i[e] = s), s;
  }
}
const Ede = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, Cde = {
  SCALAR: (r, e) => r[e],
  VEC2: (r, e) => [r[2 * e + 0], r[2 * e + 1]],
  VEC3: (r, e) => [r[3 * e + 0], r[3 * e + 1], r[3 * e + 2]],
  VEC4: (r, e) => [r[4 * e + 0], r[4 * e + 1], r[4 * e + 2], r[4 * e + 3]],
  // TODO: check column major
  MAT2: (r, e) => [
    r[4 * e + 0],
    r[4 * e + 1],
    r[4 * e + 2],
    r[4 * e + 3]
  ],
  MAT3: (r, e) => [
    r[9 * e + 0],
    r[9 * e + 1],
    r[9 * e + 2],
    r[9 * e + 3],
    r[9 * e + 4],
    r[9 * e + 5],
    r[9 * e + 6],
    r[9 * e + 7],
    r[9 * e + 8]
  ],
  MAT4: (r, e) => [
    r[16 * e + 0],
    r[16 * e + 1],
    r[16 * e + 2],
    r[16 * e + 3],
    r[16 * e + 4],
    r[16 * e + 5],
    r[16 * e + 6],
    r[16 * e + 7],
    r[16 * e + 8],
    r[16 * e + 9],
    r[16 * e + 10],
    r[16 * e + 11],
    r[16 * e + 12],
    r[16 * e + 13],
    r[16 * e + 14],
    r[16 * e + 15]
  ]
}, Sde = {
  SCALAR: (r, e, t) => {
    e[t] = r;
  },
  VEC2: (r, e, t) => {
    e[2 * t + 0] = r[0], e[2 * t + 1] = r[1];
  },
  VEC3: (r, e, t) => {
    e[3 * t + 0] = r[0], e[3 * t + 1] = r[1], e[3 * t + 2] = r[2];
  },
  VEC4: (r, e, t) => {
    e[4 * t + 0] = r[0], e[4 * t + 1] = r[1], e[4 * t + 2] = r[2], e[4 * t + 3] = r[3];
  },
  // TODO: check column major correctness
  MAT2: (r, e, t) => {
    e[4 * t + 0] = r[0], e[4 * t + 1] = r[1], e[4 * t + 2] = r[2], e[4 * t + 3] = r[3];
  },
  MAT3: (r, e, t) => {
    e[9 * t + 0] = r[0], e[9 * t + 1] = r[1], e[9 * t + 2] = r[2], e[9 * t + 3] = r[3], e[9 * t + 4] = r[4], e[9 * t + 5] = r[5], e[9 * t + 6] = r[6], e[9 * t + 7] = r[7], e[9 * t + 8] = r[8], e[9 * t + 9] = r[9];
  },
  MAT4: (r, e, t) => {
    e[16 * t + 0] = r[0], e[16 * t + 1] = r[1], e[16 * t + 2] = r[2], e[16 * t + 3] = r[3], e[16 * t + 4] = r[4], e[16 * t + 5] = r[5], e[16 * t + 6] = r[6], e[16 * t + 7] = r[7], e[16 * t + 8] = r[8], e[16 * t + 9] = r[9], e[16 * t + 10] = r[10], e[16 * t + 11] = r[11], e[16 * t + 12] = r[12], e[16 * t + 13] = r[13], e[16 * t + 14] = r[14], e[16 * t + 15] = r[15];
  }
};
function Ide(r, e, t, n) {
  const { componentType: i } = r;
  _i(r.componentType);
  const s = typeof i == "string" ? ic.fromName(i) : i, o = Ede[r.type], l = Cde[r.type], u = Sde[r.type];
  return t += r.byteOffset, {
    values: ic.createTypedArray(s, e, t, o * n),
    type: s,
    size: o,
    unpacker: l,
    packer: u
  };
}
const rc = (r) => r !== void 0;
function Pde(r, e, t) {
  if (!e)
    return null;
  let n = r.getExtension("3DTILES_batch_table_hierarchy");
  const i = e.HIERARCHY;
  return i && (console.warn("3D Tile Parser: HIERARCHY is deprecated. Use 3DTILES_batch_table_hierarchy."), e.extensions = e.extensions || {}, e.extensions["3DTILES_batch_table_hierarchy"] = i, n = i), n ? Mde(n, t) : null;
}
function Mde(r, e) {
  let t, n, i;
  const s = r.instancesLength, o = r.classes;
  let l = r.classIds, u = r.parentCounts, m = r.parentIds, y = s;
  rc(l.byteOffset) && (l.componentType = defaultValue(l.componentType, GL.UNSIGNED_SHORT), l.type = AttributeType.SCALAR, i = getBinaryAccessor(l), l = i.createArrayBufferView(e.buffer, e.byteOffset + l.byteOffset, s));
  let E;
  if (rc(u))
    for (rc(u.byteOffset) && (u.componentType = defaultValue(u.componentType, GL.UNSIGNED_SHORT), u.type = AttributeType.SCALAR, i = getBinaryAccessor(u), u = i.createArrayBufferView(e.buffer, e.byteOffset + u.byteOffset, s)), E = new Uint16Array(s), y = 0, t = 0; t < s; ++t)
      E[t] = y, y += u[t];
  rc(m) && rc(m.byteOffset) && (m.componentType = defaultValue(m.componentType, GL.UNSIGNED_SHORT), m.type = AttributeType.SCALAR, i = getBinaryAccessor(m), m = i.createArrayBufferView(e.buffer, e.byteOffset + m.byteOffset, y));
  const P = o.length;
  for (t = 0; t < P; ++t) {
    const q = o[t].length, j = o[t].instances, K = getBinaryProperties(q, j, e);
    o[t].instances = combine(K, j);
  }
  const L = new Array(P).fill(0), U = new Uint16Array(s);
  for (t = 0; t < s; ++t)
    n = l[t], U[t] = L[n], ++L[n];
  const V = {
    classes: o,
    classIds: l,
    classIndexes: U,
    parentCounts: u,
    parentIndexes: E,
    parentIds: m
  };
  return Ode(V), V;
}
function CA(r, e, t) {
  if (!r)
    return;
  const n = r.parentCounts;
  return r.parentIds ? t(r, e) : n > 0 ? Rde(r, e, t) : Bde(r, e, t);
}
function Rde(r, e, t) {
  const n = r.classIds, i = r.parentCounts, s = r.parentIds, o = r.parentIndexes, l = n.length, u = scratchVisited;
  u.length = Math.max(u.length, l);
  const m = ++marker, y = scratchStack;
  for (y.length = 0, y.push(e); y.length > 0; ) {
    if (e = y.pop(), u[e] === m)
      continue;
    u[e] = m;
    const E = t(r, e);
    if (rc(E))
      return E;
    const P = i[e], L = o[e];
    for (let U = 0; U < P; ++U) {
      const V = s[L + U];
      V !== e && y.push(V);
    }
  }
  return null;
}
function Bde(r, e, t) {
  let n = !0;
  for (; n; ) {
    const i = t(r, e);
    if (rc(i))
      return i;
    const s = r.parentIds[e];
    n = s !== e, e = s;
  }
  throw new Error("traverseHierarchySingleParent");
}
function Ode(r) {
  const t = r.classIds.length;
  for (let n = 0; n < t; ++n)
    bk(r, n, stack);
}
function bk(r, e, t) {
  const n = r.parentCounts, i = r.parentIds, s = r.parentIndexes, l = r.classIds.length;
  if (!rc(i))
    return;
  assert(e < l, `Parent index ${e} exceeds the total number of instances: ${l}`), assert(t.indexOf(e) === -1, "Circular dependency detected in the batch table hierarchy."), t.push(e);
  const u = rc(n) ? n[e] : 1, m = rc(n) ? s[e] : e;
  for (let y = 0; y < u; ++y) {
    const E = i[m + y];
    E !== e && bk(r, E, t);
  }
  t.pop(e);
}
function qo(r) {
  return r != null;
}
const sm = (r, e) => r, Dde = {
  HIERARCHY: !0,
  // Deprecated HIERARCHY property
  extensions: !0,
  extras: !0
};
class xk {
  json;
  binary;
  featureCount;
  _extensions;
  // Copy all top-level property fields from the json object, ignoring special fields
  _properties;
  _binaryProperties;
  // TODO: hierarchy support is only partially implemented and not tested
  _hierarchy;
  constructor(e, t, n, i = {}) {
    _i(n >= 0), this.json = e || {}, this.binary = t, this.featureCount = n, this._extensions = this.json?.extensions || {}, this._properties = {};
    for (const s in this.json)
      Dde[s] || (this._properties[s] = this.json[s]);
    this._binaryProperties = this._initializeBinaryProperties(), i["3DTILES_batch_table_hierarchy"] && (this._hierarchy = Pde(this, this.json, this.binary));
  }
  getExtension(e) {
    return this.json && this.json.extensions && this.json.extensions[e];
  }
  memorySizeInBytes() {
    return 0;
  }
  isClass(e, t) {
    if (this._checkBatchId(e), _i(typeof t == "string", t), this._hierarchy) {
      const n = CA(this._hierarchy, e, (i, s) => {
        const o = i.classIds[s];
        return i.classes[o].name === t;
      });
      return qo(n);
    }
    return !1;
  }
  isExactClass(e, t) {
    return _i(typeof t == "string", t), this.getExactClassName(e) === t;
  }
  getExactClassName(e) {
    if (this._checkBatchId(e), this._hierarchy) {
      const t = this._hierarchy.classIds[e];
      return this._hierarchy.classes[t].name;
    }
  }
  hasProperty(e, t) {
    return this._checkBatchId(e), _i(typeof t == "string", t), qo(this._properties[t]) || this._hasPropertyInHierarchy(e, t);
  }
  getPropertyNames(e, t) {
    this._checkBatchId(e), t = qo(t) ? t : [], t.length = 0;
    const n = Object.keys(this._properties);
    return t.push(...n), this._hierarchy && this._getPropertyNamesInHierarchy(e, t), t;
  }
  getProperty(e, t) {
    if (this._checkBatchId(e), _i(typeof t == "string", t), this._binaryProperties) {
      const i = this._binaryProperties[t];
      if (qo(i))
        return this._getBinaryProperty(i, e);
    }
    const n = this._properties[t];
    if (qo(n))
      return sm(n[e]);
    if (this._hierarchy) {
      const i = this._getHierarchyProperty(e, t);
      if (qo(i))
        return i;
    }
  }
  setProperty(e, t, n) {
    const i = this.featureCount;
    if (this._checkBatchId(e), _i(typeof t == "string", t), this._binaryProperties) {
      const o = this._binaryProperties[t];
      if (o) {
        this._setBinaryProperty(o, e, n);
        return;
      }
    }
    if (this._hierarchy && this._setHierarchyProperty(this, e, t, n))
      return;
    let s = this._properties[t];
    qo(s) || (this._properties[t] = new Array(i), s = this._properties[t]), s[e] = sm(n);
  }
  // PRIVATE METHODS
  _checkBatchId(e) {
    if (!(e >= 0 && e < this.featureCount))
      throw new Error("batchId not in range [0, featureCount - 1].");
  }
  _getBinaryProperty(e, t) {
    return e.unpack(e.typedArray, t);
  }
  _setBinaryProperty(e, t, n) {
    e.pack(n, e.typedArray, t);
  }
  _initializeBinaryProperties() {
    let e = null;
    for (const t in this._properties) {
      const n = this._properties[t], i = this._initializeBinaryProperty(t, n);
      i && (e = e || {}, e[t] = i);
    }
    return e;
  }
  _initializeBinaryProperty(e, t) {
    if ("byteOffset" in t) {
      const n = t;
      _i(this.binary, `Property ${e} requires a batch table binary.`), _i(n.type, `Property ${e} requires a type.`);
      const i = Ide(n, this.binary.buffer, this.binary.byteOffset | 0, this.featureCount);
      return {
        typedArray: i.values,
        componentCount: i.size,
        unpack: i.unpacker,
        pack: i.packer
      };
    }
    return null;
  }
  //  EXTENSION SUPPORT: 3DTILES_batch_table_hierarchy
  _hasPropertyInHierarchy(e, t) {
    if (!this._hierarchy)
      return !1;
    const n = CA(this._hierarchy, e, (i, s) => {
      const o = i.classIds[s], l = i.classes[o].instances;
      return qo(l[t]);
    });
    return qo(n);
  }
  _getPropertyNamesInHierarchy(e, t) {
    CA(this._hierarchy, e, (n, i) => {
      const s = n.classIds[i], o = n.classes[s].instances;
      for (const l in o)
        o.hasOwnProperty(l) && t.indexOf(l) === -1 && t.push(l);
    });
  }
  _getHierarchyProperty(e, t) {
    return CA(this._hierarchy, e, (n, i) => {
      const s = n.classIds[i], o = n.classes[s], l = n.classIndexes[i], u = o.instances[t];
      return qo(u) ? qo(u.typedArray) ? this._getBinaryProperty(u, l) : sm(u[l]) : null;
    });
  }
  _setHierarchyProperty(e, t, n, i) {
    const s = CA(this._hierarchy, t, (o, l) => {
      const u = o.classIds[l], m = o.classes[u], y = o.classIndexes[l], E = m.instances[n];
      return qo(E) ? (_i(l === t, `Inherited property "${n}" is read-only.`), qo(E.typedArray) ? this._setBinaryProperty(E, y, i) : E[y] = sm(i), !0) : !1;
    });
    return qo(s);
  }
}
const X1 = 4;
function my(r, e, t = 0) {
  const n = new DataView(e);
  if (r.magic = n.getUint32(t, !0), t += X1, r.version = n.getUint32(t, !0), t += X1, r.byteLength = n.getUint32(t, !0), t += X1, r.version !== 1)
    throw new Error(`3D Tile Version ${r.version} not supported`);
  return t;
}
const Pd = 4, iR = "b3dm tile in legacy format.";
function Yw(r, e, t) {
  const n = new DataView(e);
  let i;
  r.header = r.header || {};
  let s = n.getUint32(t, !0);
  t += Pd;
  let o = n.getUint32(t, !0);
  t += Pd;
  let l = n.getUint32(t, !0);
  t += Pd;
  let u = n.getUint32(t, !0);
  return t += Pd, l >= 570425344 ? (t -= Pd * 2, i = s, l = o, u = 0, s = 0, o = 0, console.warn(iR)) : u >= 570425344 && (t -= Pd, i = l, l = s, u = o, s = 0, o = 0, console.warn(iR)), r.header.featureTableJsonByteLength = s, r.header.featureTableBinaryByteLength = o, r.header.batchTableJsonByteLength = l, r.header.batchTableBinaryByteLength = u, r.header.batchLength = i, t;
}
function Kw(r, e, t, n) {
  return t = Lde(r, e, t), t = kde(r, e, t), t;
}
function Lde(r, e, t, n) {
  const { featureTableJsonByteLength: i, featureTableBinaryByteLength: s, batchLength: o } = r.header || {};
  if (r.featureTableJson = {
    BATCH_LENGTH: o || 0
  }, i && i > 0) {
    const l = vk(e, t, i);
    r.featureTableJson = JSON.parse(l);
  }
  return t += i || 0, r.featureTableBinary = new Uint8Array(e, t, s), t += s || 0, t;
}
function kde(r, e, t, n) {
  const { batchTableJsonByteLength: i, batchTableBinaryByteLength: s } = r.header || {};
  if (i && i > 0) {
    const o = vk(e, t, i);
    r.batchTableJson = JSON.parse(o), t += i, s && s > 0 && (r.batchTableBinary = new Uint8Array(e, t, s), r.batchTableBinary = new Uint8Array(r.batchTableBinary), t += s);
  }
  return t;
}
function wk(r, e, t) {
  if (!e && (!r || !r.batchIds || !t))
    return null;
  const { batchIds: n, isRGB565: i, pointCount: s = 0 } = r;
  if (n && t) {
    const o = new Uint8ClampedArray(s * 3);
    for (let l = 0; l < s; l++) {
      const u = n[l], y = t.getProperty(u, "dimensions").map((E) => E * 255);
      o[l * 3] = y[0], o[l * 3 + 1] = y[1], o[l * 3 + 2] = y[2];
    }
    return {
      type: jn.UNSIGNED_BYTE,
      value: o,
      size: 3,
      normalized: !0
    };
  }
  if (e && i) {
    const o = new Uint8ClampedArray(s * 3);
    for (let l = 0; l < s; l++) {
      const u = xde(e[l]);
      o[l * 3] = u[0], o[l * 3 + 1] = u[1], o[l * 3 + 2] = u[2];
    }
    return {
      type: jn.UNSIGNED_BYTE,
      value: o,
      size: 3,
      normalized: !0
    };
  }
  return e && e.length === s * 3 ? {
    type: jn.UNSIGNED_BYTE,
    value: e,
    size: 3,
    normalized: !0
  } : {
    type: jn.UNSIGNED_BYTE,
    value: e || new Uint8ClampedArray(),
    size: 4,
    normalized: !0
  };
}
const sR = new yt();
function Fde(r, e) {
  if (!e)
    return null;
  if (r.isOctEncoded16P) {
    const t = new Float32Array((r.pointsLength || 0) * 3);
    for (let n = 0; n < (r.pointsLength || 0); n++)
      Tde(e[n * 2], e[n * 2 + 1], sR), sR.toArray(t, n * 3);
    return {
      type: jn.FLOAT,
      size: 2,
      value: t
    };
  }
  return {
    type: jn.FLOAT,
    size: 2,
    value: e
  };
}
function Nde(r, e, t) {
  return r.isQuantized ? t["3d-tiles"] && t["3d-tiles"].decodeQuantizedPositions ? (r.isQuantized = !1, Ude(r, e)) : {
    type: jn.UNSIGNED_SHORT,
    value: e,
    size: 3,
    normalized: !0
  } : e;
}
function Ude(r, e) {
  const t = new yt(), n = new Float32Array(r.pointCount * 3);
  for (let i = 0; i < r.pointCount; i++)
    t.set(e[i * 3], e[i * 3 + 1], e[i * 3 + 2]).scale(1 / r.quantizedRange).multiply(r.quantizedVolumeScale).add(r.quantizedVolumeOffset).toArray(n, i * 3);
  return n;
}
async function zde(r, e, t, n, i) {
  t = my(r, e, t), t = Yw(r, e, t), t = Kw(r, e, t), Vde(r);
  const { featureTable: s, batchTable: o } = jde(r);
  return await qde(r, s, o, n, i), Hde(r, s, n), Gde(r, s, o), Wde(r, s), t;
}
function Vde(r) {
  r.attributes = {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  }, r.isQuantized = !1, r.isTranslucent = !1, r.isRGB565 = !1, r.isOctEncoded16P = !1;
}
function jde(r) {
  const e = new Zw(r.featureTableJson, r.featureTableBinary), t = e.getGlobalProperty("POINTS_LENGTH");
  if (!Number.isFinite(t))
    throw new Error("POINTS_LENGTH must be defined");
  e.featuresLength = t, r.featuresLength = t, r.pointsLength = t, r.pointCount = t, r.rtcCenter = e.getGlobalProperty("RTC_CENTER", jn.FLOAT, 3);
  const n = $de(r, e);
  return { featureTable: e, batchTable: n };
}
function Hde(r, e, t) {
  if (r.attributes = r.attributes || {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  }, !r.attributes.positions) {
    if (e.hasProperty("POSITION"))
      r.attributes.positions = e.getPropertyArray("POSITION", jn.FLOAT, 3);
    else if (e.hasProperty("POSITION_QUANTIZED")) {
      const n = e.getPropertyArray("POSITION_QUANTIZED", jn.UNSIGNED_SHORT, 3);
      if (r.isQuantized = !0, r.quantizedRange = 65535, r.quantizedVolumeScale = e.getGlobalProperty("QUANTIZED_VOLUME_SCALE", jn.FLOAT, 3), !r.quantizedVolumeScale)
        throw new Error("QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");
      if (r.quantizedVolumeOffset = e.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", jn.FLOAT, 3), !r.quantizedVolumeOffset)
        throw new Error("QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");
      r.attributes.positions = Nde(r, n, t);
    }
  }
  if (!r.attributes.positions)
    throw new Error("Either POSITION or POSITION_QUANTIZED must be defined.");
}
function Gde(r, e, t) {
  if (r.attributes = r.attributes || {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  }, !r.attributes.colors) {
    let n = null;
    e.hasProperty("RGBA") ? (n = e.getPropertyArray("RGBA", jn.UNSIGNED_BYTE, 4), r.isTranslucent = !0) : e.hasProperty("RGB") ? n = e.getPropertyArray("RGB", jn.UNSIGNED_BYTE, 3) : e.hasProperty("RGB565") && (n = e.getPropertyArray("RGB565", jn.UNSIGNED_SHORT, 1), r.isRGB565 = !0), r.attributes.colors = wk(r, n, t);
  }
  e.hasProperty("CONSTANT_RGBA") && (r.constantRGBA = e.getGlobalProperty("CONSTANT_RGBA", jn.UNSIGNED_BYTE, 4));
}
function Wde(r, e) {
  if (r.attributes = r.attributes || {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  }, !r.attributes.normals) {
    let t = null;
    e.hasProperty("NORMAL") ? t = e.getPropertyArray("NORMAL", jn.FLOAT, 3) : e.hasProperty("NORMAL_OCT16P") && (t = e.getPropertyArray("NORMAL_OCT16P", jn.UNSIGNED_BYTE, 2), r.isOctEncoded16P = !0), r.attributes.normals = Fde(r, t);
  }
}
function $de(r, e) {
  let t = null;
  if (!r.batchIds && e.hasProperty("BATCH_ID") && (r.batchIds = e.getPropertyArray("BATCH_ID", jn.UNSIGNED_SHORT, 1), r.batchIds)) {
    const n = e.getGlobalProperty("BATCH_LENGTH");
    if (!n)
      throw new Error("Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.");
    const { batchTableJson: i, batchTableBinary: s } = r;
    t = new xk(i, s, n);
  }
  return t;
}
async function qde(r, e, t, n, i) {
  let s, o, l;
  const u = r.batchTableJson && r.batchTableJson.extensions && r.batchTableJson.extensions["3DTILES_draco_point_compression"];
  u && (l = u.properties);
  const m = e.getExtension("3DTILES_draco_point_compression");
  if (m) {
    o = m.properties;
    const E = m.byteOffset, P = m.byteLength;
    if (!o || !Number.isFinite(E) || !P)
      throw new Error("Draco properties, byteOffset, and byteLength must be defined");
    s = (r.featureTableBinary || []).slice(E, E + P), r.hasPositions = Number.isFinite(o.POSITION), r.hasColors = Number.isFinite(o.RGB) || Number.isFinite(o.RGBA), r.hasNormals = Number.isFinite(o.NORMAL), r.hasBatchIds = Number.isFinite(o.BATCH_ID), r.isTranslucent = Number.isFinite(o.RGBA);
  }
  if (!s)
    return !0;
  const y = {
    buffer: s,
    properties: { ...o, ...l },
    batchTableProperties: l
  };
  return await Xde(r, y, n, i);
}
async function Xde(r, e, t, n) {
  if (!n)
    return;
  const i = {
    ...t,
    draco: {
      ...t?.draco,
      extraAttributes: e.batchTableProperties || {}
    }
  };
  delete i["3d-tiles"];
  const s = await g0(e.buffer, iD, i, n), o = s.attributes.POSITION && s.attributes.POSITION.value, l = s.attributes.COLOR_0 && s.attributes.COLOR_0.value, u = s.attributes.NORMAL && s.attributes.NORMAL.value, m = s.attributes.BATCH_ID && s.attributes.BATCH_ID.value, y = o && s.attributes.POSITION.value.quantization, E = u && s.attributes.NORMAL.value.quantization;
  if (y) {
    const L = s.POSITION.data.quantization, U = L.range;
    r.quantizedVolumeScale = new yt(U, U, U), r.quantizedVolumeOffset = new yt(L.minValues), r.quantizedRange = (1 << L.quantizationBits) - 1, r.isQuantizedDraco = !0;
  }
  E && (r.octEncodedRange = (1 << s.NORMAL.data.quantization.quantizationBits) - 1, r.isOctEncodedDraco = !0);
  const P = {};
  if (e.batchTableProperties)
    for (const L of Object.keys(e.batchTableProperties))
      s.attributes[L] && s.attributes[L].value && (P[L.toLowerCase()] = s.attributes[L].value);
  r.attributes = {
    // @ts-expect-error
    positions: o,
    // @ts-expect-error
    colors: wk(r, l, void 0),
    // @ts-expect-error
    normals: u,
    // @ts-expect-error
    batchIds: m,
    ...P
  };
}
const F2 = {
  URI: 0,
  EMBEDDED: 1
};
function Tk(r, e, t, n) {
  r.rotateYtoZ = !0;
  const i = (r.byteOffset || 0) + (r.byteLength || 0) - t;
  if (i === 0)
    throw new Error("glTF byte length must be greater than 0.");
  return r.gltfUpAxis = n?.["3d-tiles"] && n["3d-tiles"].assetGltfUpAxis ? n["3d-tiles"].assetGltfUpAxis : "Y", r.gltfArrayBuffer = Q2(e, t, i), r.gltfByteOffset = 0, r.gltfByteLength = i, t % 4 === 0 || console.warn(`${r.type}: embedded glb is not aligned to a 4-byte boundary.`), (r.byteOffset || 0) + (r.byteLength || 0);
}
async function Ek(r, e, t, n) {
  const i = t?.["3d-tiles"] || {};
  if (Zde(r, e), i.loadGLTF) {
    if (!n)
      return;
    if (r.gltfUrl) {
      const { fetch: s } = n, o = await s(r.gltfUrl, t);
      r.gltfArrayBuffer = await o.arrayBuffer(), r.gltfByteOffset = 0;
    }
    if (r.gltfArrayBuffer) {
      const s = await g0(r.gltfArrayBuffer, Tp, t, n);
      r.gltf = lw(s), r.gpuMemoryUsageInBytes = $6(r.gltf), delete r.gltfArrayBuffer, delete r.gltfByteOffset, delete r.gltfByteLength;
    }
  }
}
function Zde(r, e, t) {
  switch (e) {
    case F2.URI:
      if (r.gltfArrayBuffer) {
        const n = new Uint8Array(r.gltfArrayBuffer, r.gltfByteOffset), s = new TextDecoder().decode(n);
        r.gltfUrl = s.replace(/[\s\0]+$/, "");
      }
      delete r.gltfArrayBuffer, delete r.gltfByteOffset, delete r.gltfByteLength;
      break;
    case F2.EMBEDDED:
      break;
    default:
      throw new Error("b3dm: Illegal glTF format field");
  }
}
async function Yde(r, e, t, n, i) {
  t = Kde(r, e, t, n), await Ek(r, F2.EMBEDDED, n, i);
  const s = r?.gltf?.extensions;
  return s && s.CESIUM_RTC && (r.rtcCenter = s.CESIUM_RTC.center), t;
}
function Kde(r, e, t, n, i) {
  t = my(r, e, t), t = Yw(r, e, t), t = Kw(r, e, t), t = Tk(r, e, t, n);
  const s = new Zw(r.featureTableJson, r.featureTableBinary);
  return r.rtcCenter = s.getGlobalProperty("RTC_CENTER", jn.FLOAT, 3), t;
}
async function Qde(r, e, t, n, i) {
  return t = Jde(r, e, t, n), await Ek(r, r.gltfFormat || 0, n, i), t;
}
function Jde(r, e, t, n, i) {
  if (t = my(r, e, t), r.version !== 1)
    throw new Error(`Instanced 3D Model version ${r.version} is not supported`);
  t = Yw(r, e, t);
  const s = new DataView(e);
  if (r.gltfFormat = s.getUint32(t, !0), t += 4, t = Kw(r, e, t), t = Tk(r, e, t, n), !r?.header?.featureTableJsonByteLength || r.header.featureTableJsonByteLength === 0)
    throw new Error("i3dm parser: featureTableJsonByteLength is zero.");
  const o = new Zw(r.featureTableJson, r.featureTableBinary), l = o.getGlobalProperty("INSTANCES_LENGTH");
  if (o.featuresLength = l, !Number.isFinite(l))
    throw new Error("i3dm parser: INSTANCES_LENGTH must be defined");
  r.eastNorthUp = o.getGlobalProperty("EAST_NORTH_UP"), r.rtcCenter = o.getGlobalProperty("RTC_CENTER", jn.FLOAT, 3);
  const u = new xk(r.batchTableJson, r.batchTableBinary, l);
  return epe(r, o, u, l), t;
}
function epe(r, e, t, n) {
  const i = new Array(n), s = new yt();
  new yt(), new yt(), new yt();
  const o = new es(), l = new r0(), u = new yt(), m = {}, y = new xn(), E = [], P = [], L = [], U = [];
  for (let V = 0; V < n; V++) {
    let q;
    if (e.hasProperty("POSITION"))
      q = e.getProperty("POSITION", jn.FLOAT, 3, V, s);
    else if (e.hasProperty("POSITION_QUANTIZED")) {
      q = e.getProperty("POSITION_QUANTIZED", jn.UNSIGNED_SHORT, 3, V, s);
      const ae = e.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", jn.FLOAT, 3);
      if (!ae)
        throw new Error("i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");
      const De = e.getGlobalProperty("QUANTIZED_VOLUME_SCALE", jn.FLOAT, 3);
      if (!De)
        throw new Error("i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");
      const Ge = 65535;
      for (let fe = 0; fe < 3; fe++)
        q[fe] = q[fe] / Ge * De[fe] + ae[fe];
    }
    if (!q)
      throw new Error("i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.");
    if (s.copy(q), m.translation = s, r.normalUp = e.getProperty("NORMAL_UP", jn.FLOAT, 3, V, E), r.normalRight = e.getProperty("NORMAL_RIGHT", jn.FLOAT, 3, V, P), r.normalUp) {
      if (!r.normalRight)
        throw new Error("i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.");
      r.hasCustomOrientation = !0;
    } else {
      if (r.octNormalUp = e.getProperty("NORMAL_UP_OCT32P", jn.UNSIGNED_SHORT, 2, V, E), r.octNormalRight = e.getProperty("NORMAL_RIGHT_OCT32P", jn.UNSIGNED_SHORT, 2, V, P), r.octNormalUp)
        throw r.octNormalRight ? new Error("i3dm: oct-encoded orientation not implemented") : new Error("i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P");
      r.eastNorthUp ? (yi.WGS84.eastNorthUpToFixedFrame(s, y), y.getRotationMatrix3(o)) : o.identity();
    }
    l.fromMatrix3(o), m.rotation = l, u.set(1, 1, 1);
    const j = e.getProperty("SCALE", jn.FLOAT, 1, V, L);
    Number.isFinite(j) && u.multiplyByScalar(j);
    const K = e.getProperty("SCALE_NON_UNIFORM", jn.FLOAT, 3, V, E);
    K && u.scale(K), m.scale = u;
    let Y = e.getProperty("BATCH_ID", jn.UNSIGNED_SHORT, 1, V, U);
    Y === void 0 && (Y = V);
    const de = new xn().fromQuaternion(m.rotation);
    y.identity(), y.translate(m.translation), y.multiplyRight(de), y.scale(m.scale);
    const ne = y.clone();
    i[V] = {
      modelMatrix: ne,
      batchId: Y
    };
  }
  r.instances = i;
}
async function tpe(r, e, t, n, i, s) {
  t = my(r, e, t);
  const o = new DataView(e);
  for (r.tilesLength = o.getUint32(t, !0), t += 4, r.tiles = []; r.tiles.length < r.tilesLength && (r.byteLength || 0) - t > 12; ) {
    const l = { shape: "tile3d" };
    r.tiles.push(l), t = await s(e, t, n, i, l);
  }
  return t;
}
async function rpe(r, e, t, n) {
  if (r.rotateYtoZ = !0, r.gltfUpAxis = t?.["3d-tiles"]?.assetGltfUpAxis ? t["3d-tiles"].assetGltfUpAxis : "Y", t?.["3d-tiles"]?.loadGLTF) {
    if (!n)
      return e.byteLength;
    const i = await g0(e, Tp, t, n);
    r.gltf = lw(i), r.gpuMemoryUsageInBytes = $6(r.gltf);
  } else
    r.gltfArrayBuffer = e;
  return e.byteLength;
}
async function Ck(r, e = 0, t, n, i = { shape: "tile3d" }) {
  switch (i.byteOffset = e, i.type = _de(r, e), i.type) {
    case EA.COMPOSITE:
      return await tpe(i, r, e, t, n, Ck);
    case EA.BATCHED_3D_MODEL:
      return await Yde(i, r, e, t, n);
    case EA.GLTF:
      return await rpe(i, r, t, n);
    case EA.INSTANCED_3D_MODEL:
      return await Qde(i, r, e, t, n);
    case EA.POINT_CLOUD:
      return await zde(i, r, e, t, n);
    default:
      throw new Error(`3DTileLoader: unknown type ${i.type}`);
  }
}
const npe = 1952609651, ipe = 1;
async function spe(r, e, t) {
  if (new Uint32Array(r.slice(0, 4))[0] !== npe)
    throw new Error("Wrong subtree file magic number");
  if (new Uint32Array(r.slice(4, 8))[0] !== ipe)
    throw new Error("Wrong subtree file verson, must be 1");
  const s = oR(r.slice(8, 16)), o = new Uint8Array(r, 24, s), u = new TextDecoder("utf8").decode(o), m = JSON.parse(u), y = oR(r.slice(16, 24));
  let E = new ArrayBuffer(0);
  if (y && (E = r.slice(24 + s)), await om(m, m.tileAvailability, E, t), Array.isArray(m.contentAvailability))
    for (const P of m.contentAvailability)
      await om(m, P, E, t);
  else
    await om(m, m.contentAvailability, E, t);
  return await om(m, m.childSubtreeAvailability, E, t), m;
}
async function om(r, e, t, n) {
  const i = Number.isFinite(e.bitstream) ? e.bitstream : e.bufferView;
  if (typeof i != "number")
    return;
  const s = r.bufferViews[i], o = r.buffers[s.buffer];
  if (!n?.baseUrl)
    throw new Error("Url is not provided");
  if (!n.fetch)
    throw new Error("fetch is not provided");
  if (o.uri) {
    const u = `${n?.baseUrl || ""}/${o.uri}`, y = await (await n.fetch(u)).arrayBuffer();
    e.explicitBitstream = new Uint8Array(y, s.byteOffset, s.byteLength);
    return;
  }
  const l = r.buffers.slice(0, s.buffer).reduce((u, m) => u + m.byteLength, 0);
  e.explicitBitstream = new Uint8Array(t.slice(l, l + o.byteLength), s.byteOffset, s.byteLength);
}
function oR(r) {
  const e = new DataView(r), t = e.getUint32(0, !0), n = e.getUint32(4, !0);
  return t + 2 ** 32 * n;
}
const Sk = {
  dataType: null,
  batchType: null,
  id: "3d-tiles-subtree",
  name: "3D Tiles Subtree",
  module: "3d-tiles",
  version: yk,
  extensions: ["subtree"],
  mimeTypes: ["application/octet-stream"],
  tests: ["subtree"],
  parse: spe,
  options: {}
};
var Oa = null;
try {
  Oa = new WebAssembly.Instance(
    new WebAssembly.Module(
      new Uint8Array([
        // \0asm
        0,
        97,
        115,
        109,
        // version 1
        1,
        0,
        0,
        0,
        // section "type"
        1,
        13,
        2,
        // 0, () => i32
        96,
        0,
        1,
        127,
        // 1, (i32, i32, i32, i32) => i32
        96,
        4,
        127,
        127,
        127,
        127,
        1,
        127,
        // section "function"
        3,
        7,
        6,
        // 0, type 0
        0,
        // 1, type 1
        1,
        // 2, type 1
        1,
        // 3, type 1
        1,
        // 4, type 1
        1,
        // 5, type 1
        1,
        // section "global"
        6,
        6,
        1,
        // 0, "high", mutable i32
        127,
        1,
        65,
        0,
        11,
        // section "export"
        7,
        50,
        6,
        // 0, "mul"
        3,
        109,
        117,
        108,
        0,
        1,
        // 1, "div_s"
        5,
        100,
        105,
        118,
        95,
        115,
        0,
        2,
        // 2, "div_u"
        5,
        100,
        105,
        118,
        95,
        117,
        0,
        3,
        // 3, "rem_s"
        5,
        114,
        101,
        109,
        95,
        115,
        0,
        4,
        // 4, "rem_u"
        5,
        114,
        101,
        109,
        95,
        117,
        0,
        5,
        // 5, "get_high"
        8,
        103,
        101,
        116,
        95,
        104,
        105,
        103,
        104,
        0,
        0,
        // section "code"
        10,
        191,
        1,
        6,
        // 0, "get_high"
        4,
        0,
        35,
        0,
        11,
        // 1, "mul"
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        126,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        // 2, "div_s"
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        127,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        // 3, "div_u"
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        128,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        // 4, "rem_s"
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        129,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        // 5, "rem_u"
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        130,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11
      ])
    ),
    {}
  ).exports;
} catch {
}
function Wn(r, e, t) {
  this.low = r | 0, this.high = e | 0, this.unsigned = !!t;
}
Wn.prototype.__isLong__;
Object.defineProperty(Wn.prototype, "__isLong__", { value: !0 });
function yo(r) {
  return (r && r.__isLong__) === !0;
}
function aR(r) {
  var e = Math.clz32(r & -r);
  return r ? 31 - e : e;
}
Wn.isLong = yo;
var lR = {}, cR = {};
function vh(r, e) {
  var t, n, i;
  return e ? (r >>>= 0, (i = 0 <= r && r < 256) && (n = cR[r], n) ? n : (t = Hn(r, 0, !0), i && (cR[r] = t), t)) : (r |= 0, (i = -128 <= r && r < 128) && (n = lR[r], n) ? n : (t = Hn(r, r < 0 ? -1 : 0, !1), i && (lR[r] = t), t));
}
Wn.fromInt = vh;
function Da(r, e) {
  if (isNaN(r)) return e ? Zc : gl;
  if (e) {
    if (r < 0) return Zc;
    if (r >= Ik) return Rk;
  } else {
    if (r <= -fR) return Yo;
    if (r + 1 >= fR) return Mk;
  }
  return r < 0 ? Da(-r, e).neg() : Hn(
    r % Mp | 0,
    r / Mp | 0,
    e
  );
}
Wn.fromNumber = Da;
function Hn(r, e, t) {
  return new Wn(r, e, t);
}
Wn.fromBits = Hn;
var w_ = Math.pow;
function Qw(r, e, t) {
  if (r.length === 0) throw Error("empty string");
  if (typeof e == "number" ? (t = e, e = !1) : e = !!e, r === "NaN" || r === "Infinity" || r === "+Infinity" || r === "-Infinity")
    return e ? Zc : gl;
  if (t = t || 10, t < 2 || 36 < t) throw RangeError("radix");
  var n;
  if ((n = r.indexOf("-")) > 0) throw Error("interior hyphen");
  if (n === 0)
    return Qw(r.substring(1), e, t).neg();
  for (var i = Da(w_(t, 8)), s = gl, o = 0; o < r.length; o += 8) {
    var l = Math.min(8, r.length - o), u = parseInt(r.substring(o, o + l), t);
    if (l < 8) {
      var m = Da(w_(t, l));
      s = s.mul(m).add(Da(u));
    } else
      s = s.mul(i), s = s.add(Da(u));
  }
  return s.unsigned = e, s;
}
Wn.fromString = Qw;
function za(r, e) {
  return typeof r == "number" ? Da(r, e) : typeof r == "string" ? Qw(r, e) : Hn(
    r.low,
    r.high,
    typeof e == "boolean" ? e : r.unsigned
  );
}
Wn.fromValue = za;
var uR = 65536, ope = 1 << 24, Mp = uR * uR, Ik = Mp * Mp, fR = Ik / 2, hR = vh(ope), gl = vh(0);
Wn.ZERO = gl;
var Zc = vh(0, !0);
Wn.UZERO = Zc;
var np = vh(1);
Wn.ONE = np;
var Pk = vh(1, !0);
Wn.UONE = Pk;
var N2 = vh(-1);
Wn.NEG_ONE = N2;
var Mk = Hn(-1, 2147483647, !1);
Wn.MAX_VALUE = Mk;
var Rk = Hn(-1, -1, !0);
Wn.MAX_UNSIGNED_VALUE = Rk;
var Yo = Hn(0, -2147483648, !1);
Wn.MIN_VALUE = Yo;
var or = Wn.prototype;
or.toInt = function() {
  return this.unsigned ? this.low >>> 0 : this.low;
};
or.toNumber = function() {
  return this.unsigned ? (this.high >>> 0) * Mp + (this.low >>> 0) : this.high * Mp + (this.low >>> 0);
};
or.toString = function(e) {
  if (e = e || 10, e < 2 || 36 < e) throw RangeError("radix");
  if (this.isZero()) return "0";
  if (this.isNegative())
    if (this.eq(Yo)) {
      var t = Da(e), n = this.div(t), i = n.mul(t).sub(this);
      return n.toString(e) + i.toInt().toString(e);
    } else return "-" + this.neg().toString(e);
  for (var s = Da(w_(e, 6), this.unsigned), o = this, l = ""; ; ) {
    var u = o.div(s), m = o.sub(u.mul(s)).toInt() >>> 0, y = m.toString(e);
    if (o = u, o.isZero()) return y + l;
    for (; y.length < 6; ) y = "0" + y;
    l = "" + y + l;
  }
};
or.getHighBits = function() {
  return this.high;
};
or.getHighBitsUnsigned = function() {
  return this.high >>> 0;
};
or.getLowBits = function() {
  return this.low;
};
or.getLowBitsUnsigned = function() {
  return this.low >>> 0;
};
or.getNumBitsAbs = function() {
  if (this.isNegative())
    return this.eq(Yo) ? 64 : this.neg().getNumBitsAbs();
  for (var e = this.high != 0 ? this.high : this.low, t = 31; t > 0 && (e & 1 << t) == 0; t--) ;
  return this.high != 0 ? t + 33 : t + 1;
};
or.isSafeInteger = function() {
  var e = this.high >> 21;
  return e ? this.unsigned ? !1 : e === -1 && !(this.low === 0 && this.high === -2097152) : !0;
};
or.isZero = function() {
  return this.high === 0 && this.low === 0;
};
or.eqz = or.isZero;
or.isNegative = function() {
  return !this.unsigned && this.high < 0;
};
or.isPositive = function() {
  return this.unsigned || this.high >= 0;
};
or.isOdd = function() {
  return (this.low & 1) === 1;
};
or.isEven = function() {
  return (this.low & 1) === 0;
};
or.equals = function(e) {
  return yo(e) || (e = za(e)), this.unsigned !== e.unsigned && this.high >>> 31 === 1 && e.high >>> 31 === 1 ? !1 : this.high === e.high && this.low === e.low;
};
or.eq = or.equals;
or.notEquals = function(e) {
  return !this.eq(
    /* validates */
    e
  );
};
or.neq = or.notEquals;
or.ne = or.notEquals;
or.lessThan = function(e) {
  return this.comp(
    /* validates */
    e
  ) < 0;
};
or.lt = or.lessThan;
or.lessThanOrEqual = function(e) {
  return this.comp(
    /* validates */
    e
  ) <= 0;
};
or.lte = or.lessThanOrEqual;
or.le = or.lessThanOrEqual;
or.greaterThan = function(e) {
  return this.comp(
    /* validates */
    e
  ) > 0;
};
or.gt = or.greaterThan;
or.greaterThanOrEqual = function(e) {
  return this.comp(
    /* validates */
    e
  ) >= 0;
};
or.gte = or.greaterThanOrEqual;
or.ge = or.greaterThanOrEqual;
or.compare = function(e) {
  if (yo(e) || (e = za(e)), this.eq(e)) return 0;
  var t = this.isNegative(), n = e.isNegative();
  return t && !n ? -1 : !t && n ? 1 : this.unsigned ? e.high >>> 0 > this.high >>> 0 || e.high === this.high && e.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(e).isNegative() ? -1 : 1;
};
or.comp = or.compare;
or.negate = function() {
  return !this.unsigned && this.eq(Yo) ? Yo : this.not().add(np);
};
or.neg = or.negate;
or.add = function(e) {
  yo(e) || (e = za(e));
  var t = this.high >>> 16, n = this.high & 65535, i = this.low >>> 16, s = this.low & 65535, o = e.high >>> 16, l = e.high & 65535, u = e.low >>> 16, m = e.low & 65535, y = 0, E = 0, P = 0, L = 0;
  return L += s + m, P += L >>> 16, L &= 65535, P += i + u, E += P >>> 16, P &= 65535, E += n + l, y += E >>> 16, E &= 65535, y += t + o, y &= 65535, Hn(P << 16 | L, y << 16 | E, this.unsigned);
};
or.subtract = function(e) {
  return yo(e) || (e = za(e)), this.add(e.neg());
};
or.sub = or.subtract;
or.multiply = function(e) {
  if (this.isZero()) return this;
  if (yo(e) || (e = za(e)), Oa) {
    var t = Oa.mul(this.low, this.high, e.low, e.high);
    return Hn(t, Oa.get_high(), this.unsigned);
  }
  if (e.isZero()) return this.unsigned ? Zc : gl;
  if (this.eq(Yo)) return e.isOdd() ? Yo : gl;
  if (e.eq(Yo)) return this.isOdd() ? Yo : gl;
  if (this.isNegative())
    return e.isNegative() ? this.neg().mul(e.neg()) : this.neg().mul(e).neg();
  if (e.isNegative()) return this.mul(e.neg()).neg();
  if (this.lt(hR) && e.lt(hR))
    return Da(this.toNumber() * e.toNumber(), this.unsigned);
  var n = this.high >>> 16, i = this.high & 65535, s = this.low >>> 16, o = this.low & 65535, l = e.high >>> 16, u = e.high & 65535, m = e.low >>> 16, y = e.low & 65535, E = 0, P = 0, L = 0, U = 0;
  return U += o * y, L += U >>> 16, U &= 65535, L += s * y, P += L >>> 16, L &= 65535, L += o * m, P += L >>> 16, L &= 65535, P += i * y, E += P >>> 16, P &= 65535, P += s * m, E += P >>> 16, P &= 65535, P += o * u, E += P >>> 16, P &= 65535, E += n * y + i * m + s * u + o * l, E &= 65535, Hn(L << 16 | U, E << 16 | P, this.unsigned);
};
or.mul = or.multiply;
or.divide = function(e) {
  if (yo(e) || (e = za(e)), e.isZero()) throw Error("division by zero");
  if (Oa) {
    if (!this.unsigned && this.high === -2147483648 && e.low === -1 && e.high === -1)
      return this;
    var t = (this.unsigned ? Oa.div_u : Oa.div_s)(
      this.low,
      this.high,
      e.low,
      e.high
    );
    return Hn(t, Oa.get_high(), this.unsigned);
  }
  if (this.isZero()) return this.unsigned ? Zc : gl;
  var n, i, s;
  if (this.unsigned) {
    if (e.unsigned || (e = e.toUnsigned()), e.gt(this)) return Zc;
    if (e.gt(this.shru(1)))
      return Pk;
    s = Zc;
  } else {
    if (this.eq(Yo)) {
      if (e.eq(np) || e.eq(N2))
        return Yo;
      if (e.eq(Yo)) return np;
      var o = this.shr(1);
      return n = o.div(e).shl(1), n.eq(gl) ? e.isNegative() ? np : N2 : (i = this.sub(e.mul(n)), s = n.add(i.div(e)), s);
    } else if (e.eq(Yo)) return this.unsigned ? Zc : gl;
    if (this.isNegative())
      return e.isNegative() ? this.neg().div(e.neg()) : this.neg().div(e).neg();
    if (e.isNegative()) return this.div(e.neg()).neg();
    s = gl;
  }
  for (i = this; i.gte(e); ) {
    n = Math.max(1, Math.floor(i.toNumber() / e.toNumber()));
    for (var l = Math.ceil(Math.log(n) / Math.LN2), u = l <= 48 ? 1 : w_(2, l - 48), m = Da(n), y = m.mul(e); y.isNegative() || y.gt(i); )
      n -= u, m = Da(n, this.unsigned), y = m.mul(e);
    m.isZero() && (m = np), s = s.add(m), i = i.sub(y);
  }
  return s;
};
or.div = or.divide;
or.modulo = function(e) {
  if (yo(e) || (e = za(e)), Oa) {
    var t = (this.unsigned ? Oa.rem_u : Oa.rem_s)(
      this.low,
      this.high,
      e.low,
      e.high
    );
    return Hn(t, Oa.get_high(), this.unsigned);
  }
  return this.sub(this.div(e).mul(e));
};
or.mod = or.modulo;
or.rem = or.modulo;
or.not = function() {
  return Hn(~this.low, ~this.high, this.unsigned);
};
or.countLeadingZeros = function() {
  return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
};
or.clz = or.countLeadingZeros;
or.countTrailingZeros = function() {
  return this.low ? aR(this.low) : aR(this.high) + 32;
};
or.ctz = or.countTrailingZeros;
or.and = function(e) {
  return yo(e) || (e = za(e)), Hn(this.low & e.low, this.high & e.high, this.unsigned);
};
or.or = function(e) {
  return yo(e) || (e = za(e)), Hn(this.low | e.low, this.high | e.high, this.unsigned);
};
or.xor = function(e) {
  return yo(e) || (e = za(e)), Hn(this.low ^ e.low, this.high ^ e.high, this.unsigned);
};
or.shiftLeft = function(e) {
  return yo(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? Hn(
    this.low << e,
    this.high << e | this.low >>> 32 - e,
    this.unsigned
  ) : Hn(0, this.low << e - 32, this.unsigned);
};
or.shl = or.shiftLeft;
or.shiftRight = function(e) {
  return yo(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? Hn(
    this.low >>> e | this.high << 32 - e,
    this.high >> e,
    this.unsigned
  ) : Hn(
    this.high >> e - 32,
    this.high >= 0 ? 0 : -1,
    this.unsigned
  );
};
or.shr = or.shiftRight;
or.shiftRightUnsigned = function(e) {
  return yo(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? Hn(
    this.low >>> e | this.high << 32 - e,
    this.high >>> e,
    this.unsigned
  ) : e === 32 ? Hn(this.high, 0, this.unsigned) : Hn(this.high >>> e - 32, 0, this.unsigned);
};
or.shru = or.shiftRightUnsigned;
or.shr_u = or.shiftRightUnsigned;
or.rotateLeft = function(e) {
  var t;
  return yo(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e === 32 ? Hn(this.high, this.low, this.unsigned) : e < 32 ? (t = 32 - e, Hn(
    this.low << e | this.high >>> t,
    this.high << e | this.low >>> t,
    this.unsigned
  )) : (e -= 32, t = 32 - e, Hn(
    this.high << e | this.low >>> t,
    this.low << e | this.high >>> t,
    this.unsigned
  ));
};
or.rotl = or.rotateLeft;
or.rotateRight = function(e) {
  var t;
  return yo(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e === 32 ? Hn(this.high, this.low, this.unsigned) : e < 32 ? (t = 32 - e, Hn(
    this.high << t | this.low >>> e,
    this.low << t | this.high >>> e,
    this.unsigned
  )) : (e -= 32, t = 32 - e, Hn(
    this.low << t | this.high >>> e,
    this.high << t | this.low >>> e,
    this.unsigned
  ));
};
or.rotr = or.rotateRight;
or.toSigned = function() {
  return this.unsigned ? Hn(this.low, this.high, !1) : this;
};
or.toUnsigned = function() {
  return this.unsigned ? this : Hn(this.low, this.high, !0);
};
or.toBytes = function(e) {
  return e ? this.toBytesLE() : this.toBytesBE();
};
or.toBytesLE = function() {
  var e = this.high, t = this.low;
  return [
    t & 255,
    t >>> 8 & 255,
    t >>> 16 & 255,
    t >>> 24,
    e & 255,
    e >>> 8 & 255,
    e >>> 16 & 255,
    e >>> 24
  ];
};
or.toBytesBE = function() {
  var e = this.high, t = this.low;
  return [
    e >>> 24,
    e >>> 16 & 255,
    e >>> 8 & 255,
    e & 255,
    t >>> 24,
    t >>> 16 & 255,
    t >>> 8 & 255,
    t & 255
  ];
};
Wn.fromBytes = function(e, t, n) {
  return n ? Wn.fromBytesLE(e, t) : Wn.fromBytesBE(e, t);
};
Wn.fromBytesLE = function(e, t) {
  return new Wn(
    e[0] | e[1] << 8 | e[2] << 16 | e[3] << 24,
    e[4] | e[5] << 8 | e[6] << 16 | e[7] << 24,
    t
  );
};
Wn.fromBytesBE = function(e, t) {
  return new Wn(
    e[4] << 24 | e[5] << 16 | e[6] << 8 | e[7],
    e[0] << 24 | e[1] << 16 | e[2] << 8 | e[3],
    t
  );
};
typeof BigInt == "function" && (Wn.fromBigInt = function(e, t) {
  var n = Number(BigInt.asIntN(32, e)), i = Number(BigInt.asIntN(32, e >> BigInt(32)));
  return Hn(n, i, t);
}, Wn.fromValue = function(e, t) {
  return typeof e == "bigint" ? Wn.fromBigInt(e, t) : za(e, t);
}, or.toBigInt = function() {
  var e = BigInt(this.low >>> 0), t = BigInt(this.unsigned ? this.high >>> 0 : this.high);
  return t << BigInt(32) | e;
});
const ape = 16;
function Bk(r) {
  r === "X" && (r = "");
  const e = r.padEnd(ape, "0");
  return Wn.fromString(e, !0, 16);
}
function lpe(r) {
  if (r.isZero())
    return "X";
  let e = r.countTrailingZeros();
  const t = e % 4;
  e = (e - t) / 4;
  const n = e;
  e *= 4;
  const s = r.shiftRightUnsigned(e).toString(16).replace(/0+$/, "");
  return Array(17 - n - s.length).join("0") + s;
}
function cpe(r, e) {
  const t = upe(r).shiftRightUnsigned(2);
  return r.add(Wn.fromNumber(2 * e + 1 - 4).multiply(t));
}
function upe(r) {
  return r.and(r.not().add(1));
}
const fpe = 3, hpe = 30, dpe = 2 * hpe + 1, dR = 180 / Math.PI;
function ppe(r) {
  if (r.length === 0)
    throw new Error(`Invalid Hilbert quad key ${r}`);
  const e = r.split("/"), t = parseInt(e[0], 10), n = e[1], i = n.length;
  let s = 0;
  const o = [0, 0];
  for (let l = i - 1; l >= 0; l--) {
    s = i - l;
    const u = n[l];
    let m = 0, y = 0;
    u === "1" ? y = 1 : u === "2" ? (m = 1, y = 1) : u === "3" && (m = 1);
    const E = Math.pow(2, s - 1);
    gpe(E, o, m, y), o[0] += E * m, o[1] += E * y;
  }
  if (t % 2 === 1) {
    const l = o[0];
    o[0] = o[1], o[1] = l;
  }
  return { face: t, ij: o, level: s };
}
function Ape(r) {
  if (r.isZero())
    return "";
  let e = r.toString(2);
  for (; e.length < fpe + dpe; )
    e = "0" + e;
  const t = e.lastIndexOf("1"), n = e.substring(0, 3), i = e.substring(3, t), s = i.length / 2, o = Wn.fromString(n, !0, 2).toString(10);
  let l = "";
  if (s !== 0)
    for (l = Wn.fromString(i, !0, 2).toString(4); l.length < s; )
      l = "0" + l;
  return `${o}/${l}`;
}
function Ok(r, e, t) {
  const n = 1 << e;
  return [(r[0] + t[0]) / n, (r[1] + t[1]) / n];
}
function pR(r) {
  return r >= 0.5 ? 1 / 3 * (4 * r * r - 1) : 1 / 3 * (1 - 4 * (1 - r) * (1 - r));
}
function Dk(r) {
  return [pR(r[0]), pR(r[1])];
}
function Lk(r, [e, t]) {
  switch (r) {
    case 0:
      return [1, e, t];
    case 1:
      return [-e, 1, t];
    case 2:
      return [-e, -t, 1];
    case 3:
      return [-1, -t, -e];
    case 4:
      return [t, -1, -e];
    case 5:
      return [t, e, -1];
    default:
      throw new Error("Invalid face");
  }
}
function kk([r, e, t]) {
  const n = Math.atan2(t, Math.sqrt(r * r + e * e));
  return [Math.atan2(e, r) * dR, n * dR];
}
function gpe(r, e, t, n) {
  if (n === 0) {
    t === 1 && (e[0] = r - 1 - e[0], e[1] = r - 1 - e[1]);
    const i = e[0];
    e[0] = e[1], e[1] = i;
  }
}
function mpe(r) {
  const e = Ok(r.ij, r.level, [0.5, 0.5]), t = Dk(e), n = Lk(r.face, t);
  return kk(n);
}
const _pe = 100;
function AR(r) {
  const { face: e, ij: t, level: n } = r, i = [
    [0, 0],
    [0, 1],
    [1, 1],
    [1, 0],
    [0, 0]
  ], s = Math.max(1, Math.ceil(_pe * Math.pow(2, -n))), o = new Float64Array(4 * s * 2 + 2);
  let l = 0, u = 0;
  for (let m = 0; m < 4; m++) {
    const y = i[m].slice(0), E = i[m + 1], P = (E[0] - y[0]) / s, L = (E[1] - y[1]) / s;
    for (let U = 0; U < s; U++) {
      y[0] += P, y[1] += L;
      const V = Ok(t, n, y), q = Dk(V), j = Lk(e, q), K = kk(j);
      Math.abs(K[1]) > 89.999 && (K[0] = u);
      const Y = K[0] - u;
      K[0] += Y > 180 ? -360 : Y < -180 ? 360 : 0, o[l++] = K[0], o[l++] = K[1], u = K[0];
    }
  }
  return o[l++] = o[0], o[l++] = o[1], o;
}
function Jw(r) {
  const e = ype(r);
  return ppe(e);
}
function ype(r) {
  if (r.indexOf("/") > 0)
    return r;
  const e = Bk(r);
  return Ape(e);
}
function vpe(r) {
  const e = Jw(r);
  return mpe(e);
}
function bpe(r) {
  let e;
  if (r.face === 2 || r.face === 5) {
    let t = null, n = 0;
    for (let i = 0; i < 4; i++) {
      const s = `${r.face}/${i}`, o = Jw(s), l = AR(o);
      (typeof t > "u" || t === null) && (t = new Float64Array(4 * l.length)), t.set(l, n), n += l.length;
    }
    e = gR(t);
  } else {
    const t = AR(r);
    e = gR(t);
  }
  return e;
}
function gR(r) {
  if (r.length % 2 !== 0)
    throw new Error("Invalid corners");
  const e = [], t = [];
  for (let n = 0; n < r.length; n += 2)
    e.push(r[n]), t.push(r[n + 1]);
  return e.sort((n, i) => n - i), t.sort((n, i) => n - i), {
    west: e[0],
    east: e[e.length - 1],
    north: t[t.length - 1],
    south: t[0]
  };
}
function xpe(r, e) {
  const t = e?.minimumHeight || 0, n = e?.maximumHeight || 0, i = Jw(r), s = bpe(i), o = s.west, l = s.south, u = s.east, m = s.north, y = [];
  return y.push(new yt(o, m, t)), y.push(new yt(u, m, t)), y.push(new yt(u, l, t)), y.push(new yt(o, l, t)), y.push(new yt(o, m, n)), y.push(new yt(u, m, n)), y.push(new yt(u, l, n)), y.push(new yt(o, l, n)), y;
}
function Fk(r) {
  const e = r.token, t = {
    minimumHeight: r.minimumHeight,
    maximumHeight: r.maximumHeight
  }, n = xpe(e, t), i = vpe(e), s = i[0], o = i[1], l = yi.WGS84.cartographicToCartesian([
    s,
    o,
    t.maximumHeight
  ]), u = new yt(l[0], l[1], l[2]);
  n.push(u);
  const m = ik(n);
  return [...m.center, ...m.halfAxes];
}
const wpe = 4, Tpe = 8, Epe = {
  QUADTREE: wpe,
  OCTREE: Tpe
};
function Cpe(r, e, t) {
  if (r?.box) {
    const n = Bk(r.s2VolumeInfo.token), i = cpe(n, e), s = lpe(i), o = { ...r.s2VolumeInfo };
    switch (o.token = s, t) {
      case "OCTREE":
        const m = r.s2VolumeInfo, y = m.maximumHeight - m.minimumHeight, E = y / 2, P = m.minimumHeight + y / 2;
        m.minimumHeight = P - E, m.maximumHeight = P + E;
        break;
    }
    return {
      box: Fk(o),
      s2VolumeInfo: o
    };
  }
}
async function Nk(r) {
  const { subtree: e, subtreeData: t = {
    level: 0,
    x: 0,
    y: 0,
    z: 0
  }, parentData: n = {
    mortonIndex: 0,
    localLevel: -1,
    localX: 0,
    localY: 0,
    localZ: 0
  }, childIndex: i = 0, implicitOptions: s, loaderOptions: o, s2VolumeBox: l } = r, { subdivisionScheme: u, subtreeLevels: m, maximumLevel: y, contentUrlTemplate: E, subtreesUriTemplate: P, basePath: L } = s, U = { children: [], lodMetricValue: 0, contentUrl: "" };
  if (!y)
    return tB.once(`Missing 'maximumLevel' or 'availableLevels' property. The subtree ${E} won't be loaded...`), U;
  const V = n.localLevel + 1, q = t.level + V;
  if (q > y)
    return U;
  const j = Epe[u], K = Math.log2(j), Y = i & 1, de = i >> 1 & 1, ne = i >> 2 & 1, ae = Nf(n.localX, Y, 1), De = Nf(n.localY, de, 1), Ge = Nf(n.localZ, ne, 1), fe = Nf(t.x, ae, V), ve = Nf(t.y, De, V), me = Nf(t.z, Ge, V), X = Nf(n.mortonIndex, i, K), re = V === m && Z1(e.childSubtreeAvailability, X);
  let Me, ot, be, Ue;
  if (re) {
    const at = `${L}/${P}`, ct = U2(at, q, fe, ve, me);
    Me = await Kc(ct, Sk, o), Ue = 0, ot = { level: q, x: fe, y: ve, z: me }, be = { mortonIndex: 0, localLevel: 0, localX: 0, localY: 0, localZ: 0 };
  } else
    Me = e, Ue = (j ** V - 1) / (j - 1) + X, ot = t, be = { mortonIndex: X, localLevel: V, localX: ae, localY: De, localZ: Ge };
  if (!Z1(Me.tileAvailability, Ue))
    return U;
  Z1(Me.contentAvailability, Ue) && (U.contentUrl = U2(E, q, fe, ve, me));
  for (let at = 0; at < j; at++) {
    const ct = Cpe(l, at, u), gt = await Nk({
      subtree: Me,
      subtreeData: ot,
      parentData: be,
      childIndex: at,
      implicitOptions: s,
      loaderOptions: o,
      s2VolumeBox: ct
    });
    (gt.contentUrl || gt.children.length) && U.children.push(gt);
  }
  return U.contentUrl || U.children.length ? Spe(U, { level: q, x: fe, y: ve, z: me }, s, l) : U;
}
function Z1(r, e) {
  let t;
  return Array.isArray(r) ? (t = r[0], r.length > 1 && tB.once('Not supported extension "3DTILES_multiple_contents" has been detected')) : t = r, "constant" in t ? !!t.constant : t.explicitBitstream ? Mpe(e, t.explicitBitstream) : !1;
}
function Spe(r, e, t, n) {
  const { basePath: i, refine: s, getRefine: o, lodMetricType: l, getTileType: u, rootLodMetricValue: m, rootBoundingVolume: y } = t, E = r.contentUrl && r.contentUrl.replace(`${i}/`, ""), P = m / 2 ** e.level, L = n?.box ? { box: n.box } : y, U = Ipe(L, e, t.subdivisionScheme);
  return {
    children: r.children,
    contentUrl: r.contentUrl,
    content: { uri: E },
    id: r.contentUrl,
    refine: o(s),
    type: u(r),
    lodMetricType: l,
    lodMetricValue: P,
    geometricError: P,
    transform: r.transform,
    boundingVolume: U
  };
}
function Ipe(r, e, t) {
  if (r.region) {
    const { level: n, x: i, y: s, z: o } = e, [l, u, m, y, E, P] = r.region, L = 2 ** n, U = (m - l) / L, [V, q] = [l + U * i, l + U * (i + 1)], j = (y - u) / L, [K, Y] = [u + j * s, u + j * (s + 1)];
    let de, ne;
    if (t === "OCTREE") {
      const ae = (P - E) / L;
      [de, ne] = [
        E + ae * o,
        E + ae * (o + 1)
      ];
    } else
      [de, ne] = [E, P];
    return {
      region: [V, K, q, Y, de, ne]
    };
  }
  if (r.box)
    return r;
  throw new Error(`Unsupported bounding volume type ${JSON.stringify(r)}`);
}
function Nf(r, e, t) {
  return (r << t) + e;
}
function U2(r, e, t, n, i) {
  const s = Ppe({ level: e, x: t, y: n, z: i });
  return r.replace(/{level}|{x}|{y}|{z}/gi, (o) => s[o]);
}
function Ppe(r) {
  const e = {};
  for (const t in r)
    e[`{${t}}`] = r[t];
  return e;
}
function Mpe(r, e) {
  const t = Math.floor(r / 8), n = r % 8;
  return (e[t] >> n & 1) === 1;
}
function eT(r, e = "") {
  if (!e)
    return Xc.EMPTY;
  const n = e.split("?")[0].split(".").pop();
  switch (n) {
    case "pnts":
      return Xc.POINTCLOUD;
    case "i3dm":
    case "b3dm":
    case "glb":
    case "gltf":
      return Xc.SCENEGRAPH;
    default:
      return n || Xc.EMPTY;
  }
}
function tT(r) {
  switch (r) {
    case "REPLACE":
    case "replace":
      return yl.REPLACE;
    case "ADD":
    case "add":
      return yl.ADD;
    default:
      return r;
  }
}
function z2(r, e) {
  if (/^[a-z][0-9a-z+.-]*:/i.test(e)) {
    const n = new URL(r, `${e}/`);
    return decodeURI(n.toString());
  } else if (r.startsWith("/"))
    return r;
  return U5(e, r);
}
function mR(r, e) {
  if (!r)
    return null;
  let t;
  if (r.content) {
    const i = r.content.uri || r.content?.url;
    typeof i < "u" && (t = z2(i, e));
  }
  return {
    ...r,
    id: t,
    contentUrl: t,
    lodMetricType: Pp.GEOMETRIC_ERROR,
    lodMetricValue: r.geometricError,
    transformMatrix: r.transform,
    type: eT(r, t),
    refine: tT(r.refine)
  };
}
async function Rpe(r, e, t) {
  let n = null;
  const i = yR(r.root);
  i && r.root ? n = await _R(r.root, r, e, i, t) : n = mR(r.root, e);
  const s = [];
  for (s.push(n); s.length > 0; ) {
    const o = s.pop() || {}, l = o.children || [], u = [];
    for (const m of l) {
      const y = yR(m);
      let E;
      y ? E = await _R(m, r, e, y, t) : E = mR(m, e), E && (u.push(E), s.push(E));
    }
    o.children = u;
  }
  return n;
}
async function _R(r, e, t, n, i) {
  const { subdivisionScheme: s, maximumLevel: o, availableLevels: l, subtreeLevels: u, subtrees: { uri: m } } = n, y = U2(m, 0, 0, 0, 0), E = z2(y, t), P = await Kc(E, Sk, i), L = r.content?.uri, U = L ? z2(L, t) : "", V = e?.root?.refine, q = r.geometricError, j = r.boundingVolume.extensions?.["3DTILES_bounding_volume_S2"];
  if (j) {
    const ne = { box: Fk(j), s2VolumeInfo: j };
    r.boundingVolume = ne;
  }
  const K = r.boundingVolume, Y = {
    contentUrlTemplate: U,
    subtreesUriTemplate: m,
    subdivisionScheme: s,
    subtreeLevels: u,
    maximumLevel: Number.isFinite(l) ? l - 1 : o,
    refine: V,
    basePath: t,
    lodMetricType: Pp.GEOMETRIC_ERROR,
    rootLodMetricValue: q,
    rootBoundingVolume: K,
    getTileType: eT,
    getRefine: tT
  };
  return await Bpe(r, t, P, Y, i);
}
async function Bpe(r, e, t, n, i) {
  if (!r)
    return null;
  const { children: s, contentUrl: o } = await Nk({
    subtree: t,
    implicitOptions: n,
    loaderOptions: i
  });
  let l, u = null;
  return o && (l = o, u = { uri: o.replace(`${e}/`, "") }), {
    ...r,
    id: l,
    contentUrl: l,
    lodMetricType: Pp.GEOMETRIC_ERROR,
    lodMetricValue: r.geometricError,
    transformMatrix: r.transform,
    type: eT(r, l),
    refine: tT(r.refine),
    content: u || r.content,
    children: s
  };
}
function yR(r) {
  return r?.extensions?.["3DTILES_implicit_tiling"] || r?.implicitTiling;
}
const Uk = {
  dataType: null,
  batchType: null,
  id: "3d-tiles",
  name: "3D Tiles",
  module: "3d-tiles",
  version: yk,
  extensions: ["cmpt", "pnts", "b3dm", "i3dm"],
  mimeTypes: ["application/octet-stream"],
  tests: ["cmpt", "pnts", "b3dm", "i3dm"],
  parse: Ope,
  options: {
    "3d-tiles": {
      loadGLTF: !0,
      decodeQuantizedPositions: !1,
      isTileset: "auto",
      assetGltfUpAxis: null
    }
  }
};
async function Ope(r, e = {}, t) {
  const n = e["3d-tiles"] || {};
  let i;
  return n.isTileset === "auto" ? i = t?.url && t.url.indexOf(".json") !== -1 : i = n.isTileset, i ? Dpe(r, e, t) : Lpe(r, e, t);
}
async function Dpe(r, e, t) {
  const n = JSON.parse(new TextDecoder().decode(r)), i = t?.url || "", s = kpe(i), o = await Rpe(n, s, e || {});
  return {
    ...n,
    shape: "tileset3d",
    loader: Uk,
    url: i,
    queryString: t?.queryString || "",
    basePath: s,
    root: o || n.root,
    type: Xo.TILES3D,
    lodMetricType: Pp.GEOMETRIC_ERROR,
    lodMetricValue: n.root?.geometricError || 0
  };
}
async function Lpe(r, e, t) {
  const n = {
    content: {
      shape: "tile3d",
      featureIds: null
    }
  };
  return await Ck(r, 0, e, t, n.content), n.content;
}
function kpe(r) {
  return J2(r);
}
var Y1 = {}, vR;
function af() {
  return vR || (vR = 1, (function(r) {
    var e = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
    function t(s, o) {
      return Object.prototype.hasOwnProperty.call(s, o);
    }
    r.assign = function(s) {
      for (var o = Array.prototype.slice.call(arguments, 1); o.length; ) {
        var l = o.shift();
        if (l) {
          if (typeof l != "object")
            throw new TypeError(l + "must be non-object");
          for (var u in l)
            t(l, u) && (s[u] = l[u]);
        }
      }
      return s;
    }, r.shrinkBuf = function(s, o) {
      return s.length === o ? s : s.subarray ? s.subarray(0, o) : (s.length = o, s);
    };
    var n = {
      arraySet: function(s, o, l, u, m) {
        if (o.subarray && s.subarray) {
          s.set(o.subarray(l, l + u), m);
          return;
        }
        for (var y = 0; y < u; y++)
          s[m + y] = o[l + y];
      },
      // Join array of chunks to single array.
      flattenChunks: function(s) {
        var o, l, u, m, y, E;
        for (u = 0, o = 0, l = s.length; o < l; o++)
          u += s[o].length;
        for (E = new Uint8Array(u), m = 0, o = 0, l = s.length; o < l; o++)
          y = s[o], E.set(y, m), m += y.length;
        return E;
      }
    }, i = {
      arraySet: function(s, o, l, u, m) {
        for (var y = 0; y < u; y++)
          s[m + y] = o[l + y];
      },
      // Join array of chunks to single array.
      flattenChunks: function(s) {
        return [].concat.apply([], s);
      }
    };
    r.setTyped = function(s) {
      s ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, n)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, i));
    }, r.setTyped(e);
  })(Y1)), Y1;
}
var Md = {}, sl = {}, Uf = {}, bR;
function Fpe() {
  if (bR) return Uf;
  bR = 1;
  var r = af(), e = 4, t = 0, n = 1, i = 2;
  function s(Le) {
    for (var Gt = Le.length; --Gt >= 0; )
      Le[Gt] = 0;
  }
  var o = 0, l = 1, u = 2, m = 3, y = 258, E = 29, P = 256, L = P + 1 + E, U = 30, V = 19, q = 2 * L + 1, j = 15, K = 16, Y = 7, de = 256, ne = 16, ae = 17, De = 18, Ge = (
    /* extra bits for each length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
  ), fe = (
    /* extra bits for each distance code */
    [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
  ), ve = (
    /* extra bits for each bit length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
  ), me = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], X = 512, re = new Array((L + 2) * 2);
  s(re);
  var Me = new Array(U * 2);
  s(Me);
  var ot = new Array(X);
  s(ot);
  var be = new Array(y - m + 1);
  s(be);
  var Ue = new Array(E);
  s(Ue);
  var Xe = new Array(U);
  s(Xe);
  function lt(Le, Gt, Jt, pr, st) {
    this.static_tree = Le, this.extra_bits = Gt, this.extra_base = Jt, this.elems = pr, this.max_length = st, this.has_stree = Le && Le.length;
  }
  var at, ct, gt;
  function St(Le, Gt) {
    this.dyn_tree = Le, this.max_code = 0, this.stat_desc = Gt;
  }
  function Ot(Le) {
    return Le < 256 ? ot[Le] : ot[256 + (Le >>> 7)];
  }
  function dt(Le, Gt) {
    Le.pending_buf[Le.pending++] = Gt & 255, Le.pending_buf[Le.pending++] = Gt >>> 8 & 255;
  }
  function _r(Le, Gt, Jt) {
    Le.bi_valid > K - Jt ? (Le.bi_buf |= Gt << Le.bi_valid & 65535, dt(Le, Le.bi_buf), Le.bi_buf = Gt >> K - Le.bi_valid, Le.bi_valid += Jt - K) : (Le.bi_buf |= Gt << Le.bi_valid & 65535, Le.bi_valid += Jt);
  }
  function sr(Le, Gt, Jt) {
    _r(
      Le,
      Jt[Gt * 2],
      Jt[Gt * 2 + 1]
      /*.Len*/
    );
  }
  function tr(Le, Gt) {
    var Jt = 0;
    do
      Jt |= Le & 1, Le >>>= 1, Jt <<= 1;
    while (--Gt > 0);
    return Jt >>> 1;
  }
  function Wt(Le) {
    Le.bi_valid === 16 ? (dt(Le, Le.bi_buf), Le.bi_buf = 0, Le.bi_valid = 0) : Le.bi_valid >= 8 && (Le.pending_buf[Le.pending++] = Le.bi_buf & 255, Le.bi_buf >>= 8, Le.bi_valid -= 8);
  }
  function yr(Le, Gt) {
    var Jt = Gt.dyn_tree, pr = Gt.max_code, st = Gt.stat_desc.static_tree, Ft = Gt.stat_desc.has_stree, _e = Gt.stat_desc.extra_bits, Xt = Gt.stat_desc.extra_base, Ct = Gt.stat_desc.max_length, $, Et, Rt, Pe, tt, At, Q = 0;
    for (Pe = 0; Pe <= j; Pe++)
      Le.bl_count[Pe] = 0;
    for (Jt[Le.heap[Le.heap_max] * 2 + 1] = 0, $ = Le.heap_max + 1; $ < q; $++)
      Et = Le.heap[$], Pe = Jt[Jt[Et * 2 + 1] * 2 + 1] + 1, Pe > Ct && (Pe = Ct, Q++), Jt[Et * 2 + 1] = Pe, !(Et > pr) && (Le.bl_count[Pe]++, tt = 0, Et >= Xt && (tt = _e[Et - Xt]), At = Jt[Et * 2], Le.opt_len += At * (Pe + tt), Ft && (Le.static_len += At * (st[Et * 2 + 1] + tt)));
    if (Q !== 0) {
      do {
        for (Pe = Ct - 1; Le.bl_count[Pe] === 0; )
          Pe--;
        Le.bl_count[Pe]--, Le.bl_count[Pe + 1] += 2, Le.bl_count[Ct]--, Q -= 2;
      } while (Q > 0);
      for (Pe = Ct; Pe !== 0; Pe--)
        for (Et = Le.bl_count[Pe]; Et !== 0; )
          Rt = Le.heap[--$], !(Rt > pr) && (Jt[Rt * 2 + 1] !== Pe && (Le.opt_len += (Pe - Jt[Rt * 2 + 1]) * Jt[Rt * 2], Jt[Rt * 2 + 1] = Pe), Et--);
    }
  }
  function An(Le, Gt, Jt) {
    var pr = new Array(j + 1), st = 0, Ft, _e;
    for (Ft = 1; Ft <= j; Ft++)
      pr[Ft] = st = st + Jt[Ft - 1] << 1;
    for (_e = 0; _e <= Gt; _e++) {
      var Xt = Le[_e * 2 + 1];
      Xt !== 0 && (Le[_e * 2] = tr(pr[Xt]++, Xt));
    }
  }
  function Fr() {
    var Le, Gt, Jt, pr, st, Ft = new Array(j + 1);
    for (Jt = 0, pr = 0; pr < E - 1; pr++)
      for (Ue[pr] = Jt, Le = 0; Le < 1 << Ge[pr]; Le++)
        be[Jt++] = pr;
    for (be[Jt - 1] = pr, st = 0, pr = 0; pr < 16; pr++)
      for (Xe[pr] = st, Le = 0; Le < 1 << fe[pr]; Le++)
        ot[st++] = pr;
    for (st >>= 7; pr < U; pr++)
      for (Xe[pr] = st << 7, Le = 0; Le < 1 << fe[pr] - 7; Le++)
        ot[256 + st++] = pr;
    for (Gt = 0; Gt <= j; Gt++)
      Ft[Gt] = 0;
    for (Le = 0; Le <= 143; )
      re[Le * 2 + 1] = 8, Le++, Ft[8]++;
    for (; Le <= 255; )
      re[Le * 2 + 1] = 9, Le++, Ft[9]++;
    for (; Le <= 279; )
      re[Le * 2 + 1] = 7, Le++, Ft[7]++;
    for (; Le <= 287; )
      re[Le * 2 + 1] = 8, Le++, Ft[8]++;
    for (An(re, L + 1, Ft), Le = 0; Le < U; Le++)
      Me[Le * 2 + 1] = 5, Me[Le * 2] = tr(Le, 5);
    at = new lt(re, Ge, P + 1, L, j), ct = new lt(Me, fe, 0, U, j), gt = new lt(new Array(0), ve, 0, V, Y);
  }
  function Pr(Le) {
    var Gt;
    for (Gt = 0; Gt < L; Gt++)
      Le.dyn_ltree[Gt * 2] = 0;
    for (Gt = 0; Gt < U; Gt++)
      Le.dyn_dtree[Gt * 2] = 0;
    for (Gt = 0; Gt < V; Gt++)
      Le.bl_tree[Gt * 2] = 0;
    Le.dyn_ltree[de * 2] = 1, Le.opt_len = Le.static_len = 0, Le.last_lit = Le.matches = 0;
  }
  function $n(Le) {
    Le.bi_valid > 8 ? dt(Le, Le.bi_buf) : Le.bi_valid > 0 && (Le.pending_buf[Le.pending++] = Le.bi_buf), Le.bi_buf = 0, Le.bi_valid = 0;
  }
  function xr(Le, Gt, Jt, pr) {
    $n(Le), dt(Le, Jt), dt(Le, ~Jt), r.arraySet(Le.pending_buf, Le.window, Gt, Jt, Le.pending), Le.pending += Jt;
  }
  function wr(Le, Gt, Jt, pr) {
    var st = Gt * 2, Ft = Jt * 2;
    return Le[st] < Le[Ft] || Le[st] === Le[Ft] && pr[Gt] <= pr[Jt];
  }
  function gn(Le, Gt, Jt) {
    for (var pr = Le.heap[Jt], st = Jt << 1; st <= Le.heap_len && (st < Le.heap_len && wr(Gt, Le.heap[st + 1], Le.heap[st], Le.depth) && st++, !wr(Gt, pr, Le.heap[st], Le.depth)); )
      Le.heap[Jt] = Le.heap[st], Jt = st, st <<= 1;
    Le.heap[Jt] = pr;
  }
  function zr(Le, Gt, Jt) {
    var pr, st, Ft = 0, _e, Xt;
    if (Le.last_lit !== 0)
      do
        pr = Le.pending_buf[Le.d_buf + Ft * 2] << 8 | Le.pending_buf[Le.d_buf + Ft * 2 + 1], st = Le.pending_buf[Le.l_buf + Ft], Ft++, pr === 0 ? sr(Le, st, Gt) : (_e = be[st], sr(Le, _e + P + 1, Gt), Xt = Ge[_e], Xt !== 0 && (st -= Ue[_e], _r(Le, st, Xt)), pr--, _e = Ot(pr), sr(Le, _e, Jt), Xt = fe[_e], Xt !== 0 && (pr -= Xe[_e], _r(Le, pr, Xt)));
      while (Ft < Le.last_lit);
    sr(Le, de, Gt);
  }
  function ci(Le, Gt) {
    var Jt = Gt.dyn_tree, pr = Gt.stat_desc.static_tree, st = Gt.stat_desc.has_stree, Ft = Gt.stat_desc.elems, _e, Xt, Ct = -1, $;
    for (Le.heap_len = 0, Le.heap_max = q, _e = 0; _e < Ft; _e++)
      Jt[_e * 2] !== 0 ? (Le.heap[++Le.heap_len] = Ct = _e, Le.depth[_e] = 0) : Jt[_e * 2 + 1] = 0;
    for (; Le.heap_len < 2; )
      $ = Le.heap[++Le.heap_len] = Ct < 2 ? ++Ct : 0, Jt[$ * 2] = 1, Le.depth[$] = 0, Le.opt_len--, st && (Le.static_len -= pr[$ * 2 + 1]);
    for (Gt.max_code = Ct, _e = Le.heap_len >> 1; _e >= 1; _e--)
      gn(Le, Jt, _e);
    $ = Ft;
    do
      _e = Le.heap[
        1
        /*SMALLEST*/
      ], Le.heap[
        1
        /*SMALLEST*/
      ] = Le.heap[Le.heap_len--], gn(
        Le,
        Jt,
        1
        /*SMALLEST*/
      ), Xt = Le.heap[
        1
        /*SMALLEST*/
      ], Le.heap[--Le.heap_max] = _e, Le.heap[--Le.heap_max] = Xt, Jt[$ * 2] = Jt[_e * 2] + Jt[Xt * 2], Le.depth[$] = (Le.depth[_e] >= Le.depth[Xt] ? Le.depth[_e] : Le.depth[Xt]) + 1, Jt[_e * 2 + 1] = Jt[Xt * 2 + 1] = $, Le.heap[
        1
        /*SMALLEST*/
      ] = $++, gn(
        Le,
        Jt,
        1
        /*SMALLEST*/
      );
    while (Le.heap_len >= 2);
    Le.heap[--Le.heap_max] = Le.heap[
      1
      /*SMALLEST*/
    ], yr(Le, Gt), An(Jt, Ct, Le.bl_count);
  }
  function Jn(Le, Gt, Jt) {
    var pr, st = -1, Ft, _e = Gt[1], Xt = 0, Ct = 7, $ = 4;
    for (_e === 0 && (Ct = 138, $ = 3), Gt[(Jt + 1) * 2 + 1] = 65535, pr = 0; pr <= Jt; pr++)
      Ft = _e, _e = Gt[(pr + 1) * 2 + 1], !(++Xt < Ct && Ft === _e) && (Xt < $ ? Le.bl_tree[Ft * 2] += Xt : Ft !== 0 ? (Ft !== st && Le.bl_tree[Ft * 2]++, Le.bl_tree[ne * 2]++) : Xt <= 10 ? Le.bl_tree[ae * 2]++ : Le.bl_tree[De * 2]++, Xt = 0, st = Ft, _e === 0 ? (Ct = 138, $ = 3) : Ft === _e ? (Ct = 6, $ = 3) : (Ct = 7, $ = 4));
  }
  function wn(Le, Gt, Jt) {
    var pr, st = -1, Ft, _e = Gt[1], Xt = 0, Ct = 7, $ = 4;
    for (_e === 0 && (Ct = 138, $ = 3), pr = 0; pr <= Jt; pr++)
      if (Ft = _e, _e = Gt[(pr + 1) * 2 + 1], !(++Xt < Ct && Ft === _e)) {
        if (Xt < $)
          do
            sr(Le, Ft, Le.bl_tree);
          while (--Xt !== 0);
        else Ft !== 0 ? (Ft !== st && (sr(Le, Ft, Le.bl_tree), Xt--), sr(Le, ne, Le.bl_tree), _r(Le, Xt - 3, 2)) : Xt <= 10 ? (sr(Le, ae, Le.bl_tree), _r(Le, Xt - 3, 3)) : (sr(Le, De, Le.bl_tree), _r(Le, Xt - 11, 7));
        Xt = 0, st = Ft, _e === 0 ? (Ct = 138, $ = 3) : Ft === _e ? (Ct = 6, $ = 3) : (Ct = 7, $ = 4);
      }
  }
  function ii(Le) {
    var Gt;
    for (Jn(Le, Le.dyn_ltree, Le.l_desc.max_code), Jn(Le, Le.dyn_dtree, Le.d_desc.max_code), ci(Le, Le.bl_desc), Gt = V - 1; Gt >= 3 && Le.bl_tree[me[Gt] * 2 + 1] === 0; Gt--)
      ;
    return Le.opt_len += 3 * (Gt + 1) + 5 + 5 + 4, Gt;
  }
  function qn(Le, Gt, Jt, pr) {
    var st;
    for (_r(Le, Gt - 257, 5), _r(Le, Jt - 1, 5), _r(Le, pr - 4, 4), st = 0; st < pr; st++)
      _r(Le, Le.bl_tree[me[st] * 2 + 1], 3);
    wn(Le, Le.dyn_ltree, Gt - 1), wn(Le, Le.dyn_dtree, Jt - 1);
  }
  function Rn(Le) {
    var Gt = 4093624447, Jt;
    for (Jt = 0; Jt <= 31; Jt++, Gt >>>= 1)
      if (Gt & 1 && Le.dyn_ltree[Jt * 2] !== 0)
        return t;
    if (Le.dyn_ltree[18] !== 0 || Le.dyn_ltree[20] !== 0 || Le.dyn_ltree[26] !== 0)
      return n;
    for (Jt = 32; Jt < P; Jt++)
      if (Le.dyn_ltree[Jt * 2] !== 0)
        return n;
    return t;
  }
  var ei = !1;
  function Zt(Le) {
    ei || (Fr(), ei = !0), Le.l_desc = new St(Le.dyn_ltree, at), Le.d_desc = new St(Le.dyn_dtree, ct), Le.bl_desc = new St(Le.bl_tree, gt), Le.bi_buf = 0, Le.bi_valid = 0, Pr(Le);
  }
  function br(Le, Gt, Jt, pr) {
    _r(Le, (o << 1) + (pr ? 1 : 0), 3), xr(Le, Gt, Jt);
  }
  function Nr(Le) {
    _r(Le, l << 1, 3), sr(Le, de, re), Wt(Le);
  }
  function on(Le, Gt, Jt, pr) {
    var st, Ft, _e = 0;
    Le.level > 0 ? (Le.strm.data_type === i && (Le.strm.data_type = Rn(Le)), ci(Le, Le.l_desc), ci(Le, Le.d_desc), _e = ii(Le), st = Le.opt_len + 3 + 7 >>> 3, Ft = Le.static_len + 3 + 7 >>> 3, Ft <= st && (st = Ft)) : st = Ft = Jt + 5, Jt + 4 <= st && Gt !== -1 ? br(Le, Gt, Jt, pr) : Le.strategy === e || Ft === st ? (_r(Le, (l << 1) + (pr ? 1 : 0), 3), zr(Le, re, Me)) : (_r(Le, (u << 1) + (pr ? 1 : 0), 3), qn(Le, Le.l_desc.max_code + 1, Le.d_desc.max_code + 1, _e + 1), zr(Le, Le.dyn_ltree, Le.dyn_dtree)), Pr(Le), pr && $n(Le);
  }
  function pi(Le, Gt, Jt) {
    return Le.pending_buf[Le.d_buf + Le.last_lit * 2] = Gt >>> 8 & 255, Le.pending_buf[Le.d_buf + Le.last_lit * 2 + 1] = Gt & 255, Le.pending_buf[Le.l_buf + Le.last_lit] = Jt & 255, Le.last_lit++, Gt === 0 ? Le.dyn_ltree[Jt * 2]++ : (Le.matches++, Gt--, Le.dyn_ltree[(be[Jt] + P + 1) * 2]++, Le.dyn_dtree[Ot(Gt) * 2]++), Le.last_lit === Le.lit_bufsize - 1;
  }
  return Uf._tr_init = Zt, Uf._tr_stored_block = br, Uf._tr_flush_block = on, Uf._tr_tally = pi, Uf._tr_align = Nr, Uf;
}
var K1, xR;
function zk() {
  if (xR) return K1;
  xR = 1;
  function r(e, t, n, i) {
    for (var s = e & 65535 | 0, o = e >>> 16 & 65535 | 0, l = 0; n !== 0; ) {
      l = n > 2e3 ? 2e3 : n, n -= l;
      do
        s = s + t[i++] | 0, o = o + s | 0;
      while (--l);
      s %= 65521, o %= 65521;
    }
    return s | o << 16 | 0;
  }
  return K1 = r, K1;
}
var Q1, wR;
function Vk() {
  if (wR) return Q1;
  wR = 1;
  function r() {
    for (var n, i = [], s = 0; s < 256; s++) {
      n = s;
      for (var o = 0; o < 8; o++)
        n = n & 1 ? 3988292384 ^ n >>> 1 : n >>> 1;
      i[s] = n;
    }
    return i;
  }
  var e = r();
  function t(n, i, s, o) {
    var l = e, u = o + s;
    n ^= -1;
    for (var m = o; m < u; m++)
      n = n >>> 8 ^ l[(n ^ i[m]) & 255];
    return n ^ -1;
  }
  return Q1 = t, Q1;
}
var J1, TR;
function rT() {
  return TR || (TR = 1, J1 = {
    2: "need dictionary",
    /* Z_NEED_DICT       2  */
    1: "stream end",
    /* Z_STREAM_END      1  */
    0: "",
    /* Z_OK              0  */
    "-1": "file error",
    /* Z_ERRNO         (-1) */
    "-2": "stream error",
    /* Z_STREAM_ERROR  (-2) */
    "-3": "data error",
    /* Z_DATA_ERROR    (-3) */
    "-4": "insufficient memory",
    /* Z_MEM_ERROR     (-4) */
    "-5": "buffer error",
    /* Z_BUF_ERROR     (-5) */
    "-6": "incompatible version"
    /* Z_VERSION_ERROR (-6) */
  }), J1;
}
var ER;
function Npe() {
  if (ER) return sl;
  ER = 1;
  var r = af(), e = Fpe(), t = zk(), n = Vk(), i = rT(), s = 0, o = 1, l = 3, u = 4, m = 5, y = 0, E = 1, P = -2, L = -3, U = -5, V = -1, q = 1, j = 2, K = 3, Y = 4, de = 0, ne = 2, ae = 8, De = 9, Ge = 15, fe = 8, ve = 29, me = 256, X = me + 1 + ve, re = 30, Me = 19, ot = 2 * X + 1, be = 15, Ue = 3, Xe = 258, lt = Xe + Ue + 1, at = 32, ct = 42, gt = 69, St = 73, Ot = 91, dt = 103, _r = 113, sr = 666, tr = 1, Wt = 2, yr = 3, An = 4, Fr = 3;
  function Pr($, Et) {
    return $.msg = i[Et], Et;
  }
  function $n($) {
    return ($ << 1) - ($ > 4 ? 9 : 0);
  }
  function xr($) {
    for (var Et = $.length; --Et >= 0; )
      $[Et] = 0;
  }
  function wr($) {
    var Et = $.state, Rt = Et.pending;
    Rt > $.avail_out && (Rt = $.avail_out), Rt !== 0 && (r.arraySet($.output, Et.pending_buf, Et.pending_out, Rt, $.next_out), $.next_out += Rt, Et.pending_out += Rt, $.total_out += Rt, $.avail_out -= Rt, Et.pending -= Rt, Et.pending === 0 && (Et.pending_out = 0));
  }
  function gn($, Et) {
    e._tr_flush_block($, $.block_start >= 0 ? $.block_start : -1, $.strstart - $.block_start, Et), $.block_start = $.strstart, wr($.strm);
  }
  function zr($, Et) {
    $.pending_buf[$.pending++] = Et;
  }
  function ci($, Et) {
    $.pending_buf[$.pending++] = Et >>> 8 & 255, $.pending_buf[$.pending++] = Et & 255;
  }
  function Jn($, Et, Rt, Pe) {
    var tt = $.avail_in;
    return tt > Pe && (tt = Pe), tt === 0 ? 0 : ($.avail_in -= tt, r.arraySet(Et, $.input, $.next_in, tt, Rt), $.state.wrap === 1 ? $.adler = t($.adler, Et, tt, Rt) : $.state.wrap === 2 && ($.adler = n($.adler, Et, tt, Rt)), $.next_in += tt, $.total_in += tt, tt);
  }
  function wn($, Et) {
    var Rt = $.max_chain_length, Pe = $.strstart, tt, At, Q = $.prev_length, ie = $.nice_match, ce = $.strstart > $.w_size - lt ? $.strstart - ($.w_size - lt) : 0, we = $.window, Ne = $.w_mask, pe = $.prev, Te = $.strstart + Xe, le = we[Pe + Q - 1], ge = we[Pe + Q];
    $.prev_length >= $.good_match && (Rt >>= 2), ie > $.lookahead && (ie = $.lookahead);
    do
      if (tt = Et, !(we[tt + Q] !== ge || we[tt + Q - 1] !== le || we[tt] !== we[Pe] || we[++tt] !== we[Pe + 1])) {
        Pe += 2, tt++;
        do
          ;
        while (we[++Pe] === we[++tt] && we[++Pe] === we[++tt] && we[++Pe] === we[++tt] && we[++Pe] === we[++tt] && we[++Pe] === we[++tt] && we[++Pe] === we[++tt] && we[++Pe] === we[++tt] && we[++Pe] === we[++tt] && Pe < Te);
        if (At = Xe - (Te - Pe), Pe = Te - Xe, At > Q) {
          if ($.match_start = Et, Q = At, At >= ie)
            break;
          le = we[Pe + Q - 1], ge = we[Pe + Q];
        }
      }
    while ((Et = pe[Et & Ne]) > ce && --Rt !== 0);
    return Q <= $.lookahead ? Q : $.lookahead;
  }
  function ii($) {
    var Et = $.w_size, Rt, Pe, tt, At, Q;
    do {
      if (At = $.window_size - $.lookahead - $.strstart, $.strstart >= Et + (Et - lt)) {
        r.arraySet($.window, $.window, Et, Et, 0), $.match_start -= Et, $.strstart -= Et, $.block_start -= Et, Pe = $.hash_size, Rt = Pe;
        do
          tt = $.head[--Rt], $.head[Rt] = tt >= Et ? tt - Et : 0;
        while (--Pe);
        Pe = Et, Rt = Pe;
        do
          tt = $.prev[--Rt], $.prev[Rt] = tt >= Et ? tt - Et : 0;
        while (--Pe);
        At += Et;
      }
      if ($.strm.avail_in === 0)
        break;
      if (Pe = Jn($.strm, $.window, $.strstart + $.lookahead, At), $.lookahead += Pe, $.lookahead + $.insert >= Ue)
        for (Q = $.strstart - $.insert, $.ins_h = $.window[Q], $.ins_h = ($.ins_h << $.hash_shift ^ $.window[Q + 1]) & $.hash_mask; $.insert && ($.ins_h = ($.ins_h << $.hash_shift ^ $.window[Q + Ue - 1]) & $.hash_mask, $.prev[Q & $.w_mask] = $.head[$.ins_h], $.head[$.ins_h] = Q, Q++, $.insert--, !($.lookahead + $.insert < Ue)); )
          ;
    } while ($.lookahead < lt && $.strm.avail_in !== 0);
  }
  function qn($, Et) {
    var Rt = 65535;
    for (Rt > $.pending_buf_size - 5 && (Rt = $.pending_buf_size - 5); ; ) {
      if ($.lookahead <= 1) {
        if (ii($), $.lookahead === 0 && Et === s)
          return tr;
        if ($.lookahead === 0)
          break;
      }
      $.strstart += $.lookahead, $.lookahead = 0;
      var Pe = $.block_start + Rt;
      if (($.strstart === 0 || $.strstart >= Pe) && ($.lookahead = $.strstart - Pe, $.strstart = Pe, gn($, !1), $.strm.avail_out === 0) || $.strstart - $.block_start >= $.w_size - lt && (gn($, !1), $.strm.avail_out === 0))
        return tr;
    }
    return $.insert = 0, Et === u ? (gn($, !0), $.strm.avail_out === 0 ? yr : An) : ($.strstart > $.block_start && (gn($, !1), $.strm.avail_out === 0), tr);
  }
  function Rn($, Et) {
    for (var Rt, Pe; ; ) {
      if ($.lookahead < lt) {
        if (ii($), $.lookahead < lt && Et === s)
          return tr;
        if ($.lookahead === 0)
          break;
      }
      if (Rt = 0, $.lookahead >= Ue && ($.ins_h = ($.ins_h << $.hash_shift ^ $.window[$.strstart + Ue - 1]) & $.hash_mask, Rt = $.prev[$.strstart & $.w_mask] = $.head[$.ins_h], $.head[$.ins_h] = $.strstart), Rt !== 0 && $.strstart - Rt <= $.w_size - lt && ($.match_length = wn($, Rt)), $.match_length >= Ue)
        if (Pe = e._tr_tally($, $.strstart - $.match_start, $.match_length - Ue), $.lookahead -= $.match_length, $.match_length <= $.max_lazy_match && $.lookahead >= Ue) {
          $.match_length--;
          do
            $.strstart++, $.ins_h = ($.ins_h << $.hash_shift ^ $.window[$.strstart + Ue - 1]) & $.hash_mask, Rt = $.prev[$.strstart & $.w_mask] = $.head[$.ins_h], $.head[$.ins_h] = $.strstart;
          while (--$.match_length !== 0);
          $.strstart++;
        } else
          $.strstart += $.match_length, $.match_length = 0, $.ins_h = $.window[$.strstart], $.ins_h = ($.ins_h << $.hash_shift ^ $.window[$.strstart + 1]) & $.hash_mask;
      else
        Pe = e._tr_tally($, 0, $.window[$.strstart]), $.lookahead--, $.strstart++;
      if (Pe && (gn($, !1), $.strm.avail_out === 0))
        return tr;
    }
    return $.insert = $.strstart < Ue - 1 ? $.strstart : Ue - 1, Et === u ? (gn($, !0), $.strm.avail_out === 0 ? yr : An) : $.last_lit && (gn($, !1), $.strm.avail_out === 0) ? tr : Wt;
  }
  function ei($, Et) {
    for (var Rt, Pe, tt; ; ) {
      if ($.lookahead < lt) {
        if (ii($), $.lookahead < lt && Et === s)
          return tr;
        if ($.lookahead === 0)
          break;
      }
      if (Rt = 0, $.lookahead >= Ue && ($.ins_h = ($.ins_h << $.hash_shift ^ $.window[$.strstart + Ue - 1]) & $.hash_mask, Rt = $.prev[$.strstart & $.w_mask] = $.head[$.ins_h], $.head[$.ins_h] = $.strstart), $.prev_length = $.match_length, $.prev_match = $.match_start, $.match_length = Ue - 1, Rt !== 0 && $.prev_length < $.max_lazy_match && $.strstart - Rt <= $.w_size - lt && ($.match_length = wn($, Rt), $.match_length <= 5 && ($.strategy === q || $.match_length === Ue && $.strstart - $.match_start > 4096) && ($.match_length = Ue - 1)), $.prev_length >= Ue && $.match_length <= $.prev_length) {
        tt = $.strstart + $.lookahead - Ue, Pe = e._tr_tally($, $.strstart - 1 - $.prev_match, $.prev_length - Ue), $.lookahead -= $.prev_length - 1, $.prev_length -= 2;
        do
          ++$.strstart <= tt && ($.ins_h = ($.ins_h << $.hash_shift ^ $.window[$.strstart + Ue - 1]) & $.hash_mask, Rt = $.prev[$.strstart & $.w_mask] = $.head[$.ins_h], $.head[$.ins_h] = $.strstart);
        while (--$.prev_length !== 0);
        if ($.match_available = 0, $.match_length = Ue - 1, $.strstart++, Pe && (gn($, !1), $.strm.avail_out === 0))
          return tr;
      } else if ($.match_available) {
        if (Pe = e._tr_tally($, 0, $.window[$.strstart - 1]), Pe && gn($, !1), $.strstart++, $.lookahead--, $.strm.avail_out === 0)
          return tr;
      } else
        $.match_available = 1, $.strstart++, $.lookahead--;
    }
    return $.match_available && (Pe = e._tr_tally($, 0, $.window[$.strstart - 1]), $.match_available = 0), $.insert = $.strstart < Ue - 1 ? $.strstart : Ue - 1, Et === u ? (gn($, !0), $.strm.avail_out === 0 ? yr : An) : $.last_lit && (gn($, !1), $.strm.avail_out === 0) ? tr : Wt;
  }
  function Zt($, Et) {
    for (var Rt, Pe, tt, At, Q = $.window; ; ) {
      if ($.lookahead <= Xe) {
        if (ii($), $.lookahead <= Xe && Et === s)
          return tr;
        if ($.lookahead === 0)
          break;
      }
      if ($.match_length = 0, $.lookahead >= Ue && $.strstart > 0 && (tt = $.strstart - 1, Pe = Q[tt], Pe === Q[++tt] && Pe === Q[++tt] && Pe === Q[++tt])) {
        At = $.strstart + Xe;
        do
          ;
        while (Pe === Q[++tt] && Pe === Q[++tt] && Pe === Q[++tt] && Pe === Q[++tt] && Pe === Q[++tt] && Pe === Q[++tt] && Pe === Q[++tt] && Pe === Q[++tt] && tt < At);
        $.match_length = Xe - (At - tt), $.match_length > $.lookahead && ($.match_length = $.lookahead);
      }
      if ($.match_length >= Ue ? (Rt = e._tr_tally($, 1, $.match_length - Ue), $.lookahead -= $.match_length, $.strstart += $.match_length, $.match_length = 0) : (Rt = e._tr_tally($, 0, $.window[$.strstart]), $.lookahead--, $.strstart++), Rt && (gn($, !1), $.strm.avail_out === 0))
        return tr;
    }
    return $.insert = 0, Et === u ? (gn($, !0), $.strm.avail_out === 0 ? yr : An) : $.last_lit && (gn($, !1), $.strm.avail_out === 0) ? tr : Wt;
  }
  function br($, Et) {
    for (var Rt; ; ) {
      if ($.lookahead === 0 && (ii($), $.lookahead === 0)) {
        if (Et === s)
          return tr;
        break;
      }
      if ($.match_length = 0, Rt = e._tr_tally($, 0, $.window[$.strstart]), $.lookahead--, $.strstart++, Rt && (gn($, !1), $.strm.avail_out === 0))
        return tr;
    }
    return $.insert = 0, Et === u ? (gn($, !0), $.strm.avail_out === 0 ? yr : An) : $.last_lit && (gn($, !1), $.strm.avail_out === 0) ? tr : Wt;
  }
  function Nr($, Et, Rt, Pe, tt) {
    this.good_length = $, this.max_lazy = Et, this.nice_length = Rt, this.max_chain = Pe, this.func = tt;
  }
  var on;
  on = [
    /*      good lazy nice chain */
    new Nr(0, 0, 0, 0, qn),
    /* 0 store only */
    new Nr(4, 4, 8, 4, Rn),
    /* 1 max speed, no lazy matches */
    new Nr(4, 5, 16, 8, Rn),
    /* 2 */
    new Nr(4, 6, 32, 32, Rn),
    /* 3 */
    new Nr(4, 4, 16, 16, ei),
    /* 4 lazy matches */
    new Nr(8, 16, 32, 32, ei),
    /* 5 */
    new Nr(8, 16, 128, 128, ei),
    /* 6 */
    new Nr(8, 32, 128, 256, ei),
    /* 7 */
    new Nr(32, 128, 258, 1024, ei),
    /* 8 */
    new Nr(32, 258, 258, 4096, ei)
    /* 9 max compression */
  ];
  function pi($) {
    $.window_size = 2 * $.w_size, xr($.head), $.max_lazy_match = on[$.level].max_lazy, $.good_match = on[$.level].good_length, $.nice_match = on[$.level].nice_length, $.max_chain_length = on[$.level].max_chain, $.strstart = 0, $.block_start = 0, $.lookahead = 0, $.insert = 0, $.match_length = $.prev_length = Ue - 1, $.match_available = 0, $.ins_h = 0;
  }
  function Le() {
    this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = ae, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new r.Buf16(ot * 2), this.dyn_dtree = new r.Buf16((2 * re + 1) * 2), this.bl_tree = new r.Buf16((2 * Me + 1) * 2), xr(this.dyn_ltree), xr(this.dyn_dtree), xr(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new r.Buf16(be + 1), this.heap = new r.Buf16(2 * X + 1), xr(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new r.Buf16(2 * X + 1), xr(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
  }
  function Gt($) {
    var Et;
    return !$ || !$.state ? Pr($, P) : ($.total_in = $.total_out = 0, $.data_type = ne, Et = $.state, Et.pending = 0, Et.pending_out = 0, Et.wrap < 0 && (Et.wrap = -Et.wrap), Et.status = Et.wrap ? ct : _r, $.adler = Et.wrap === 2 ? 0 : 1, Et.last_flush = s, e._tr_init(Et), y);
  }
  function Jt($) {
    var Et = Gt($);
    return Et === y && pi($.state), Et;
  }
  function pr($, Et) {
    return !$ || !$.state || $.state.wrap !== 2 ? P : ($.state.gzhead = Et, y);
  }
  function st($, Et, Rt, Pe, tt, At) {
    if (!$)
      return P;
    var Q = 1;
    if (Et === V && (Et = 6), Pe < 0 ? (Q = 0, Pe = -Pe) : Pe > 15 && (Q = 2, Pe -= 16), tt < 1 || tt > De || Rt !== ae || Pe < 8 || Pe > 15 || Et < 0 || Et > 9 || At < 0 || At > Y)
      return Pr($, P);
    Pe === 8 && (Pe = 9);
    var ie = new Le();
    return $.state = ie, ie.strm = $, ie.wrap = Q, ie.gzhead = null, ie.w_bits = Pe, ie.w_size = 1 << ie.w_bits, ie.w_mask = ie.w_size - 1, ie.hash_bits = tt + 7, ie.hash_size = 1 << ie.hash_bits, ie.hash_mask = ie.hash_size - 1, ie.hash_shift = ~~((ie.hash_bits + Ue - 1) / Ue), ie.window = new r.Buf8(ie.w_size * 2), ie.head = new r.Buf16(ie.hash_size), ie.prev = new r.Buf16(ie.w_size), ie.lit_bufsize = 1 << tt + 6, ie.pending_buf_size = ie.lit_bufsize * 4, ie.pending_buf = new r.Buf8(ie.pending_buf_size), ie.d_buf = 1 * ie.lit_bufsize, ie.l_buf = 3 * ie.lit_bufsize, ie.level = Et, ie.strategy = At, ie.method = Rt, Jt($);
  }
  function Ft($, Et) {
    return st($, Et, ae, Ge, fe, de);
  }
  function _e($, Et) {
    var Rt, Pe, tt, At;
    if (!$ || !$.state || Et > m || Et < 0)
      return $ ? Pr($, P) : P;
    if (Pe = $.state, !$.output || !$.input && $.avail_in !== 0 || Pe.status === sr && Et !== u)
      return Pr($, $.avail_out === 0 ? U : P);
    if (Pe.strm = $, Rt = Pe.last_flush, Pe.last_flush = Et, Pe.status === ct)
      if (Pe.wrap === 2)
        $.adler = 0, zr(Pe, 31), zr(Pe, 139), zr(Pe, 8), Pe.gzhead ? (zr(
          Pe,
          (Pe.gzhead.text ? 1 : 0) + (Pe.gzhead.hcrc ? 2 : 0) + (Pe.gzhead.extra ? 4 : 0) + (Pe.gzhead.name ? 8 : 0) + (Pe.gzhead.comment ? 16 : 0)
        ), zr(Pe, Pe.gzhead.time & 255), zr(Pe, Pe.gzhead.time >> 8 & 255), zr(Pe, Pe.gzhead.time >> 16 & 255), zr(Pe, Pe.gzhead.time >> 24 & 255), zr(Pe, Pe.level === 9 ? 2 : Pe.strategy >= j || Pe.level < 2 ? 4 : 0), zr(Pe, Pe.gzhead.os & 255), Pe.gzhead.extra && Pe.gzhead.extra.length && (zr(Pe, Pe.gzhead.extra.length & 255), zr(Pe, Pe.gzhead.extra.length >> 8 & 255)), Pe.gzhead.hcrc && ($.adler = n($.adler, Pe.pending_buf, Pe.pending, 0)), Pe.gzindex = 0, Pe.status = gt) : (zr(Pe, 0), zr(Pe, 0), zr(Pe, 0), zr(Pe, 0), zr(Pe, 0), zr(Pe, Pe.level === 9 ? 2 : Pe.strategy >= j || Pe.level < 2 ? 4 : 0), zr(Pe, Fr), Pe.status = _r);
      else {
        var Q = ae + (Pe.w_bits - 8 << 4) << 8, ie = -1;
        Pe.strategy >= j || Pe.level < 2 ? ie = 0 : Pe.level < 6 ? ie = 1 : Pe.level === 6 ? ie = 2 : ie = 3, Q |= ie << 6, Pe.strstart !== 0 && (Q |= at), Q += 31 - Q % 31, Pe.status = _r, ci(Pe, Q), Pe.strstart !== 0 && (ci(Pe, $.adler >>> 16), ci(Pe, $.adler & 65535)), $.adler = 1;
      }
    if (Pe.status === gt)
      if (Pe.gzhead.extra) {
        for (tt = Pe.pending; Pe.gzindex < (Pe.gzhead.extra.length & 65535) && !(Pe.pending === Pe.pending_buf_size && (Pe.gzhead.hcrc && Pe.pending > tt && ($.adler = n($.adler, Pe.pending_buf, Pe.pending - tt, tt)), wr($), tt = Pe.pending, Pe.pending === Pe.pending_buf_size)); )
          zr(Pe, Pe.gzhead.extra[Pe.gzindex] & 255), Pe.gzindex++;
        Pe.gzhead.hcrc && Pe.pending > tt && ($.adler = n($.adler, Pe.pending_buf, Pe.pending - tt, tt)), Pe.gzindex === Pe.gzhead.extra.length && (Pe.gzindex = 0, Pe.status = St);
      } else
        Pe.status = St;
    if (Pe.status === St)
      if (Pe.gzhead.name) {
        tt = Pe.pending;
        do {
          if (Pe.pending === Pe.pending_buf_size && (Pe.gzhead.hcrc && Pe.pending > tt && ($.adler = n($.adler, Pe.pending_buf, Pe.pending - tt, tt)), wr($), tt = Pe.pending, Pe.pending === Pe.pending_buf_size)) {
            At = 1;
            break;
          }
          Pe.gzindex < Pe.gzhead.name.length ? At = Pe.gzhead.name.charCodeAt(Pe.gzindex++) & 255 : At = 0, zr(Pe, At);
        } while (At !== 0);
        Pe.gzhead.hcrc && Pe.pending > tt && ($.adler = n($.adler, Pe.pending_buf, Pe.pending - tt, tt)), At === 0 && (Pe.gzindex = 0, Pe.status = Ot);
      } else
        Pe.status = Ot;
    if (Pe.status === Ot)
      if (Pe.gzhead.comment) {
        tt = Pe.pending;
        do {
          if (Pe.pending === Pe.pending_buf_size && (Pe.gzhead.hcrc && Pe.pending > tt && ($.adler = n($.adler, Pe.pending_buf, Pe.pending - tt, tt)), wr($), tt = Pe.pending, Pe.pending === Pe.pending_buf_size)) {
            At = 1;
            break;
          }
          Pe.gzindex < Pe.gzhead.comment.length ? At = Pe.gzhead.comment.charCodeAt(Pe.gzindex++) & 255 : At = 0, zr(Pe, At);
        } while (At !== 0);
        Pe.gzhead.hcrc && Pe.pending > tt && ($.adler = n($.adler, Pe.pending_buf, Pe.pending - tt, tt)), At === 0 && (Pe.status = dt);
      } else
        Pe.status = dt;
    if (Pe.status === dt && (Pe.gzhead.hcrc ? (Pe.pending + 2 > Pe.pending_buf_size && wr($), Pe.pending + 2 <= Pe.pending_buf_size && (zr(Pe, $.adler & 255), zr(Pe, $.adler >> 8 & 255), $.adler = 0, Pe.status = _r)) : Pe.status = _r), Pe.pending !== 0) {
      if (wr($), $.avail_out === 0)
        return Pe.last_flush = -1, y;
    } else if ($.avail_in === 0 && $n(Et) <= $n(Rt) && Et !== u)
      return Pr($, U);
    if (Pe.status === sr && $.avail_in !== 0)
      return Pr($, U);
    if ($.avail_in !== 0 || Pe.lookahead !== 0 || Et !== s && Pe.status !== sr) {
      var ce = Pe.strategy === j ? br(Pe, Et) : Pe.strategy === K ? Zt(Pe, Et) : on[Pe.level].func(Pe, Et);
      if ((ce === yr || ce === An) && (Pe.status = sr), ce === tr || ce === yr)
        return $.avail_out === 0 && (Pe.last_flush = -1), y;
      if (ce === Wt && (Et === o ? e._tr_align(Pe) : Et !== m && (e._tr_stored_block(Pe, 0, 0, !1), Et === l && (xr(Pe.head), Pe.lookahead === 0 && (Pe.strstart = 0, Pe.block_start = 0, Pe.insert = 0))), wr($), $.avail_out === 0))
        return Pe.last_flush = -1, y;
    }
    return Et !== u ? y : Pe.wrap <= 0 ? E : (Pe.wrap === 2 ? (zr(Pe, $.adler & 255), zr(Pe, $.adler >> 8 & 255), zr(Pe, $.adler >> 16 & 255), zr(Pe, $.adler >> 24 & 255), zr(Pe, $.total_in & 255), zr(Pe, $.total_in >> 8 & 255), zr(Pe, $.total_in >> 16 & 255), zr(Pe, $.total_in >> 24 & 255)) : (ci(Pe, $.adler >>> 16), ci(Pe, $.adler & 65535)), wr($), Pe.wrap > 0 && (Pe.wrap = -Pe.wrap), Pe.pending !== 0 ? y : E);
  }
  function Xt($) {
    var Et;
    return !$ || !$.state ? P : (Et = $.state.status, Et !== ct && Et !== gt && Et !== St && Et !== Ot && Et !== dt && Et !== _r && Et !== sr ? Pr($, P) : ($.state = null, Et === _r ? Pr($, L) : y));
  }
  function Ct($, Et) {
    var Rt = Et.length, Pe, tt, At, Q, ie, ce, we, Ne;
    if (!$ || !$.state || (Pe = $.state, Q = Pe.wrap, Q === 2 || Q === 1 && Pe.status !== ct || Pe.lookahead))
      return P;
    for (Q === 1 && ($.adler = t($.adler, Et, Rt, 0)), Pe.wrap = 0, Rt >= Pe.w_size && (Q === 0 && (xr(Pe.head), Pe.strstart = 0, Pe.block_start = 0, Pe.insert = 0), Ne = new r.Buf8(Pe.w_size), r.arraySet(Ne, Et, Rt - Pe.w_size, Pe.w_size, 0), Et = Ne, Rt = Pe.w_size), ie = $.avail_in, ce = $.next_in, we = $.input, $.avail_in = Rt, $.next_in = 0, $.input = Et, ii(Pe); Pe.lookahead >= Ue; ) {
      tt = Pe.strstart, At = Pe.lookahead - (Ue - 1);
      do
        Pe.ins_h = (Pe.ins_h << Pe.hash_shift ^ Pe.window[tt + Ue - 1]) & Pe.hash_mask, Pe.prev[tt & Pe.w_mask] = Pe.head[Pe.ins_h], Pe.head[Pe.ins_h] = tt, tt++;
      while (--At);
      Pe.strstart = tt, Pe.lookahead = Ue - 1, ii(Pe);
    }
    return Pe.strstart += Pe.lookahead, Pe.block_start = Pe.strstart, Pe.insert = Pe.lookahead, Pe.lookahead = 0, Pe.match_length = Pe.prev_length = Ue - 1, Pe.match_available = 0, $.next_in = ce, $.input = we, $.avail_in = ie, Pe.wrap = Q, y;
  }
  return sl.deflateInit = Ft, sl.deflateInit2 = st, sl.deflateReset = Jt, sl.deflateResetKeep = Gt, sl.deflateSetHeader = pr, sl.deflate = _e, sl.deflateEnd = Xt, sl.deflateSetDictionary = Ct, sl.deflateInfo = "pako deflate (from Nodeca project)", sl;
}
var zf = {}, CR;
function jk() {
  if (CR) return zf;
  CR = 1;
  var r = af(), e = !0, t = !0;
  try {
    String.fromCharCode.apply(null, [0]);
  } catch {
    e = !1;
  }
  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch {
    t = !1;
  }
  for (var n = new r.Buf8(256), i = 0; i < 256; i++)
    n[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;
  n[254] = n[254] = 1, zf.string2buf = function(o) {
    var l, u, m, y, E, P = o.length, L = 0;
    for (y = 0; y < P; y++)
      u = o.charCodeAt(y), (u & 64512) === 55296 && y + 1 < P && (m = o.charCodeAt(y + 1), (m & 64512) === 56320 && (u = 65536 + (u - 55296 << 10) + (m - 56320), y++)), L += u < 128 ? 1 : u < 2048 ? 2 : u < 65536 ? 3 : 4;
    for (l = new r.Buf8(L), E = 0, y = 0; E < L; y++)
      u = o.charCodeAt(y), (u & 64512) === 55296 && y + 1 < P && (m = o.charCodeAt(y + 1), (m & 64512) === 56320 && (u = 65536 + (u - 55296 << 10) + (m - 56320), y++)), u < 128 ? l[E++] = u : u < 2048 ? (l[E++] = 192 | u >>> 6, l[E++] = 128 | u & 63) : u < 65536 ? (l[E++] = 224 | u >>> 12, l[E++] = 128 | u >>> 6 & 63, l[E++] = 128 | u & 63) : (l[E++] = 240 | u >>> 18, l[E++] = 128 | u >>> 12 & 63, l[E++] = 128 | u >>> 6 & 63, l[E++] = 128 | u & 63);
    return l;
  };
  function s(o, l) {
    if (l < 65534 && (o.subarray && t || !o.subarray && e))
      return String.fromCharCode.apply(null, r.shrinkBuf(o, l));
    for (var u = "", m = 0; m < l; m++)
      u += String.fromCharCode(o[m]);
    return u;
  }
  return zf.buf2binstring = function(o) {
    return s(o, o.length);
  }, zf.binstring2buf = function(o) {
    for (var l = new r.Buf8(o.length), u = 0, m = l.length; u < m; u++)
      l[u] = o.charCodeAt(u);
    return l;
  }, zf.buf2string = function(o, l) {
    var u, m, y, E, P = l || o.length, L = new Array(P * 2);
    for (m = 0, u = 0; u < P; ) {
      if (y = o[u++], y < 128) {
        L[m++] = y;
        continue;
      }
      if (E = n[y], E > 4) {
        L[m++] = 65533, u += E - 1;
        continue;
      }
      for (y &= E === 2 ? 31 : E === 3 ? 15 : 7; E > 1 && u < P; )
        y = y << 6 | o[u++] & 63, E--;
      if (E > 1) {
        L[m++] = 65533;
        continue;
      }
      y < 65536 ? L[m++] = y : (y -= 65536, L[m++] = 55296 | y >> 10 & 1023, L[m++] = 56320 | y & 1023);
    }
    return s(L, m);
  }, zf.utf8border = function(o, l) {
    var u;
    for (l = l || o.length, l > o.length && (l = o.length), u = l - 1; u >= 0 && (o[u] & 192) === 128; )
      u--;
    return u < 0 || u === 0 ? l : u + n[o[u]] > l ? u : l;
  }, zf;
}
var eb, SR;
function Hk() {
  if (SR) return eb;
  SR = 1;
  function r() {
    this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
  }
  return eb = r, eb;
}
var IR;
function Upe() {
  if (IR) return Md;
  IR = 1;
  var r = Npe(), e = af(), t = jk(), n = rT(), i = Hk(), s = Object.prototype.toString, o = 0, l = 4, u = 0, m = 1, y = 2, E = -1, P = 0, L = 8;
  function U(K) {
    if (!(this instanceof U)) return new U(K);
    this.options = e.assign({
      level: E,
      method: L,
      chunkSize: 16384,
      windowBits: 15,
      memLevel: 8,
      strategy: P,
      to: ""
    }, K || {});
    var Y = this.options;
    Y.raw && Y.windowBits > 0 ? Y.windowBits = -Y.windowBits : Y.gzip && Y.windowBits > 0 && Y.windowBits < 16 && (Y.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new i(), this.strm.avail_out = 0;
    var de = r.deflateInit2(
      this.strm,
      Y.level,
      Y.method,
      Y.windowBits,
      Y.memLevel,
      Y.strategy
    );
    if (de !== u)
      throw new Error(n[de]);
    if (Y.header && r.deflateSetHeader(this.strm, Y.header), Y.dictionary) {
      var ne;
      if (typeof Y.dictionary == "string" ? ne = t.string2buf(Y.dictionary) : s.call(Y.dictionary) === "[object ArrayBuffer]" ? ne = new Uint8Array(Y.dictionary) : ne = Y.dictionary, de = r.deflateSetDictionary(this.strm, ne), de !== u)
        throw new Error(n[de]);
      this._dict_set = !0;
    }
  }
  U.prototype.push = function(K, Y) {
    var de = this.strm, ne = this.options.chunkSize, ae, De;
    if (this.ended)
      return !1;
    De = Y === ~~Y ? Y : Y === !0 ? l : o, typeof K == "string" ? de.input = t.string2buf(K) : s.call(K) === "[object ArrayBuffer]" ? de.input = new Uint8Array(K) : de.input = K, de.next_in = 0, de.avail_in = de.input.length;
    do {
      if (de.avail_out === 0 && (de.output = new e.Buf8(ne), de.next_out = 0, de.avail_out = ne), ae = r.deflate(de, De), ae !== m && ae !== u)
        return this.onEnd(ae), this.ended = !0, !1;
      (de.avail_out === 0 || de.avail_in === 0 && (De === l || De === y)) && (this.options.to === "string" ? this.onData(t.buf2binstring(e.shrinkBuf(de.output, de.next_out))) : this.onData(e.shrinkBuf(de.output, de.next_out)));
    } while ((de.avail_in > 0 || de.avail_out === 0) && ae !== m);
    return De === l ? (ae = r.deflateEnd(this.strm), this.onEnd(ae), this.ended = !0, ae === u) : (De === y && (this.onEnd(u), de.avail_out = 0), !0);
  }, U.prototype.onData = function(K) {
    this.chunks.push(K);
  }, U.prototype.onEnd = function(K) {
    K === u && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = e.flattenChunks(this.chunks)), this.chunks = [], this.err = K, this.msg = this.strm.msg;
  };
  function V(K, Y) {
    var de = new U(Y);
    if (de.push(K, !0), de.err)
      throw de.msg || n[de.err];
    return de.result;
  }
  function q(K, Y) {
    return Y = Y || {}, Y.raw = !0, V(K, Y);
  }
  function j(K, Y) {
    return Y = Y || {}, Y.gzip = !0, V(K, Y);
  }
  return Md.Deflate = U, Md.deflate = V, Md.deflateRaw = q, Md.gzip = j, Md;
}
var Rd = {}, Pa = {}, tb, PR;
function zpe() {
  if (PR) return tb;
  PR = 1;
  var r = 30, e = 12;
  return tb = function(n, i) {
    var s, o, l, u, m, y, E, P, L, U, V, q, j, K, Y, de, ne, ae, De, Ge, fe, ve, me, X, re;
    s = n.state, o = n.next_in, X = n.input, l = o + (n.avail_in - 5), u = n.next_out, re = n.output, m = u - (i - n.avail_out), y = u + (n.avail_out - 257), E = s.dmax, P = s.wsize, L = s.whave, U = s.wnext, V = s.window, q = s.hold, j = s.bits, K = s.lencode, Y = s.distcode, de = (1 << s.lenbits) - 1, ne = (1 << s.distbits) - 1;
    e:
      do {
        j < 15 && (q += X[o++] << j, j += 8, q += X[o++] << j, j += 8), ae = K[q & de];
        t:
          for (; ; ) {
            if (De = ae >>> 24, q >>>= De, j -= De, De = ae >>> 16 & 255, De === 0)
              re[u++] = ae & 65535;
            else if (De & 16) {
              Ge = ae & 65535, De &= 15, De && (j < De && (q += X[o++] << j, j += 8), Ge += q & (1 << De) - 1, q >>>= De, j -= De), j < 15 && (q += X[o++] << j, j += 8, q += X[o++] << j, j += 8), ae = Y[q & ne];
              r:
                for (; ; ) {
                  if (De = ae >>> 24, q >>>= De, j -= De, De = ae >>> 16 & 255, De & 16) {
                    if (fe = ae & 65535, De &= 15, j < De && (q += X[o++] << j, j += 8, j < De && (q += X[o++] << j, j += 8)), fe += q & (1 << De) - 1, fe > E) {
                      n.msg = "invalid distance too far back", s.mode = r;
                      break e;
                    }
                    if (q >>>= De, j -= De, De = u - m, fe > De) {
                      if (De = fe - De, De > L && s.sane) {
                        n.msg = "invalid distance too far back", s.mode = r;
                        break e;
                      }
                      if (ve = 0, me = V, U === 0) {
                        if (ve += P - De, De < Ge) {
                          Ge -= De;
                          do
                            re[u++] = V[ve++];
                          while (--De);
                          ve = u - fe, me = re;
                        }
                      } else if (U < De) {
                        if (ve += P + U - De, De -= U, De < Ge) {
                          Ge -= De;
                          do
                            re[u++] = V[ve++];
                          while (--De);
                          if (ve = 0, U < Ge) {
                            De = U, Ge -= De;
                            do
                              re[u++] = V[ve++];
                            while (--De);
                            ve = u - fe, me = re;
                          }
                        }
                      } else if (ve += U - De, De < Ge) {
                        Ge -= De;
                        do
                          re[u++] = V[ve++];
                        while (--De);
                        ve = u - fe, me = re;
                      }
                      for (; Ge > 2; )
                        re[u++] = me[ve++], re[u++] = me[ve++], re[u++] = me[ve++], Ge -= 3;
                      Ge && (re[u++] = me[ve++], Ge > 1 && (re[u++] = me[ve++]));
                    } else {
                      ve = u - fe;
                      do
                        re[u++] = re[ve++], re[u++] = re[ve++], re[u++] = re[ve++], Ge -= 3;
                      while (Ge > 2);
                      Ge && (re[u++] = re[ve++], Ge > 1 && (re[u++] = re[ve++]));
                    }
                  } else if ((De & 64) === 0) {
                    ae = Y[(ae & 65535) + (q & (1 << De) - 1)];
                    continue r;
                  } else {
                    n.msg = "invalid distance code", s.mode = r;
                    break e;
                  }
                  break;
                }
            } else if ((De & 64) === 0) {
              ae = K[(ae & 65535) + (q & (1 << De) - 1)];
              continue t;
            } else if (De & 32) {
              s.mode = e;
              break e;
            } else {
              n.msg = "invalid literal/length code", s.mode = r;
              break e;
            }
            break;
          }
      } while (o < l && u < y);
    Ge = j >> 3, o -= Ge, j -= Ge << 3, q &= (1 << j) - 1, n.next_in = o, n.next_out = u, n.avail_in = o < l ? 5 + (l - o) : 5 - (o - l), n.avail_out = u < y ? 257 + (y - u) : 257 - (u - y), s.hold = q, s.bits = j;
  }, tb;
}
var rb, MR;
function Vpe() {
  if (MR) return rb;
  MR = 1;
  var r = af(), e = 15, t = 852, n = 592, i = 0, s = 1, o = 2, l = [
    /* Length codes 257..285 base */
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
  ], u = [
    /* Length codes 257..285 extra */
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
  ], m = [
    /* Distance codes 0..29 base */
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
  ], y = [
    /* Distance codes 0..29 extra */
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
  ];
  return rb = function(P, L, U, V, q, j, K, Y) {
    var de = Y.bits, ne = 0, ae = 0, De = 0, Ge = 0, fe = 0, ve = 0, me = 0, X = 0, re = 0, Me = 0, ot, be, Ue, Xe, lt, at = null, ct = 0, gt, St = new r.Buf16(e + 1), Ot = new r.Buf16(e + 1), dt = null, _r = 0, sr, tr, Wt;
    for (ne = 0; ne <= e; ne++)
      St[ne] = 0;
    for (ae = 0; ae < V; ae++)
      St[L[U + ae]]++;
    for (fe = de, Ge = e; Ge >= 1 && St[Ge] === 0; Ge--)
      ;
    if (fe > Ge && (fe = Ge), Ge === 0)
      return q[j++] = 1 << 24 | 64 << 16 | 0, q[j++] = 1 << 24 | 64 << 16 | 0, Y.bits = 1, 0;
    for (De = 1; De < Ge && St[De] === 0; De++)
      ;
    for (fe < De && (fe = De), X = 1, ne = 1; ne <= e; ne++)
      if (X <<= 1, X -= St[ne], X < 0)
        return -1;
    if (X > 0 && (P === i || Ge !== 1))
      return -1;
    for (Ot[1] = 0, ne = 1; ne < e; ne++)
      Ot[ne + 1] = Ot[ne] + St[ne];
    for (ae = 0; ae < V; ae++)
      L[U + ae] !== 0 && (K[Ot[L[U + ae]]++] = ae);
    if (P === i ? (at = dt = K, gt = 19) : P === s ? (at = l, ct -= 257, dt = u, _r -= 257, gt = 256) : (at = m, dt = y, gt = -1), Me = 0, ae = 0, ne = De, lt = j, ve = fe, me = 0, Ue = -1, re = 1 << fe, Xe = re - 1, P === s && re > t || P === o && re > n)
      return 1;
    for (; ; ) {
      sr = ne - me, K[ae] < gt ? (tr = 0, Wt = K[ae]) : K[ae] > gt ? (tr = dt[_r + K[ae]], Wt = at[ct + K[ae]]) : (tr = 96, Wt = 0), ot = 1 << ne - me, be = 1 << ve, De = be;
      do
        be -= ot, q[lt + (Me >> me) + be] = sr << 24 | tr << 16 | Wt | 0;
      while (be !== 0);
      for (ot = 1 << ne - 1; Me & ot; )
        ot >>= 1;
      if (ot !== 0 ? (Me &= ot - 1, Me += ot) : Me = 0, ae++, --St[ne] === 0) {
        if (ne === Ge)
          break;
        ne = L[U + K[ae]];
      }
      if (ne > fe && (Me & Xe) !== Ue) {
        for (me === 0 && (me = fe), lt += De, ve = ne - me, X = 1 << ve; ve + me < Ge && (X -= St[ve + me], !(X <= 0)); )
          ve++, X <<= 1;
        if (re += 1 << ve, P === s && re > t || P === o && re > n)
          return 1;
        Ue = Me & Xe, q[Ue] = fe << 24 | ve << 16 | lt - j | 0;
      }
    }
    return Me !== 0 && (q[lt + Me] = ne - me << 24 | 64 << 16 | 0), Y.bits = fe, 0;
  }, rb;
}
var RR;
function jpe() {
  if (RR) return Pa;
  RR = 1;
  var r = af(), e = zk(), t = Vk(), n = zpe(), i = Vpe(), s = 0, o = 1, l = 2, u = 4, m = 5, y = 6, E = 0, P = 1, L = 2, U = -2, V = -3, q = -4, j = -5, K = 8, Y = 1, de = 2, ne = 3, ae = 4, De = 5, Ge = 6, fe = 7, ve = 8, me = 9, X = 10, re = 11, Me = 12, ot = 13, be = 14, Ue = 15, Xe = 16, lt = 17, at = 18, ct = 19, gt = 20, St = 21, Ot = 22, dt = 23, _r = 24, sr = 25, tr = 26, Wt = 27, yr = 28, An = 29, Fr = 30, Pr = 31, $n = 32, xr = 852, wr = 592, gn = 15, zr = gn;
  function ci(st) {
    return (st >>> 24 & 255) + (st >>> 8 & 65280) + ((st & 65280) << 8) + ((st & 255) << 24);
  }
  function Jn() {
    this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new r.Buf16(320), this.work = new r.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
  }
  function wn(st) {
    var Ft;
    return !st || !st.state ? U : (Ft = st.state, st.total_in = st.total_out = Ft.total = 0, st.msg = "", Ft.wrap && (st.adler = Ft.wrap & 1), Ft.mode = Y, Ft.last = 0, Ft.havedict = 0, Ft.dmax = 32768, Ft.head = null, Ft.hold = 0, Ft.bits = 0, Ft.lencode = Ft.lendyn = new r.Buf32(xr), Ft.distcode = Ft.distdyn = new r.Buf32(wr), Ft.sane = 1, Ft.back = -1, E);
  }
  function ii(st) {
    var Ft;
    return !st || !st.state ? U : (Ft = st.state, Ft.wsize = 0, Ft.whave = 0, Ft.wnext = 0, wn(st));
  }
  function qn(st, Ft) {
    var _e, Xt;
    return !st || !st.state || (Xt = st.state, Ft < 0 ? (_e = 0, Ft = -Ft) : (_e = (Ft >> 4) + 1, Ft < 48 && (Ft &= 15)), Ft && (Ft < 8 || Ft > 15)) ? U : (Xt.window !== null && Xt.wbits !== Ft && (Xt.window = null), Xt.wrap = _e, Xt.wbits = Ft, ii(st));
  }
  function Rn(st, Ft) {
    var _e, Xt;
    return st ? (Xt = new Jn(), st.state = Xt, Xt.window = null, _e = qn(st, Ft), _e !== E && (st.state = null), _e) : U;
  }
  function ei(st) {
    return Rn(st, zr);
  }
  var Zt = !0, br, Nr;
  function on(st) {
    if (Zt) {
      var Ft;
      for (br = new r.Buf32(512), Nr = new r.Buf32(32), Ft = 0; Ft < 144; )
        st.lens[Ft++] = 8;
      for (; Ft < 256; )
        st.lens[Ft++] = 9;
      for (; Ft < 280; )
        st.lens[Ft++] = 7;
      for (; Ft < 288; )
        st.lens[Ft++] = 8;
      for (i(o, st.lens, 0, 288, br, 0, st.work, { bits: 9 }), Ft = 0; Ft < 32; )
        st.lens[Ft++] = 5;
      i(l, st.lens, 0, 32, Nr, 0, st.work, { bits: 5 }), Zt = !1;
    }
    st.lencode = br, st.lenbits = 9, st.distcode = Nr, st.distbits = 5;
  }
  function pi(st, Ft, _e, Xt) {
    var Ct, $ = st.state;
    return $.window === null && ($.wsize = 1 << $.wbits, $.wnext = 0, $.whave = 0, $.window = new r.Buf8($.wsize)), Xt >= $.wsize ? (r.arraySet($.window, Ft, _e - $.wsize, $.wsize, 0), $.wnext = 0, $.whave = $.wsize) : (Ct = $.wsize - $.wnext, Ct > Xt && (Ct = Xt), r.arraySet($.window, Ft, _e - Xt, Ct, $.wnext), Xt -= Ct, Xt ? (r.arraySet($.window, Ft, _e - Xt, Xt, 0), $.wnext = Xt, $.whave = $.wsize) : ($.wnext += Ct, $.wnext === $.wsize && ($.wnext = 0), $.whave < $.wsize && ($.whave += Ct))), 0;
  }
  function Le(st, Ft) {
    var _e, Xt, Ct, $, Et, Rt, Pe, tt, At, Q, ie, ce, we, Ne, pe = 0, Te, le, ge, d, ee, It, nt, Mt, kt = new r.Buf8(4), zt, _t, Vt = (
      /* permutation of code lengths */
      [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
    );
    if (!st || !st.state || !st.output || !st.input && st.avail_in !== 0)
      return U;
    _e = st.state, _e.mode === Me && (_e.mode = ot), Et = st.next_out, Ct = st.output, Pe = st.avail_out, $ = st.next_in, Xt = st.input, Rt = st.avail_in, tt = _e.hold, At = _e.bits, Q = Rt, ie = Pe, Mt = E;
    e:
      for (; ; )
        switch (_e.mode) {
          case Y:
            if (_e.wrap === 0) {
              _e.mode = ot;
              break;
            }
            for (; At < 16; ) {
              if (Rt === 0)
                break e;
              Rt--, tt += Xt[$++] << At, At += 8;
            }
            if (_e.wrap & 2 && tt === 35615) {
              _e.check = 0, kt[0] = tt & 255, kt[1] = tt >>> 8 & 255, _e.check = t(_e.check, kt, 2, 0), tt = 0, At = 0, _e.mode = de;
              break;
            }
            if (_e.flags = 0, _e.head && (_e.head.done = !1), !(_e.wrap & 1) || /* check if zlib header allowed */
            (((tt & 255) << 8) + (tt >> 8)) % 31) {
              st.msg = "incorrect header check", _e.mode = Fr;
              break;
            }
            if ((tt & 15) !== K) {
              st.msg = "unknown compression method", _e.mode = Fr;
              break;
            }
            if (tt >>>= 4, At -= 4, nt = (tt & 15) + 8, _e.wbits === 0)
              _e.wbits = nt;
            else if (nt > _e.wbits) {
              st.msg = "invalid window size", _e.mode = Fr;
              break;
            }
            _e.dmax = 1 << nt, st.adler = _e.check = 1, _e.mode = tt & 512 ? X : Me, tt = 0, At = 0;
            break;
          case de:
            for (; At < 16; ) {
              if (Rt === 0)
                break e;
              Rt--, tt += Xt[$++] << At, At += 8;
            }
            if (_e.flags = tt, (_e.flags & 255) !== K) {
              st.msg = "unknown compression method", _e.mode = Fr;
              break;
            }
            if (_e.flags & 57344) {
              st.msg = "unknown header flags set", _e.mode = Fr;
              break;
            }
            _e.head && (_e.head.text = tt >> 8 & 1), _e.flags & 512 && (kt[0] = tt & 255, kt[1] = tt >>> 8 & 255, _e.check = t(_e.check, kt, 2, 0)), tt = 0, At = 0, _e.mode = ne;
          /* falls through */
          case ne:
            for (; At < 32; ) {
              if (Rt === 0)
                break e;
              Rt--, tt += Xt[$++] << At, At += 8;
            }
            _e.head && (_e.head.time = tt), _e.flags & 512 && (kt[0] = tt & 255, kt[1] = tt >>> 8 & 255, kt[2] = tt >>> 16 & 255, kt[3] = tt >>> 24 & 255, _e.check = t(_e.check, kt, 4, 0)), tt = 0, At = 0, _e.mode = ae;
          /* falls through */
          case ae:
            for (; At < 16; ) {
              if (Rt === 0)
                break e;
              Rt--, tt += Xt[$++] << At, At += 8;
            }
            _e.head && (_e.head.xflags = tt & 255, _e.head.os = tt >> 8), _e.flags & 512 && (kt[0] = tt & 255, kt[1] = tt >>> 8 & 255, _e.check = t(_e.check, kt, 2, 0)), tt = 0, At = 0, _e.mode = De;
          /* falls through */
          case De:
            if (_e.flags & 1024) {
              for (; At < 16; ) {
                if (Rt === 0)
                  break e;
                Rt--, tt += Xt[$++] << At, At += 8;
              }
              _e.length = tt, _e.head && (_e.head.extra_len = tt), _e.flags & 512 && (kt[0] = tt & 255, kt[1] = tt >>> 8 & 255, _e.check = t(_e.check, kt, 2, 0)), tt = 0, At = 0;
            } else _e.head && (_e.head.extra = null);
            _e.mode = Ge;
          /* falls through */
          case Ge:
            if (_e.flags & 1024 && (ce = _e.length, ce > Rt && (ce = Rt), ce && (_e.head && (nt = _e.head.extra_len - _e.length, _e.head.extra || (_e.head.extra = new Array(_e.head.extra_len)), r.arraySet(
              _e.head.extra,
              Xt,
              $,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              ce,
              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              nt
            )), _e.flags & 512 && (_e.check = t(_e.check, Xt, ce, $)), Rt -= ce, $ += ce, _e.length -= ce), _e.length))
              break e;
            _e.length = 0, _e.mode = fe;
          /* falls through */
          case fe:
            if (_e.flags & 2048) {
              if (Rt === 0)
                break e;
              ce = 0;
              do
                nt = Xt[$ + ce++], _e.head && nt && _e.length < 65536 && (_e.head.name += String.fromCharCode(nt));
              while (nt && ce < Rt);
              if (_e.flags & 512 && (_e.check = t(_e.check, Xt, ce, $)), Rt -= ce, $ += ce, nt)
                break e;
            } else _e.head && (_e.head.name = null);
            _e.length = 0, _e.mode = ve;
          /* falls through */
          case ve:
            if (_e.flags & 4096) {
              if (Rt === 0)
                break e;
              ce = 0;
              do
                nt = Xt[$ + ce++], _e.head && nt && _e.length < 65536 && (_e.head.comment += String.fromCharCode(nt));
              while (nt && ce < Rt);
              if (_e.flags & 512 && (_e.check = t(_e.check, Xt, ce, $)), Rt -= ce, $ += ce, nt)
                break e;
            } else _e.head && (_e.head.comment = null);
            _e.mode = me;
          /* falls through */
          case me:
            if (_e.flags & 512) {
              for (; At < 16; ) {
                if (Rt === 0)
                  break e;
                Rt--, tt += Xt[$++] << At, At += 8;
              }
              if (tt !== (_e.check & 65535)) {
                st.msg = "header crc mismatch", _e.mode = Fr;
                break;
              }
              tt = 0, At = 0;
            }
            _e.head && (_e.head.hcrc = _e.flags >> 9 & 1, _e.head.done = !0), st.adler = _e.check = 0, _e.mode = Me;
            break;
          case X:
            for (; At < 32; ) {
              if (Rt === 0)
                break e;
              Rt--, tt += Xt[$++] << At, At += 8;
            }
            st.adler = _e.check = ci(tt), tt = 0, At = 0, _e.mode = re;
          /* falls through */
          case re:
            if (_e.havedict === 0)
              return st.next_out = Et, st.avail_out = Pe, st.next_in = $, st.avail_in = Rt, _e.hold = tt, _e.bits = At, L;
            st.adler = _e.check = 1, _e.mode = Me;
          /* falls through */
          case Me:
            if (Ft === m || Ft === y)
              break e;
          /* falls through */
          case ot:
            if (_e.last) {
              tt >>>= At & 7, At -= At & 7, _e.mode = Wt;
              break;
            }
            for (; At < 3; ) {
              if (Rt === 0)
                break e;
              Rt--, tt += Xt[$++] << At, At += 8;
            }
            switch (_e.last = tt & 1, tt >>>= 1, At -= 1, tt & 3) {
              case 0:
                _e.mode = be;
                break;
              case 1:
                if (on(_e), _e.mode = gt, Ft === y) {
                  tt >>>= 2, At -= 2;
                  break e;
                }
                break;
              case 2:
                _e.mode = lt;
                break;
              case 3:
                st.msg = "invalid block type", _e.mode = Fr;
            }
            tt >>>= 2, At -= 2;
            break;
          case be:
            for (tt >>>= At & 7, At -= At & 7; At < 32; ) {
              if (Rt === 0)
                break e;
              Rt--, tt += Xt[$++] << At, At += 8;
            }
            if ((tt & 65535) !== (tt >>> 16 ^ 65535)) {
              st.msg = "invalid stored block lengths", _e.mode = Fr;
              break;
            }
            if (_e.length = tt & 65535, tt = 0, At = 0, _e.mode = Ue, Ft === y)
              break e;
          /* falls through */
          case Ue:
            _e.mode = Xe;
          /* falls through */
          case Xe:
            if (ce = _e.length, ce) {
              if (ce > Rt && (ce = Rt), ce > Pe && (ce = Pe), ce === 0)
                break e;
              r.arraySet(Ct, Xt, $, ce, Et), Rt -= ce, $ += ce, Pe -= ce, Et += ce, _e.length -= ce;
              break;
            }
            _e.mode = Me;
            break;
          case lt:
            for (; At < 14; ) {
              if (Rt === 0)
                break e;
              Rt--, tt += Xt[$++] << At, At += 8;
            }
            if (_e.nlen = (tt & 31) + 257, tt >>>= 5, At -= 5, _e.ndist = (tt & 31) + 1, tt >>>= 5, At -= 5, _e.ncode = (tt & 15) + 4, tt >>>= 4, At -= 4, _e.nlen > 286 || _e.ndist > 30) {
              st.msg = "too many length or distance symbols", _e.mode = Fr;
              break;
            }
            _e.have = 0, _e.mode = at;
          /* falls through */
          case at:
            for (; _e.have < _e.ncode; ) {
              for (; At < 3; ) {
                if (Rt === 0)
                  break e;
                Rt--, tt += Xt[$++] << At, At += 8;
              }
              _e.lens[Vt[_e.have++]] = tt & 7, tt >>>= 3, At -= 3;
            }
            for (; _e.have < 19; )
              _e.lens[Vt[_e.have++]] = 0;
            if (_e.lencode = _e.lendyn, _e.lenbits = 7, zt = { bits: _e.lenbits }, Mt = i(s, _e.lens, 0, 19, _e.lencode, 0, _e.work, zt), _e.lenbits = zt.bits, Mt) {
              st.msg = "invalid code lengths set", _e.mode = Fr;
              break;
            }
            _e.have = 0, _e.mode = ct;
          /* falls through */
          case ct:
            for (; _e.have < _e.nlen + _e.ndist; ) {
              for (; pe = _e.lencode[tt & (1 << _e.lenbits) - 1], Te = pe >>> 24, le = pe >>> 16 & 255, ge = pe & 65535, !(Te <= At); ) {
                if (Rt === 0)
                  break e;
                Rt--, tt += Xt[$++] << At, At += 8;
              }
              if (ge < 16)
                tt >>>= Te, At -= Te, _e.lens[_e.have++] = ge;
              else {
                if (ge === 16) {
                  for (_t = Te + 2; At < _t; ) {
                    if (Rt === 0)
                      break e;
                    Rt--, tt += Xt[$++] << At, At += 8;
                  }
                  if (tt >>>= Te, At -= Te, _e.have === 0) {
                    st.msg = "invalid bit length repeat", _e.mode = Fr;
                    break;
                  }
                  nt = _e.lens[_e.have - 1], ce = 3 + (tt & 3), tt >>>= 2, At -= 2;
                } else if (ge === 17) {
                  for (_t = Te + 3; At < _t; ) {
                    if (Rt === 0)
                      break e;
                    Rt--, tt += Xt[$++] << At, At += 8;
                  }
                  tt >>>= Te, At -= Te, nt = 0, ce = 3 + (tt & 7), tt >>>= 3, At -= 3;
                } else {
                  for (_t = Te + 7; At < _t; ) {
                    if (Rt === 0)
                      break e;
                    Rt--, tt += Xt[$++] << At, At += 8;
                  }
                  tt >>>= Te, At -= Te, nt = 0, ce = 11 + (tt & 127), tt >>>= 7, At -= 7;
                }
                if (_e.have + ce > _e.nlen + _e.ndist) {
                  st.msg = "invalid bit length repeat", _e.mode = Fr;
                  break;
                }
                for (; ce--; )
                  _e.lens[_e.have++] = nt;
              }
            }
            if (_e.mode === Fr)
              break;
            if (_e.lens[256] === 0) {
              st.msg = "invalid code -- missing end-of-block", _e.mode = Fr;
              break;
            }
            if (_e.lenbits = 9, zt = { bits: _e.lenbits }, Mt = i(o, _e.lens, 0, _e.nlen, _e.lencode, 0, _e.work, zt), _e.lenbits = zt.bits, Mt) {
              st.msg = "invalid literal/lengths set", _e.mode = Fr;
              break;
            }
            if (_e.distbits = 6, _e.distcode = _e.distdyn, zt = { bits: _e.distbits }, Mt = i(l, _e.lens, _e.nlen, _e.ndist, _e.distcode, 0, _e.work, zt), _e.distbits = zt.bits, Mt) {
              st.msg = "invalid distances set", _e.mode = Fr;
              break;
            }
            if (_e.mode = gt, Ft === y)
              break e;
          /* falls through */
          case gt:
            _e.mode = St;
          /* falls through */
          case St:
            if (Rt >= 6 && Pe >= 258) {
              st.next_out = Et, st.avail_out = Pe, st.next_in = $, st.avail_in = Rt, _e.hold = tt, _e.bits = At, n(st, ie), Et = st.next_out, Ct = st.output, Pe = st.avail_out, $ = st.next_in, Xt = st.input, Rt = st.avail_in, tt = _e.hold, At = _e.bits, _e.mode === Me && (_e.back = -1);
              break;
            }
            for (_e.back = 0; pe = _e.lencode[tt & (1 << _e.lenbits) - 1], Te = pe >>> 24, le = pe >>> 16 & 255, ge = pe & 65535, !(Te <= At); ) {
              if (Rt === 0)
                break e;
              Rt--, tt += Xt[$++] << At, At += 8;
            }
            if (le && (le & 240) === 0) {
              for (d = Te, ee = le, It = ge; pe = _e.lencode[It + ((tt & (1 << d + ee) - 1) >> d)], Te = pe >>> 24, le = pe >>> 16 & 255, ge = pe & 65535, !(d + Te <= At); ) {
                if (Rt === 0)
                  break e;
                Rt--, tt += Xt[$++] << At, At += 8;
              }
              tt >>>= d, At -= d, _e.back += d;
            }
            if (tt >>>= Te, At -= Te, _e.back += Te, _e.length = ge, le === 0) {
              _e.mode = tr;
              break;
            }
            if (le & 32) {
              _e.back = -1, _e.mode = Me;
              break;
            }
            if (le & 64) {
              st.msg = "invalid literal/length code", _e.mode = Fr;
              break;
            }
            _e.extra = le & 15, _e.mode = Ot;
          /* falls through */
          case Ot:
            if (_e.extra) {
              for (_t = _e.extra; At < _t; ) {
                if (Rt === 0)
                  break e;
                Rt--, tt += Xt[$++] << At, At += 8;
              }
              _e.length += tt & (1 << _e.extra) - 1, tt >>>= _e.extra, At -= _e.extra, _e.back += _e.extra;
            }
            _e.was = _e.length, _e.mode = dt;
          /* falls through */
          case dt:
            for (; pe = _e.distcode[tt & (1 << _e.distbits) - 1], Te = pe >>> 24, le = pe >>> 16 & 255, ge = pe & 65535, !(Te <= At); ) {
              if (Rt === 0)
                break e;
              Rt--, tt += Xt[$++] << At, At += 8;
            }
            if ((le & 240) === 0) {
              for (d = Te, ee = le, It = ge; pe = _e.distcode[It + ((tt & (1 << d + ee) - 1) >> d)], Te = pe >>> 24, le = pe >>> 16 & 255, ge = pe & 65535, !(d + Te <= At); ) {
                if (Rt === 0)
                  break e;
                Rt--, tt += Xt[$++] << At, At += 8;
              }
              tt >>>= d, At -= d, _e.back += d;
            }
            if (tt >>>= Te, At -= Te, _e.back += Te, le & 64) {
              st.msg = "invalid distance code", _e.mode = Fr;
              break;
            }
            _e.offset = ge, _e.extra = le & 15, _e.mode = _r;
          /* falls through */
          case _r:
            if (_e.extra) {
              for (_t = _e.extra; At < _t; ) {
                if (Rt === 0)
                  break e;
                Rt--, tt += Xt[$++] << At, At += 8;
              }
              _e.offset += tt & (1 << _e.extra) - 1, tt >>>= _e.extra, At -= _e.extra, _e.back += _e.extra;
            }
            if (_e.offset > _e.dmax) {
              st.msg = "invalid distance too far back", _e.mode = Fr;
              break;
            }
            _e.mode = sr;
          /* falls through */
          case sr:
            if (Pe === 0)
              break e;
            if (ce = ie - Pe, _e.offset > ce) {
              if (ce = _e.offset - ce, ce > _e.whave && _e.sane) {
                st.msg = "invalid distance too far back", _e.mode = Fr;
                break;
              }
              ce > _e.wnext ? (ce -= _e.wnext, we = _e.wsize - ce) : we = _e.wnext - ce, ce > _e.length && (ce = _e.length), Ne = _e.window;
            } else
              Ne = Ct, we = Et - _e.offset, ce = _e.length;
            ce > Pe && (ce = Pe), Pe -= ce, _e.length -= ce;
            do
              Ct[Et++] = Ne[we++];
            while (--ce);
            _e.length === 0 && (_e.mode = St);
            break;
          case tr:
            if (Pe === 0)
              break e;
            Ct[Et++] = _e.length, Pe--, _e.mode = St;
            break;
          case Wt:
            if (_e.wrap) {
              for (; At < 32; ) {
                if (Rt === 0)
                  break e;
                Rt--, tt |= Xt[$++] << At, At += 8;
              }
              if (ie -= Pe, st.total_out += ie, _e.total += ie, ie && (st.adler = _e.check = /*UPDATE(state.check, put - _out, _out);*/
              _e.flags ? t(_e.check, Ct, ie, Et - ie) : e(_e.check, Ct, ie, Et - ie)), ie = Pe, (_e.flags ? tt : ci(tt)) !== _e.check) {
                st.msg = "incorrect data check", _e.mode = Fr;
                break;
              }
              tt = 0, At = 0;
            }
            _e.mode = yr;
          /* falls through */
          case yr:
            if (_e.wrap && _e.flags) {
              for (; At < 32; ) {
                if (Rt === 0)
                  break e;
                Rt--, tt += Xt[$++] << At, At += 8;
              }
              if (tt !== (_e.total & 4294967295)) {
                st.msg = "incorrect length check", _e.mode = Fr;
                break;
              }
              tt = 0, At = 0;
            }
            _e.mode = An;
          /* falls through */
          case An:
            Mt = P;
            break e;
          case Fr:
            Mt = V;
            break e;
          case Pr:
            return q;
          case $n:
          /* falls through */
          default:
            return U;
        }
    return st.next_out = Et, st.avail_out = Pe, st.next_in = $, st.avail_in = Rt, _e.hold = tt, _e.bits = At, (_e.wsize || ie !== st.avail_out && _e.mode < Fr && (_e.mode < Wt || Ft !== u)) && pi(st, st.output, st.next_out, ie - st.avail_out), Q -= st.avail_in, ie -= st.avail_out, st.total_in += Q, st.total_out += ie, _e.total += ie, _e.wrap && ie && (st.adler = _e.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
    _e.flags ? t(_e.check, Ct, ie, st.next_out - ie) : e(_e.check, Ct, ie, st.next_out - ie)), st.data_type = _e.bits + (_e.last ? 64 : 0) + (_e.mode === Me ? 128 : 0) + (_e.mode === gt || _e.mode === Ue ? 256 : 0), (Q === 0 && ie === 0 || Ft === u) && Mt === E && (Mt = j), Mt;
  }
  function Gt(st) {
    if (!st || !st.state)
      return U;
    var Ft = st.state;
    return Ft.window && (Ft.window = null), st.state = null, E;
  }
  function Jt(st, Ft) {
    var _e;
    return !st || !st.state || (_e = st.state, (_e.wrap & 2) === 0) ? U : (_e.head = Ft, Ft.done = !1, E);
  }
  function pr(st, Ft) {
    var _e = Ft.length, Xt, Ct, $;
    return !st || !st.state || (Xt = st.state, Xt.wrap !== 0 && Xt.mode !== re) ? U : Xt.mode === re && (Ct = 1, Ct = e(Ct, Ft, _e, 0), Ct !== Xt.check) ? V : ($ = pi(st, Ft, _e, _e), $ ? (Xt.mode = Pr, q) : (Xt.havedict = 1, E));
  }
  return Pa.inflateReset = ii, Pa.inflateReset2 = qn, Pa.inflateResetKeep = wn, Pa.inflateInit = ei, Pa.inflateInit2 = Rn, Pa.inflate = Le, Pa.inflateEnd = Gt, Pa.inflateGetHeader = Jt, Pa.inflateSetDictionary = pr, Pa.inflateInfo = "pako inflate (from Nodeca project)", Pa;
}
var nb, BR;
function Gk() {
  return BR || (BR = 1, nb = {
    /* Allowed flush values; see deflate() and inflate() below for details */
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    /* Return codes for the compression/decompression functions. Negative values
    * are errors, positive values are used for special but normal events.
    */
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    //Z_MEM_ERROR:     -4,
    Z_BUF_ERROR: -5,
    //Z_VERSION_ERROR: -6,
    /* compression levels */
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    /* Possible values of the data_type field (though see inflate()) */
    Z_BINARY: 0,
    Z_TEXT: 1,
    //Z_ASCII:                1, // = Z_TEXT (deprecated)
    Z_UNKNOWN: 2,
    /* The deflate compression method */
    Z_DEFLATED: 8
    //Z_NULL:                 null // Use -1 or null inline, depending on var type
  }), nb;
}
var ib, OR;
function Hpe() {
  if (OR) return ib;
  OR = 1;
  function r() {
    this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
  }
  return ib = r, ib;
}
var DR;
function Gpe() {
  if (DR) return Rd;
  DR = 1;
  var r = jpe(), e = af(), t = jk(), n = Gk(), i = rT(), s = Hk(), o = Hpe(), l = Object.prototype.toString;
  function u(E) {
    if (!(this instanceof u)) return new u(E);
    this.options = e.assign({
      chunkSize: 16384,
      windowBits: 0,
      to: ""
    }, E || {});
    var P = this.options;
    P.raw && P.windowBits >= 0 && P.windowBits < 16 && (P.windowBits = -P.windowBits, P.windowBits === 0 && (P.windowBits = -15)), P.windowBits >= 0 && P.windowBits < 16 && !(E && E.windowBits) && (P.windowBits += 32), P.windowBits > 15 && P.windowBits < 48 && (P.windowBits & 15) === 0 && (P.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;
    var L = r.inflateInit2(
      this.strm,
      P.windowBits
    );
    if (L !== n.Z_OK)
      throw new Error(i[L]);
    if (this.header = new o(), r.inflateGetHeader(this.strm, this.header), P.dictionary && (typeof P.dictionary == "string" ? P.dictionary = t.string2buf(P.dictionary) : l.call(P.dictionary) === "[object ArrayBuffer]" && (P.dictionary = new Uint8Array(P.dictionary)), P.raw && (L = r.inflateSetDictionary(this.strm, P.dictionary), L !== n.Z_OK)))
      throw new Error(i[L]);
  }
  u.prototype.push = function(E, P) {
    var L = this.strm, U = this.options.chunkSize, V = this.options.dictionary, q, j, K, Y, de, ne = !1;
    if (this.ended)
      return !1;
    j = P === ~~P ? P : P === !0 ? n.Z_FINISH : n.Z_NO_FLUSH, typeof E == "string" ? L.input = t.binstring2buf(E) : l.call(E) === "[object ArrayBuffer]" ? L.input = new Uint8Array(E) : L.input = E, L.next_in = 0, L.avail_in = L.input.length;
    do {
      if (L.avail_out === 0 && (L.output = new e.Buf8(U), L.next_out = 0, L.avail_out = U), q = r.inflate(L, n.Z_NO_FLUSH), q === n.Z_NEED_DICT && V && (q = r.inflateSetDictionary(this.strm, V)), q === n.Z_BUF_ERROR && ne === !0 && (q = n.Z_OK, ne = !1), q !== n.Z_STREAM_END && q !== n.Z_OK)
        return this.onEnd(q), this.ended = !0, !1;
      L.next_out && (L.avail_out === 0 || q === n.Z_STREAM_END || L.avail_in === 0 && (j === n.Z_FINISH || j === n.Z_SYNC_FLUSH)) && (this.options.to === "string" ? (K = t.utf8border(L.output, L.next_out), Y = L.next_out - K, de = t.buf2string(L.output, K), L.next_out = Y, L.avail_out = U - Y, Y && e.arraySet(L.output, L.output, K, Y, 0), this.onData(de)) : this.onData(e.shrinkBuf(L.output, L.next_out))), L.avail_in === 0 && L.avail_out === 0 && (ne = !0);
    } while ((L.avail_in > 0 || L.avail_out === 0) && q !== n.Z_STREAM_END);
    return q === n.Z_STREAM_END && (j = n.Z_FINISH), j === n.Z_FINISH ? (q = r.inflateEnd(this.strm), this.onEnd(q), this.ended = !0, q === n.Z_OK) : (j === n.Z_SYNC_FLUSH && (this.onEnd(n.Z_OK), L.avail_out = 0), !0);
  }, u.prototype.onData = function(E) {
    this.chunks.push(E);
  }, u.prototype.onEnd = function(E) {
    E === n.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = e.flattenChunks(this.chunks)), this.chunks = [], this.err = E, this.msg = this.strm.msg;
  };
  function m(E, P) {
    var L = new u(P);
    if (L.push(E, !0), L.err)
      throw L.msg || i[L.err];
    return L.result;
  }
  function y(E, P) {
    return P = P || {}, P.raw = !0, m(E, P);
  }
  return Rd.Inflate = u, Rd.inflate = m, Rd.inflateRaw = y, Rd.ungzip = m, Rd;
}
var sb, LR;
function Wpe() {
  if (LR) return sb;
  LR = 1;
  var r = af().assign, e = Upe(), t = Gpe(), n = Gk(), i = {};
  return r(i, e, t, n), sb = i, sb;
}
var $pe = Wpe();
const Bd = /* @__PURE__ */ dh($pe), kR = [0], qpe = {
  getPointColor: { type: "accessor", value: [0, 0, 0, 255] },
  pointSize: 1,
  // Disable async data loading (handling it in _loadTileSet)
  data: "",
  loader: Uk,
  onTilesetLoad: { type: "function", value: (r) => {
  } },
  onTileLoad: { type: "function", value: (r) => {
  } },
  onTileUnload: { type: "function", value: (r) => {
  } },
  onTileError: { type: "function", value: (r, e, t) => {
  } },
  _getMeshColor: { type: "function", value: (r) => [255, 255, 255] }
};
class nT extends Ps {
  initializeState() {
    "onTileLoadFail" in this.props && Jr.removed("onTileLoadFail", "onTileError")(), this.state = {
      layerMap: {},
      tileset3d: null,
      activeViewports: {},
      lastUpdatedViewports: null
    };
  }
  get isLoaded() {
    return !!(this.state?.tileset3d?.isLoaded() && super.isLoaded);
  }
  shouldUpdateState({ changeFlags: e }) {
    return e.somethingChanged;
  }
  updateState({ props: e, oldProps: t, changeFlags: n }) {
    if (e.data && e.data !== t.data && this._loadTileset(e.data), n.viewportChanged) {
      const { activeViewports: i } = this.state;
      Object.keys(i).length && (this._updateTileset(i), this.state.lastUpdatedViewports = i, this.state.activeViewports = {});
    }
    if (n.propsChanged) {
      const { layerMap: i } = this.state;
      for (const s in i)
        i[s].needsUpdate = !0;
    }
  }
  activateViewport(e) {
    const { activeViewports: t, lastUpdatedViewports: n } = this.state;
    this.internalState.viewport = e, t[e.id] = e;
    const i = n?.[e.id];
    (!i || !e.equals(i)) && (this.setChangeFlags({ viewportChanged: !0 }), this.setNeedsUpdate());
  }
  getPickingInfo({ info: e, sourceLayer: t }) {
    const n = t && t.props.tile;
    return e.picked && (e.object = n), e.sourceTile = n, e;
  }
  filterSubLayer({ layer: e, viewport: t }) {
    const { tile: n } = e.props, { id: i } = t;
    return n.selected && n.viewportIds.includes(i);
  }
  _updateAutoHighlight(e) {
    const t = e.sourceTile, n = this.state.layerMap[t?.id];
    n && n.layer && n.layer.updateAutoHighlight(e);
  }
  async _loadTileset(e) {
    const { loadOptions: t = {} } = this.props, n = this.props.loader || this.props.loaders, i = Array.isArray(n) ? n[0] : n, s = { loadOptions: { ...t } };
    let o = e;
    if (i.preload) {
      const m = await i.preload(e, t);
      m.url && (o = m.url), m.headers && (s.loadOptions.fetch = {
        ...s.loadOptions.fetch,
        headers: m.headers
      }), Object.assign(s, m);
    }
    const l = await Kc(o, i, s.loadOptions), u = new mde(l, {
      onTileLoad: this._onTileLoad.bind(this),
      onTileUnload: this._onTileUnload.bind(this),
      onTileError: this.props.onTileError,
      ...s
    });
    this.setState({
      tileset3d: u,
      layerMap: {}
    }), this._updateTileset(this.state.activeViewports), this.props.onTilesetLoad(u);
  }
  _onTileLoad(e) {
    const { lastUpdatedViewports: t } = this.state;
    this.props.onTileLoad(e), this._updateTileset(t), this.setNeedsUpdate();
  }
  _onTileUnload(e) {
    delete this.state.layerMap[e.id], this.props.onTileUnload(e);
  }
  _updateTileset(e) {
    if (!e)
      return;
    const { tileset3d: t } = this.state, { timeline: n } = this.context, i = Object.keys(e).length;
    !n || !i || !t || t.selectTiles(Object.values(e)).then((s) => {
      this.state.frameNumber !== s && this.setState({ frameNumber: s });
    });
  }
  _getSubLayer(e, t) {
    if (!e.content)
      return null;
    switch (e.type) {
      case Xc.POINTCLOUD:
        return this._makePointCloudLayer(e, t);
      case Xc.SCENEGRAPH:
        return this._make3DModelLayer(e);
      case Xc.MESH:
        return this._makeSimpleMeshLayer(e, t);
      default:
        throw new Error(`Tile3DLayer: Failed to render layer of type ${e.content.type}`);
    }
  }
  _makePointCloudLayer(e, t) {
    const { attributes: n, pointCount: i, constantRGBA: s, cartographicOrigin: o, modelMatrix: l } = e.content, { positions: u, normals: m, colors: y } = n;
    if (!u)
      return null;
    const E = t && t.props.data || {
      header: {
        vertexCount: i
      },
      attributes: {
        POSITION: u,
        NORMAL: m,
        COLOR_0: y
      }
    }, { pointSize: P, getPointColor: L } = this.props, U = this.getSubLayerClass("pointcloud", w0);
    return new U({
      pointSize: P
    }, this.getSubLayerProps({
      id: "pointcloud"
    }), {
      id: `${this.id}-pointcloud-${e.id}`,
      tile: e,
      data: E,
      coordinateSystem: rn.METER_OFFSETS,
      coordinateOrigin: o,
      modelMatrix: l,
      getColor: s || L,
      _offset: 0
    });
  }
  _make3DModelLayer(e) {
    const { gltf: t, instances: n, cartographicOrigin: i, modelMatrix: s } = e.content, o = this.getSubLayerClass("scenegraph", P0);
    return new o({
      _lighting: "pbr"
    }, this.getSubLayerProps({
      id: "scenegraph"
    }), {
      id: `${this.id}-scenegraph-${e.id}`,
      tile: e,
      data: n || kR,
      scenegraph: t,
      coordinateSystem: rn.METER_OFFSETS,
      coordinateOrigin: i,
      modelMatrix: s,
      getTransformMatrix: (l) => l.modelMatrix,
      getPosition: [0, 0, 0],
      _offset: 0
    });
  }
  _makeSimpleMeshLayer(e, t) {
    const n = e.content, { attributes: i, indices: s, modelMatrix: o, cartographicOrigin: l, coordinateSystem: u = rn.METER_OFFSETS, material: m, featureIds: y } = n, { _getMeshColor: E } = this.props, P = t && t.props.mesh || new no({
      topology: "triangle-list",
      attributes: Xpe(i),
      indices: s
    }), L = this.getSubLayerClass("mesh", Xw);
    return new L(this.getSubLayerProps({
      id: "mesh"
    }), {
      id: `${this.id}-mesh-${e.id}`,
      tile: e,
      mesh: P,
      data: kR,
      getColor: E(e),
      pbrMaterial: m,
      modelMatrix: o,
      coordinateOrigin: l,
      coordinateSystem: u,
      featureIds: y,
      _offset: 0
    });
  }
  renderLayers() {
    const { tileset3d: e, layerMap: t } = this.state;
    return e ? e.tiles.map((n) => {
      const i = t[n.id] = t[n.id] || { tile: n };
      let { layer: s } = i;
      return n.selected && (s ? i.needsUpdate && (s = this._getSubLayer(n, s), i.needsUpdate = !1) : s = this._getSubLayer(n)), i.layer = s, s;
    }).filter(Boolean) : null;
  }
}
nT.defaultProps = qpe;
nT.layerName = "Tile3DLayer";
function Xpe(r) {
  const e = {};
  return e.positions = {
    ...r.positions,
    value: new Float32Array(r.positions.value)
  }, r.normals && (e.normals = r.normals), r.texCoords && (e.texCoords = r.texCoords), r.colors && (e.colors = r.colors), r.uvRegions && (e.uvRegions = r.uvRegions), e;
}
const Zpe = "4.3.3", Wk = {
  dataType: null,
  batchType: null,
  name: "Terrain",
  id: "terrain",
  module: "terrain",
  version: Zpe,
  worker: !0,
  extensions: ["png", "pngraw", "jpg", "jpeg", "gif", "webp", "bmp"],
  mimeTypes: ["image/png", "image/jpeg", "image/gif", "image/webp", "image/bmp"],
  options: {
    terrain: {
      tesselator: "auto",
      bounds: void 0,
      meshMaxError: 10,
      elevationDecoder: {
        rScaler: 1,
        gScaler: 0,
        bScaler: 0,
        offset: 0
      },
      skirtHeight: void 0
    }
  }
};
({
  ...Wk
});
const FR = [1], Ype = {
  ...ou.defaultProps,
  // Image url that encodes height data
  elevationData: x_,
  // Image url to use as texture
  texture: { ...x_, optional: !0 },
  // Martini error tolerance in meters, smaller number -> more detailed mesh
  meshMaxError: { type: "number", value: 4 },
  // Bounding box of the terrain image, [minX, minY, maxX, maxY] in world coordinates
  bounds: { type: "array", value: null, optional: !0, compare: !0 },
  // Color to use if texture is unavailable
  color: { type: "color", value: [255, 255, 255] },
  // Object to decode height data, from (r, g, b) to height in meters
  elevationDecoder: {
    type: "object",
    value: {
      rScaler: 1,
      gScaler: 0,
      bScaler: 0,
      offset: 0
    }
  },
  // Supply url to local terrain worker bundle. Only required if running offline and cannot access CDN.
  workerUrl: "",
  // Same as SimpleMeshLayer wireframe
  wireframe: !1,
  material: !0,
  loaders: [Wk]
};
function NR(r) {
  return Array.isArray(r) ? r.join(";") : r || "";
}
class iT extends Ps {
  updateState({ props: e, oldProps: t }) {
    const n = e.elevationData !== t.elevationData;
    if (n) {
      const { elevationData: s } = e, o = s && (Array.isArray(s) || Kpe(s));
      this.setState({ isTiled: o });
    }
    const i = n || e.meshMaxError !== t.meshMaxError || e.elevationDecoder !== t.elevationDecoder || e.bounds !== t.bounds;
    if (!this.state.isTiled && i) {
      const s = this.loadTerrain(e);
      this.setState({ terrain: s });
    }
    e.workerUrl && Jr.removed("workerUrl", "loadOptions.terrain.workerUrl")();
  }
  loadTerrain({ elevationData: e, bounds: t, elevationDecoder: n, meshMaxError: i, signal: s }) {
    if (!e)
      return null;
    let o = this.getLoadOptions();
    o = {
      ...o,
      terrain: {
        skirtHeight: this.state.isTiled ? i * 2 : 0,
        ...o?.terrain,
        bounds: t,
        meshMaxError: i,
        elevationDecoder: n
      }
    };
    const { fetch: l } = this.props;
    return l(e, { propName: "elevationData", layer: this, loadOptions: o, signal: s });
  }
  getTiledTerrainData(e) {
    const { elevationData: t, fetch: n, texture: i, elevationDecoder: s, meshMaxError: o } = this.props, { viewport: l } = this.context, u = ch(t, e), m = i && ch(i, e), { signal: y } = e;
    let E = [0, 0], P = [0, 0];
    if (l.isGeospatial) {
      const q = e.bbox;
      E = l.projectFlat([q.west, q.south]), P = l.projectFlat([q.east, q.north]);
    } else {
      const q = e.bbox;
      E = [q.left, q.bottom], P = [q.right, q.top];
    }
    const L = [E[0], E[1], P[0], P[1]], U = this.loadTerrain({
      elevationData: u,
      bounds: L,
      elevationDecoder: s,
      meshMaxError: o,
      signal: y
    }), V = m ? (
      // If surface image fails to load, the tile should still be displayed
      n(m, { propName: "texture", layer: this, loaders: [], signal: y }).catch((q) => null)
    ) : Promise.resolve(null);
    return Promise.all([U, V]);
  }
  renderSubLayers(e) {
    const t = this.getSubLayerClass("mesh", uh), { color: n, wireframe: i, material: s } = this.props, { data: o } = e;
    if (!o)
      return null;
    const [l, u] = o;
    return new t(e, {
      data: FR,
      mesh: l,
      texture: u,
      _instanced: !1,
      coordinateSystem: rn.CARTESIAN,
      getPosition: (m) => [0, 0, 0],
      getColor: n,
      wireframe: i,
      material: s
    });
  }
  // Update zRange of viewport
  onViewportLoad(e) {
    if (!e)
      return;
    const { zRange: t } = this.state, n = e.map((o) => o.content).filter(Boolean).map((o) => o[0].header.boundingBox.map((u) => u[2]));
    if (n.length === 0)
      return;
    const i = Math.min(...n.map((o) => o[0])), s = Math.max(...n.map((o) => o[1]));
    (!t || i < t[0] || s > t[1]) && this.setState({ zRange: [i, s] });
  }
  renderLayers() {
    const { color: e, material: t, elevationData: n, texture: i, wireframe: s, meshMaxError: o, elevationDecoder: l, tileSize: u, maxZoom: m, minZoom: y, extent: E, maxRequests: P, onTileLoad: L, onTileUnload: U, onTileError: V, maxCacheSize: q, maxCacheByteSize: j, refinementStrategy: K } = this.props;
    if (this.state.isTiled)
      return new ou(this.getSubLayerProps({
        id: "tiles"
      }), {
        getTileData: this.getTiledTerrainData.bind(this),
        renderSubLayers: this.renderSubLayers.bind(this),
        updateTriggers: {
          getTileData: {
            elevationData: NR(n),
            texture: NR(i),
            meshMaxError: o,
            elevationDecoder: l
          }
        },
        onViewportLoad: this.onViewportLoad.bind(this),
        zRange: this.state.zRange || null,
        tileSize: u,
        maxZoom: m,
        minZoom: y,
        extent: E,
        maxRequests: P,
        onTileLoad: L,
        onTileUnload: U,
        onTileError: V,
        maxCacheSize: q,
        maxCacheByteSize: j,
        refinementStrategy: K
      });
    if (!n)
      return null;
    const Y = this.getSubLayerClass("mesh", uh);
    return new Y(this.getSubLayerProps({
      id: "mesh"
    }), {
      data: FR,
      mesh: this.state.terrain,
      texture: i,
      _instanced: !1,
      getPosition: (de) => [0, 0, 0],
      getColor: e,
      material: t,
      wireframe: s
    });
  }
}
iT.defaultProps = Ype;
iT.layerName = "TerrainLayer";
const Kpe = (r) => r.includes("{x}") && (r.includes("{y}") || r.includes("{-y}")), Qpe = {
  clipBounds: [0, 0, 1, 1],
  clipByInstance: void 0
}, $k = (
  /* glsl */
  `
uniform clipUniforms {
  vec4 bounds;
} clip;

bool clip_isInBounds(vec2 position) {
  return position.x >= clip.bounds[0] && position.y >= clip.bounds[1] && position.x < clip.bounds[2] && position.y < clip.bounds[3];
}
`
), Jpe = {
  name: "clip",
  vs: $k,
  uniformTypes: {
    bounds: "vec4<f32>"
  }
}, eAe = {
  "vs:#decl": (
    /* glsl */
    `
out float clip_isVisible;
`
  ),
  "vs:DECKGL_FILTER_GL_POSITION": (
    /* glsl */
    `
  clip_isVisible = float(clip_isInBounds(geometry.worldPosition.xy));
`
  ),
  "fs:#decl": (
    /* glsl */
    `
in float clip_isVisible;
`
  ),
  "fs:DECKGL_FILTER_COLOR": (
    /* glsl */
    `
  if (clip_isVisible < 0.5) discard;
`
  )
}, tAe = {
  name: "clip",
  fs: $k,
  uniformTypes: {
    bounds: "vec4<f32>"
  }
}, rAe = {
  "vs:#decl": (
    /* glsl */
    `
out vec2 clip_commonPosition;
`
  ),
  "vs:DECKGL_FILTER_GL_POSITION": (
    /* glsl */
    `
  clip_commonPosition = geometry.position.xy;
`
  ),
  "fs:#decl": (
    /* glsl */
    `
in vec2 clip_commonPosition;
`
  ),
  "fs:DECKGL_FILTER_COLOR": (
    /* glsl */
    `
  if (!clip_isInBounds(clip_commonPosition)) discard;
`
  )
};
class _y extends G_ {
  getShaders() {
    let e = "instancePositions" in this.getAttributeManager().attributes;
    return this.props.clipByInstance !== void 0 && (e = !!this.props.clipByInstance), this.state.clipByInstance = e, e ? {
      modules: [Jpe],
      inject: eAe
    } : {
      modules: [tAe],
      inject: rAe
    };
  }
  /* eslint-disable camelcase */
  draw() {
    const { clipBounds: e } = this.props, t = {};
    if (this.state.clipByInstance)
      t.bounds = e;
    else {
      const n = this.projectPosition([e[0], e[1], 0]), i = this.projectPosition([e[2], e[3], 0]);
      t.bounds = [
        Math.min(n[0], i[0]),
        Math.min(n[1], i[1]),
        Math.max(n[0], i[0]),
        Math.max(n[1], i[1])
      ];
    }
    this.setShaderModuleProps({ clip: t });
  }
}
_y.defaultProps = Qpe;
_y.extensionName = "ClipExtension";
const nAe = (
  /* glsl */
  `
in float collisionPriorities;

uniform sampler2D collision_texture;

uniform collisionUniforms {
  bool sort;
  bool enabled;
} collision;

vec2 collision_getCoords(vec4 position) {
  vec4 collision_clipspace = project_common_position_to_clipspace(position);
  return (1.0 + collision_clipspace.xy / collision_clipspace.w) / 2.0;
}

float collision_match(vec2 tex, vec3 pickingColor) {
  vec4 collision_pickingColor = texture(collision_texture, tex);
  float delta = dot(abs(collision_pickingColor.rgb - pickingColor), vec3(1.0));
  float e = 0.001;
  return step(delta, e);
}

float collision_isVisible(vec2 texCoords, vec3 pickingColor) {
  if (!collision.enabled) {
    return 1.0;
  }

  // Visibility test, sample area of 5x5 pixels in order to fade in/out.
  // Due to the locality, the lookups will be cached
  // This reduces the flicker present when objects are shown/hidden
  const int N = 2;
  float accumulator = 0.0;
  vec2 step = vec2(1.0 / project.viewportSize);

  const float floatN = float(N);
  vec2 delta = -floatN * step;
  for(int i = -N; i <= N; i++) {
    delta.x = -step.x * floatN;
    for(int j = -N; j <= N; j++) {
      accumulator += collision_match(texCoords + delta, pickingColor);
      delta.x += step.x;
    }
    delta.y += step.y;
  }

  float W = 2.0 * floatN + 1.0;
  return pow(accumulator / (W * W), 2.2);
}
`
), iAe = {
  "vs:#decl": (
    /* glsl */
    `
  float collision_fade = 1.0;
`
  ),
  "vs:DECKGL_FILTER_GL_POSITION": (
    /* glsl */
    `
  if (collision.sort) {
    float collisionPriority = collisionPriorities;
    position.z = -0.001 * collisionPriority * position.w; // Support range -1000 -> 1000
  }

  if (collision.enabled) {
    vec4 collision_common_position = project_position(vec4(geometry.worldPosition, 1.0));
    vec2 collision_texCoords = collision_getCoords(collision_common_position);
    collision_fade = collision_isVisible(collision_texCoords, geometry.pickingColor / 255.0);
    if (collision_fade < 0.0001) {
      // Position outside clip space bounds to discard
      position = vec4(0.0, 0.0, 2.0, 1.0);
    }
  }
  `
  ),
  "vs:DECKGL_FILTER_COLOR": (
    /* glsl */
    `
  color.a *= collision_fade;
  `
  )
}, sAe = (r) => {
  if (!r || !("dummyCollisionMap" in r))
    return {};
  const { enabled: e, collisionFBO: t, drawToCollisionMap: n, dummyCollisionMap: i } = r;
  return {
    enabled: e && !n,
    sort: !!n,
    collision_texture: !n && t ? t.colorAttachments[0] : i
  };
}, oAe = {
  name: "collision",
  dependencies: [N_],
  vs: nAe,
  inject: iAe,
  getUniforms: sAe,
  uniformTypes: {
    sort: "i32",
    enabled: "i32"
  }
};
class aAe extends U_ {
  renderCollisionMap(e, t) {
    const i = [0, 0, 0, 0], s = [1, 1, e.width - 2, e.height - 2];
    this.render({ ...t, clearColor: i, scissorRect: s, target: e, pass: "collision" });
  }
  getLayerParameters(e, t, n) {
    return {
      ...e.props.parameters,
      blend: !1,
      depthWriteEnabled: !0,
      depthCompare: "less-equal"
    };
  }
  getShaderModuleProps() {
    return {
      collision: {
        drawToCollisionMap: !0
      },
      picking: {
        isActive: 1,
        isAttribute: !1
      },
      lighting: { enabled: !1 }
    };
  }
}
const ob = 2;
class lAe {
  constructor() {
    this.id = "collision-filter-effect", this.props = null, this.useInPicking = !0, this.order = 1, this.channels = {}, this.collisionFBOs = {};
  }
  setup(e) {
    this.context = e;
    const { device: t } = e;
    this.dummyCollisionMap = t.createTexture({ width: 1, height: 1 }), this.collisionFilterPass = new aAe(t, { id: "default-collision-filter" });
  }
  preRender({ effects: e, layers: t, layerFilter: n, viewports: i, onViewportActive: s, views: o, isPicking: l, preRenderStats: u = {} }) {
    const { device: m } = this.context;
    if (l)
      return;
    const y = t.filter(
      // @ts-ignore
      ({ props: { visible: q, collisionEnabled: j } }) => q && j
    );
    if (y.length === 0) {
      this.channels = {};
      return;
    }
    const E = e?.filter((q) => q.useInPicking && u[q.id]), P = u["mask-effect"]?.didRender, L = this._groupByCollisionGroup(m, y), U = i[0], V = !this.lastViewport || !this.lastViewport.equals(U) || P;
    for (const q in L) {
      const j = this.collisionFBOs[q], K = L[q], [Y, de] = m.canvasContext.getPixelSize();
      j.resize({
        width: Y / ob,
        height: de / ob
      }), this._render(K, {
        effects: E,
        layerFilter: n,
        onViewportActive: s,
        views: o,
        viewport: U,
        viewportChanged: V
      });
    }
  }
  _render(e, { effects: t, layerFilter: n, onViewportActive: i, views: s, viewport: o, viewportChanged: l }) {
    const { collisionGroup: u } = e, m = this.channels[u];
    if (!m)
      return;
    const y = l || // If render info is new
    e === m || // If sublayers have changed
    !Fi(m.layers, e.layers, 1) || // If a sublayer's bounds have been updated
    e.layerBounds.some((E, P) => !Aa(E, m.layerBounds[P])) || // If a sublayer's isLoaded state has been updated
    e.allLayersLoaded !== m.allLayersLoaded || // Some prop is in transition
    e.layers.some((E) => E.props.transitions);
    if (this.channels[u] = e, y) {
      this.lastViewport = o;
      const E = this.collisionFBOs[u];
      this.collisionFilterPass.renderCollisionMap(E, {
        pass: "collision-filter",
        isPicking: !0,
        layers: e.layers,
        effects: t,
        layerFilter: n,
        viewports: o ? [o] : [],
        onViewportActive: i,
        views: s,
        shaderModuleProps: {
          collision: {
            enabled: !0,
            // To avoid feedback loop forming between Framebuffer and active Texture.
            dummyCollisionMap: this.dummyCollisionMap
          },
          project: {
            // @ts-expect-error TODO - assuming WebGL context
            devicePixelRatio: E.device.canvasContext.getDevicePixelRatio() / ob
          }
        }
      });
    }
  }
  /**
   * Group layers by collisionGroup
   * Returns a map from collisionGroup to render info
   */
  _groupByCollisionGroup(e, t) {
    const n = {};
    for (const i of t) {
      const s = i.props.collisionGroup;
      let o = n[s];
      o || (o = { collisionGroup: s, layers: [], layerBounds: [], allLayersLoaded: !0 }, n[s] = o), o.layers.push(i), o.layerBounds.push(i.getBounds()), i.isLoaded || (o.allLayersLoaded = !1);
    }
    for (const i of Object.keys(n))
      this.collisionFBOs[i] || this.createFBO(e, i), this.channels[i] || (this.channels[i] = n[i]);
    for (const i of Object.keys(this.collisionFBOs))
      n[i] || this.destroyFBO(i);
    return n;
  }
  getShaderModuleProps(e) {
    const { collisionGroup: t, collisionEnabled: n } = e.props, { collisionFBOs: i, dummyCollisionMap: s } = this, o = i[t];
    return {
      collision: {
        enabled: n && !!o,
        collisionFBO: o,
        dummyCollisionMap: s
      }
    };
  }
  cleanup() {
    this.dummyCollisionMap && (this.dummyCollisionMap.delete(), this.dummyCollisionMap = void 0), this.channels = {};
    for (const e of Object.keys(this.collisionFBOs))
      this.destroyFBO(e);
    this.collisionFBOs = {}, this.lastViewport = void 0;
  }
  createFBO(e, t) {
    const { width: n, height: i } = e.getDefaultCanvasContext().canvas, s = e.createTexture({
      format: "rgba8unorm",
      width: n,
      height: i,
      sampler: {
        minFilter: "nearest",
        magFilter: "nearest",
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
      }
    }), o = e.createTexture({
      format: "depth16unorm",
      width: n,
      height: i
    });
    this.collisionFBOs[t] = e.createFramebuffer({
      id: `collision-${t}`,
      width: n,
      height: i,
      colorAttachments: [s],
      depthStencilAttachment: o
    });
  }
  destroyFBO(e) {
    const t = this.collisionFBOs[e];
    t.colorAttachments[0]?.destroy(), t.depthStencilAttachment?.destroy(), t.destroy(), delete this.collisionFBOs[e];
  }
}
const cAe = {
  getCollisionPriority: { type: "accessor", value: 0 },
  collisionEnabled: !0,
  collisionGroup: { type: "string", value: "default" },
  collisionTestProps: {}
};
class sT extends G_ {
  getShaders() {
    return { modules: [oAe] };
  }
  /* eslint-disable camelcase */
  draw({ shaderModuleProps: e }) {
    e.collision?.drawToCollisionMap && (this.props = this.clone(this.props.collisionTestProps).props);
  }
  initializeState(e, t) {
    if (this.getAttributeManager() === null)
      return;
    this.context.deck?._addDefaultEffect(new lAe()), this.getAttributeManager().add({
      collisionPriorities: {
        size: 1,
        stepMode: "dynamic",
        accessor: "getCollisionPriority"
      }
    });
  }
  getNeedsPickingBuffer() {
    return this.props.collisionEnabled;
  }
}
sT.defaultProps = cAe;
sT.extensionName = "CollisionFilterExtension";
function V2(r, e) {
  const t = e?.globalFeatureId;
  return t !== void 0 ? uAe(r, t) : fAe(r, e?.type);
}
function uAe(r, e) {
  const t = qk(r);
  for (const n of t) {
    let i = 0, s = n.featureIds.value[0];
    for (let o = 0; o < n.featureIds.value.length; o++) {
      const l = n.featureIds.value[o];
      if (l !== s) {
        if (e === n.globalFeatureIds.value[i])
          return T_(n, i, o);
        i = o, s = l;
      }
    }
    if (e === n.globalFeatureIds.value[i])
      return T_(n, i, n.featureIds.value.length);
  }
  throw new Error(`featureId:${e} not found`);
}
function fAe(r, e) {
  const t = qk(r);
  return dAe(t);
}
function hAe(r, e, t) {
  switch (r.type) {
    case "Point":
      return mAe(r, e, t);
    case "LineString":
      return gAe(r, e, t);
    case "Polygon":
      return Xk(r, e, t);
    default:
      const n = r;
      throw new Error(`Unsupported geometry type: ${n?.type}`);
  }
}
function qk(r, e) {
  const t = [];
  return r.points && (r.points.type = "Point", t.push(r.points)), r.lines && (r.lines.type = "LineString", t.push(r.lines)), r.polygons && (r.polygons.type = "Polygon", t.push(r.polygons)), t;
}
function dAe(r) {
  const e = [];
  for (const t of r) {
    if (t.featureIds.value.length === 0)
      continue;
    let n = 0, i = t.featureIds.value[0];
    for (let s = 0; s < t.featureIds.value.length; s++) {
      const o = t.featureIds.value[s];
      o !== i && (e.push(T_(t, n, s)), n = s, i = o);
    }
    e.push(T_(t, n, t.featureIds.value.length));
  }
  return e;
}
function T_(r, e, t) {
  const n = hAe(r, e, t), i = AAe(r, e), s = pAe(r, e);
  return { type: "Feature", geometry: n, properties: i, ...s };
}
function pAe(r, e = 0, t) {
  return r.fields && r.fields[r.featureIds.value[e]];
}
function AAe(r, e = 0, t) {
  const n = Object.assign({}, r.properties[r.featureIds.value[e]]);
  for (const i in r.numericProps)
    n[i] = r.numericProps[i].value[e];
  return n;
}
function Xk(r, e = -1 / 0, t = 1 / 0) {
  const { positions: n } = r, i = r.polygonIndices.value.filter((u) => u >= e && u <= t), s = r.primitivePolygonIndices.value.filter((u) => u >= e && u <= t);
  if (!(i.length > 2)) {
    const u = [];
    for (let m = 0; m < s.length - 1; m++) {
      const y = s[m], E = s[m + 1], P = E_(n, y, E);
      u.push(P);
    }
    return { type: "Polygon", coordinates: u };
  }
  const l = [];
  for (let u = 0; u < i.length - 1; u++) {
    const m = i[u], y = i[u + 1], E = Xk(r, m, y).coordinates;
    l.push(E);
  }
  return { type: "MultiPolygon", coordinates: l };
}
function gAe(r, e = -1 / 0, t = 1 / 0) {
  const { positions: n } = r, i = r.pathIndices.value.filter((l) => l >= e && l <= t);
  if (!(i.length > 2))
    return { type: "LineString", coordinates: E_(n, i[0], i[1]) };
  const o = [];
  for (let l = 0; l < i.length - 1; l++) {
    const u = E_(n, i[l], i[l + 1]);
    o.push(u);
  }
  return { type: "MultiLineString", coordinates: o };
}
function mAe(r, e, t) {
  const { positions: n } = r, i = E_(n, e, t);
  return i.length > 1 ? { type: "MultiPoint", coordinates: i } : { type: "Point", coordinates: i[0] };
}
function E_(r, e, t) {
  e = e || 0, t = t || r.value.length / r.size;
  const n = [];
  for (let i = e; i < t; i++) {
    const s = Array();
    for (let o = i * r.size; o < (i + 1) * r.size; o++)
      s.push(Number(r.value[o]));
    n.push(s);
  }
  return n;
}
var am = {};
var UR;
function _Ae() {
  return UR || (UR = 1, am.read = function(r, e, t, n, i) {
    var s, o, l = i * 8 - n - 1, u = (1 << l) - 1, m = u >> 1, y = -7, E = t ? i - 1 : 0, P = t ? -1 : 1, L = r[e + E];
    for (E += P, s = L & (1 << -y) - 1, L >>= -y, y += l; y > 0; s = s * 256 + r[e + E], E += P, y -= 8)
      ;
    for (o = s & (1 << -y) - 1, s >>= -y, y += n; y > 0; o = o * 256 + r[e + E], E += P, y -= 8)
      ;
    if (s === 0)
      s = 1 - m;
    else {
      if (s === u)
        return o ? NaN : (L ? -1 : 1) * (1 / 0);
      o = o + Math.pow(2, n), s = s - m;
    }
    return (L ? -1 : 1) * o * Math.pow(2, s - n);
  }, am.write = function(r, e, t, n, i, s) {
    var o, l, u, m = s * 8 - i - 1, y = (1 << m) - 1, E = y >> 1, P = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, L = n ? 0 : s - 1, U = n ? 1 : -1, V = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
    for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (l = isNaN(e) ? 1 : 0, o = y) : (o = Math.floor(Math.log(e) / Math.LN2), e * (u = Math.pow(2, -o)) < 1 && (o--, u *= 2), o + E >= 1 ? e += P / u : e += P * Math.pow(2, 1 - E), e * u >= 2 && (o++, u /= 2), o + E >= y ? (l = 0, o = y) : o + E >= 1 ? (l = (e * u - 1) * Math.pow(2, i), o = o + E) : (l = e * Math.pow(2, E - 1) * Math.pow(2, i), o = 0)); i >= 8; r[t + L] = l & 255, L += U, l /= 256, i -= 8)
      ;
    for (o = o << i | l, m += i; m > 0; r[t + L] = o & 255, L += U, o /= 256, m -= 8)
      ;
    r[t + L - U] |= V * 128;
  }), am;
}
var ab, zR;
function yAe() {
  if (zR) return ab;
  zR = 1, ab = e;
  var r = _Ae();
  function e(X) {
    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(X) ? X : new Uint8Array(X || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
  }
  e.Varint = 0, e.Fixed64 = 1, e.Bytes = 2, e.Fixed32 = 5;
  var t = 65536 * 65536, n = 1 / t, i = 12, s = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
  e.prototype = {
    destroy: function() {
      this.buf = null;
    },
    // === READING =================================================================
    readFields: function(X, re, Me) {
      for (Me = Me || this.length; this.pos < Me; ) {
        var ot = this.readVarint(), be = ot >> 3, Ue = this.pos;
        this.type = ot & 7, X(be, re, this), this.pos === Ue && this.skip(ot);
      }
      return re;
    },
    readMessage: function(X, re) {
      return this.readFields(X, re, this.readVarint() + this.pos);
    },
    readFixed32: function() {
      var X = ae(this.buf, this.pos);
      return this.pos += 4, X;
    },
    readSFixed32: function() {
      var X = Ge(this.buf, this.pos);
      return this.pos += 4, X;
    },
    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)
    readFixed64: function() {
      var X = ae(this.buf, this.pos) + ae(this.buf, this.pos + 4) * t;
      return this.pos += 8, X;
    },
    readSFixed64: function() {
      var X = ae(this.buf, this.pos) + Ge(this.buf, this.pos + 4) * t;
      return this.pos += 8, X;
    },
    readFloat: function() {
      var X = r.read(this.buf, this.pos, !0, 23, 4);
      return this.pos += 4, X;
    },
    readDouble: function() {
      var X = r.read(this.buf, this.pos, !0, 52, 8);
      return this.pos += 8, X;
    },
    readVarint: function(X) {
      var re = this.buf, Me, ot;
      return ot = re[this.pos++], Me = ot & 127, ot < 128 || (ot = re[this.pos++], Me |= (ot & 127) << 7, ot < 128) || (ot = re[this.pos++], Me |= (ot & 127) << 14, ot < 128) || (ot = re[this.pos++], Me |= (ot & 127) << 21, ot < 128) ? Me : (ot = re[this.pos], Me |= (ot & 15) << 28, o(Me, X, this));
    },
    readVarint64: function() {
      return this.readVarint(!0);
    },
    readSVarint: function() {
      var X = this.readVarint();
      return X % 2 === 1 ? (X + 1) / -2 : X / 2;
    },
    readBoolean: function() {
      return !!this.readVarint();
    },
    readString: function() {
      var X = this.readVarint() + this.pos, re = this.pos;
      return this.pos = X, X - re >= i && s ? ve(this.buf, re, X) : fe(this.buf, re, X);
    },
    readBytes: function() {
      var X = this.readVarint() + this.pos, re = this.buf.subarray(this.pos, X);
      return this.pos = X, re;
    },
    // verbose for performance reasons; doesn't affect gzipped size
    readPackedVarint: function(X, re) {
      if (this.type !== e.Bytes) return X.push(this.readVarint(re));
      var Me = l(this);
      for (X = X || []; this.pos < Me; ) X.push(this.readVarint(re));
      return X;
    },
    readPackedSVarint: function(X) {
      if (this.type !== e.Bytes) return X.push(this.readSVarint());
      var re = l(this);
      for (X = X || []; this.pos < re; ) X.push(this.readSVarint());
      return X;
    },
    readPackedBoolean: function(X) {
      if (this.type !== e.Bytes) return X.push(this.readBoolean());
      var re = l(this);
      for (X = X || []; this.pos < re; ) X.push(this.readBoolean());
      return X;
    },
    readPackedFloat: function(X) {
      if (this.type !== e.Bytes) return X.push(this.readFloat());
      var re = l(this);
      for (X = X || []; this.pos < re; ) X.push(this.readFloat());
      return X;
    },
    readPackedDouble: function(X) {
      if (this.type !== e.Bytes) return X.push(this.readDouble());
      var re = l(this);
      for (X = X || []; this.pos < re; ) X.push(this.readDouble());
      return X;
    },
    readPackedFixed32: function(X) {
      if (this.type !== e.Bytes) return X.push(this.readFixed32());
      var re = l(this);
      for (X = X || []; this.pos < re; ) X.push(this.readFixed32());
      return X;
    },
    readPackedSFixed32: function(X) {
      if (this.type !== e.Bytes) return X.push(this.readSFixed32());
      var re = l(this);
      for (X = X || []; this.pos < re; ) X.push(this.readSFixed32());
      return X;
    },
    readPackedFixed64: function(X) {
      if (this.type !== e.Bytes) return X.push(this.readFixed64());
      var re = l(this);
      for (X = X || []; this.pos < re; ) X.push(this.readFixed64());
      return X;
    },
    readPackedSFixed64: function(X) {
      if (this.type !== e.Bytes) return X.push(this.readSFixed64());
      var re = l(this);
      for (X = X || []; this.pos < re; ) X.push(this.readSFixed64());
      return X;
    },
    skip: function(X) {
      var re = X & 7;
      if (re === e.Varint) for (; this.buf[this.pos++] > 127; )
        ;
      else if (re === e.Bytes) this.pos = this.readVarint() + this.pos;
      else if (re === e.Fixed32) this.pos += 4;
      else if (re === e.Fixed64) this.pos += 8;
      else throw new Error("Unimplemented type: " + re);
    },
    // === WRITING =================================================================
    writeTag: function(X, re) {
      this.writeVarint(X << 3 | re);
    },
    realloc: function(X) {
      for (var re = this.length || 16; re < this.pos + X; ) re *= 2;
      if (re !== this.length) {
        var Me = new Uint8Array(re);
        Me.set(this.buf), this.buf = Me, this.length = re;
      }
    },
    finish: function() {
      return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
    },
    writeFixed32: function(X) {
      this.realloc(4), De(this.buf, X, this.pos), this.pos += 4;
    },
    writeSFixed32: function(X) {
      this.realloc(4), De(this.buf, X, this.pos), this.pos += 4;
    },
    writeFixed64: function(X) {
      this.realloc(8), De(this.buf, X & -1, this.pos), De(this.buf, Math.floor(X * n), this.pos + 4), this.pos += 8;
    },
    writeSFixed64: function(X) {
      this.realloc(8), De(this.buf, X & -1, this.pos), De(this.buf, Math.floor(X * n), this.pos + 4), this.pos += 8;
    },
    writeVarint: function(X) {
      if (X = +X || 0, X > 268435455 || X < 0) {
        m(X, this);
        return;
      }
      this.realloc(4), this.buf[this.pos++] = X & 127 | (X > 127 ? 128 : 0), !(X <= 127) && (this.buf[this.pos++] = (X >>>= 7) & 127 | (X > 127 ? 128 : 0), !(X <= 127) && (this.buf[this.pos++] = (X >>>= 7) & 127 | (X > 127 ? 128 : 0), !(X <= 127) && (this.buf[this.pos++] = X >>> 7 & 127)));
    },
    writeSVarint: function(X) {
      this.writeVarint(X < 0 ? -X * 2 - 1 : X * 2);
    },
    writeBoolean: function(X) {
      this.writeVarint(!!X);
    },
    writeString: function(X) {
      X = String(X), this.realloc(X.length * 4), this.pos++;
      var re = this.pos;
      this.pos = me(this.buf, X, this.pos);
      var Me = this.pos - re;
      Me >= 128 && P(re, Me, this), this.pos = re - 1, this.writeVarint(Me), this.pos += Me;
    },
    writeFloat: function(X) {
      this.realloc(4), r.write(this.buf, X, this.pos, !0, 23, 4), this.pos += 4;
    },
    writeDouble: function(X) {
      this.realloc(8), r.write(this.buf, X, this.pos, !0, 52, 8), this.pos += 8;
    },
    writeBytes: function(X) {
      var re = X.length;
      this.writeVarint(re), this.realloc(re);
      for (var Me = 0; Me < re; Me++) this.buf[this.pos++] = X[Me];
    },
    writeRawMessage: function(X, re) {
      this.pos++;
      var Me = this.pos;
      X(re, this);
      var ot = this.pos - Me;
      ot >= 128 && P(Me, ot, this), this.pos = Me - 1, this.writeVarint(ot), this.pos += ot;
    },
    writeMessage: function(X, re, Me) {
      this.writeTag(X, e.Bytes), this.writeRawMessage(re, Me);
    },
    writePackedVarint: function(X, re) {
      re.length && this.writeMessage(X, L, re);
    },
    writePackedSVarint: function(X, re) {
      re.length && this.writeMessage(X, U, re);
    },
    writePackedBoolean: function(X, re) {
      re.length && this.writeMessage(X, j, re);
    },
    writePackedFloat: function(X, re) {
      re.length && this.writeMessage(X, V, re);
    },
    writePackedDouble: function(X, re) {
      re.length && this.writeMessage(X, q, re);
    },
    writePackedFixed32: function(X, re) {
      re.length && this.writeMessage(X, K, re);
    },
    writePackedSFixed32: function(X, re) {
      re.length && this.writeMessage(X, Y, re);
    },
    writePackedFixed64: function(X, re) {
      re.length && this.writeMessage(X, de, re);
    },
    writePackedSFixed64: function(X, re) {
      re.length && this.writeMessage(X, ne, re);
    },
    writeBytesField: function(X, re) {
      this.writeTag(X, e.Bytes), this.writeBytes(re);
    },
    writeFixed32Field: function(X, re) {
      this.writeTag(X, e.Fixed32), this.writeFixed32(re);
    },
    writeSFixed32Field: function(X, re) {
      this.writeTag(X, e.Fixed32), this.writeSFixed32(re);
    },
    writeFixed64Field: function(X, re) {
      this.writeTag(X, e.Fixed64), this.writeFixed64(re);
    },
    writeSFixed64Field: function(X, re) {
      this.writeTag(X, e.Fixed64), this.writeSFixed64(re);
    },
    writeVarintField: function(X, re) {
      this.writeTag(X, e.Varint), this.writeVarint(re);
    },
    writeSVarintField: function(X, re) {
      this.writeTag(X, e.Varint), this.writeSVarint(re);
    },
    writeStringField: function(X, re) {
      this.writeTag(X, e.Bytes), this.writeString(re);
    },
    writeFloatField: function(X, re) {
      this.writeTag(X, e.Fixed32), this.writeFloat(re);
    },
    writeDoubleField: function(X, re) {
      this.writeTag(X, e.Fixed64), this.writeDouble(re);
    },
    writeBooleanField: function(X, re) {
      this.writeVarintField(X, !!re);
    }
  };
  function o(X, re, Me) {
    var ot = Me.buf, be, Ue;
    if (Ue = ot[Me.pos++], be = (Ue & 112) >> 4, Ue < 128 || (Ue = ot[Me.pos++], be |= (Ue & 127) << 3, Ue < 128) || (Ue = ot[Me.pos++], be |= (Ue & 127) << 10, Ue < 128) || (Ue = ot[Me.pos++], be |= (Ue & 127) << 17, Ue < 128) || (Ue = ot[Me.pos++], be |= (Ue & 127) << 24, Ue < 128) || (Ue = ot[Me.pos++], be |= (Ue & 1) << 31, Ue < 128)) return u(X, be, re);
    throw new Error("Expected varint not more than 10 bytes");
  }
  function l(X) {
    return X.type === e.Bytes ? X.readVarint() + X.pos : X.pos + 1;
  }
  function u(X, re, Me) {
    return Me ? re * 4294967296 + (X >>> 0) : (re >>> 0) * 4294967296 + (X >>> 0);
  }
  function m(X, re) {
    var Me, ot;
    if (X >= 0 ? (Me = X % 4294967296 | 0, ot = X / 4294967296 | 0) : (Me = ~(-X % 4294967296), ot = ~(-X / 4294967296), Me ^ 4294967295 ? Me = Me + 1 | 0 : (Me = 0, ot = ot + 1 | 0)), X >= 18446744073709552e3 || X < -18446744073709552e3)
      throw new Error("Given varint doesn't fit into 10 bytes");
    re.realloc(10), y(Me, ot, re), E(ot, re);
  }
  function y(X, re, Me) {
    Me.buf[Me.pos++] = X & 127 | 128, X >>>= 7, Me.buf[Me.pos++] = X & 127 | 128, X >>>= 7, Me.buf[Me.pos++] = X & 127 | 128, X >>>= 7, Me.buf[Me.pos++] = X & 127 | 128, X >>>= 7, Me.buf[Me.pos] = X & 127;
  }
  function E(X, re) {
    var Me = (X & 7) << 4;
    re.buf[re.pos++] |= Me | ((X >>>= 3) ? 128 : 0), X && (re.buf[re.pos++] = X & 127 | ((X >>>= 7) ? 128 : 0), X && (re.buf[re.pos++] = X & 127 | ((X >>>= 7) ? 128 : 0), X && (re.buf[re.pos++] = X & 127 | ((X >>>= 7) ? 128 : 0), X && (re.buf[re.pos++] = X & 127 | ((X >>>= 7) ? 128 : 0), X && (re.buf[re.pos++] = X & 127)))));
  }
  function P(X, re, Me) {
    var ot = re <= 16383 ? 1 : re <= 2097151 ? 2 : re <= 268435455 ? 3 : Math.floor(Math.log(re) / (Math.LN2 * 7));
    Me.realloc(ot);
    for (var be = Me.pos - 1; be >= X; be--) Me.buf[be + ot] = Me.buf[be];
  }
  function L(X, re) {
    for (var Me = 0; Me < X.length; Me++) re.writeVarint(X[Me]);
  }
  function U(X, re) {
    for (var Me = 0; Me < X.length; Me++) re.writeSVarint(X[Me]);
  }
  function V(X, re) {
    for (var Me = 0; Me < X.length; Me++) re.writeFloat(X[Me]);
  }
  function q(X, re) {
    for (var Me = 0; Me < X.length; Me++) re.writeDouble(X[Me]);
  }
  function j(X, re) {
    for (var Me = 0; Me < X.length; Me++) re.writeBoolean(X[Me]);
  }
  function K(X, re) {
    for (var Me = 0; Me < X.length; Me++) re.writeFixed32(X[Me]);
  }
  function Y(X, re) {
    for (var Me = 0; Me < X.length; Me++) re.writeSFixed32(X[Me]);
  }
  function de(X, re) {
    for (var Me = 0; Me < X.length; Me++) re.writeFixed64(X[Me]);
  }
  function ne(X, re) {
    for (var Me = 0; Me < X.length; Me++) re.writeSFixed64(X[Me]);
  }
  function ae(X, re) {
    return (X[re] | X[re + 1] << 8 | X[re + 2] << 16) + X[re + 3] * 16777216;
  }
  function De(X, re, Me) {
    X[Me] = re, X[Me + 1] = re >>> 8, X[Me + 2] = re >>> 16, X[Me + 3] = re >>> 24;
  }
  function Ge(X, re) {
    return (X[re] | X[re + 1] << 8 | X[re + 2] << 16) + (X[re + 3] << 24);
  }
  function fe(X, re, Me) {
    for (var ot = "", be = re; be < Me; ) {
      var Ue = X[be], Xe = null, lt = Ue > 239 ? 4 : Ue > 223 ? 3 : Ue > 191 ? 2 : 1;
      if (be + lt > Me) break;
      var at, ct, gt;
      lt === 1 ? Ue < 128 && (Xe = Ue) : lt === 2 ? (at = X[be + 1], (at & 192) === 128 && (Xe = (Ue & 31) << 6 | at & 63, Xe <= 127 && (Xe = null))) : lt === 3 ? (at = X[be + 1], ct = X[be + 2], (at & 192) === 128 && (ct & 192) === 128 && (Xe = (Ue & 15) << 12 | (at & 63) << 6 | ct & 63, (Xe <= 2047 || Xe >= 55296 && Xe <= 57343) && (Xe = null))) : lt === 4 && (at = X[be + 1], ct = X[be + 2], gt = X[be + 3], (at & 192) === 128 && (ct & 192) === 128 && (gt & 192) === 128 && (Xe = (Ue & 15) << 18 | (at & 63) << 12 | (ct & 63) << 6 | gt & 63, (Xe <= 65535 || Xe >= 1114112) && (Xe = null))), Xe === null ? (Xe = 65533, lt = 1) : Xe > 65535 && (Xe -= 65536, ot += String.fromCharCode(Xe >>> 10 & 1023 | 55296), Xe = 56320 | Xe & 1023), ot += String.fromCharCode(Xe), be += lt;
    }
    return ot;
  }
  function ve(X, re, Me) {
    return s.decode(X.subarray(re, Me));
  }
  function me(X, re, Me) {
    for (var ot = 0, be, Ue; ot < re.length; ot++) {
      if (be = re.charCodeAt(ot), be > 55295 && be < 57344)
        if (Ue)
          if (be < 56320) {
            X[Me++] = 239, X[Me++] = 191, X[Me++] = 189, Ue = be;
            continue;
          } else
            be = Ue - 55296 << 10 | be - 56320 | 65536, Ue = null;
        else {
          be > 56319 || ot + 1 === re.length ? (X[Me++] = 239, X[Me++] = 191, X[Me++] = 189) : Ue = be;
          continue;
        }
      else Ue && (X[Me++] = 239, X[Me++] = 191, X[Me++] = 189, Ue = null);
      be < 128 ? X[Me++] = be : (be < 2048 ? X[Me++] = be >> 6 | 192 : (be < 65536 ? X[Me++] = be >> 12 | 224 : (X[Me++] = be >> 18 | 240, X[Me++] = be >> 12 & 63 | 128), X[Me++] = be >> 6 & 63 | 128), X[Me++] = be & 63 | 128);
    }
    return Me;
  }
  return ab;
}
var vAe = yAe();
const bAe = /* @__PURE__ */ dh(vAe), xAe = "4.3.3", Zk = {
  dataType: null,
  batchType: null,
  name: "Mapbox Vector Tile",
  id: "mvt",
  module: "mvt",
  version: xAe,
  // Note: ArcGIS uses '.pbf' extension and 'application/octet-stream'
  extensions: ["mvt", "pbf"],
  mimeTypes: [
    // https://www.iana.org/assignments/media-types/application/vnd.mapbox-vector-tile
    "application/vnd.mapbox-vector-tile",
    "application/x-protobuf"
    // 'application/octet-stream'
  ],
  worker: !0,
  category: "geometry",
  options: {
    mvt: {
      shape: "geojson",
      coordinates: "local",
      layerProperty: "layerName",
      layers: void 0,
      tileIndex: void 0
    }
  }
};
({
  ...Zk
});
const wAe = {
  Point: Yk,
  MultiPoint: TAe,
  LineString: Kk,
  MultiLineString: EAe,
  Polygon: Qk,
  MultiPolygon: CAe
};
function Yk([r, e], [t, n], i) {
  const s = ml(t[0], n[0], r), o = ml(t[1], n[1], e);
  return i.unprojectFlat([s, o]);
}
function oT(r, e, t) {
  return r.map((n) => Yk(n, e, t));
}
function TAe(r, e, t) {
  return oT(r, e, t);
}
function Kk(r, e, t) {
  return oT(r, e, t);
}
function EAe(r, e, t) {
  return r.map((n) => Kk(n, e, t));
}
function Qk(r, e, t) {
  return r.map((n) => oT(n, e, t));
}
function CAe(r, e, t) {
  return r.map((n) => Qk(n, e, t));
}
function SAe(r, e, t) {
  const n = t.projectFlat([e.west, e.north]), i = t.projectFlat([e.east, e.south]), s = [n, i];
  return {
    ...r,
    coordinates: wAe[r.type](r.coordinates, s, t)
  };
}
const IAe = ["points", "lines", "polygons"];
function PAe(r, e, t, n) {
  for (const i of IAe) {
    const s = r[i] && MAe(r[i], e, t, n);
    if (s >= 0)
      return s;
  }
  return -1;
}
function MAe(r, e, t, n) {
  const i = r.featureIds.value;
  if (!i.length)
    return -1;
  let s = 0, o = i[i.length - 1] + 1;
  if (n) {
    const u = RAe(r, n);
    if (u)
      s = u[0], o = u[1] + 1;
    else
      return -1;
  }
  let l = -1;
  if (e in r.numericProps) {
    const u = r.numericProps[e].value.findIndex((m, y) => m === t && i[y] >= s && i[y] < o);
    return u >= 0 ? r.globalFeatureIds.value[u] : -1;
  } else e ? l = VR(r.properties, (u) => u[e] === t, s, o) : r.fields && (l = VR(r.fields, (u) => u.id === t, s, o));
  return l >= 0 ? BAe(r, l) : -1;
}
function RAe(r, e) {
  if (!r.__layers) {
    const t = {}, { properties: n } = r;
    for (let i = 0; i < n.length; i++) {
      const { layerName: s } = n[i];
      s && (t[s] ? t[s][1] = i : t[s] = [i, i]);
    }
    r.__layers = t;
  }
  return r.__layers[e];
}
function BAe(r, e) {
  if (!r.__ids) {
    const t = [], n = r.featureIds.value, i = r.globalFeatureIds.value;
    for (let s = 0; s < n.length; s++)
      t[n[s]] = i[s];
    r.__ids = t;
  }
  return r.__ids[e];
}
function VR(r, e, t, n) {
  for (let i = t; i < n; i++)
    if (e(r[i], i))
      return i;
  return -1;
}
const lb = 512, OAe = {
  ...iu.defaultProps,
  data: x_,
  onDataLoad: { type: "function", value: null, optional: !0, compare: !1 },
  uniqueIdProperty: "",
  highlightedFeatureId: null,
  loaders: [Zk],
  binary: !0
};
class Np extends ou {
  initializeState() {
    super.initializeState();
    const e = this.context.viewport.resolution !== void 0 ? !1 : this.props.binary;
    this.setState({
      binary: e,
      data: null,
      tileJSON: null,
      hoveredFeatureId: null,
      hoveredFeatureLayerName: null
    });
  }
  get isLoaded() {
    return !!(this.state?.data && super.isLoaded);
  }
  updateState({ props: e, oldProps: t, context: n, changeFlags: i }) {
    i.dataChanged && this._updateTileData(), this.state?.data && (super.updateState({ props: e, oldProps: t, context: n, changeFlags: i }), this._setWGS84PropertyForTiles());
    const { highlightColor: s } = e;
    s !== t.highlightColor && Array.isArray(s) && this.setState({ highlightColor: s });
  }
  /* eslint-disable complexity */
  async _updateTileData() {
    let e = this.props.data, t = null;
    if (typeof e == "string" && !hfe(e)) {
      const { onDataLoad: n, fetch: i } = this.props;
      this.setState({ data: null, tileJSON: null });
      try {
        t = await i(e, { propName: "data", layer: this, loaders: [] });
      } catch (s) {
        this.raiseError(s, "loading TileJSON"), e = null;
      }
      n && n(t, { propName: "data", layer: this });
    } else e && typeof e == "object" && "tilejson" in e && (t = e);
    t && (e = t.tiles), this.setState({ data: e, tileJSON: t });
  }
  _getTilesetOptions() {
    const e = super._getTilesetOptions(), t = this.state.tileJSON, { minZoom: n, maxZoom: i } = this.props;
    return t && (Number.isFinite(t.minzoom) && t.minzoom > n && (e.minZoom = t.minzoom), Number.isFinite(t.maxzoom) && (!Number.isFinite(i) || t.maxzoom < i) && (e.maxZoom = t.maxzoom)), e;
  }
  /* eslint-disable complexity */
  renderLayers() {
    return this.state?.data ? super.renderLayers() : null;
  }
  getTileData(e) {
    const { data: t, binary: n } = this.state, { index: i, signal: s } = e, o = ch(t, e);
    if (!o)
      return Promise.reject("Invalid URL");
    let l = this.getLoadOptions();
    const { fetch: u } = this.props;
    return l = {
      ...l,
      mimeType: "application/x-protobuf",
      mvt: {
        ...l?.mvt,
        coordinates: this.context.viewport.resolution ? "wgs84" : "local",
        tileIndex: i
        // Local worker debug
        // workerUrl: `modules/mvt/dist/mvt-loader.worker.js`
        // Set worker to null to skip web workers
        // workerUrl: null
      },
      gis: n ? { format: "binary" } : {}
    }, u(o, { propName: "data", layer: this, loadOptions: l, signal: s });
  }
  renderSubLayers(e) {
    const { x: t, y: n, z: i } = e.tile.index, s = Math.pow(2, i), o = lb / s, l = -o, u = lb * t / s, m = lb * (1 - n / s), y = new xn().scale([o, l, 1]);
    e.autoHighlight = !1, this.context.viewport.resolution || (e.modelMatrix = y, e.coordinateOrigin = [u, m, 0], e.coordinateSystem = rn.CARTESIAN, e.extensions = [...e.extensions || [], new _y()]);
    const E = super.renderSubLayers(e);
    return this.state.binary && !(E instanceof iu) && Jr.warn("renderSubLayers() must return GeoJsonLayer when using binary:true")(), E;
  }
  _updateAutoHighlight(e) {
    const { uniqueIdProperty: t } = this.props, { hoveredFeatureId: n, hoveredFeatureLayerName: i } = this.state, s = e.object;
    let o = null, l = null;
    s && (o = cb(s, t), l = jR(s));
    let { highlightColor: u } = this.props;
    typeof u == "function" && (u = u(e)), (n !== o || i !== l) && this.setState({
      highlightColor: u,
      hoveredFeatureId: o,
      hoveredFeatureLayerName: l
    });
  }
  _isWGS84() {
    return !!this.context.viewport.resolution;
  }
  getPickingInfo(e) {
    const t = super.getPickingInfo(e);
    if (this.state.binary && t.index !== -1) {
      const { data: n } = e.sourceLayer.props;
      t.object = V2(n, {
        globalFeatureId: t.index
      });
    }
    return t.object && !this._isWGS84() && (t.object = GR(
      t.object,
      t.tile.bbox,
      // eslint-disable-line
      this.context.viewport
    )), t;
  }
  getSubLayerPropsByTile(e) {
    return {
      highlightedObjectIndex: this.getHighlightedObjectIndex(e),
      highlightColor: this.state.highlightColor
    };
  }
  getHighlightedObjectIndex(e) {
    const { hoveredFeatureId: t, hoveredFeatureLayerName: n, binary: i } = this.state, { uniqueIdProperty: s, highlightedFeatureId: o } = this.props, l = e.content, u = HR(o);
    if (!(HR(t) || u))
      return -1;
    const y = u ? o : t;
    return Array.isArray(l) ? l.findIndex((E) => {
      const P = cb(E, s) === y, L = u || jR(E) === n;
      return P && L;
    }) : l && i ? PAe(l, s, y, u ? "" : n) : -1;
  }
  _pickObjects(e) {
    const { deck: t, viewport: n } = this.context, i = n.width, s = n.height, o = n.x, l = n.y, u = [this.id];
    return t.pickObjects({ x: o, y: l, width: i, height: s, layerIds: u, maxObjects: e });
  }
  /** Get the rendered features in the current viewport. */
  getRenderedFeatures(e = null) {
    const t = this._pickObjects(e), n = /* @__PURE__ */ new Set(), i = [];
    for (const s of t) {
      const o = cb(s.object, this.props.uniqueIdProperty);
      o === void 0 ? i.push(s.object) : n.has(o) || (n.add(o), i.push(s.object));
    }
    return i;
  }
  _setWGS84PropertyForTiles() {
    const e = "dataInWGS84";
    this.state.tileset.selectedTiles.forEach((n) => {
      n.hasOwnProperty(e) || Object.defineProperty(n, e, {
        get: () => {
          if (!n.content)
            return null;
          if (this.state.binary && Array.isArray(n.content) && !n.content.length)
            return [];
          const { bbox: i } = n;
          if (n._contentWGS84 === void 0 && dfe(i)) {
            const s = this.state.binary ? V2(n.content) : n.content;
            n._contentWGS84 = s.map((o) => GR(o, i, this.context.viewport));
          }
          return n._contentWGS84;
        }
      });
    });
  }
}
Np.layerName = "MVTLayer";
Np.defaultProps = OAe;
function cb(r, e) {
  if (r.properties && e)
    return r.properties[e];
  if ("id" in r)
    return r.id;
}
function jR(r) {
  return r.properties?.layerName || null;
}
function HR(r) {
  return r != null && r !== "";
}
function GR(r, e, t) {
  const n = {
    ...r,
    geometry: {
      type: r.geometry.type
    }
  };
  return Object.defineProperty(n.geometry, "coordinates", {
    get: () => SAe(r.geometry, e, t).coordinates
  }), n;
}
const WR = "0123456789bcdefghjkmnpqrstuvwxyz", Jk = {};
for (let r = 0; r < WR.length; r++)
  Jk[WR.charAt(r)] = r;
const DAe = -90, LAe = 90, kAe = -180, FAe = 180;
function NAe(r) {
  let e = !0, t = LAe, n = DAe, i = FAe, s = kAe, o, l = 0;
  for (let u = 0, m = r.length; u < m; u++) {
    const y = r[u].toLowerCase();
    l = Jk[y];
    for (let E = 4; E >= 0; E--) {
      const P = l >> E & 1;
      e ? (o = (i + s) / 2, P === 1 ? s = o : i = o) : (o = (t + n) / 2, P === 1 ? n = o : t = o), e = !e;
    }
  }
  return [n, s, t, i];
}
function UAe(r) {
  const [e, t, n, i] = NAe(r);
  return [i, n, i, e, t, e, t, n, i, n];
}
const zAe = {
  getGeohash: { type: "accessor", value: (r) => r.geohash }
};
class yy extends su {
  indexToBounds() {
    const { data: e, getGeohash: t } = this.props;
    return {
      data: e,
      _normalize: !1,
      positionFormat: "XY",
      getPolygon: (n, i) => UAe(t(n, i))
    };
  }
}
yy.layerName = "GeohashLayer";
yy.defaultProps = zAe;
const VAe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  A5Layer: Nw,
  GeohashLayer: yy,
  GreatCircleLayer: jw,
  H3ClusterLayer: py,
  H3HexagonLayer: pc,
  MVTLayer: Np,
  QuadkeyLayer: uy,
  S2Layer: cy,
  TerrainLayer: iT,
  Tile3DLayer: nT,
  TileLayer: ou,
  TripsLayer: dy,
  _GeoCellLayer: su,
  _Tile2DHeader: nk,
  _Tileset2D: hy,
  _WMSLayer: Vw,
  _getURLFromTemplate: ch
}, Symbol.toStringTag, { value: "Module" }));
function jAe({ pointCount: r, getBinId: e }) {
  const t = /* @__PURE__ */ new Map();
  for (let n = 0; n < r; n++) {
    const i = e(n);
    if (i === null)
      continue;
    let s = t.get(String(i));
    s ? s.points.push(n) : (s = {
      id: i,
      index: t.size,
      points: [n]
    }, t.set(String(i), s));
  }
  return Array.from(t.values());
}
function HAe({ bins: r, dimensions: e, target: t }) {
  const n = r.length * e;
  (!t || t.length < n) && (t = new Float32Array(n));
  for (let i = 0; i < r.length; i++) {
    const { id: s } = r[i];
    Array.isArray(s) ? t.set(s, i * e) : t[i] = s;
  }
  return t;
}
const GAe = (r) => r.length, eF = (r, e) => {
  let t = 0;
  for (const n of r)
    t += e(n);
  return t;
}, WAe = (r, e) => r.length === 0 ? NaN : eF(r, e) / r.length, $Ae = (r, e) => {
  let t = 1 / 0;
  for (const n of r) {
    const i = e(n);
    i < t && (t = i);
  }
  return t;
}, qAe = (r, e) => {
  let t = -1 / 0;
  for (const n of r) {
    const i = e(n);
    i > t && (t = i);
  }
  return t;
}, XAe = {
  COUNT: GAe,
  SUM: eF,
  MEAN: WAe,
  MIN: $Ae,
  MAX: qAe
};
function ZAe({ bins: r, getValue: e, operation: t, target: n }) {
  (!n || n.length < r.length) && (n = new Float32Array(r.length));
  let i = 1 / 0, s = -1 / 0;
  for (let o = 0; o < r.length; o++) {
    const { points: l } = r[o];
    n[o] = t(l, e), n[o] < i && (i = n[o]), n[o] > s && (s = n[o]);
  }
  return { value: n, domain: [i, s] };
}
function $R(r, e, t) {
  const n = {};
  for (const s of r.sources || []) {
    const o = e[s];
    if (o)
      n[s] = YAe(o);
    else
      throw new Error(`Cannot find attribute ${s}`);
  }
  const i = {};
  return (s) => {
    for (const o in n)
      i[o] = n[o](s);
    return r.getValue(i, s, t);
  };
}
function YAe(r) {
  const e = r.value, { offset: t = 0, stride: n, size: i } = r.getAccessor(), s = e.BYTES_PER_ELEMENT, o = t / s, l = n ? n / s : i;
  if (i === 1)
    return r.isConstant ? () => e[0] : (m) => {
      const y = o + l * m;
      return e[y];
    };
  let u;
  return r.isConstant ? (u = Array.from(e), () => u) : (u = new Array(i), (m) => {
    const y = o + l * m;
    for (let E = 0; E < i; E++)
      u[E] = e[y + E];
    return u;
  });
}
class Up {
  constructor(e) {
    this.bins = [], this.binIds = null, this.results = [], this.dimensions = e.dimensions, this.channelCount = e.getValue.length, this.props = {
      ...e,
      binOptions: {},
      pointCount: 0,
      operations: [],
      customOperations: [],
      attributes: {}
    }, this.needsUpdate = !0, this.setProps(e);
  }
  destroy() {
  }
  get binCount() {
    return this.bins.length;
  }
  /** Update aggregation props */
  // eslint-disable-next-line complexity
  setProps(e) {
    const t = this.props;
    if (e.binOptions && (Fi(e.binOptions, t.binOptions, 2) || this.setNeedsUpdate()), e.operations)
      for (let n = 0; n < this.channelCount; n++)
        e.operations[n] !== t.operations[n] && this.setNeedsUpdate(n);
    if (e.customOperations)
      for (let n = 0; n < this.channelCount; n++)
        !!e.customOperations[n] != !!t.customOperations[n] && this.setNeedsUpdate(n);
    e.pointCount !== void 0 && e.pointCount !== t.pointCount && this.setNeedsUpdate(), e.attributes && (e.attributes = { ...t.attributes, ...e.attributes }), Object.assign(this.props, e);
  }
  /** Flags a channel to need update
   * This is called internally by setProps() if certain props change
   * Users of this class still need to manually set the dirty flag sometimes, because even if no props changed
   * the underlying buffers could have been updated and require rerunning the aggregation
   * @param {number} channel - mark the given channel as dirty. If not provided, all channels will be updated.
   */
  setNeedsUpdate(e) {
    e === void 0 ? this.needsUpdate = !0 : this.needsUpdate !== !0 && (this.needsUpdate = this.needsUpdate || [], this.needsUpdate[e] = !0);
  }
  /** Run aggregation */
  update() {
    if (this.needsUpdate === !0) {
      this.bins = jAe({
        pointCount: this.props.pointCount,
        getBinId: $R(this.props.getBin, this.props.attributes, this.props.binOptions)
      });
      const e = HAe({
        bins: this.bins,
        dimensions: this.dimensions,
        // Reuse allocated typed array
        target: this.binIds?.value
      });
      this.binIds = { value: e, type: "float32", size: this.dimensions };
    }
    for (let e = 0; e < this.channelCount; e++)
      if (this.needsUpdate === !0 || this.needsUpdate[e]) {
        const t = this.props.customOperations[e] || XAe[this.props.operations[e]], { value: n, domain: i } = ZAe({
          bins: this.bins,
          getValue: $R(this.props.getValue[e], this.props.attributes, void 0),
          operation: t,
          // Reuse allocated typed array
          target: this.results[e]?.value
        });
        this.results[e] = { value: n, domain: i, type: "float32", size: 1 }, this.props.onUpdate?.({ channel: e });
      }
    this.needsUpdate = !1;
  }
  preDraw() {
  }
  /** Returns an accessor to the bins. */
  getBins() {
    return this.binIds;
  }
  /** Returns an accessor to the output for a given channel. */
  getResult(e) {
    return this.results[e];
  }
  /** Returns the [min, max] of aggregated values for a given channel. */
  getResultDomain(e) {
    return this.results[e]?.domain ?? [1 / 0, -1 / 0];
  }
  /** Returns the information for a given bin. */
  getBin(e) {
    const t = this.bins[e];
    if (!t)
      return null;
    const n = new Array(this.channelCount);
    for (let i = 0; i < n.length; i++) {
      const s = this.results[i];
      n[i] = s?.value[e];
    }
    return {
      id: t.id,
      value: n,
      count: t.points.length,
      pointIndices: t.points
    };
  }
}
function tF(r, e, t) {
  return r.createFramebuffer({
    width: e,
    height: t,
    colorAttachments: [
      r.createTexture({
        width: e,
        height: t,
        format: "rgba32float",
        sampler: {
          minFilter: "nearest",
          magFilter: "nearest"
        }
      })
    ]
  });
}
const KAe = (
  /* glsl */
  `uniform binSorterUniforms {
  ivec4 binIdRange;
  ivec2 targetSize;
} binSorter;
`
), QAe = {
  name: "binSorter",
  vs: KAe,
  uniformTypes: {
    binIdRange: "vec4<i32>",
    targetSize: "vec2<i32>"
  }
}, rF = [1, 2, 4, 8], qR = 3e38, JAe = { SUM: 0, MEAN: 0, MIN: 0, MAX: 0, COUNT: 0 }, zm = 1024;
class e0e {
  constructor(e, t) {
    this.binsFBO = null, this.device = e, this.model = r0e(e, t);
  }
  get texture() {
    return this.binsFBO ? this.binsFBO.colorAttachments[0].texture : null;
  }
  destroy() {
    this.model.destroy(), this.binsFBO?.colorAttachments[0].texture.destroy(), this.binsFBO?.destroy();
  }
  getBinValues(e) {
    if (!this.binsFBO)
      return null;
    const t = e % zm, n = Math.floor(e / zm), i = this.device.readPixelsToArrayWebGL(this.binsFBO, {
      sourceX: t,
      sourceY: n,
      sourceWidth: 1,
      sourceHeight: 1
    }).buffer;
    return new Float32Array(i);
  }
  setDimensions(e, t) {
    const n = zm, i = Math.ceil(e / n);
    this.binsFBO ? this.binsFBO.height < i && this.binsFBO.resize({ width: n, height: i }) : this.binsFBO = tF(this.device, n, i);
    const s = {
      binIdRange: [
        t[0][0],
        t[0][1],
        t[1]?.[0] || 0,
        t[1]?.[1] || 0
      ],
      targetSize: [this.binsFBO.width, this.binsFBO.height]
    };
    this.model.shaderInputs.setProps({ binSorter: s });
  }
  setModelProps(e) {
    const t = this.model;
    e.attributes && t.setAttributes(e.attributes), e.constantAttributes && t.setConstantAttributes(e.constantAttributes), e.vertexCount !== void 0 && t.setVertexCount(e.vertexCount), e.shaderModuleProps && t.shaderInputs.setProps(e.shaderModuleProps);
  }
  /** Update aggregation */
  update(e) {
    if (!this.binsFBO)
      return;
    const t = t0e(e);
    this._updateBins("SUM", t.SUM + t.MEAN), this._updateBins("MIN", t.MIN), this._updateBins("MAX", t.MAX);
  }
  /** Recalculate aggregation on the given channels using the given operation */
  _updateBins(e, t) {
    if (t === 0)
      return;
    t |= rF[3];
    const n = this.model, i = this.binsFBO, s = e === "MAX" ? -qR : e === "MIN" ? qR : 0, o = this.device.beginRenderPass({
      id: `gpu-aggregation-${e}`,
      framebuffer: i,
      parameters: {
        viewport: [0, 0, i.width, i.height],
        colorMask: t
      },
      clearColor: [s, s, s, 0],
      clearDepth: !1,
      clearStencil: !1
    });
    n.setParameters({
      blend: !0,
      blendColorSrcFactor: "one",
      blendColorDstFactor: "one",
      blendAlphaSrcFactor: "one",
      blendAlphaDstFactor: "one",
      blendColorOperation: e === "MAX" ? "max" : e === "MIN" ? "min" : "add",
      blendAlphaOperation: "add"
    }), n.draw(o), o.end();
  }
}
function t0e(r) {
  const e = { ...JAe };
  for (let t = 0; t < r.length; t++) {
    const n = r[t];
    n && (e[n] += rF[t]);
  }
  return e;
}
function r0e(r, e) {
  let t = e.vs;
  e.dimensions === 2 && (t += /* glsl */
  `
void getBin(out int binId) {
  ivec2 binId2;
  getBin(binId2);
  if (binId2.x < binSorter.binIdRange.x || binId2.x >= binSorter.binIdRange.y) {
    binId = -1;
  } else {
    binId = (binId2.y - binSorter.binIdRange.z) * (binSorter.binIdRange.y - binSorter.binIdRange.x) + binId2.x;
  }
}
`);
  const n = `#version 300 es
#define SHADER_NAME gpu-aggregation-sort-bins-vertex

${t}

out vec3 v_Value;

void main() {
  int binIndex;
  getBin(binIndex);
  binIndex = binIndex - binSorter.binIdRange.x;
  if (binIndex < 0) {
    gl_Position = vec4(0.);
    return;
  }
  int row = binIndex / binSorter.targetSize.x;
  int col = binIndex - row * binSorter.targetSize.x;
  vec2 position = (vec2(col, row) + 0.5) / vec2(binSorter.targetSize) * 2.0 - 1.0;
  gl_Position = vec4(position, 0.0, 1.0);
  gl_PointSize = 1.0;

#if NUM_CHANNELS == 3
  getValue(v_Value);
#elif NUM_CHANNELS == 2
  getValue(v_Value.xy);
#else
  getValue(v_Value.x);
#endif
}
`, i = (
    /* glsl */
    `#version 300 es
#define SHADER_NAME gpu-aggregation-sort-bins-fragment

precision highp float;

in vec3 v_Value;
out vec4 fragColor;

void main() {
  fragColor.xyz = v_Value;

  #ifdef MODULE_GEOMETRY
  geometry.uv = vec2(0.);
  DECKGL_FILTER_COLOR(fragColor, geometry);
  #endif

  fragColor.w = 1.0;
}
`
  );
  return new Bi(r, {
    bufferLayout: e.bufferLayout,
    modules: [...e.modules || [], QAe],
    // @ts-expect-error TODO fix luma type
    defines: { ...e.defines, NON_INSTANCED_MODEL: 1, NUM_CHANNELS: e.channelCount },
    isInstanced: !1,
    vs: n,
    fs: i,
    topology: "point-list",
    disableWarnings: !0
  });
}
const n0e = (
  /* glsl */
  `uniform aggregatorTransformUniforms {
  ivec4 binIdRange;
  bvec3 isCount;
  bvec3 isMean;
  float naN;
} aggregatorTransform;
`
), i0e = {
  name: "aggregatorTransform",
  vs: n0e,
  uniformTypes: {
    binIdRange: "vec4<i32>",
    isCount: "vec3<f32>",
    isMean: "vec3<f32>"
  }
};
class s0e {
  constructor(e, t) {
    this.binBuffer = null, this.valueBuffer = null, this._domains = null, this.device = e, this.channelCount = t.channelCount, this.transform = o0e(e, t), this.domainFBO = tF(e, 2, 1);
  }
  destroy() {
    this.transform.destroy(), this.binBuffer?.destroy(), this.valueBuffer?.destroy(), this.domainFBO.colorAttachments[0].texture.destroy(), this.domainFBO.destroy();
  }
  get domains() {
    if (!this._domains) {
      const e = this.device.readPixelsToArrayWebGL(this.domainFBO).buffer, t = new Float32Array(e);
      this._domains = [
        [-t[4], t[0]],
        [-t[5], t[1]],
        [-t[6], t[2]]
      ].slice(0, this.channelCount);
    }
    return this._domains;
  }
  setDimensions(e, t) {
    const { model: n, transformFeedback: i } = this.transform;
    n.setVertexCount(e);
    const s = {
      binIdRange: [
        t[0][0],
        t[0][1],
        t[1]?.[0] || 0,
        t[1]?.[1] || 0
      ]
    };
    n.shaderInputs.setProps({ aggregatorTransform: s });
    const o = e * t.length * 4;
    (!this.binBuffer || this.binBuffer.byteLength < o) && (this.binBuffer?.destroy(), this.binBuffer = this.device.createBuffer({ byteLength: o }), i.setBuffer("binIds", this.binBuffer));
    const l = e * this.channelCount * 4;
    (!this.valueBuffer || this.valueBuffer.byteLength < l) && (this.valueBuffer?.destroy(), this.valueBuffer = this.device.createBuffer({ byteLength: l }), i.setBuffer("values", this.valueBuffer));
  }
  update(e, t) {
    if (!e)
      return;
    const n = this.transform, i = this.domainFBO, s = [0, 1, 2].map((u) => t[u] === "COUNT" ? 1 : 0), o = [0, 1, 2].map((u) => t[u] === "MEAN" ? 1 : 0), l = {
      isCount: s,
      isMean: o,
      bins: e
    };
    n.model.shaderInputs.setProps({ aggregatorTransform: l }), n.run({
      id: "gpu-aggregation-domain",
      framebuffer: i,
      parameters: {
        viewport: [0, 0, 2, 1]
      },
      clearColor: [-3e38, -3e38, -3e38, 0],
      clearDepth: !1,
      clearStencil: !1
    }), this._domains = null;
  }
}
function o0e(r, e) {
  const t = (
    /* glsl */
    `#version 300 es
#define SHADER_NAME gpu-aggregation-domain-vertex

uniform sampler2D bins;

#if NUM_DIMS == 1
out float binIds;
#else
out vec2 binIds;
#endif

#if NUM_CHANNELS == 1
flat out float values;
#elif NUM_CHANNELS == 2
flat out vec2 values;
#else
flat out vec3 values;
#endif

const float NAN = intBitsToFloat(-1);

void main() {
  int row = gl_VertexID / SAMPLER_WIDTH;
  int col = gl_VertexID - row * SAMPLER_WIDTH;
  vec4 weights = texelFetch(bins, ivec2(col, row), 0);
  vec3 value3 = mix(
    mix(weights.rgb, vec3(weights.a), aggregatorTransform.isCount),
    weights.rgb / max(weights.a, 1.0),
    aggregatorTransform.isMean
  );
  if (weights.a == 0.0) {
    value3 = vec3(NAN);
  }

#if NUM_DIMS == 1
  binIds = float(gl_VertexID + aggregatorTransform.binIdRange.x);
#else
  int y = gl_VertexID / (aggregatorTransform.binIdRange.y - aggregatorTransform.binIdRange.x);
  int x = gl_VertexID - y * (aggregatorTransform.binIdRange.y - aggregatorTransform.binIdRange.x);
  binIds.y = float(y + aggregatorTransform.binIdRange.z);
  binIds.x = float(x + aggregatorTransform.binIdRange.x);
#endif

#if NUM_CHANNELS == 3
  values = value3;
#elif NUM_CHANNELS == 2
  values = value3.xy;
#else
  values = value3.x;
#endif

  gl_Position = vec4(0., 0., 0., 1.);
  // This model renders into a 2x1 texture to obtain min and max simultaneously.
  // See comments in fragment shader
  gl_PointSize = 2.0;
}
`
  ), n = (
    /* glsl */
    `#version 300 es
#define SHADER_NAME gpu-aggregation-domain-fragment

precision highp float;

#if NUM_CHANNELS == 1
flat in float values;
#elif NUM_CHANNELS == 2
flat in vec2 values;
#else
flat in vec3 values;
#endif

out vec4 fragColor;

void main() {
  vec3 value3;
#if NUM_CHANNELS == 3
  value3 = values;
#elif NUM_CHANNELS == 2
  value3.xy = values;
#else
  value3.x = values;
#endif
  if (isnan(value3.x)) discard;
  // This shader renders into a 2x1 texture with blending=max
  // The left pixel yields the max value of each channel
  // The right pixel yields the min value of each channel
  if (gl_FragCoord.x < 1.0) {
    fragColor = vec4(value3, 1.0);
  } else {
    fragColor = vec4(-value3, 1.0);
  }
}
`
  );
  return new ih(r, {
    vs: t,
    fs: n,
    topology: "point-list",
    modules: [i0e],
    parameters: {
      blend: !0,
      blendColorSrcFactor: "one",
      blendColorDstFactor: "one",
      blendColorOperation: "max",
      blendAlphaSrcFactor: "one",
      blendAlphaDstFactor: "one",
      blendAlphaOperation: "max"
    },
    defines: {
      // @ts-expect-error TODO fix luma type
      NUM_DIMS: e.dimensions,
      // @ts-expect-error TODO fix luma type
      NUM_CHANNELS: e.channelCount,
      // @ts-expect-error TODO fix luma type
      SAMPLER_WIDTH: zm
    },
    varyings: ["binIds", "values"],
    disableWarnings: !0
  });
}
class La {
  /** Checks if the current device supports GPU aggregation */
  static isSupported(e) {
    return e.features.has("float32-renderable-webgl") && e.features.has("texture-blend-float-webgl");
  }
  constructor(e, t) {
    this.binCount = 0, this.binIds = null, this.results = [], this.device = e, this.dimensions = t.dimensions, this.channelCount = t.channelCount, this.props = {
      ...t,
      pointCount: 0,
      binIdRange: [[0, 0]],
      operations: [],
      attributes: {},
      binOptions: {}
    }, this.needsUpdate = new Array(this.channelCount).fill(!0), this.binSorter = new e0e(e, t), this.aggregationTransform = new s0e(e, t), this.setProps(t);
  }
  getBins() {
    const e = this.aggregationTransform.binBuffer;
    return e ? (this.binIds?.buffer !== e && (this.binIds = { buffer: e, type: "float32", size: this.dimensions }), this.binIds) : null;
  }
  /** Returns an accessor to the output for a given channel. */
  getResult(e) {
    const t = this.aggregationTransform.valueBuffer;
    return !t || e >= this.channelCount ? null : (this.results[e]?.buffer !== t && (this.results[e] = {
      buffer: t,
      type: "float32",
      size: 1,
      stride: this.channelCount * 4,
      offset: e * 4
    }), this.results[e]);
  }
  /** Returns the [min, max] of aggregated values for a given channel. */
  getResultDomain(e) {
    return this.aggregationTransform.domains[e];
  }
  /** Returns the information for a given bin. */
  getBin(e) {
    if (e < 0 || e >= this.binCount)
      return null;
    const { binIdRange: t } = this.props;
    let n;
    if (this.dimensions === 1)
      n = [e + t[0][0]];
    else {
      const [[l, u], [m]] = t, y = u - l;
      n = [e % y + l, Math.floor(e / y) + m];
    }
    const i = this.binSorter.getBinValues(e);
    if (!i)
      return null;
    const s = i[3], o = [];
    for (let l = 0; l < this.channelCount; l++) {
      const u = this.props.operations[l];
      u === "COUNT" ? o[l] = s : s === 0 ? o[l] = NaN : o[l] = u === "MEAN" ? i[l] / s : i[l];
    }
    return { id: n, value: o, count: s };
  }
  /** Release GPU resources */
  destroy() {
    this.binSorter.destroy(), this.aggregationTransform.destroy();
  }
  /** Update aggregation props. Normalize prop values and set change flags. */
  // eslint-disable-next-line complexity, max-statements
  setProps(e) {
    const t = this.props;
    if ("binIdRange" in e && !Fi(e.binIdRange, t.binIdRange, 2)) {
      const n = e.binIdRange;
      if (Jr.assert(n.length === this.dimensions), this.dimensions === 1) {
        const [[i, s]] = n;
        this.binCount = s - i;
      } else {
        const [[i, s], [o, l]] = n;
        this.binCount = (s - i) * (l - o);
      }
      this.binSorter.setDimensions(this.binCount, n), this.aggregationTransform.setDimensions(this.binCount, n), this.setNeedsUpdate();
    }
    if (e.operations)
      for (let n = 0; n < this.channelCount; n++)
        e.operations[n] !== t.operations[n] && this.setNeedsUpdate(n);
    if (e.pointCount !== void 0 && e.pointCount !== t.pointCount && (this.binSorter.setModelProps({ vertexCount: e.pointCount }), this.setNeedsUpdate()), e.binOptions && (Fi(e.binOptions, t.binOptions, 2) || this.setNeedsUpdate(), this.binSorter.model.shaderInputs.setProps({ binOptions: e.binOptions })), e.attributes) {
      const n = {}, i = {};
      for (const s of Object.values(e.attributes))
        for (const [o, l] of Object.entries(s.getValue()))
          ArrayBuffer.isView(l) ? i[o] = l : l && (n[o] = l);
      this.binSorter.setModelProps({ attributes: n, constantAttributes: i });
    }
    e.shaderModuleProps && this.binSorter.setModelProps({ shaderModuleProps: e.shaderModuleProps }), Object.assign(this.props, e);
  }
  /** Flags a channel to need update.
   * This is called internally by setProps() if certain props change
   * Users of this class still need to manually set the dirty flag sometimes, because even if no props changed
   * the underlying buffers could have been updated and require rerunning the aggregation
   * @param {number} channel - mark the given channel as dirty. If not provided, all channels will be updated.
   */
  setNeedsUpdate(e) {
    e === void 0 ? this.needsUpdate.fill(!0) : this.needsUpdate[e] = !0;
  }
  update() {
  }
  /** Run aggregation */
  preDraw() {
    if (!this.needsUpdate.some(Boolean))
      return;
    const { operations: e } = this.props, t = this.needsUpdate.map((n, i) => n ? e[i] : null);
    this.binSorter.update(t), this.aggregationTransform.update(this.binSorter.texture, e);
    for (let n = 0; n < this.channelCount; n++)
      this.needsUpdate[n] && (this.needsUpdate[n] = !1, this.props.onUpdate?.({ channel: n }));
  }
}
let zp = class extends Ps {
  /** Allow this layer to participates in the draw cycle */
  get isDrawable() {
    return !0;
  }
  initializeState() {
    this.getAttributeManager().remove(["instancePickingColors"]);
  }
  // Extend Layer.updateState to update the Aggregator instance
  // returns true if aggregator is changed
  updateState(e) {
    super.updateState(e);
    const t = this.getAggregatorType();
    if (e.changeFlags.extensionsChanged || this.state.aggregatorType !== t) {
      this.state.aggregator?.destroy();
      const n = this.createAggregator(t);
      return n.setProps({
        attributes: this.getAttributeManager()?.attributes
      }), this.setState({ aggregator: n, aggregatorType: t }), !0;
    }
    return !1;
  }
  // Override Layer.finalizeState to dispose the Aggregator instance
  finalizeState(e) {
    super.finalizeState(e), this.state.aggregator.destroy();
  }
  // Override Layer.updateAttributes to update the aggregator
  updateAttributes(e) {
    const { aggregator: t } = this.state;
    t.setProps({
      attributes: e
    });
    for (const n in e)
      this.onAttributeChange(n);
    t.update();
  }
  draw({ shaderModuleProps: e }) {
    const { aggregator: t } = this.state;
    t.setProps({ shaderModuleProps: e }), t.preDraw();
  }
  // override CompositeLayer._getAttributeManager to create AttributeManager instance
  _getAttributeManager() {
    return new j_(this.context.device, {
      id: this.props.id,
      stats: this.context.stats
    });
  }
};
zp.layerName = "AggregationLayer";
const vy = [
  [255, 255, 178],
  [254, 217, 118],
  [254, 178, 76],
  [253, 141, 60],
  [240, 59, 32],
  [189, 0, 38]
];
function nF(r, e = !1, t = Float32Array) {
  let n;
  if (Number.isFinite(r[0]))
    n = new t(r);
  else {
    n = new t(r.length * 4);
    let i = 0;
    for (let s = 0; s < r.length; s++) {
      const o = r[s];
      n[i++] = o[0], n[i++] = o[1], n[i++] = o[2], n[i++] = Number.isFinite(o[3]) ? o[3] : 255;
    }
  }
  if (e)
    for (let i = 0; i < n.length; i++)
      n[i] /= 255;
  return n;
}
const C_ = {
  linear: "linear",
  quantile: "nearest",
  quantize: "nearest",
  ordinal: "nearest"
};
function aT(r, e) {
  r.setSampler({
    minFilter: C_[e],
    magFilter: C_[e]
  });
}
function lT(r, e, t = "linear") {
  const n = nF(e, !1, Uint8Array);
  return r.createTexture({
    format: "rgba8unorm",
    sampler: {
      minFilter: C_[t],
      magFilter: C_[t],
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    },
    data: n,
    width: n.length / 4,
    height: 1
  });
}
const a0e = (
  /* glsl */
  `#version 300 es
#define SHADER_NAME screen-grid-layer-vertex-shader
#define RANGE_COUNT 6
in vec2 positions;
in vec2 instancePositions;
in float instanceWeights;
in vec3 instancePickingColors;
uniform sampler2D colorRange;
out vec4 vColor;
vec4 interp(float value, vec2 domain, sampler2D range) {
float r = (value - domain.x) / (domain.y - domain.x);
return texture(range, vec2(r, 0.5));
}
void main(void) {
if (isnan(instanceWeights)) {
gl_Position = vec4(0.);
return;
}
vec2 pos = instancePositions * screenGrid.gridSizeClipspace + positions * screenGrid.cellSizeClipspace;
pos.x = pos.x - 1.0;
pos.y = 1.0 - pos.y;
gl_Position = vec4(pos, 0., 1.);
vColor = interp(instanceWeights, screenGrid.colorDomain, colorRange);
vColor.a *= layer.opacity;
picking_setPickingColor(instancePickingColors);
}
`
), l0e = (
  /* glsl */
  `#version 300 es
#define SHADER_NAME screen-grid-layer-fragment-shader
precision highp float;
in vec4 vColor;
out vec4 fragColor;
void main(void) {
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`
), c0e = (
  /* glsl */
  `uniform screenGridUniforms {
  vec2 cellSizeClipspace;
  vec2 gridSizeClipspace;
  vec2 colorDomain;
} screenGrid;
`
), u0e = {
  name: "screenGrid",
  vs: c0e,
  uniformTypes: {
    cellSizeClipspace: "vec2<f32>",
    gridSizeClipspace: "vec2<f32>",
    colorDomain: "vec2<f32>"
  }
};
class iF extends Is {
  getShaders() {
    return super.getShaders({ vs: a0e, fs: l0e, modules: [ga, u0e] });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 2,
        type: "float32",
        accessor: "getBin"
      },
      instanceWeights: {
        size: 1,
        type: "float32",
        accessor: "getWeight"
      }
    }), this.state.model = this._getModel();
  }
  updateState(e) {
    super.updateState(e);
    const { props: t, oldProps: n, changeFlags: i } = e, s = this.state.model;
    if (n.colorRange !== t.colorRange) {
      this.state.colorTexture?.destroy(), this.state.colorTexture = lT(this.context.device, t.colorRange, t.colorScaleType);
      const o = { colorRange: this.state.colorTexture };
      s.shaderInputs.setProps({ screenGrid: o });
    } else n.colorScaleType !== t.colorScaleType && aT(this.state.colorTexture, t.colorScaleType);
    if (n.cellMarginPixels !== t.cellMarginPixels || n.cellSizePixels !== t.cellSizePixels || i.viewportChanged) {
      const { width: o, height: l } = this.context.viewport, { cellSizePixels: u, cellMarginPixels: m } = this.props, y = Math.max(u - m, 0), E = {
        gridSizeClipspace: [u / o * 2, u / l * 2],
        cellSizeClipspace: [y / o * 2, y / l * 2]
      };
      s.shaderInputs.setProps({ screenGrid: E });
    }
  }
  finalizeState(e) {
    super.finalizeState(e), this.state.colorTexture?.destroy();
  }
  draw({ uniforms: e }) {
    const t = this.props.colorDomain(), n = this.state.model, i = { colorDomain: t };
    n.shaderInputs.setProps({ screenGrid: i }), n.draw(this.context.renderPass);
  }
  // Private Methods
  _getModel() {
    return new Bi(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new no({
        topology: "triangle-strip",
        attributes: {
          positions: {
            value: new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]),
            size: 2
          }
        }
      }),
      isInstanced: !0
    });
  }
}
iF.layerName = "ScreenGridCellLayer";
const f0e = (
  /* glsl */
  `uniform binOptionsUniforms {
  float cellSizePixels;
} binOptions;
`
), h0e = {
  name: "binOptions",
  vs: f0e,
  uniformTypes: {
    cellSizePixels: "f32"
  }
}, d0e = {
  cellSizePixels: { type: "number", value: 100, min: 1 },
  cellMarginPixels: { type: "number", value: 2, min: 0 },
  colorRange: vy,
  colorScaleType: "linear",
  getPosition: { type: "accessor", value: (r) => r.position },
  getWeight: { type: "accessor", value: 1 },
  gpuAggregation: !0,
  aggregation: "SUM"
};
class cT extends zp {
  getAggregatorType() {
    return this.props.gpuAggregation && La.isSupported(this.context.device) ? "gpu" : "cpu";
  }
  createAggregator(e) {
    return e === "cpu" || !La.isSupported(this.context.device) ? new Up({
      dimensions: 2,
      getBin: {
        sources: ["positions"],
        getValue: ({ positions: t }, n, i) => {
          const s = this.context.viewport, o = s.project(t), l = i.cellSizePixels;
          return o[0] < 0 || o[0] >= s.width || o[1] < 0 || o[1] >= s.height ? null : [Math.floor(o[0] / l), Math.floor(o[1] / l)];
        }
      },
      getValue: [{ sources: ["counts"], getValue: ({ counts: t }) => t }]
    }) : new La(this.context.device, {
      dimensions: 2,
      channelCount: 1,
      bufferLayout: this.getAttributeManager().getBufferLayouts({ isInstanced: !1 }),
      ...super.getShaders({
        modules: [Ws, h0e],
        vs: `
  in vec3 positions;
  in vec3 positions64Low;
  in float counts;
  
  void getBin(out ivec2 binId) {
    vec4 pos = project_position_to_clipspace(positions, positions64Low, vec3(0.0));
    vec2 screenCoords = vec2(pos.x / pos.w + 1.0, 1.0 - pos.y / pos.w) / 2.0 * project.viewportSize / project.devicePixelRatio;
    vec2 gridCoords = floor(screenCoords / binOptions.cellSizePixels);
    binId = ivec2(gridCoords);
  }
  void getValue(out float weight) {
    weight = counts;
  }
  `
      })
    });
  }
  initializeState() {
    super.initializeState(), this.getAttributeManager().add({
      positions: {
        size: 3,
        accessor: "getPosition",
        type: "float64",
        fp64: this.use64bitPositions()
      },
      // this attribute is used in gpu aggregation path only
      counts: { size: 1, accessor: "getWeight" }
    });
  }
  shouldUpdateState({ changeFlags: e }) {
    return e.somethingChanged;
  }
  updateState(e) {
    const t = super.updateState(e), { props: n, oldProps: i, changeFlags: s } = e, { cellSizePixels: o, aggregation: l } = n;
    if (t || s.dataChanged || s.updateTriggersChanged || s.viewportChanged || l !== i.aggregation || o !== i.cellSizePixels) {
      const { width: u, height: m } = this.context.viewport, { aggregator: y } = this.state;
      y instanceof La && y.setProps({
        binIdRange: [
          [0, Math.ceil(u / o)],
          [0, Math.ceil(m / o)]
        ]
      }), y.setProps({
        pointCount: this.getNumInstances(),
        operations: [l],
        binOptions: {
          cellSizePixels: o
        }
      });
    }
    return s.viewportChanged && this.state.aggregator.setNeedsUpdate(), t;
  }
  onAttributeChange(e) {
    const { aggregator: t } = this.state;
    switch (e) {
      case "positions":
        t.setNeedsUpdate();
        break;
      case "counts":
        t.setNeedsUpdate(0);
        break;
    }
  }
  renderLayers() {
    const { aggregator: e } = this.state, t = this.getSubLayerClass("cells", iF), n = e.getBins(), i = e.getResult(0);
    return new t(this.props, this.getSubLayerProps({
      id: "cell-layer"
    }), {
      data: {
        length: e.binCount,
        attributes: {
          getBin: n,
          getWeight: i
        }
      },
      // Data has changed shallowly, but we likely don't need to update the attributes
      dataComparator: (s, o) => s.length === o.length,
      updateTriggers: {
        getBin: [n],
        getWeight: [i]
      },
      parameters: {
        depthWriteEnabled: !1,
        ...this.props.parameters
      },
      // Evaluate domain at draw() time
      colorDomain: () => this.props.colorDomain || e.getResultDomain(0),
      // Extensions are already handled by the GPUAggregator, do not pass it down
      extensions: []
    });
  }
  getPickingInfo(e) {
    const t = e.info, { index: n } = t;
    if (n >= 0) {
      const i = this.state.aggregator.getBin(n);
      let s;
      i && (s = {
        col: i.id[0],
        row: i.id[1],
        value: i.value[0],
        count: i.count
      }, i.pointIndices && (s.pointIndices = i.pointIndices, s.points = Array.isArray(this.props.data) ? i.pointIndices.map((o) => this.props.data[o]) : [])), t.object = s;
    }
    return t;
  }
}
cT.layerName = "ScreenGridLayer";
cT.defaultProps = d0e;
class S_ {
  constructor(e, t) {
    this.props = {
      scaleType: "linear",
      lowerPercentile: 0,
      upperPercentile: 100
    }, this.domain = null, this.cutoff = null, this.input = e, this.inputLength = t, this.attribute = e;
  }
  getScalePercentile() {
    if (!this._percentile) {
      const e = XR(this.input, this.inputLength);
      this._percentile = A0e(e);
    }
    return this._percentile;
  }
  getScaleOrdinal() {
    if (!this._ordinal) {
      const e = XR(this.input, this.inputLength);
      this._ordinal = p0e(e);
    }
    return this._ordinal;
  }
  /** Returns the [lowerCutoff, upperCutoff] of scaled values, or null if not applicable */
  getCutoff({ scaleType: e, lowerPercentile: t, upperPercentile: n }) {
    if (e === "quantile")
      return [t, n - 1];
    if (t > 0 || n < 100) {
      const { domain: i } = this.getScalePercentile();
      let s = i[Math.floor(t) - 1] ?? -1 / 0, o = i[Math.floor(n) - 1] ?? 1 / 0;
      if (e === "ordinal") {
        const { domain: l } = this.getScaleOrdinal();
        s = l.findIndex((u) => u >= s), o = l.findIndex((u) => u > o) - 1, o === -2 && (o = l.length - 1);
      }
      return [s, o];
    }
    return null;
  }
  update(e) {
    const t = this.props;
    if (e.scaleType !== t.scaleType)
      switch (e.scaleType) {
        case "quantile": {
          const { attribute: n } = this.getScalePercentile();
          this.attribute = n, this.domain = [0, 99];
          break;
        }
        case "ordinal": {
          const { attribute: n, domain: i } = this.getScaleOrdinal();
          this.attribute = n, this.domain = [0, i.length - 1];
          break;
        }
        default:
          this.attribute = this.input, this.domain = null;
      }
    return (e.scaleType !== t.scaleType || e.lowerPercentile !== t.lowerPercentile || e.upperPercentile !== t.upperPercentile) && (this.cutoff = this.getCutoff(e)), this.props = e, this;
  }
}
function p0e(r) {
  const e = /* @__PURE__ */ new Set();
  for (const i of r)
    Number.isFinite(i) && e.add(i);
  const t = Array.from(e).sort(), n = /* @__PURE__ */ new Map();
  for (let i = 0; i < t.length; i++)
    n.set(t[i], i);
  return {
    attribute: {
      value: r.map((i) => Number.isFinite(i) ? n.get(i) : NaN),
      type: "float32",
      size: 1
    },
    domain: t
  };
}
function A0e(r, e = 100) {
  const t = Array.from(r).filter(Number.isFinite).sort(g0e);
  let n = 0;
  const i = Math.max(1, e), s = new Array(i - 1);
  for (; ++n < i; )
    s[n - 1] = m0e(t, n / i);
  return {
    attribute: {
      value: r.map((o) => Number.isFinite(o) ? _0e(s, o) : NaN),
      type: "float32",
      size: 1
    },
    domain: s
  };
}
function XR(r, e) {
  const t = (r.stride ?? 4) / 4, n = (r.offset ?? 0) / 4;
  let i = r.value;
  if (!i) {
    const o = r.buffer?.readSyncWebGL(0, t * 4 * e);
    o && (i = new Float32Array(o.buffer), r.value = i);
  }
  if (t === 1)
    return i.subarray(0, e);
  const s = new Float32Array(e);
  for (let o = 0; o < e; o++)
    s[o] = i[o * t + n];
  return s;
}
function g0e(r, e) {
  return r - e;
}
function m0e(r, e) {
  const t = r.length;
  if (e <= 0 || t < 2)
    return r[0];
  if (e >= 1)
    return r[t - 1];
  const n = (t - 1) * e, i = Math.floor(n), s = r[i], o = r[i + 1];
  return s + (o - s) * (n - i);
}
function _0e(r, e) {
  let t = 0, n = r.length;
  for (; t < n; ) {
    const i = t + n >>> 1;
    r[i] > e ? n = i : t = i + 1;
  }
  return t;
}
function uT({ dataBounds: r, getBinId: e, padding: t = 0 }) {
  const n = [
    r[0],
    r[1],
    [r[0][0], r[1][1]],
    [r[1][0], r[0][1]]
  ].map((u) => e(u)), i = Math.min(...n.map((u) => u[0])) - t, s = Math.min(...n.map((u) => u[1])) - t, o = Math.max(...n.map((u) => u[0])) + t + 1, l = Math.max(...n.map((u) => u[1])) + t + 1;
  return [
    [i, o],
    [s, l]
  ];
}
const sF = Math.PI / 3, by = 2 * Math.sin(sF), xy = 1.5, y0e = Array.from({ length: 6 }, (r, e) => {
  const t = e * sF;
  return [Math.sin(t), -Math.cos(t)];
});
function ub([r, e], t) {
  let n = Math.round(e = e / t / xy), i = Math.round(r = r / t / by - (n & 1) / 2);
  const s = e - n;
  if (Math.abs(s) * 3 > 1) {
    const o = r - i, l = i + (r < i ? -1 : 1) / 2, u = n + (e < n ? -1 : 1), m = r - l, y = e - u;
    o * o + s * s > m * m + y * y && (i = l + (n & 1 ? 1 : -1) / 2, n = u);
  }
  return [i, n];
}
const v0e = (
  /* glsl */
  `
const vec2 DIST = vec2(${by}, ${xy});

ivec2 pointToHexbin(vec2 p, float radius) {
  p /= radius * DIST;
  float pj = round(p.y);
  float pjm2 = mod(pj, 2.0);
  p.x -= pjm2 * 0.5;
  float pi = round(p.x);
  vec2 d1 = p - vec2(pi, pj);

  if (abs(d1.y) * 3. > 1.) {
    vec2 v2 = step(0.0, d1) - 0.5;
    v2.y *= 2.0;
    vec2 d2 = d1 - v2;
    if (dot(d1, d1) > dot(d2, d2)) {
      pi += v2.x + pjm2 - 0.5;
      pj += v2.y;
    }
  }
  return ivec2(pi, pj);
}
`
);
function ZR([r, e], t) {
  return [(r + (e & 1) / 2) * t * by, e * t * xy];
}
const b0e = `
const vec2 DIST = vec2(${by}, ${xy});

vec2 hexbinCentroid(vec2 binId, float radius) {
  binId.x += fract(binId.y * 0.5);
  return binId * DIST * radius;
}
`, x0e = (
  /* glsl */
  `#version 300 es
#define SHADER_NAME hexagon-cell-layer-vertex-shader
in vec3 positions;
in vec3 normals;
in vec2 instancePositions;
in float instanceElevationValues;
in float instanceColorValues;
in vec3 instancePickingColors;
uniform sampler2D colorRange;
out vec4 vColor;
${b0e}
float interp(float value, vec2 domain, vec2 range) {
float r = min(max((value - domain.x) / (domain.y - domain.x), 0.), 1.);
return mix(range.x, range.y, r);
}
vec4 interp(float value, vec2 domain, sampler2D range) {
float r = (value - domain.x) / (domain.y - domain.x);
return texture(range, vec2(r, 0.5));
}
void main(void) {
geometry.pickingColor = instancePickingColors;
if (isnan(instanceColorValues) ||
instanceColorValues < hexagon.colorDomain.z ||
instanceColorValues > hexagon.colorDomain.w ||
instanceElevationValues < hexagon.elevationDomain.z ||
instanceElevationValues > hexagon.elevationDomain.w
) {
gl_Position = vec4(0.);
return;
}
vec2 commonPosition = hexbinCentroid(instancePositions, column.radius) + (hexagon.originCommon - project.commonOrigin.xy);
commonPosition += positions.xy * column.radius * column.coverage;
geometry.position = vec4(commonPosition, 0.0, 1.0);
geometry.normal = project_normal(normals);
float elevation = 0.0;
if (column.extruded) {
elevation = interp(instanceElevationValues, hexagon.elevationDomain.xy, hexagon.elevationRange);
elevation = project_size(elevation);
geometry.position.z = (positions.z + 1.0) / 2.0 * elevation;
}
gl_Position = project_common_position_to_clipspace(geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vColor = interp(instanceColorValues, hexagon.colorDomain.xy, colorRange);
vColor.a *= layer.opacity;
if (column.extruded) {
vColor.rgb = lighting_getLightColor(vColor.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`
), w0e = (
  /* glsl */
  `uniform hexagonUniforms {
  vec4 colorDomain;
  vec4 elevationDomain;
  vec2 elevationRange;
  vec2 originCommon;
} hexagon;
`
), T0e = {
  name: "hexagon",
  vs: w0e,
  uniformTypes: {
    colorDomain: "vec4<f32>",
    elevationDomain: "vec4<f32>",
    elevationRange: "vec2<f32>",
    originCommon: "vec2<f32>"
  }
};
class oF extends dc {
  getShaders() {
    const e = super.getShaders();
    return e.modules.push(T0e), { ...e, vs: x0e };
  }
  initializeState() {
    super.initializeState();
    const e = this.getAttributeManager();
    e.remove([
      "instanceElevations",
      "instanceFillColors",
      "instanceLineColors",
      "instanceStrokeWidths"
    ]), e.addInstanced({
      instancePositions: {
        size: 2,
        type: "float32",
        accessor: "getBin"
      },
      instanceColorValues: {
        size: 1,
        type: "float32",
        accessor: "getColorValue"
      },
      instanceElevationValues: {
        size: 1,
        type: "float32",
        accessor: "getElevationValue"
      }
    });
  }
  updateState(e) {
    super.updateState(e);
    const { props: t, oldProps: n } = e, i = this.state.fillModel;
    if (n.colorRange !== t.colorRange) {
      this.state.colorTexture?.destroy(), this.state.colorTexture = lT(this.context.device, t.colorRange, t.colorScaleType);
      const s = { colorRange: this.state.colorTexture };
      i.shaderInputs.setProps({ hexagon: s });
    } else n.colorScaleType !== t.colorScaleType && aT(this.state.colorTexture, t.colorScaleType);
  }
  finalizeState(e) {
    super.finalizeState(e), this.state.colorTexture?.destroy();
  }
  draw({ uniforms: e }) {
    const { radius: t, hexOriginCommon: n, elevationRange: i, elevationScale: s, extruded: o, coverage: l, colorDomain: u, elevationDomain: m } = this.props, y = this.props.colorCutoff || [-1 / 0, 1 / 0], E = this.props.elevationCutoff || [-1 / 0, 1 / 0], P = this.state.fillModel;
    P.vertexArray.indexBuffer && P.setIndexBuffer(null), P.setVertexCount(this.state.fillVertexCount);
    const L = {
      colorDomain: [
        Math.max(u[0], y[0]),
        // instanceColorValue that maps to colorRange[0]
        Math.min(u[1], y[1]),
        // instanceColorValue that maps to colorRange[colorRange.length - 1]
        Math.max(u[0] - 1, y[0]),
        // hide cell if instanceColorValue is less than this
        Math.min(u[1] + 1, y[1])
        // hide cell if instanceColorValue is greater than this
      ],
      elevationDomain: [
        Math.max(m[0], E[0]),
        // instanceElevationValue that maps to elevationRange[0]
        Math.min(m[1], E[1]),
        // instanceElevationValue that maps to elevationRange[elevationRange.length - 1]
        Math.max(m[0] - 1, E[0]),
        // hide cell if instanceElevationValue is less than this
        Math.min(m[1] + 1, E[1])
        // hide cell if instanceElevationValue is greater than this
      ],
      elevationRange: [i[0] * s, i[1] * s],
      originCommon: n
    };
    P.shaderInputs.setProps({
      column: { extruded: o, coverage: l, radius: t },
      hexagon: L
    }), P.draw(this.context.renderPass);
  }
}
oF.layerName = "HexagonCellLayer";
const E0e = (
  /* glsl */
  `uniform binOptionsUniforms {
  vec2 hexOriginCommon;
  float radiusCommon;
} binOptions;
`
), C0e = {
  name: "binOptions",
  vs: E0e,
  uniformTypes: {
    hexOriginCommon: "vec2<f32>",
    radiusCommon: "f32"
  }
};
function YR() {
}
const S0e = {
  gpuAggregation: !0,
  // color
  colorDomain: null,
  colorRange: vy,
  getColorValue: { type: "accessor", value: null },
  // default value is calculated from `getColorWeight` and `colorAggregation`
  getColorWeight: { type: "accessor", value: 1 },
  colorAggregation: "SUM",
  lowerPercentile: { type: "number", min: 0, max: 100, value: 0 },
  upperPercentile: { type: "number", min: 0, max: 100, value: 100 },
  colorScaleType: "quantize",
  onSetColorDomain: YR,
  // elevation
  elevationDomain: null,
  elevationRange: [0, 1e3],
  getElevationValue: { type: "accessor", value: null },
  // default value is calculated from `getElevationWeight` and `elevationAggregation`
  getElevationWeight: { type: "accessor", value: 1 },
  elevationAggregation: "SUM",
  elevationScale: { type: "number", min: 0, value: 1 },
  elevationLowerPercentile: { type: "number", min: 0, max: 100, value: 0 },
  elevationUpperPercentile: { type: "number", min: 0, max: 100, value: 100 },
  elevationScaleType: "linear",
  onSetElevationDomain: YR,
  // hexbin
  radius: { type: "number", min: 1, value: 1e3 },
  coverage: { type: "number", min: 0, max: 1, value: 1 },
  getPosition: { type: "accessor", value: (r) => r.position },
  hexagonAggregator: { type: "function", optional: !0, value: null },
  extruded: !1,
  // Optional material for 'lighting' shader module
  material: !0
};
class fT extends zp {
  getAggregatorType() {
    const { gpuAggregation: e, hexagonAggregator: t, getColorValue: n, getElevationValue: i } = this.props;
    return e && (t || n || i) ? (Jr.warn("Features not supported by GPU aggregation, falling back to CPU")(), "cpu") : (
      // GPU aggregation is requested
      e && // GPU aggregation is supported by the device
      La.isSupported(this.context.device) ? "gpu" : "cpu"
    );
  }
  createAggregator(e) {
    if (e === "cpu") {
      const { hexagonAggregator: t, radius: n } = this.props;
      return new Up({
        dimensions: 2,
        getBin: {
          sources: ["positions"],
          getValue: ({ positions: i }, s, o) => {
            if (t)
              return t(i, n);
            const u = this.state.aggregatorViewport.projectPosition(i), { radiusCommon: m, hexOriginCommon: y } = o;
            return ub([u[0] - y[0], u[1] - y[1]], m);
          }
        },
        getValue: [
          { sources: ["colorWeights"], getValue: ({ colorWeights: i }) => i },
          { sources: ["elevationWeights"], getValue: ({ elevationWeights: i }) => i }
        ]
      });
    }
    return new La(this.context.device, {
      dimensions: 2,
      channelCount: 2,
      bufferLayout: this.getAttributeManager().getBufferLayouts({ isInstanced: !1 }),
      ...super.getShaders({
        modules: [Ws, C0e],
        vs: (
          /* glsl */
          `
  in vec3 positions;
  in vec3 positions64Low;
  in float colorWeights;
  in float elevationWeights;
  
  ${v0e}

  void getBin(out ivec2 binId) {
    vec3 positionCommon = project_position(positions, positions64Low);
    binId = pointToHexbin(positionCommon.xy, binOptions.radiusCommon);
  }
  void getValue(out vec2 value) {
    value = vec2(colorWeights, elevationWeights);
  }
  `
        )
      })
    });
  }
  initializeState() {
    super.initializeState(), this.getAttributeManager().add({
      positions: {
        size: 3,
        accessor: "getPosition",
        type: "float64",
        fp64: this.use64bitPositions()
      },
      colorWeights: { size: 1, accessor: "getColorWeight" },
      elevationWeights: { size: 1, accessor: "getElevationWeight" }
    });
  }
  // eslint-disable-next-line complexity
  updateState(e) {
    const t = super.updateState(e), { props: n, oldProps: i, changeFlags: s } = e, { aggregator: o } = this.state;
    if ((s.dataChanged || !this.state.dataAsArray) && (n.getColorValue || n.getElevationValue) && (this.state.dataAsArray = Array.from(hc(n.data).iterable)), t || s.dataChanged || n.radius !== i.radius || n.getColorValue !== i.getColorValue || n.getElevationValue !== i.getElevationValue || n.colorAggregation !== i.colorAggregation || n.elevationAggregation !== i.elevationAggregation) {
      this._updateBinOptions();
      const { radiusCommon: l, hexOriginCommon: u, binIdRange: m, dataAsArray: y } = this.state;
      if (o.setProps({
        // @ts-expect-error only used by GPUAggregator
        binIdRange: m,
        pointCount: this.getNumInstances(),
        operations: [n.colorAggregation, n.elevationAggregation],
        binOptions: {
          radiusCommon: l,
          hexOriginCommon: u
        },
        onUpdate: this._onAggregationUpdate.bind(this)
      }), y) {
        const { getColorValue: E, getElevationValue: P } = this.props;
        o.setProps({
          // @ts-expect-error only used by CPUAggregator
          customOperations: [
            E && ((L) => E(L.map((U) => y[U]), { indices: L, data: n.data })),
            P && ((L) => P(L.map((U) => y[U]), { indices: L, data: n.data }))
          ]
        });
      }
    }
    return s.updateTriggersChanged && s.updateTriggersChanged.getColorValue && o.setNeedsUpdate(0), s.updateTriggersChanged && s.updateTriggersChanged.getElevationValue && o.setNeedsUpdate(1), t;
  }
  _updateBinOptions() {
    const e = this.getBounds();
    let t = 1, n = [0, 0], i = [
      [0, 1],
      [0, 1]
    ], s = this.context.viewport;
    if (e && Number.isFinite(e[0][0])) {
      let o = [(e[0][0] + e[1][0]) / 2, (e[0][1] + e[1][1]) / 2];
      const { radius: l } = this.props, { unitsPerMeter: u } = s.getDistanceScales(o);
      t = u[0] * l;
      const m = ub(s.projectFlat(o), t);
      o = s.unprojectFlat(ZR(m, t));
      const y = s.constructor;
      s = s.isGeospatial ? new y({ longitude: o[0], latitude: o[1], zoom: 12 }) : new tu({ position: [o[0], o[1], 0], zoom: 12 }), n = [Math.fround(s.center[0]), Math.fround(s.center[1])], i = uT({
        dataBounds: e,
        getBinId: (E) => {
          const P = s.projectFlat(E);
          return P[0] -= n[0], P[1] -= n[1], ub(P, t);
        },
        padding: 1
      });
    }
    this.setState({ radiusCommon: t, hexOriginCommon: n, binIdRange: i, aggregatorViewport: s });
  }
  draw(e) {
    e.shaderModuleProps.project && (e.shaderModuleProps.project.viewport = this.state.aggregatorViewport), super.draw(e);
  }
  _onAggregationUpdate({ channel: e }) {
    const t = this.getCurrentLayer().props, { aggregator: n } = this.state;
    if (e === 0) {
      const i = n.getResult(0);
      this.setState({
        colors: new S_(i, n.binCount)
      }), t.onSetColorDomain(n.getResultDomain(0));
    } else if (e === 1) {
      const i = n.getResult(1);
      this.setState({
        elevations: new S_(i, n.binCount)
      }), t.onSetElevationDomain(n.getResultDomain(1));
    }
  }
  onAttributeChange(e) {
    const { aggregator: t } = this.state;
    switch (e) {
      case "positions":
        t.setNeedsUpdate(), this._updateBinOptions();
        const { radiusCommon: n, hexOriginCommon: i, binIdRange: s } = this.state;
        t.setProps({
          // @ts-expect-error only used by GPUAggregator
          binIdRange: s,
          binOptions: {
            radiusCommon: n,
            hexOriginCommon: i
          }
        });
        break;
      case "colorWeights":
        t.setNeedsUpdate(0);
        break;
      case "elevationWeights":
        t.setNeedsUpdate(1);
        break;
    }
  }
  renderLayers() {
    const { aggregator: e, radiusCommon: t, hexOriginCommon: n } = this.state, { elevationScale: i, colorRange: s, elevationRange: o, extruded: l, coverage: u, material: m, transitions: y, colorScaleType: E, lowerPercentile: P, upperPercentile: L, colorDomain: U, elevationScaleType: V, elevationLowerPercentile: q, elevationUpperPercentile: j, elevationDomain: K } = this.props, Y = this.getSubLayerClass("cells", oF), de = e.getBins(), ne = this.state.colors?.update({
      scaleType: E,
      lowerPercentile: P,
      upperPercentile: L
    }), ae = this.state.elevations?.update({
      scaleType: V,
      lowerPercentile: q,
      upperPercentile: j
    });
    return !ne || !ae ? null : new Y(this.getSubLayerProps({
      id: "cells"
    }), {
      data: {
        length: e.binCount,
        attributes: {
          getBin: de,
          getColorValue: ne.attribute,
          getElevationValue: ae.attribute
        }
      },
      // Data has changed shallowly, but we likely don't need to update the attributes
      dataComparator: (De, Ge) => De.length === Ge.length,
      updateTriggers: {
        getBin: [de],
        getColorValue: [ne.attribute],
        getElevationValue: [ae.attribute]
      },
      diskResolution: 6,
      vertices: y0e,
      radius: t,
      hexOriginCommon: n,
      elevationScale: i,
      colorRange: s,
      colorScaleType: E,
      elevationRange: o,
      extruded: l,
      coverage: u,
      material: m,
      colorDomain: ne.domain || U || e.getResultDomain(0),
      elevationDomain: ae.domain || K || e.getResultDomain(1),
      colorCutoff: ne.cutoff,
      elevationCutoff: ae.cutoff,
      transitions: y && {
        getFillColor: y.getColorValue || y.getColorWeight,
        getElevation: y.getElevationValue || y.getElevationWeight
      },
      // Extensions are already handled by the GPUAggregator, do not pass it down
      extensions: []
    });
  }
  getPickingInfo(e) {
    const t = e.info, { index: n } = t;
    if (n >= 0) {
      const i = this.state.aggregator.getBin(n);
      let s;
      if (i) {
        const o = ZR(i.id, this.state.radiusCommon), l = this.context.viewport.unprojectFlat(o);
        s = {
          col: i.id[0],
          row: i.id[1],
          position: l,
          colorValue: i.value[0],
          elevationValue: i.value[1],
          count: i.count
        }, i.pointIndices && (s.pointIndices = i.pointIndices, s.points = Array.isArray(this.props.data) ? i.pointIndices.map((u) => this.props.data[u]) : []);
      }
      t.object = s;
    }
    return t;
  }
}
fT.layerName = "HexagonLayer";
fT.defaultProps = S0e;
const fr = 0.5, Rr = 1 / 6, Pt = {
  N: [0, fr],
  // NORTH
  E: [fr, 0],
  // EAST
  S: [0, -fr],
  // SOUTH
  W: [-fr, 0],
  // WEST
  // CORNERS
  NE: [fr, fr],
  NW: [-fr, fr],
  SE: [fr, -fr],
  SW: [-fr, -fr]
}, Od = [Pt.W, Pt.SW, Pt.S], Dd = [Pt.S, Pt.SE, Pt.E], Ld = [Pt.E, Pt.NE, Pt.N], kd = [Pt.NW, Pt.W, Pt.N], Fd = [
  [-fr, Rr],
  [-fr, -Rr],
  [-Rr, -fr],
  [Rr, -fr]
], Nd = [
  [-Rr, -fr],
  [Rr, -fr],
  [fr, -Rr],
  [fr, Rr]
], Ud = [
  [fr, -Rr],
  [fr, Rr],
  [Rr, fr],
  [-Rr, fr]
], zd = [
  [-fr, Rr],
  [-fr, -Rr],
  [Rr, fr],
  [-Rr, fr]
], KR = [Pt.W, Pt.SW, Pt.SE, Pt.E], QR = [Pt.S, Pt.SE, Pt.NE, Pt.N], JR = [Pt.NW, Pt.W, Pt.E, Pt.NE], e4 = [Pt.NW, Pt.SW, Pt.S, Pt.N], t4 = [
  [-fr, Rr],
  [-fr, -Rr],
  [fr, -Rr],
  [fr, Rr]
], r4 = [
  [-Rr, -fr],
  [Rr, -fr],
  [Rr, fr],
  [-Rr, fr]
], I0e = [Pt.NW, Pt.SW, Pt.SE, Pt.NE], n4 = [Pt.NW, Pt.SW, Pt.SE, Pt.E, Pt.N], i4 = [Pt.W, Pt.SW, Pt.SE, Pt.NE, Pt.N], s4 = [Pt.NW, Pt.W, Pt.S, Pt.SE, Pt.NE], o4 = [Pt.NW, Pt.SW, Pt.S, Pt.E, Pt.NE], a4 = [Pt.NW, Pt.W, [fr, -Rr], [fr, Rr], Pt.N], l4 = [[-Rr, -fr], [Rr, -fr], Pt.E, Pt.NE, Pt.N], c4 = [[-fr, Rr], [-fr, -Rr], Pt.S, Pt.SE, Pt.E], u4 = [Pt.W, Pt.SW, Pt.S, [Rr, fr], [-Rr, fr]], f4 = [Pt.NW, Pt.W, [-Rr, -fr], [Rr, -fr], Pt.N], h4 = [[-fr, Rr], [-fr, -Rr], Pt.E, Pt.NE, Pt.N], d4 = [Pt.S, Pt.SE, Pt.E, [Rr, fr], [-Rr, fr]], p4 = [Pt.W, Pt.SW, Pt.S, [fr, -Rr], [fr, Rr]], A4 = [Pt.W, Pt.SW, Pt.SE, Pt.E, [Rr, fr], [-Rr, fr]], g4 = [[-fr, Rr], [-fr, -Rr], Pt.S, Pt.SE, Pt.NE, Pt.N], m4 = [Pt.NW, Pt.W, [-Rr, -fr], [Rr, -fr], Pt.E, Pt.NE], _4 = [Pt.NW, Pt.SW, Pt.S, [fr, -Rr], [fr, Rr], Pt.N], Vd = [Pt.W, Pt.SW, Pt.S, Pt.E, Pt.NE, Pt.N], jd = [Pt.NW, Pt.W, Pt.S, Pt.SE, Pt.E, Pt.N], lm = [
  [-fr, Rr],
  [-fr, -Rr],
  [-Rr, -fr],
  [Rr, -fr],
  Pt.E,
  Pt.NE,
  Pt.N
], cm = [
  Pt.W,
  Pt.SW,
  Pt.S,
  [fr, -Rr],
  [fr, Rr],
  [Rr, fr],
  [-Rr, fr]
], um = [
  Pt.NW,
  Pt.W,
  [-Rr, -fr],
  [Rr, -fr],
  [fr, -Rr],
  [fr, Rr],
  Pt.N
], fm = [
  [-fr, Rr],
  [-fr, -Rr],
  Pt.S,
  Pt.SE,
  Pt.E,
  [Rr, fr],
  [-Rr, fr]
], y4 = [
  [-fr, Rr],
  [-fr, -Rr],
  [-Rr, -fr],
  [Rr, -fr],
  [fr, -Rr],
  [fr, Rr],
  [Rr, fr],
  [-Rr, fr]
], P0e = {
  // key is equal to the code of 4 vertices (invert the code specified in wiki)
  // value can be an array or an Object
  // Array : [line] or [line, line], where each line is [start-point, end-point], and each point is [x, y]
  // Object : to handle saddle cases, whos output depends on mean value of all 4 corners
  //  key: code of mean value (0 or 1)
  //  value: Array , as above defines one or two line segments
  0: [],
  1: [[Pt.W, Pt.S]],
  2: [[Pt.S, Pt.E]],
  3: [[Pt.W, Pt.E]],
  4: [[Pt.N, Pt.E]],
  5: {
    0: [
      [Pt.W, Pt.S],
      [Pt.N, Pt.E]
    ],
    1: [
      [Pt.W, Pt.N],
      [Pt.S, Pt.E]
    ]
  },
  6: [[Pt.N, Pt.S]],
  7: [[Pt.W, Pt.N]],
  8: [[Pt.W, Pt.N]],
  9: [[Pt.N, Pt.S]],
  10: {
    0: [
      [Pt.W, Pt.N],
      [Pt.S, Pt.E]
    ],
    1: [
      [Pt.W, Pt.S],
      [Pt.N, Pt.E]
    ]
  },
  11: [[Pt.N, Pt.E]],
  12: [[Pt.W, Pt.E]],
  13: [[Pt.S, Pt.E]],
  14: [[Pt.W, Pt.S]],
  15: []
};
function gr(r) {
  return parseInt(r, 4);
}
const M0e = {
  // Below list of cases, follow the same order as in above mentioned wiki page.
  // Each case has its code on first commented line // T,TR,R,C
  // where T: Top, TR: Top-right, R: Right and C: current, each will be either 0, 1 or 2
  // final code is binary representation of above code , where takes 2 digits
  // for example:  code 2-2-2-1 => 10-10-10-01 => 10101001 => 169
  // no contours
  [gr("0000")]: [],
  [gr("2222")]: [],
  // single triangle
  [gr("2221")]: [Od],
  [gr("2212")]: [Dd],
  [gr("2122")]: [Ld],
  [gr("1222")]: [kd],
  [gr("0001")]: [Od],
  [gr("0010")]: [Dd],
  [gr("0100")]: [Ld],
  [gr("1000")]: [kd],
  // single trapezoid
  [gr("2220")]: [Fd],
  [gr("2202")]: [Nd],
  [gr("2022")]: [Ud],
  [gr("0222")]: [zd],
  [gr("0002")]: [Fd],
  [gr("0020")]: [Nd],
  [gr("0200")]: [Ud],
  [gr("2000")]: [zd],
  // single rectangle
  [gr("0011")]: [KR],
  [gr("0110")]: [QR],
  [gr("1100")]: [JR],
  [gr("1001")]: [e4],
  [gr("2211")]: [KR],
  [gr("2112")]: [QR],
  [gr("1122")]: [JR],
  [gr("1221")]: [e4],
  [gr("2200")]: [t4],
  [gr("2002")]: [r4],
  [gr("0022")]: [t4],
  [gr("0220")]: [r4],
  // single square
  // 1111
  [gr("1111")]: [I0e],
  // single pentagon
  [gr("1211")]: [n4],
  [gr("2111")]: [i4],
  [gr("1112")]: [s4],
  [gr("1121")]: [o4],
  [gr("1011")]: [n4],
  [gr("0111")]: [i4],
  [gr("1110")]: [s4],
  [gr("1101")]: [o4],
  [gr("1200")]: [a4],
  [gr("0120")]: [l4],
  [gr("0012")]: [c4],
  [gr("2001")]: [u4],
  [gr("1022")]: [a4],
  [gr("2102")]: [l4],
  [gr("2210")]: [c4],
  [gr("0221")]: [u4],
  [gr("1002")]: [f4],
  [gr("2100")]: [h4],
  [gr("0210")]: [d4],
  [gr("0021")]: [p4],
  [gr("1220")]: [f4],
  [gr("0122")]: [h4],
  [gr("2012")]: [d4],
  [gr("2201")]: [p4],
  // single hexagon
  [gr("0211")]: [A4],
  [gr("2110")]: [g4],
  [gr("1102")]: [m4],
  [gr("1021")]: [_4],
  [gr("2011")]: [A4],
  [gr("0112")]: [g4],
  [gr("1120")]: [m4],
  [gr("1201")]: [_4],
  [gr("2101")]: [Vd],
  [gr("0121")]: [Vd],
  [gr("1012")]: [jd],
  [gr("1210")]: [jd],
  // 6-sided polygons based on mean weight
  // NOTE: merges mean value codes for extreme changes (as per above Wiki doc)
  [gr("0101")]: {
    0: [Od, Ld],
    1: [Vd],
    2: [Vd]
  },
  [gr("1010")]: {
    0: [kd, Dd],
    1: [jd],
    2: [jd]
  },
  [gr("2121")]: {
    0: [Vd],
    1: [Vd],
    2: [Od, Ld]
  },
  [gr("1212")]: {
    0: [jd],
    1: [jd],
    2: [kd, Dd]
  },
  // 7-sided polygons based on mean weight
  [gr("2120")]: {
    0: [lm],
    1: [lm],
    2: [Fd, Ld]
  },
  [gr("2021")]: {
    0: [cm],
    1: [cm],
    2: [Od, Ud]
  },
  [gr("1202")]: {
    0: [um],
    1: [um],
    2: [kd, Nd]
  },
  [gr("0212")]: {
    0: [fm],
    1: [fm],
    2: [Dd, zd]
  },
  [gr("0102")]: {
    0: [Fd, Ld],
    1: [lm],
    2: [lm]
  },
  [gr("0201")]: {
    0: [Od, Ud],
    1: [cm],
    2: [cm]
  },
  [gr("1020")]: {
    0: [kd, Nd],
    1: [um],
    2: [um]
  },
  [gr("2010")]: {
    0: [Dd, zd],
    1: [fm],
    2: [fm]
  },
  // 8-sided polygons based on mean weight
  [gr("2020")]: {
    0: [zd, Nd],
    1: [y4],
    2: [Fd, Ud]
  },
  [gr("0202")]: {
    0: [Ud, Fd],
    1: [y4],
    2: [zd, Nd]
  }
};
function SA(r, e) {
  return Number.isNaN(r) ? 0 : Array.isArray(e) ? r < e[0] ? 0 : r < e[1] ? 1 : 2 : r >= e ? 1 : 0;
}
function R0e(r) {
  const { x: e, y: t, xRange: n, yRange: i, getValue: s, threshold: o } = r, l = e < n[0], u = e >= n[1] - 1, m = t < i[0], y = t >= i[1] - 1, E = l || u || m || y;
  let P = 0, L, U, V, q;
  if (l || y)
    V = 0;
  else {
    const Y = s(e, t + 1);
    V = SA(Y, o), P += Y;
  }
  if (u || y)
    q = 0;
  else {
    const Y = s(e + 1, t + 1);
    q = SA(Y, o), P += Y;
  }
  if (u || m)
    U = 0;
  else {
    const Y = s(e + 1, t);
    U = SA(Y, o), P += Y;
  }
  if (l || m)
    L = 0;
  else {
    const Y = s(e, t);
    L = SA(Y, o), P += Y;
  }
  let j = -1;
  Number.isFinite(o) && (j = V << 3 | q << 2 | U << 1 | L), Array.isArray(o) && (j = V << 6 | q << 4 | U << 2 | L);
  let K = 0;
  return E || (K = SA(P / 4, o)), { code: j, meanCode: K };
}
function B0e(r) {
  const { x: e, y: t, z: n, code: i, meanCode: s } = r;
  let o = M0e[i];
  Array.isArray(o) || (o = o[s]);
  const l = e + 1, u = t + 1, m = [];
  return o.forEach((y) => {
    const E = [];
    y.forEach((P) => {
      const L = l + P[0], U = u + P[1];
      E.push([L, U, n]);
    }), m.push(E);
  }), m;
}
function O0e(r) {
  const { x: e, y: t, z: n, code: i, meanCode: s } = r;
  let o = P0e[i];
  Array.isArray(o) || (o = o[s]);
  const l = e + 1, u = t + 1, m = [];
  return o.forEach((y) => {
    y.forEach((E) => {
      const P = l + E[0], L = u + E[1];
      m.push([P, L, n]);
    });
  }), m;
}
function D0e({ contours: r, getValue: e, xRange: t, yRange: n }) {
  const i = [], s = [];
  let o = 0, l = 0;
  for (let u = 0; u < r.length; u++) {
    const m = r[u], y = m.zIndex ?? u, { threshold: E } = m;
    for (let P = t[0] - 1; P < t[1]; P++)
      for (let L = n[0] - 1; L < n[1]; L++) {
        const { code: U, meanCode: V } = R0e({
          getValue: e,
          threshold: E,
          x: P,
          y: L,
          xRange: t,
          yRange: n
        }), q = {
          x: P,
          y: L,
          z: y,
          code: U,
          meanCode: V
        };
        if (Array.isArray(E)) {
          const j = B0e(q);
          for (const K of j)
            s[l++] = {
              vertices: K,
              contour: m
            };
        } else {
          const j = O0e(q);
          j.length > 0 && (i[o++] = {
            vertices: j,
            contour: m
          });
        }
      }
  }
  return { lines: i, polygons: s };
}
function L0e(r) {
  const { aggregator: e, binIdRange: t, channel: n } = r;
  if (e instanceof La) {
    const i = e.getResult(n)?.buffer;
    if (i) {
      const s = new Float32Array(i.readSyncWebGL().buffer);
      return k0e(s, t);
    }
  }
  if (e instanceof Up) {
    const i = e.getResult(n)?.value, s = e.getBins()?.value;
    if (s && i)
      return F0e(i, s, e.binCount);
  }
  return null;
}
function k0e(r, e) {
  const [[t, n], [i, s]] = e, o = n - t, l = s - i;
  return (u, m) => (u -= t, m -= i, u < 0 || u >= o || m < 0 || m >= l ? NaN : r[m * o + u]);
}
function F0e(r, e, t) {
  const n = {};
  for (let i = 0; i < t; i++) {
    const s = e[i * 2], o = e[i * 2 + 1];
    n[s] = n[s] || {}, n[s][o] = r[i];
  }
  return (i, s) => n[i]?.[s] ?? NaN;
}
const N0e = (
  /* glsl */
  `uniform binOptionsUniforms {
  vec2 cellOriginCommon;
  vec2 cellSizeCommon;
} binOptions;
`
), U0e = {
  name: "binOptions",
  vs: N0e,
  uniformTypes: {
    cellOriginCommon: "vec2<f32>",
    cellSizeCommon: "vec2<f32>"
  }
}, v4 = [255, 255, 255, 255], z0e = 1, V0e = {
  // grid aggregation
  cellSize: { type: "number", min: 1, value: 1e3 },
  gridOrigin: { type: "array", compare: !0, value: [0, 0] },
  getPosition: { type: "accessor", value: (r) => r.position },
  getWeight: { type: "accessor", value: 1 },
  gpuAggregation: !0,
  aggregation: "SUM",
  // contour lines
  contours: {
    type: "object",
    value: [{ threshold: 1 }],
    optional: !0,
    compare: 3
  },
  zOffset: 5e-3
};
let hT = class extends zp {
  getAggregatorType() {
    return this.props.gpuAggregation && La.isSupported(this.context.device) ? "gpu" : "cpu";
  }
  createAggregator(e) {
    return e === "cpu" ? new Up({
      dimensions: 2,
      getBin: {
        sources: ["positions"],
        getValue: ({ positions: t }, n, i) => {
          const o = this.state.aggregatorViewport.projectPosition(t), { cellSizeCommon: l, cellOriginCommon: u } = i;
          return [
            Math.floor((o[0] - u[0]) / l[0]),
            Math.floor((o[1] - u[1]) / l[1])
          ];
        }
      },
      getValue: [{ sources: ["counts"], getValue: ({ counts: t }) => t }],
      onUpdate: this._onAggregationUpdate.bind(this)
    }) : new La(this.context.device, {
      dimensions: 2,
      channelCount: 1,
      bufferLayout: this.getAttributeManager().getBufferLayouts({ isInstanced: !1 }),
      ...super.getShaders({
        modules: [Ws, U0e],
        vs: (
          /* glsl */
          `
  in vec3 positions;
  in vec3 positions64Low;
  in float counts;

  void getBin(out ivec2 binId) {
    vec3 positionCommon = project_position(positions, positions64Low);
    vec2 gridCoords = floor(positionCommon.xy / binOptions.cellSizeCommon);
    binId = ivec2(gridCoords);
  }
  void getValue(out float value) {
    value = counts;
  }
  `
        )
      }),
      onUpdate: this._onAggregationUpdate.bind(this)
    });
  }
  initializeState() {
    super.initializeState(), this.getAttributeManager().add({
      positions: {
        size: 3,
        accessor: "getPosition",
        type: "float64",
        fp64: this.use64bitPositions()
      },
      counts: { size: 1, accessor: "getWeight" }
    });
  }
  updateState(e) {
    const t = super.updateState(e), { props: n, oldProps: i, changeFlags: s } = e, { aggregator: o } = this.state;
    if (t || s.dataChanged || n.cellSize !== i.cellSize || !Fi(n.gridOrigin, i.gridOrigin, 1) || n.aggregation !== i.aggregation) {
      this._updateBinOptions();
      const { cellSizeCommon: l, cellOriginCommon: u, binIdRange: m } = this.state;
      o.setProps({
        // @ts-expect-error only used by GPUAggregator
        binIdRange: m,
        pointCount: this.getNumInstances(),
        operations: [n.aggregation],
        binOptions: {
          cellSizeCommon: l,
          cellOriginCommon: u
        }
      });
    }
    return Fi(i.contours, n.contours, 2) || this.setState({ contourData: null }), t;
  }
  _updateBinOptions() {
    const e = this.getBounds(), t = [1, 1];
    let n = [0, 0], i = [
      [0, 1],
      [0, 1]
    ], s = this.context.viewport;
    if (e && Number.isFinite(e[0][0])) {
      let o = [(e[0][0] + e[1][0]) / 2, (e[0][1] + e[1][1]) / 2];
      const { cellSize: l, gridOrigin: u } = this.props, { unitsPerMeter: m } = s.getDistanceScales(o);
      t[0] = m[0] * l, t[1] = m[1] * l;
      const y = s.projectFlat(o);
      n = [
        Math.floor((y[0] - u[0]) / t[0]) * t[0] + u[0],
        Math.floor((y[1] - u[1]) / t[1]) * t[1] + u[1]
      ], o = s.unprojectFlat(n);
      const E = s.constructor;
      s = s.isGeospatial ? new E({ longitude: o[0], latitude: o[1], zoom: 12 }) : new tu({ position: [o[0], o[1], 0], zoom: 12 }), n = [Math.fround(s.center[0]), Math.fround(s.center[1])], i = uT({
        dataBounds: e,
        getBinId: (P) => {
          const L = s.projectFlat(P);
          return [
            Math.floor((L[0] - n[0]) / t[0]),
            Math.floor((L[1] - n[1]) / t[1])
          ];
        }
      });
    }
    this.setState({ cellSizeCommon: t, cellOriginCommon: n, binIdRange: i, aggregatorViewport: s });
  }
  draw(e) {
    e.shaderModuleProps.project && (e.shaderModuleProps.project.viewport = this.state.aggregatorViewport), super.draw(e);
  }
  _onAggregationUpdate() {
    const { aggregator: e, binIdRange: t } = this.state;
    this.setState({
      aggregatedValueReader: L0e({ aggregator: e, binIdRange: t, channel: 0 }),
      contourData: null
    });
  }
  _getContours() {
    const { aggregatedValueReader: e } = this.state;
    if (!e)
      return null;
    if (!this.state.contourData) {
      const { binIdRange: t } = this.state, { contours: n } = this.props, i = D0e({
        contours: n,
        getValue: e,
        xRange: t[0],
        yRange: t[1]
      });
      this.state.contourData = i;
    }
    return this.state.contourData;
  }
  onAttributeChange(e) {
    const { aggregator: t } = this.state;
    switch (e) {
      case "positions":
        t.setNeedsUpdate(), this._updateBinOptions();
        const { cellSizeCommon: n, cellOriginCommon: i, binIdRange: s } = this.state;
        t.setProps({
          // @ts-expect-error only used by GPUAggregator
          binIdRange: s,
          binOptions: {
            cellSizeCommon: n,
            cellOriginCommon: i
          }
        });
        break;
      case "counts":
        t.setNeedsUpdate(0);
        break;
    }
  }
  renderLayers() {
    const e = this._getContours();
    if (!e)
      return null;
    const { lines: t, polygons: n } = e, { zOffset: i } = this.props, { cellOriginCommon: s, cellSizeCommon: o } = this.state, l = this.getSubLayerClass("lines", nf), u = this.getSubLayerClass("bands", sf), m = new xn().translate([s[0], s[1], 0]).scale([o[0], o[1], i]), y = t && t.length > 0 && new l(this.getSubLayerProps({
      id: "lines"
    }), {
      data: t,
      coordinateSystem: rn.CARTESIAN,
      modelMatrix: m,
      getPath: (P) => P.vertices,
      getColor: (P) => P.contour.color ?? v4,
      getWidth: (P) => P.contour.strokeWidth ?? z0e,
      widthUnits: "pixels"
    }), E = n && n.length > 0 && new u(this.getSubLayerProps({
      id: "bands"
    }), {
      data: n,
      coordinateSystem: rn.CARTESIAN,
      modelMatrix: m,
      getPolygon: (P) => P.vertices,
      getFillColor: (P) => P.contour.color ?? v4
    });
    return [y, E];
  }
  getPickingInfo(e) {
    const t = e.info, { object: n } = t;
    return n && (t.object = {
      contour: n.contour
    }), t;
  }
};
hT.layerName = "ContourLayer";
hT.defaultProps = V0e;
const j0e = (
  /* glsl */
  `#version 300 es
#define SHADER_NAME grid-cell-layer-vertex-shader
in vec3 positions;
in vec3 normals;
in vec2 instancePositions;
in float instanceElevationValues;
in float instanceColorValues;
in vec3 instancePickingColors;
uniform sampler2D colorRange;
out vec4 vColor;
float interp(float value, vec2 domain, vec2 range) {
float r = min(max((value - domain.x) / (domain.y - domain.x), 0.), 1.);
return mix(range.x, range.y, r);
}
vec4 interp(float value, vec2 domain, sampler2D range) {
float r = (value - domain.x) / (domain.y - domain.x);
return texture(range, vec2(r, 0.5));
}
void main(void) {
geometry.pickingColor = instancePickingColors;
if (isnan(instanceColorValues) ||
instanceColorValues < grid.colorDomain.z ||
instanceColorValues > grid.colorDomain.w ||
instanceElevationValues < grid.elevationDomain.z ||
instanceElevationValues > grid.elevationDomain.w
) {
gl_Position = vec4(0.);
return;
}
vec2 commonPosition = (instancePositions + (positions.xy + 1.0) / 2.0 * column.coverage) * grid.sizeCommon + grid.originCommon - project.commonOrigin.xy;
geometry.position = vec4(commonPosition, 0.0, 1.0);
geometry.normal = project_normal(normals);
float elevation = 0.0;
if (column.extruded) {
elevation = interp(instanceElevationValues, grid.elevationDomain.xy, grid.elevationRange);
elevation = project_size(elevation);
geometry.position.z = (positions.z + 1.0) / 2.0 * elevation;
}
gl_Position = project_common_position_to_clipspace(geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vColor = interp(instanceColorValues, grid.colorDomain.xy, colorRange);
vColor.a *= layer.opacity;
if (column.extruded) {
vColor.rgb = lighting_getLightColor(vColor.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`
), H0e = (
  /* glsl */
  `uniform gridUniforms {
  vec4 colorDomain;
  vec4 elevationDomain;
  vec2 elevationRange;
  vec2 originCommon;
  vec2 sizeCommon;
} grid;
`
), G0e = {
  name: "grid",
  vs: H0e,
  uniformTypes: {
    colorDomain: "vec4<f32>",
    elevationDomain: "vec4<f32>",
    elevationRange: "vec2<f32>",
    originCommon: "vec2<f32>",
    sizeCommon: "vec2<f32>"
  }
};
class aF extends dc {
  getShaders() {
    const e = super.getShaders();
    return e.modules.push(G0e), { ...e, vs: j0e };
  }
  initializeState() {
    super.initializeState();
    const e = this.getAttributeManager();
    e.remove([
      "instanceElevations",
      "instanceFillColors",
      "instanceLineColors",
      "instanceStrokeWidths"
    ]), e.addInstanced({
      instancePositions: {
        size: 2,
        type: "float32",
        accessor: "getBin"
      },
      instanceColorValues: {
        size: 1,
        type: "float32",
        accessor: "getColorValue"
      },
      instanceElevationValues: {
        size: 1,
        type: "float32",
        accessor: "getElevationValue"
      }
    });
  }
  updateState(e) {
    super.updateState(e);
    const { props: t, oldProps: n } = e, i = this.state.fillModel;
    if (n.colorRange !== t.colorRange) {
      this.state.colorTexture?.destroy(), this.state.colorTexture = lT(this.context.device, t.colorRange, t.colorScaleType);
      const s = { colorRange: this.state.colorTexture };
      i.shaderInputs.setProps({ grid: s });
    } else n.colorScaleType !== t.colorScaleType && aT(this.state.colorTexture, t.colorScaleType);
  }
  finalizeState(e) {
    super.finalizeState(e), this.state.colorTexture?.destroy();
  }
  _updateGeometry() {
    const e = new n6();
    this.state.fillModel.setGeometry(e);
  }
  draw({ uniforms: e }) {
    const { cellOriginCommon: t, cellSizeCommon: n, elevationRange: i, elevationScale: s, extruded: o, coverage: l, colorDomain: u, elevationDomain: m } = this.props, y = this.props.colorCutoff || [-1 / 0, 1 / 0], E = this.props.elevationCutoff || [-1 / 0, 1 / 0], P = this.state.fillModel, L = {
      colorDomain: [
        Math.max(u[0], y[0]),
        // instanceColorValue that maps to colorRange[0]
        Math.min(u[1], y[1]),
        // instanceColorValue that maps to colorRange[colorRange.length - 1]
        Math.max(u[0] - 1, y[0]),
        // hide cell if instanceColorValue is less than this
        Math.min(u[1] + 1, y[1])
        // hide cell if instanceColorValue is greater than this
      ],
      elevationDomain: [
        Math.max(m[0], E[0]),
        // instanceElevationValue that maps to elevationRange[0]
        Math.min(m[1], E[1]),
        // instanceElevationValue that maps to elevationRange[elevationRange.length - 1]
        Math.max(m[0] - 1, E[0]),
        // hide cell if instanceElevationValue is less than this
        Math.min(m[1] + 1, E[1])
        // hide cell if instanceElevationValue is greater than this
      ],
      elevationRange: [i[0] * s, i[1] * s],
      originCommon: t,
      sizeCommon: n
    };
    P.shaderInputs.setProps({
      column: { extruded: o, coverage: l },
      grid: L
    }), P.draw(this.context.renderPass);
  }
}
aF.layerName = "GridCellLayer";
const W0e = (
  /* glsl */
  `uniform binOptionsUniforms {
  vec2 cellOriginCommon;
  vec2 cellSizeCommon;
} binOptions;
`
), $0e = {
  name: "binOptions",
  vs: W0e,
  uniformTypes: {
    cellOriginCommon: "vec2<f32>",
    cellSizeCommon: "vec2<f32>"
  }
};
function b4() {
}
const q0e = {
  gpuAggregation: !0,
  // color
  colorDomain: null,
  colorRange: vy,
  getColorValue: { type: "accessor", value: null },
  // default value is calculated from `getColorWeight` and `colorAggregation`
  getColorWeight: { type: "accessor", value: 1 },
  colorAggregation: "SUM",
  lowerPercentile: { type: "number", min: 0, max: 100, value: 0 },
  upperPercentile: { type: "number", min: 0, max: 100, value: 100 },
  colorScaleType: "quantize",
  onSetColorDomain: b4,
  // elevation
  elevationDomain: null,
  elevationRange: [0, 1e3],
  getElevationValue: { type: "accessor", value: null },
  // default value is calculated from `getElevationWeight` and `elevationAggregation`
  getElevationWeight: { type: "accessor", value: 1 },
  elevationAggregation: "SUM",
  elevationScale: { type: "number", min: 0, value: 1 },
  elevationLowerPercentile: { type: "number", min: 0, max: 100, value: 0 },
  elevationUpperPercentile: { type: "number", min: 0, max: 100, value: 100 },
  elevationScaleType: "linear",
  onSetElevationDomain: b4,
  // grid
  cellSize: { type: "number", min: 0, value: 1e3 },
  coverage: { type: "number", min: 0, max: 1, value: 1 },
  getPosition: { type: "accessor", value: (r) => r.position },
  gridAggregator: { type: "function", optional: !0, value: null },
  extruded: !1,
  // Optional material for 'lighting' shader module
  material: !0
};
class dT extends zp {
  getAggregatorType() {
    const { gpuAggregation: e, gridAggregator: t, getColorValue: n, getElevationValue: i } = this.props;
    return e && (t || n || i) ? (Jr.warn("Features not supported by GPU aggregation, falling back to CPU")(), "cpu") : (
      // GPU aggregation is requested
      e && // GPU aggregation is supported by the device
      La.isSupported(this.context.device) ? "gpu" : "cpu"
    );
  }
  createAggregator(e) {
    if (e === "cpu") {
      const { gridAggregator: t, cellSize: n } = this.props;
      return new Up({
        dimensions: 2,
        getBin: {
          sources: ["positions"],
          getValue: ({ positions: i }, s, o) => {
            if (t)
              return t(i, n);
            const u = this.state.aggregatorViewport.projectPosition(i), { cellSizeCommon: m, cellOriginCommon: y } = o;
            return [
              Math.floor((u[0] - y[0]) / m[0]),
              Math.floor((u[1] - y[1]) / m[1])
            ];
          }
        },
        getValue: [
          { sources: ["colorWeights"], getValue: ({ colorWeights: i }) => i },
          { sources: ["elevationWeights"], getValue: ({ elevationWeights: i }) => i }
        ]
      });
    }
    return new La(this.context.device, {
      dimensions: 2,
      channelCount: 2,
      bufferLayout: this.getAttributeManager().getBufferLayouts({ isInstanced: !1 }),
      ...super.getShaders({
        modules: [Ws, $0e],
        vs: (
          /* glsl */
          `
  in vec3 positions;
  in vec3 positions64Low;
  in float colorWeights;
  in float elevationWeights;

  void getBin(out ivec2 binId) {
    vec3 positionCommon = project_position(positions, positions64Low);
    vec2 gridCoords = floor(positionCommon.xy / binOptions.cellSizeCommon);
    binId = ivec2(gridCoords);
  }
  void getValue(out vec2 value) {
    value = vec2(colorWeights, elevationWeights);
  }
  `
        )
      })
    });
  }
  initializeState() {
    super.initializeState(), this.getAttributeManager().add({
      positions: {
        size: 3,
        accessor: "getPosition",
        type: "float64",
        fp64: this.use64bitPositions()
      },
      colorWeights: { size: 1, accessor: "getColorWeight" },
      elevationWeights: { size: 1, accessor: "getElevationWeight" }
    });
  }
  // eslint-disable-next-line complexity
  updateState(e) {
    const t = super.updateState(e), { props: n, oldProps: i, changeFlags: s } = e, { aggregator: o } = this.state;
    if ((s.dataChanged || !this.state.dataAsArray) && (n.getColorValue || n.getElevationValue) && (this.state.dataAsArray = Array.from(hc(n.data).iterable)), t || s.dataChanged || n.cellSize !== i.cellSize || n.getColorValue !== i.getColorValue || n.getElevationValue !== i.getElevationValue || n.colorAggregation !== i.colorAggregation || n.elevationAggregation !== i.elevationAggregation) {
      this._updateBinOptions();
      const { cellSizeCommon: l, cellOriginCommon: u, binIdRange: m, dataAsArray: y } = this.state;
      if (o.setProps({
        // @ts-expect-error only used by GPUAggregator
        binIdRange: m,
        pointCount: this.getNumInstances(),
        operations: [n.colorAggregation, n.elevationAggregation],
        binOptions: {
          cellSizeCommon: l,
          cellOriginCommon: u
        },
        onUpdate: this._onAggregationUpdate.bind(this)
      }), y) {
        const { getColorValue: E, getElevationValue: P } = this.props;
        o.setProps({
          // @ts-expect-error only used by CPUAggregator
          customOperations: [
            E && ((L) => E(L.map((U) => y[U]), { indices: L, data: n.data })),
            P && ((L) => P(L.map((U) => y[U]), { indices: L, data: n.data }))
          ]
        });
      }
    }
    return s.updateTriggersChanged && s.updateTriggersChanged.getColorValue && o.setNeedsUpdate(0), s.updateTriggersChanged && s.updateTriggersChanged.getElevationValue && o.setNeedsUpdate(1), t;
  }
  _updateBinOptions() {
    const e = this.getBounds(), t = [1, 1];
    let n = [0, 0], i = [
      [0, 1],
      [0, 1]
    ], s = this.context.viewport;
    if (e && Number.isFinite(e[0][0])) {
      let o = [(e[0][0] + e[1][0]) / 2, (e[0][1] + e[1][1]) / 2];
      const { cellSize: l } = this.props, { unitsPerMeter: u } = s.getDistanceScales(o);
      t[0] = u[0] * l, t[1] = u[1] * l;
      const m = s.projectFlat(o);
      n = [
        Math.floor(m[0] / t[0]) * t[0],
        Math.floor(m[1] / t[1]) * t[1]
      ], o = s.unprojectFlat(n);
      const y = s.constructor;
      s = s.isGeospatial ? new y({ longitude: o[0], latitude: o[1], zoom: 12 }) : new tu({ position: [o[0], o[1], 0], zoom: 12 }), n = [Math.fround(s.center[0]), Math.fround(s.center[1])], i = uT({
        dataBounds: e,
        getBinId: (E) => {
          const P = s.projectFlat(E);
          return [
            Math.floor((P[0] - n[0]) / t[0]),
            Math.floor((P[1] - n[1]) / t[1])
          ];
        }
      });
    }
    this.setState({ cellSizeCommon: t, cellOriginCommon: n, binIdRange: i, aggregatorViewport: s });
  }
  draw(e) {
    e.shaderModuleProps.project && (e.shaderModuleProps.project.viewport = this.state.aggregatorViewport), super.draw(e);
  }
  _onAggregationUpdate({ channel: e }) {
    const t = this.getCurrentLayer().props, { aggregator: n } = this.state;
    if (e === 0) {
      const i = n.getResult(0);
      this.setState({
        colors: new S_(i, n.binCount)
      }), t.onSetColorDomain(n.getResultDomain(0));
    } else if (e === 1) {
      const i = n.getResult(1);
      this.setState({
        elevations: new S_(i, n.binCount)
      }), t.onSetElevationDomain(n.getResultDomain(1));
    }
  }
  onAttributeChange(e) {
    const { aggregator: t } = this.state;
    switch (e) {
      case "positions":
        t.setNeedsUpdate(), this._updateBinOptions();
        const { cellSizeCommon: n, cellOriginCommon: i, binIdRange: s } = this.state;
        t.setProps({
          // @ts-expect-error only used by GPUAggregator
          binIdRange: s,
          binOptions: {
            cellSizeCommon: n,
            cellOriginCommon: i
          }
        });
        break;
      case "colorWeights":
        t.setNeedsUpdate(0);
        break;
      case "elevationWeights":
        t.setNeedsUpdate(1);
        break;
    }
  }
  renderLayers() {
    const { aggregator: e, cellOriginCommon: t, cellSizeCommon: n } = this.state, { elevationScale: i, colorRange: s, elevationRange: o, extruded: l, coverage: u, material: m, transitions: y, colorScaleType: E, lowerPercentile: P, upperPercentile: L, colorDomain: U, elevationScaleType: V, elevationLowerPercentile: q, elevationUpperPercentile: j, elevationDomain: K } = this.props, Y = this.getSubLayerClass("cells", aF), de = e.getBins(), ne = this.state.colors?.update({
      scaleType: E,
      lowerPercentile: P,
      upperPercentile: L
    }), ae = this.state.elevations?.update({
      scaleType: V,
      lowerPercentile: q,
      upperPercentile: j
    });
    return !ne || !ae ? null : new Y(this.getSubLayerProps({
      id: "cells"
    }), {
      data: {
        length: e.binCount,
        attributes: {
          getBin: de,
          getColorValue: ne.attribute,
          getElevationValue: ae.attribute
        }
      },
      // Data has changed shallowly, but we likely don't need to update the attributes
      dataComparator: (De, Ge) => De.length === Ge.length,
      updateTriggers: {
        getBin: [de],
        getColorValue: [ne.attribute],
        getElevationValue: [ae.attribute]
      },
      cellOriginCommon: t,
      cellSizeCommon: n,
      elevationScale: i,
      colorRange: s,
      colorScaleType: E,
      elevationRange: o,
      extruded: l,
      coverage: u,
      material: m,
      colorDomain: ne.domain || U || e.getResultDomain(0),
      elevationDomain: ae.domain || K || e.getResultDomain(1),
      colorCutoff: ne.cutoff,
      elevationCutoff: ae.cutoff,
      transitions: y && {
        getFillColor: y.getColorValue || y.getColorWeight,
        getElevation: y.getElevationValue || y.getElevationWeight
      },
      // Extensions are already handled by the GPUAggregator, do not pass it down
      extensions: []
    });
  }
  getPickingInfo(e) {
    const t = e.info, { index: n } = t;
    if (n >= 0) {
      const i = this.state.aggregator.getBin(n);
      let s;
      i && (s = {
        col: i.id[0],
        row: i.id[1],
        colorValue: i.value[0],
        elevationValue: i.value[1],
        count: i.count
      }, i.pointIndices && (s.pointIndices = i.pointIndices, s.points = Array.isArray(this.props.data) ? i.pointIndices.map((o) => this.props.data[o]) : [])), t.object = s;
    }
    return t;
  }
}
dT.layerName = "GridLayer";
dT.defaultProps = q0e;
function X0e(r) {
  const e = r.map((l) => l[0]), t = r.map((l) => l[1]), n = Math.min.apply(null, e), i = Math.max.apply(null, e), s = Math.min.apply(null, t), o = Math.max.apply(null, t);
  return [n, s, i, o];
}
function Z0e(r, e) {
  return e[0] >= r[0] && e[2] <= r[2] && e[1] >= r[1] && e[3] <= r[3];
}
const x4 = new Float32Array(12);
function w4(r, e = 2) {
  let t = 0;
  for (const n of r)
    for (let i = 0; i < e; i++)
      x4[t++] = n[i] || 0;
  return x4;
}
function Y0e(r, e, t) {
  const [n, i, s, o] = r, l = s - n, u = o - i;
  let m = l, y = u;
  l / u < e / t ? m = e / t * u : y = t / e * l, m < e && (m = e, y = t);
  const E = (s + n) / 2, P = (o + i) / 2;
  return [
    E - m / 2,
    P - y / 2,
    E + m / 2,
    P + y / 2
  ];
}
function K0e(r, e) {
  const [t, n, i, s] = e;
  return [(r[0] - t) / (i - t), (r[1] - n) / (s - n)];
}
const Q0e = `#version 300 es
#define SHADER_NAME heatp-map-layer-vertex-shader
uniform sampler2D maxTexture;
in vec3 positions;
in vec2 texCoords;
out vec2 vTexCoords;
out float vIntensityMin;
out float vIntensityMax;
void main(void) {
gl_Position = project_position_to_clipspace(positions, vec3(0.0), vec3(0.0));
vTexCoords = texCoords;
vec4 maxTexture = texture(maxTexture, vec2(0.5));
float maxValue = triangle.aggregationMode < 0.5 ? maxTexture.r : maxTexture.g;
float minValue = maxValue * triangle.threshold;
if (triangle.colorDomain[1] > 0.) {
maxValue = triangle.colorDomain[1];
minValue = triangle.colorDomain[0];
}
vIntensityMax = triangle.intensity / maxValue;
vIntensityMin = triangle.intensity / minValue;
}
`, J0e = `#version 300 es
#define SHADER_NAME triangle-layer-fragment-shader
precision highp float;
uniform sampler2D weightsTexture;
uniform sampler2D colorTexture;
in vec2 vTexCoords;
in float vIntensityMin;
in float vIntensityMax;
out vec4 fragColor;
vec4 getLinearColor(float value) {
float factor = clamp(value * vIntensityMax, 0., 1.);
vec4 color = texture(colorTexture, vec2(factor, 0.5));
color.a *= min(value * vIntensityMin, 1.0);
return color;
}
void main(void) {
vec4 weights = texture(weightsTexture, vTexCoords);
float weight = weights.r;
if (triangle.aggregationMode > 0.5) {
weight /= max(1.0, weights.a);
}
if (weight <= 0.) {
discard;
}
vec4 linearColor = getLinearColor(weight);
linearColor.a *= layer.opacity;
fragColor = linearColor;
}
`, T4 = `uniform triangleUniforms {
  float aggregationMode;
  vec2 colorDomain;
  float intensity;
  float threshold;
} triangle;
`, ege = {
  name: "triangle",
  vs: T4,
  fs: T4,
  uniformTypes: {
    aggregationMode: "f32",
    colorDomain: "vec2<f32>",
    intensity: "f32",
    threshold: "f32"
  }
};
class lF extends Is {
  getShaders() {
    return super.getShaders({ vs: Q0e, fs: J0e, modules: [Ws, ege] });
  }
  initializeState({ device: e }) {
    this.setState({ model: this._getModel(e) });
  }
  _getModel(e) {
    const { vertexCount: t, data: n } = this.props;
    return new Bi(e, {
      ...this.getShaders(),
      id: this.props.id,
      attributes: n.attributes,
      bufferLayout: [
        { name: "positions", format: "float32x3" },
        { name: "texCoords", format: "float32x2" }
      ],
      topology: "triangle-strip",
      vertexCount: t
    });
  }
  draw() {
    const { model: e } = this.state, { aggregationMode: t, colorDomain: n, intensity: i, threshold: s, colorTexture: o, maxTexture: l, weightsTexture: u } = this.props, m = {
      aggregationMode: t,
      colorDomain: n,
      intensity: i,
      threshold: s,
      colorTexture: o,
      maxTexture: l,
      weightsTexture: u
    };
    e.shaderInputs.setProps({ triangle: m }), e.draw(this.context.renderPass);
  }
}
lF.layerName = "TriangleLayer";
function tge(r, e) {
  const t = {};
  for (const n in r)
    e.includes(n) || (t[n] = r[n]);
  return t;
}
class cF extends Ps {
  initializeAggregationLayer(e) {
    super.initializeState(this.context), this.setState({
      // Layer props , when changed doesn't require updating aggregation
      ignoreProps: tge(this.constructor._propTypes, e.data.props),
      dimensions: e
    });
  }
  updateState(e) {
    super.updateState(e);
    const { changeFlags: t } = e;
    if (t.extensionsChanged) {
      const n = this.getShaders({});
      n && n.defines && (n.defines.NON_INSTANCED_MODEL = 1), this.updateShaders(n);
    }
    this._updateAttributes();
  }
  updateAttributes(e) {
    this.setState({ changedAttributes: e });
  }
  getAttributes() {
    return this.getAttributeManager().getAttributes();
  }
  getModuleSettings() {
    const { viewport: e, mousePosition: t, device: n } = this.context;
    return Object.assign(Object.create(this.props), {
      viewport: e,
      mousePosition: t,
      picking: {
        isActive: 0
      },
      // @ts-expect-error TODO - assuming WebGL context
      devicePixelRatio: n.canvasContext.cssToDeviceRatio()
    });
  }
  updateShaders(e) {
  }
  /**
   * Checks if aggregation is dirty
   * @param {Object} updateOpts - object {props, oldProps, changeFlags}
   * @param {Object} params - object {dimension, compareAll}
   * @param {Object} params.dimension - {props, accessors} array of props and/or accessors
   * @param {Boolean} params.compareAll - when `true` it will include non layer props for comparision
   * @returns {Boolean} - returns true if dimensions' prop or accessor is changed
   **/
  isAggregationDirty(e, t = {}) {
    const { props: n, oldProps: i, changeFlags: s } = e, { compareAll: o = !1, dimension: l } = t, { ignoreProps: u } = this.state, { props: m, accessors: y = [] } = l, { updateTriggersChanged: E } = s;
    if (s.dataChanged)
      return !0;
    if (E) {
      if (E.all)
        return !0;
      for (const P of y)
        if (E[P])
          return !0;
    }
    if (o)
      return s.extensionsChanged ? !0 : Jx({
        oldProps: i,
        newProps: n,
        ignoreProps: u,
        propTypes: this.constructor._propTypes
      });
    for (const P of m)
      if (n[P] !== i[P])
        return !0;
    return !1;
  }
  /**
   * Checks if an attribute is changed
   * @param {String} name - name of the attribute
   * @returns {Boolean} - `true` if attribute `name` is changed, `false` otherwise,
   *                       If `name` is not passed or `undefiend`, `true` if any attribute is changed, `false` otherwise
   **/
  isAttributeChanged(e) {
    const { changedAttributes: t } = this.state;
    return e ? t && t[e] !== void 0 : !rge(t);
  }
  // Private
  // override Composite layer private method to create AttributeManager instance
  _getAttributeManager() {
    return new j_(this.context.device, {
      id: this.props.id,
      stats: this.context.stats
    });
  }
}
cF.layerName = "AggregationLayer";
function rge(r) {
  let e = !0;
  for (const t in r) {
    e = !1;
    break;
  }
  return e;
}
const fb = `#version 300 es
in vec3 positions;
in vec3 positions64Low;
in float weights;
out vec4 weightsTexture;
void main()
{
weightsTexture = vec4(weights * weight.weightsScale, 0., 0., 1.);
float radiusTexels = project_pixel_size(weight.radiusPixels) * weight.textureWidth / (weight.commonBounds.z - weight.commonBounds.x);
gl_PointSize = radiusTexels * 2.;
vec3 commonPosition = project_position(positions, positions64Low);
gl_Position.xy = (commonPosition.xy - weight.commonBounds.xy) / (weight.commonBounds.zw - weight.commonBounds.xy) ;
gl_Position.xy = (gl_Position.xy * 2.) - (1.);
gl_Position.w = 1.0;
}
`, hb = `#version 300 es
in vec4 weightsTexture;
out vec4 fragColor;
float gaussianKDE(float u){
return pow(2.71828, -u*u/0.05555)/(1.77245385*0.166666);
}
void main()
{
float dist = length(gl_PointCoord - vec2(0.5, 0.5));
if (dist > 0.5) {
discard;
}
fragColor = weightsTexture * gaussianKDE(2. * dist);
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`, nge = `#version 300 es
uniform sampler2D inTexture;
out vec4 outTexture;
void main()
{
int yIndex = gl_VertexID / int(maxWeight.textureSize);
int xIndex = gl_VertexID - (yIndex * int(maxWeight.textureSize));
vec2 uv = (0.5 + vec2(float(xIndex), float(yIndex))) / maxWeight.textureSize;
outTexture = texture(inTexture, uv);
gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
gl_PointSize = 1.0;
}
`, ige = `#version 300 es
in vec4 outTexture;
out vec4 fragColor;
void main() {
fragColor = outTexture;
fragColor.g = outTexture.r / max(1.0, outTexture.a);
}
`, sge = `uniform weightUniforms {
  vec4 commonBounds;
  float radiusPixels;
  float textureWidth;
  float weightsScale;
} weight;
`, oge = {
  name: "weight",
  vs: sge,
  uniformTypes: {
    commonBounds: "vec4<f32>",
    radiusPixels: "f32",
    textureWidth: "f32",
    weightsScale: "f32"
  }
}, age = {
  name: "maxWeight",
  vs: `uniform maxWeightUniforms {
  float textureSize;
} maxWeight;
`,
  uniformTypes: {
    textureSize: "f32"
  }
}, lge = 2, db = {
  format: "rgba8unorm",
  dimension: "2d",
  width: 1,
  height: 1,
  sampler: {
    minFilter: "linear",
    magFilter: "linear",
    addressModeU: "clamp-to-edge",
    addressModeV: "clamp-to-edge"
  }
}, E4 = [0, 0], cge = {
  SUM: 0,
  MEAN: 1
}, uge = {
  getPosition: { type: "accessor", value: (r) => r.position },
  getWeight: { type: "accessor", value: 1 },
  intensity: { type: "number", min: 0, value: 1 },
  radiusPixels: { type: "number", min: 1, max: 100, value: 50 },
  colorRange: vy,
  threshold: { type: "number", min: 0, max: 1, value: 0.05 },
  colorDomain: { type: "array", value: null, optional: !0 },
  // 'SUM' or 'MEAN'
  aggregation: "SUM",
  weightsTextureSize: { type: "number", min: 128, max: 2048, value: 2048 },
  debounceTimeout: { type: "number", min: 0, max: 1e3, value: 500 }
}, fge = [
  "float32-renderable-webgl",
  // ability to render to float texture
  "texture-blend-float-webgl"
  // ability to blend when rendering to float texture
], hge = {
  data: {
    props: ["radiusPixels"]
  }
};
class pT extends cF {
  getShaders(e) {
    let t = [Ws];
    return e.modules && (t = [...t, ...e.modules]), super.getShaders({ ...e, modules: t });
  }
  initializeState() {
    super.initializeAggregationLayer(hge), this.setState({ colorDomain: E4 }), this._setupTextureParams(), this._setupAttributes(), this._setupResources();
  }
  shouldUpdateState({ changeFlags: e }) {
    return e.somethingChanged;
  }
  /* eslint-disable max-statements,complexity */
  updateState(e) {
    super.updateState(e), this._updateHeatmapState(e);
  }
  _updateHeatmapState(e) {
    const { props: t, oldProps: n } = e, i = this._getChangeFlags(e);
    if ((i.dataChanged || i.viewportChanged) && (i.boundsChanged = this._updateBounds(i.dataChanged), this._updateTextureRenderingBounds()), i.dataChanged || i.boundsChanged) {
      if (clearTimeout(this.state.updateTimer), this.setState({ isWeightMapDirty: !0 }), i.dataChanged) {
        const s = this.getShaders({ vs: fb, fs: hb });
        this._createWeightsTransform(s);
      }
    } else i.viewportZoomChanged && this._debouncedUpdateWeightmap();
    t.colorRange !== n.colorRange && this._updateColorTexture(e), this.state.isWeightMapDirty && this._updateWeightmap(), this.setState({ zoom: e.context.viewport.zoom });
  }
  renderLayers() {
    const { weightsTexture: e, triPositionBuffer: t, triTexCoordBuffer: n, maxWeightsTexture: i, colorTexture: s, colorDomain: o } = this.state, { updateTriggers: l, intensity: u, threshold: m, aggregation: y } = this.props, E = this.getSubLayerClass("triangle", lF);
    return new E(this.getSubLayerProps({
      id: "triangle-layer",
      updateTriggers: l
    }), {
      // position buffer is filled with world coordinates generated from viewport.unproject
      // i.e. LNGLAT if geospatial, CARTESIAN otherwise
      coordinateSystem: rn.DEFAULT,
      data: {
        attributes: {
          positions: t,
          texCoords: n
        }
      },
      vertexCount: 4,
      maxTexture: i,
      colorTexture: s,
      aggregationMode: cge[y] || 0,
      weightsTexture: e,
      intensity: u,
      threshold: m,
      colorDomain: o
    });
  }
  finalizeState(e) {
    super.finalizeState(e);
    const { weightsTransform: t, weightsTexture: n, maxWeightTransform: i, maxWeightsTexture: s, triPositionBuffer: o, triTexCoordBuffer: l, colorTexture: u, updateTimer: m } = this.state;
    t?.destroy(), n?.destroy(), i?.destroy(), s?.destroy(), o?.destroy(), l?.destroy(), u?.destroy(), m && clearTimeout(m);
  }
  // PRIVATE
  // override Composite layer private method to create AttributeManager instance
  _getAttributeManager() {
    return new j_(this.context.device, {
      id: this.props.id,
      stats: this.context.stats
    });
  }
  _getChangeFlags(e) {
    const t = {}, { dimensions: n } = this.state;
    t.dataChanged = this.isAttributeChanged() && "attribute changed" || // if any attribute is changed
    this.isAggregationDirty(e, {
      compareAll: !0,
      dimension: n.data
    }) && "aggregation is dirty", t.viewportChanged = e.changeFlags.viewportChanged;
    const { zoom: i } = this.state;
    return (!e.context.viewport || e.context.viewport.zoom !== i) && (t.viewportZoomChanged = !0), t;
  }
  _createTextures() {
    const { textureSize: e, format: t } = this.state;
    this.setState({
      weightsTexture: this.context.device.createTexture({
        ...db,
        width: e,
        height: e,
        format: t
      }),
      maxWeightsTexture: this.context.device.createTexture({
        ...db,
        width: 1,
        height: 1,
        format: t
      })
    });
  }
  _setupAttributes() {
    this.getAttributeManager().add({
      positions: { size: 3, type: "float64", accessor: "getPosition" },
      weights: { size: 1, accessor: "getWeight" }
    }), this.setState({ positionAttributeName: "positions" });
  }
  _setupTextureParams() {
    const { device: e } = this.context, { weightsTextureSize: t } = this.props, n = Math.min(t, e.limits.maxTextureDimension2D), i = fge.every((l) => e.features.has(l)), s = i ? "rgba32float" : "rgba8unorm", o = i ? 1 : 1 / 255;
    this.setState({ textureSize: n, format: s, weightsScale: o }), i || Jr.warn(`HeatmapLayer: ${this.id} rendering to float texture not supported, falling back to low precision format`)();
  }
  _createWeightsTransform(e) {
    let { weightsTransform: t } = this.state;
    const { weightsTexture: n } = this.state, i = this.getAttributeManager();
    t?.destroy(), t = new VC(this.context.device, {
      id: `${this.id}-weights-transform`,
      bufferLayout: i.getBufferLayouts(),
      vertexCount: 1,
      targetTexture: n,
      parameters: {
        depthWriteEnabled: !1,
        blendColorOperation: "add",
        blendColorSrcFactor: "one",
        blendColorDstFactor: "one",
        blendAlphaSrcFactor: "one",
        blendAlphaDstFactor: "one"
      },
      topology: "point-list",
      ...e,
      modules: [...e.modules, oge]
    }), this.setState({ weightsTransform: t });
  }
  _setupResources() {
    this._createTextures();
    const { device: e } = this.context, { textureSize: t, weightsTexture: n, maxWeightsTexture: i } = this.state, s = this.getShaders({
      vs: fb,
      fs: hb
    });
    this._createWeightsTransform(s);
    const o = this.getShaders({
      vs: nge,
      fs: ige,
      modules: [age]
    }), l = new VC(e, {
      id: `${this.id}-max-weights-transform`,
      targetTexture: i,
      ...o,
      vertexCount: t * t,
      topology: "point-list",
      parameters: {
        depthWriteEnabled: !1,
        blendColorOperation: "max",
        blendAlphaOperation: "max",
        blendColorSrcFactor: "one",
        blendColorDstFactor: "one",
        blendAlphaSrcFactor: "one",
        blendAlphaDstFactor: "one"
      }
    }), u = { inTexture: n, textureSize: t };
    l.model.shaderInputs.setProps({
      maxWeight: u
    }), this.setState({
      weightsTexture: n,
      maxWeightsTexture: i,
      maxWeightTransform: l,
      zoom: null,
      triPositionBuffer: e.createBuffer({ byteLength: 48 }),
      triTexCoordBuffer: e.createBuffer({ byteLength: 48 })
    });
  }
  // overwrite super class method to update transform model
  updateShaders(e) {
    this._createWeightsTransform({
      vs: fb,
      fs: hb,
      ...e
    });
  }
  _updateMaxWeightValue() {
    const { maxWeightTransform: e } = this.state;
    e.run({
      parameters: { viewport: [0, 0, 1, 1] },
      clearColor: [0, 0, 0, 0]
    });
  }
  // Computes world bounds area that needs to be processed for generate heatmap
  _updateBounds(e = !1) {
    const { viewport: t } = this.context, n = [
      t.unproject([0, 0]),
      t.unproject([t.width, 0]),
      t.unproject([0, t.height]),
      t.unproject([t.width, t.height])
    ].map((l) => l.map(Math.fround)), i = X0e(n), s = { visibleWorldBounds: i, viewportCorners: n };
    let o = !1;
    if (e || !this.state.worldBounds || !Z0e(this.state.worldBounds, i)) {
      const l = this._worldToCommonBounds(i), u = this._commonToWorldBounds(l);
      this.props.coordinateSystem === rn.LNGLAT && (u[1] = Math.max(u[1], -85.051129), u[3] = Math.min(u[3], 85.051129), u[0] = Math.max(u[0], -360), u[2] = Math.min(u[2], 360));
      const m = this._worldToCommonBounds(u);
      s.worldBounds = u, s.normalizedCommonBounds = m, o = !0;
    }
    return this.setState(s), o;
  }
  _updateTextureRenderingBounds() {
    const { triPositionBuffer: e, triTexCoordBuffer: t, normalizedCommonBounds: n, viewportCorners: i } = this.state, { viewport: s } = this.context;
    e.write(w4(i, 3));
    const o = i.map((l) => K0e(s.projectPosition(l), n));
    t.write(w4(o, 2));
  }
  _updateColorTexture(e) {
    const { colorRange: t } = e.props;
    let { colorTexture: n } = this.state;
    const i = nF(t, !1, Uint8Array);
    n?.destroy(), n = this.context.device.createTexture({
      ...db,
      data: i,
      width: t.length,
      height: 1
    }), this.setState({ colorTexture: n });
  }
  _updateWeightmap() {
    const { radiusPixels: e, colorDomain: t, aggregation: n } = this.props, { worldBounds: i, textureSize: s, weightsScale: o, weightsTexture: l } = this.state, u = this.state.weightsTransform;
    this.state.isWeightMapDirty = !1;
    const m = this._worldToCommonBounds(i, {
      useLayerCoordinateSystem: !0
    });
    if (t && n === "SUM") {
      const { viewport: Y } = this.context, de = Y.distanceScales.metersPerUnit[2] * (m[2] - m[0]) / s;
      this.state.colorDomain = t.map((ne) => ne * de * o);
    } else
      this.state.colorDomain = t || E4;
    const E = this.getAttributeManager().getAttributes(), P = this.getModuleSettings();
    this._setModelAttributes(u.model, E), u.model.setVertexCount(this.getNumInstances());
    const L = {
      radiusPixels: e,
      commonBounds: m,
      textureWidth: s,
      weightsScale: o,
      weightsTexture: l
    }, { viewport: U, devicePixelRatio: V, coordinateSystem: q, coordinateOrigin: j } = P, { modelMatrix: K } = this.props;
    u.model.shaderInputs.setProps({
      project: { viewport: U, devicePixelRatio: V, modelMatrix: K, coordinateSystem: q, coordinateOrigin: j },
      weight: L
    }), u.run({
      parameters: { viewport: [0, 0, s, s] },
      clearColor: [0, 0, 0, 0]
    }), this._updateMaxWeightValue();
  }
  _debouncedUpdateWeightmap(e = !1) {
    let { updateTimer: t } = this.state;
    const { debounceTimeout: n } = this.props;
    e ? (t = null, this._updateBounds(!0), this._updateTextureRenderingBounds(), this.setState({ isWeightMapDirty: !0 })) : (this.setState({ isWeightMapDirty: !1 }), clearTimeout(t), t = setTimeout(this._debouncedUpdateWeightmap.bind(this, !0), n)), this.setState({ updateTimer: t });
  }
  // input: worldBounds: [minLong, minLat, maxLong, maxLat]
  // input: opts.useLayerCoordinateSystem : layers coordiante system is used
  // optput: commonBounds: [minX, minY, maxX, maxY] scaled to fit the current texture
  _worldToCommonBounds(e, t = {}) {
    const { useLayerCoordinateSystem: n = !1 } = t, [i, s, o, l] = e, { viewport: u } = this.context, { textureSize: m } = this.state, { coordinateSystem: y } = this.props, E = n && (y === rn.LNGLAT_OFFSETS || y === rn.METER_OFFSETS), P = E ? u.projectPosition(this.props.coordinateOrigin) : [0, 0], L = m * lge / u.scale;
    let U, V;
    return n && !E ? (U = this.projectPosition([i, s, 0]), V = this.projectPosition([o, l, 0])) : (U = u.projectPosition([i, s, 0]), V = u.projectPosition([o, l, 0])), Y0e([
      U[0] - P[0],
      U[1] - P[1],
      V[0] - P[0],
      V[1] - P[1]
    ], L, L);
  }
  // input commonBounds: [xMin, yMin, xMax, yMax]
  // output worldBounds: [minLong, minLat, maxLong, maxLat]
  _commonToWorldBounds(e) {
    const [t, n, i, s] = e, { viewport: o } = this.context, l = o.unprojectPosition([t, n]), u = o.unprojectPosition([i, s]);
    return l.slice(0, 2).concat(u.slice(0, 2));
  }
}
pT.layerName = "HeatmapLayer";
pT.defaultProps = uge;
const dge = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CPUAggregator: Up,
  ContourLayer: hT,
  GridLayer: dT,
  HeatmapLayer: pT,
  HexagonLayer: fT,
  ScreenGridLayer: cT,
  WebGLAggregator: La,
  _AggregationLayer: zp
}, Symbol.toStringTag, { value: "Module" })), uF = [0x5555555555555555n, 0x3333333333333333n, 0x0f0f0f0f0f0f0f0fn, 0x00ff00ff00ff00ffn, 0x0000ffff0000ffffn, 0x00000000ffffffffn], fF = [0n, 1n, 2n, 4n, 8n, 16n];
function pge(r) {
  return BigInt(`0x${r}`);
}
function j2(r) {
  return r.toString(16);
}
function Age(r) {
  if (r.z < 0 || r.z > 26)
    throw new Error("Wrong zoom");
  const e = BigInt(r.z);
  let t = BigInt(r.x) << 32n - e, n = BigInt(r.y) << 32n - e;
  for (let s = 0; s < 5; s++) {
    const o = fF[5 - s], l = uF[4 - s];
    t = (t | t << o) & l, n = (n | n << o) & l;
  }
  return 0x4000000000000000n | 1n << 59n | // | (mode << 59) | (mode_dep << 57)
  e << 52n | (t | n << 1n) >> 12n | 0xfffffffffffffn >> e * 2n;
}
function hF(r) {
  const e = r >> 59n & 7n, t = r >> 57n & 3n, n = r >> 52n & 0x1fn, i = (r & 0xfffffffffffffn) << 12n;
  if (e !== 1n && t !== 0n)
    throw new Error("Wrong mode");
  let s = i, o = i >> 1n;
  for (let l = 0; l < 6; l++) {
    const u = fF[l], m = uF[l];
    s = (s | s >> u) & m, o = (o | o >> u) & m;
  }
  return s = s >> 32n - n, o = o >> 32n - n, {
    z: Number(n),
    x: Number(s),
    y: Number(o)
  };
}
function AT(r) {
  return r >> 52n & 0x1fn;
}
function dF(r) {
  const e = AT(r) - 1n;
  return r & ~(0x1fn << 52n) | e << 52n | 0xfffffffffffffn >> e * 2n;
}
function fh(r, e) {
  Jr.assert(r, e);
}
function gge(r, e) {
  const { properties: t, numericProps: n } = r;
  return new Proxy(t[e] || {}, {
    get(i, s) {
      return s in n ? n[s].value[e] : i[s];
    },
    has(i, s) {
      return s in n || s in i;
    },
    ownKeys(i) {
      return [...Object.keys(n), ...Reflect.ownKeys(i)];
    },
    getOwnPropertyDescriptor(i, s) {
      return { enumerable: !0, configurable: !0 };
    }
  });
}
function wy(r, e) {
  return `https://unpkg.com/@deck.gl/carto@${e}/dist/${r}-worker.js`;
}
const e0 = new Uint16Array(), pb = {
  positions: { value: new Float32Array(), size: 2 },
  properties: [],
  numericProps: {},
  featureIds: { value: e0, size: 1 },
  globalFeatureIds: { value: e0, size: 1 }
};
function pF() {
  return {
    shape: "binary-feature-collection",
    points: {
      type: "Point",
      ...pb
    },
    lines: {
      type: "LineString",
      pathIndices: { value: e0, size: 1 },
      ...pb
    },
    polygons: {
      type: "Polygon",
      polygonIndices: { value: e0, size: 1 },
      primitivePolygonIndices: { value: e0, size: 1 },
      ...pb
    }
  };
}
function gT(r, e, t, n, i, s = 2) {
  return {
    type: "Point",
    positions: { value: new Float32Array(r), size: s },
    featureIds: { value: new Uint16Array(e), size: 1 },
    globalFeatureIds: { value: new Uint32Array(t), size: 1 },
    numericProps: n,
    properties: i
  };
}
function AF(r, e) {
  const t = {};
  return e && Object.keys(e).forEach((n) => {
    t[n] = { value: new Float32Array(r), size: 1 };
  }), t;
}
function gF(r, e, t, n) {
  Object.keys(r).forEach((i) => {
    e[i].value[n] = r[i].value[t];
  });
}
function mge(r, e, t, n = [], i, s, o = "quadbin") {
  if (!r.content)
    return !1;
  r.userData || (r.userData = {});
  const l = e.get(t)?.[0];
  if (l) {
    if (n.every((m) => m.name in l))
      return !1;
    e.clear();
  }
  const u = {};
  for (const m of r.content) {
    let y = m.id;
    const E = typeof i == "function" ? i(m, {}) : i;
    for (let q = 0; q < t - 1; q++)
      if (o === "h3") {
        const j = lh(y);
        y = YL(y, Math.max(0, j - 1));
      } else
        y = dF(y);
    const P = String(y);
    if (!(P in u)) {
      u[P] = { id: y, count: 0, position: [0, 0] };
      for (const { name: q, aggregation: j } of n)
        j === "any" ? u[P][q] = m.properties[q] : u[P][q] = 0;
    }
    const L = u[P].count;
    u[P].count += typeof s == "function" ? s(m, {}) : s;
    const U = u[P].count, V = U - L;
    u[P].position[0] = (L * u[P].position[0] + V * E[0]) / U, u[P].position[1] = (L * u[P].position[1] + V * E[1]) / U;
    for (const { name: q, aggregation: j } of n) {
      const K = u[P][q], Y = m.properties[q];
      j === "average" ? u[P][q] = (L * K + V * Y) / U : j === "count" || j === "sum" ? u[P][q] = K + Y : j === "max" ? u[P][q] = Math.max(K, Y) : j === "min" && (u[P][q] = Math.min(K, Y));
    }
  }
  return e.set(t, Object.values(u)), !0;
}
function _ge(r) {
  const e = [], t = ["any", "average", "count", "min", "max", "sum"];
  for (const n of Object.keys(r.content[0].properties)) {
    let i = n.split("_").pop().toLowerCase();
    t.includes(i) || (Jr.warn(`No valid aggregation present in ${n} property`)(), i = "any"), e.push({ name: n, aggregation: i });
  }
  return e;
}
function yge(r, e) {
  const t = {};
  for (const { name: n, aggregation: i } of e)
    if (t[n] = { min: 1 / 0, max: -1 / 0 }, i !== "any")
      for (const s of r)
        t[n].min = Math.min(t[n].min, s[n]), t[n].max = Math.max(t[n].max, s[n]);
  return t;
}
function vge(r) {
  const e = new Float32Array(r.length * 2), t = new Uint16Array(r.length);
  for (let n = 0; n < r.length; n++)
    e.set(r[n].position, 2 * n), t[n] = n;
  return {
    ...pF(),
    points: gT(e, t, t, {}, r)
  };
}
const Vp = 512;
class Ty extends hy {
  // @ts-expect-error for spatial indices, TileSet2d should be parametrized by TileIndexT
  getTileIndices(e) {
    return super.getTileIndices(e).map(Age).map((t) => ({ q: t, i: j2(t) }));
  }
  // @ts-expect-error TileIndex must be generic
  getTileId({ q: e, i: t }) {
    return t || j2(e);
  }
  // @ts-expect-error TileIndex must be generic
  getTileMetadata({ q: e }) {
    return super.getTileMetadata(hF(e));
  }
  // @ts-expect-error TileIndex must be generic
  getTileZoom({ q: e }) {
    return Number(AT(e));
  }
  // @ts-expect-error TileIndex must be generic
  getParentIndex({ q: e }) {
    return { q: dF(e) };
  }
}
const C4 = 85.051128;
function mF({ west: r, north: e, east: t, south: n }, i, s = 1) {
  const u = [
    [e, t],
    [n, t],
    [n, r],
    [e, r]
  ].map((E) => kw(E[0], E[1], i)).map((E) => Math.max(...yce(E).map((P) => bce(P, pp.rads))) * 180 / Math.PI), m = Math.max(...u) * s, y = Math.min(180, m / Math.cos((e + n) / 2 * Math.PI / 180));
  return {
    north: Math.min(e + m, C4),
    east: t + y,
    south: Math.max(n - m, -C4),
    west: r - y
  };
}
function _F({ west: r, north: e, east: t, south: n }, i) {
  const s = Math.abs(t - r);
  if (s > 180) {
    const l = Math.ceil(s / 180);
    let u = [];
    for (let m = 0; m < l; m++) {
      const y = r + m * 180, E = Math.min(y + 179.9999999, t);
      u = u.concat(_F({ west: y, north: e, east: E, south: n }, i));
    }
    return [...new Set(u)];
  }
  return mce([
    [e, t],
    [n, t],
    [n, r],
    [e, r],
    [e, t]
  ], i);
}
function bge(r) {
  const e = ZL(r), t = e.map((m) => m[0]), n = e.map((m) => m[1]), i = Math.min(...n), s = Math.min(...t), o = Math.max(...n), l = Math.max(...t);
  return mF({ west: i, south: s, east: o, north: l }, lh(r), 0.12);
}
const xge = 2;
function I_(r, e) {
  const t = Math.log2(e / 512), n = 2 / 3 * (r.zoom - t), i = Math.log(1 / Math.cos(Math.PI * r.latitude / 180));
  return Math.max(0, Math.floor(n + i - xge));
}
class mT extends hy {
  /**
   * Returns all tile indices in the current viewport. If the current zoom level is smaller
   * than minZoom, return an empty array. If the current zoom level is greater than maxZoom,
   * return tiles that are on maxZoom.
   */
  // @ts-expect-error Tileset2D should be generic over TileIndex
  getTileIndices({ viewport: e, minZoom: t, maxZoom: n }) {
    if (e.latitude === void 0)
      return [];
    const [i, s, o, l] = e.getBounds(), { tileSize: u } = this.opts;
    let m = I_(e, u), y;
    if (typeof t == "number" && Number.isFinite(t) && m < t)
      return [];
    if (typeof n == "number" && Number.isFinite(n) && m > n) {
      m = n;
      const E = kw(e.latitude, e.longitude, n);
      y = gce(E, 1);
    } else {
      const E = mF({ west: i, north: l, east: o, south: s }, m);
      y = _F(E, m);
    }
    return y.map((E) => ({ i: E }));
  }
  // @ts-expect-error Tileset2D should be generic over TileIndex
  getTileId({ i: e }) {
    return e;
  }
  // @ts-expect-error Tileset2D should be generic over TileIndex
  getTileMetadata({ i: e }) {
    return { bbox: bge(e) };
  }
  // @ts-expect-error Tileset2D should be generic over TileIndex
  getTileZoom({ i: e }) {
    return lh(e);
  }
  // @ts-expect-error Tileset2D should be generic over TileIndex
  getParentIndex(e) {
    const t = lh(e.i);
    return { i: YL(e.i, t - 1) };
  }
}
const S4 = 512;
function yF(r) {
  const { x: e, y: t, z: n } = hF(r), i = S4 / (1 << n);
  return [e * i, S4 - t * i, i];
}
function wge(r, e) {
  const [t, n, i] = yF(r);
  return [
    [t, n],
    [t + e * i, n - e * i]
  ];
}
function vF(r, e = 1) {
  const [t, n] = wge(r, e), [i, s] = lc(t), [o, l] = lc(n);
  return [o, s, o, l, i, l, i, s, o, s];
}
const hm = (
  // @ts-ignore process does not exist on browser
  !!(typeof process != "object" || String(process) !== "[object process]" || process.browser)
), I4 = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version);
I4 && parseFloat(I4[1]);
function Tge(r) {
  globalThis.loaders ||= {}, globalThis.loaders.modules ||= {}, Object.assign(globalThis.loaders.modules, r);
}
function Ege(...r) {
  return Cge(r);
}
function Cge(r) {
  const e = r.map((s) => s instanceof ArrayBuffer ? new Uint8Array(s) : s), t = e.reduce((s, o) => s + o.byteLength, 0), n = new Uint8Array(t);
  let i = 0;
  for (const s of e)
    n.set(s, i), i += s.byteLength;
  return n.buffer;
}
async function Sge(r) {
  const e = [];
  for await (const t of r)
    e.push(t);
  return Ege(...e);
}
function Ige(r) {
  return r && typeof r == "object" && r.isBuffer;
}
function dm(r) {
  if (Ige(r))
    return r;
  if (r instanceof ArrayBuffer)
    return r;
  if (ArrayBuffer.isView(r))
    return r.byteOffset === 0 && r.byteLength === r.buffer.byteLength ? r.buffer : r.buffer.slice(r.byteOffset, r.byteOffset + r.byteLength);
  if (typeof r == "string") {
    const e = r;
    return new TextEncoder().encode(e).buffer;
  }
  if (r && typeof r == "object" && r._toArrayBuffer)
    return r._toArrayBuffer();
  throw new Error("toArrayBuffer");
}
function pm(r) {
  return (e) => new Promise((t, n) => r(e, (i, s) => i ? n(i) : t(s)));
}
class Pge {
  constructor(e) {
    this.compressBatches = this.compressBatches.bind(this), this.decompressBatches = this.decompressBatches.bind(this);
  }
  /** Preloads any dynamic libraries. May enable sync functions */
  async preload(e = {}) {
    Tge(e);
  }
  /** Asynchronously compress data */
  async compress(e) {
    return await this.preload(), this.compressSync(e);
  }
  /** Asynchronously decompress data */
  async decompress(e, t) {
    return await this.preload(), this.decompressSync(e, t);
  }
  /** Synchronously compress data */
  compressSync(e) {
    throw new Error(`${this.name}: sync compression not supported`);
  }
  /** Synchronously compress data */
  decompressSync(e, t) {
    throw new Error(`${this.name}: sync decompression not supported`);
  }
  /** Compress batches */
  async *compressBatches(e) {
    const t = await this.concatenate(e);
    yield this.compress(t);
  }
  /** Decompress batches */
  async *decompressBatches(e) {
    const t = await this.concatenate(e);
    yield this.decompress(t);
  }
  // HELPERS
  concatenate(e) {
    return Sge(e);
  }
  improveError(e) {
    return e.message.includes(this.name) || (e.message = `${this.name} ${e.message}`), e;
  }
}
class Mge extends Pge {
  name = "deflate";
  extensions = [];
  contentEncodings = ["deflate"];
  isSupported = !0;
  options;
  _chunks = [];
  constructor(e = {}) {
    super(e), this.options = e;
  }
  async compress(e) {
    if (!hm && this.options.deflate?.useZlib) {
      const t = this.options.deflate?.gzip ? await pm(Ou.gzip)(e) : await pm(Ou.deflate)(e);
      return dm(t);
    }
    return this.compressSync(e);
  }
  async decompress(e) {
    if (!hm && this.options.deflate?.useZlib) {
      const t = this.options.deflate?.gzip ? await pm(Ou.gunzip)(e) : await pm(Ou.inflate)(e);
      return dm(t);
    }
    return this.decompressSync(e);
  }
  compressSync(e) {
    if (!hm && this.options.deflate?.useZlib) {
      const s = this.options.deflate?.gzip ? Ou.gzipSync(e) : Ou.deflateSync(e);
      return dm(s);
    }
    const t = this.options?.deflate || {}, n = new Uint8Array(e);
    return (this.options?.raw ? Bd.deflateRaw : Bd.deflate)(n, t).buffer;
  }
  decompressSync(e) {
    if (!hm && this.options.deflate?.useZlib) {
      const s = this.options.deflate?.gzip ? Ou.gunzipSync(e) : Ou.inflateSync(e);
      return dm(s);
    }
    const t = this.options?.deflate || {}, n = new Uint8Array(e);
    return (this.options?.raw ? Bd.inflateRaw : Bd.inflate)(n, t).buffer;
  }
  async *compressBatches(e) {
    const t = this.options?.deflate || {}, n = new Bd.Deflate(t);
    yield* this.transformBatches(n, e);
  }
  async *decompressBatches(e) {
    const t = this.options?.deflate || {}, n = new Bd.Inflate(t);
    yield* this.transformBatches(n, e);
  }
  async *transformBatches(e, t) {
    e.onData = this._onData.bind(this), e.onEnd = this._onEnd.bind(this);
    for await (const s of t) {
      const o = new Uint8Array(s);
      if (!e.push(o, !1))
        throw new Error(`${this._getError()}write`);
      yield* this._getChunks();
    }
    const n = new Uint8Array(0);
    e.push(n, !0), yield* this._getChunks();
  }
  _onData(e) {
    this._chunks.push(e);
  }
  _onEnd(e) {
    if (e !== 0)
      throw new Error(this._getError(e) + this._chunks.length);
  }
  _getChunks() {
    const e = this._chunks;
    return this._chunks = [], e;
  }
  // TODO - For some reason we don't get the error message from pako in _onEnd?
  _getError(e = 0) {
    const t = {
      /* Z_NEED_DICT       2  */
      2: "need dictionary",
      /* Z_STREAM_END      1  */
      1: "stream end",
      /* Z_OK              0  */
      0: "",
      /* Z_ERRNO         (-1) */
      "-1": "file error",
      /* Z_STREAM_ERROR  (-2) */
      "-2": "stream error",
      /* Z_DATA_ERROR    (-3) */
      "-3": "data error",
      /* Z_MEM_ERROR     (-4) */
      "-4": "insufficient memory",
      /* Z_BUF_ERROR     (-5) */
      "-5": "buffer error",
      /* Z_VERSION_ERROR (-6) */
      "-6": "incompatible version"
    };
    return `${this.name}: ${t[e]}`;
  }
}
class Rge extends Mge {
  name = "gzip";
  extensions = ["gz", "gzip"];
  contentEncodings = ["gzip", "x-gzip"];
  isSupported = !0;
  constructor(e) {
    super({ ...e, deflate: { ...e?.gzip, gzip: !0 } });
  }
}
function Ey(r, e, t, n) {
  const i = e.type === 2 ? e.readVarint() + e.pos : e.pos + 1, s = e.buf.buffer.slice(e.pos, i);
  if (n?.compression === "gzip") {
    const l = new Rge().decompressSync(s);
    t.value = new r(l);
  } else
    t.value = new r(s);
  return e.pos = i, t.value;
}
class _T {
  static read(e, t) {
    return e.readFields(_T._readField, { key: "", value: null }, t);
  }
  static _readField(e, t, n) {
    e === 1 ? t.key = n.readString() : e === 2 && (t.value = n.readString());
  }
}
class bh {
  static read(e, t) {
    return e.readFields(bh._readField, {}, t);
  }
  static _readField(e, t, n) {
    if (e === 1) {
      const { key: i, value: s } = _T.read(n, n.readVarint() + n.pos);
      t[i] = s;
    }
  }
}
class M0 {
  static read(e, t) {
    const { value: n, size: i } = e.readFields(M0._readField, { value: [], size: 0 }, t);
    return { value: n, size: i };
  }
  static _readField(e, t, n) {
    e === 1 ? Ey(Float64Array, n, t) : e === 2 && (t.size = n.readVarint(!0));
  }
}
class Ra {
  static read(e, t) {
    const { value: n, size: i } = e.readFields(Ra._readField, { value: [], size: 0 }, t);
    return { value: new Uint32Array(n), size: i };
  }
  static _readField(e, t, n) {
    e === 1 ? n.readPackedVarint(t.value) : e === 2 && (t.size = n.readVarint(!0));
  }
}
class R0 {
  static read(e, t) {
    return e.readFields(R0._readField, { id: 0 }, t);
  }
  static _readField(e, t, n) {
    e === 1 && (t.id = n.readVarint());
  }
}
class yT {
  static read(e, t) {
    return e.readFields(yT._readField, { value: [] }, t);
  }
  static _readField(e, t, n) {
    e === 1 && Ey(Float64Array, n, t);
  }
}
class xh {
  static read(e, t) {
    return e.readFields(xh._readField, { key: "", value: null }, t);
  }
  static _readField(e, t, n) {
    e === 1 ? t.key = n.readString() : e === 2 && (t.value = yT.read(n, n.readVarint() + n.pos));
  }
}
class vT {
  static read(e, t) {
    return e.readFields(vT._readField, {
      positions: null,
      globalFeatureIds: null,
      featureIds: null,
      properties: [],
      numericProps: {},
      fields: []
    }, t);
  }
  static _readField(e, t, n) {
    if (e === 1)
      t.positions = M0.read(n, n.readVarint() + n.pos);
    else if (e === 2)
      t.globalFeatureIds = Ra.read(n, n.readVarint() + n.pos);
    else if (e === 3)
      t.featureIds = Ra.read(n, n.readVarint() + n.pos);
    else if (e === 4)
      t.properties.push(bh.read(n, n.readVarint() + n.pos));
    else if (e === 5) {
      const i = xh.read(n, n.readVarint() + n.pos);
      t.numericProps[i.key] = i.value;
    } else e === 6 && t.fields.push(R0.read(n, n.readVarint() + n.pos));
  }
}
class bT {
  static read(e, t) {
    return e.readFields(bT._readField, {
      positions: null,
      pathIndices: null,
      globalFeatureIds: null,
      featureIds: null,
      properties: [],
      numericProps: {},
      fields: []
    }, t);
  }
  static _readField(e, t, n) {
    if (e === 1)
      t.positions = M0.read(n, n.readVarint() + n.pos);
    else if (e === 2)
      t.pathIndices = Ra.read(n, n.readVarint() + n.pos);
    else if (e === 3)
      t.globalFeatureIds = Ra.read(n, n.readVarint() + n.pos);
    else if (e === 4)
      t.featureIds = Ra.read(n, n.readVarint() + n.pos);
    else if (e === 5)
      t.properties.push(bh.read(n, n.readVarint() + n.pos));
    else if (e === 6) {
      const i = xh.read(n, n.readVarint() + n.pos);
      t.numericProps[i.key] = i.value;
    } else e === 7 && t.fields.push(R0.read(n, n.readVarint() + n.pos));
  }
}
class xT {
  static read(e, t) {
    return e.readFields(xT._readField, {
      positions: null,
      polygonIndices: null,
      globalFeatureIds: null,
      featureIds: null,
      primitivePolygonIndices: null,
      triangles: null,
      properties: [],
      numericProps: {},
      fields: []
    }, t);
  }
  static _readField(e, t, n) {
    if (e === 1)
      t.positions = M0.read(n, n.readVarint() + n.pos);
    else if (e === 2)
      t.polygonIndices = Ra.read(n, n.readVarint() + n.pos);
    else if (e === 3)
      t.globalFeatureIds = Ra.read(n, n.readVarint() + n.pos);
    else if (e === 4)
      t.featureIds = Ra.read(n, n.readVarint() + n.pos);
    else if (e === 5)
      t.primitivePolygonIndices = Ra.read(n, n.readVarint() + n.pos);
    else if (e === 6)
      t.triangles = Ra.read(n, n.readVarint() + n.pos);
    else if (e === 7)
      t.properties.push(bh.read(n, n.readVarint() + n.pos));
    else if (e === 8) {
      const i = xh.read(n, n.readVarint() + n.pos);
      t.numericProps[i.key] = i.value;
    } else e === 9 && t.fields.push(R0.read(n, n.readVarint() + n.pos));
  }
}
let Bge = class bF {
  static read(e, t) {
    return e.readFields(bF._readField, { points: null, lines: null, polygons: null }, t);
  }
  static _readField(e, t, n) {
    e === 1 ? t.points = vT.read(n, n.readVarint() + n.pos) : e === 2 ? t.lines = bT.read(n, n.readVarint() + n.pos) : e === 3 && (t.polygons = xT.read(n, n.readVarint() + n.pos));
  }
};
class wT {
  static read(e, t) {
    return e.readFields(wT._readField, { value: [] }, t);
  }
  static _readField(e, t, n) {
    e === 1 && Ey(BigUint64Array, n, t);
  }
}
class TT {
  static read(e, t) {
    return e.readFields(TT._readField, { indices: null, properties: [], numericProps: {} }, t);
  }
  static _readField(e, t, n) {
    if (e === 1)
      t.indices = wT.read(n, n.readVarint() + n.pos);
    else if (e === 2)
      t.properties.push(bh.read(n, n.readVarint() + n.pos));
    else if (e === 3) {
      const i = xh.read(n, n.readVarint() + n.pos);
      t.numericProps[i.key] = i.value;
    }
  }
}
let Oge = class xF {
  static read(e, t) {
    return e.readFields(xF._readField, { scheme: 0, cells: null }, t);
  }
  static _readField(e, t, n) {
    e === 1 ? t.scheme = n.readVarint() : e === 2 && (t.cells = TT.read(n, n.readVarint() + n.pos));
  }
};
function Cy(r, e) {
  const t = new bAe(r);
  return e.read(t);
}
function Dge(r) {
  const { cells: e, scheme: t } = r, n = e.indices.value.length, i = [];
  for (let s = 0; s < n; s++) {
    const o = t === "h3" ? j2(e.indices.value[s]) : e.indices.value[s], l = { ...e.properties[s] };
    for (const u of Object.keys(e.numericProps))
      l[u] = e.numericProps[u].value[s];
    i.push({ id: o, properties: l });
  }
  return i;
}
const wF = "9.2.2", TF = "cartoSpatialTile", Lge = {
  cartoSpatialTile: {
    scheme: "quadbin",
    workerUrl: wy(TF, wF)
  }
}, EF = {
  name: "CARTO Spatial Tile",
  version: wF,
  id: TF,
  module: "carto",
  extensions: ["pbf"],
  mimeTypes: ["application/vnd.carto-spatial-tile"],
  category: "geometry",
  parse: async (r, e) => P4(r, e),
  parseSync: P4,
  worker: !0,
  options: Lge
};
function P4(r, e) {
  if (!r)
    return null;
  const t = Cy(r, Oge), { cells: n } = t, i = e?.cartoSpatialTile?.scheme;
  return Dge({ cells: n, scheme: i });
}
function jp(r, e, t = 0) {
  if (!r)
    return e;
  if (!e)
    return r;
  if (t > 10)
    return e;
  const n = { ...r };
  for (const i in e) {
    const s = e[i];
    s === r || s === e || (typeof s == "object" && s !== null ? n[i] = jp(r[i], s, t + 1) : n[i] = s);
  }
  return n;
}
function kge(r, e) {
  const t = {};
  for (const { geoid: n, ...i } of e.properties)
    n in t ? Jr.warn("Duplicate geoid key in boundary mapping, using first occurance")() : t[n] = i;
  for (const n of ["points", "lines", "polygons"]) {
    const i = r[n];
    if (i.positions.value.length === 0)
      continue;
    i.properties = i.properties.map(({ geoid: m }) => t[m]);
    const { positions: s, globalFeatureIds: o } = i;
    let l = null;
    n === "lines" && (l = i.pathIndices.value), n === "polygons" && (l = i.polygonIndices.value);
    const u = s.value.length / s.size;
    for (const m in e.numericProps) {
      const y = e.numericProps[m].value, E = y.constructor, P = new E(u);
      if (i.numericProps[m] = { value: P, size: 1 }, l)
        for (let L = 0; L < l.length - 1; L++) {
          const U = l[L], V = l[L + 1], q = o.value[U];
          P.fill(y[q], U, V);
        }
      else
        for (let L = 0; L < u; L++) {
          const U = o.value[L];
          P[L] = y[U];
        }
    }
  }
  return r;
}
const hh = {
  type: "object",
  value: null,
  validate: (r, e) => e.optional && r === null || typeof r == "object" && Array.isArray(r.tiles) && r.tiles.every((t) => typeof t == "string"),
  equal: (r, e) => Fi(r, e, 2),
  async: !0
};
Op([EF]);
function M4(r) {
  if (r === mT)
    return "h3";
  if (r === Ty)
    return "quadbin";
  throw new Error("Invalid tileset class");
}
const CF = {
  data: hh,
  clusterLevel: { type: "number", value: 5, min: 1 },
  getPosition: {
    type: "accessor",
    value: ({ id: r }) => {
      if (typeof r == "string") {
        const [e, t] = ay(r);
        return [t, e];
      }
      return vF(r, 0.5).slice(2, 4);
    }
  },
  getWeight: { type: "accessor", value: 1 },
  refinementStrategy: "no-overlap",
  tileSize: Vp
};
class ET extends ou {
  initializeState() {
    super.initializeState(), this.state.aggregationCache = /* @__PURE__ */ new WeakMap(), this.state.scheme = M4(this.props.TilesetClass);
  }
  updateState(e) {
    const { props: t } = e, n = M4(t.TilesetClass);
    this.state.scheme !== n && (this.setState({ scheme: n, tileset: null }), this.state.aggregationCache = /* @__PURE__ */ new WeakMap()), super.updateState(e);
  }
  // eslint-disable-next-line max-statements
  renderLayers() {
    const e = this.state.tileset?.tiles.filter((L) => L.isLoaded && L.content && this.state.tileset.isTileVisible(L));
    if (!e?.length || !this.state.tileset)
      return null;
    e.sort((L, U) => U.zoom - L.zoom);
    const { getPosition: t, getWeight: n } = this.props, { aggregationCache: i, scheme: s } = this.state, o = s === "h3", l = _ge(e[0]), u = [];
    let m = !1;
    const y = this._getAggregationLevels(e);
    for (const L of e) {
      let U = i.get(L.content);
      U || (U = /* @__PURE__ */ new Map(), i.set(L.content, U));
      const V = mge(L, U, y, l, t, n, o ? "h3" : "quadbin");
      m || (m = V), u.push(...U.get(y));
    }
    u.sort((L, U) => Number(U.count - L.count));
    const E = u?.map((L) => L.id);
    if (m || (m = !Fi(E, this.state.clusterIds, 1)), this.setState({ clusterIds: E }), m) {
      const L = yge(u, l), U = vge(u);
      U.points.attributes = { stats: L }, this.setState({ data: U });
    }
    const P = {
      ...this.props,
      id: "clusters",
      data: this.state.data,
      dataComparator: (L, U) => {
        const V = L?.points?.properties?.map((j) => j.id), q = U?.points?.properties?.map((j) => j.id);
        return Fi(V, q, 1);
      }
    };
    return new iu(this.getSubLayerProps(P));
  }
  getPickingInfo(e) {
    const t = e.info;
    if (t.index !== -1) {
      const { data: n } = e.sourceLayer.props;
      t.object = V2(n, {
        globalFeatureId: t.index
      });
    }
    return t;
  }
  _updateAutoHighlight(e) {
    for (const t of this.getSubLayers())
      t.updateAutoHighlight(e);
  }
  filterSubLayer() {
    return !0;
  }
  _getAggregationLevels(e) {
    const t = this.state.scheme === "h3", n = e[0];
    let i, s;
    t ? (i = lh(n.id), s = I_(this.context.viewport, this.state.tileset.opts.tileSize)) : (i = n.zoom, s = this.context.viewport.zoom);
    const o = Math.round(s - i);
    return Math.round(this.props.clusterLevel) - o;
  }
}
ET.layerName = "ClusterGeoJsonLayer";
ET.defaultProps = CF;
class CT extends Ps {
  getLoadOptions() {
    const e = this.props.data, t = e && "scheme" in e ? e.scheme : "quadbin";
    return jp(super.getLoadOptions(), {
      fetch: { headers: { Authorization: `Bearer ${e.accessToken}` } },
      cartoSpatialTile: { scheme: t }
    });
  }
  renderLayers() {
    const e = this.props.data;
    if (!e)
      return null;
    const { tiles: t, maxresolution: n } = e, s = e && "scheme" in e && e.scheme === "h3" ? mT : Ty;
    return [
      // @ts-ignore
      new ET(this.props, {
        id: `cluster-geojson-layer-${this.props.id}`,
        data: t,
        // TODO: Tileset2D should be generic over TileIndex type
        TilesetClass: s,
        maxZoom: n,
        loadOptions: this.getLoadOptions()
      })
    ];
  }
}
CT.layerName = "ClusterTileLayer";
CT.defaultProps = CF;
Op([EF]);
function Fge(r) {
  return r != null && r !== "";
}
const Nge = {
  tileSize: Vp
};
class Sy extends ou {
  _updateAutoHighlight(e) {
    const { hoveredFeatureId: t } = this.state, n = e.object;
    let i = null;
    if (n && (i = n.id), t !== i) {
      let { highlightColor: s } = this.props;
      typeof s == "function" && (s = s(e)), this.setState({
        highlightColor: s,
        hoveredFeatureId: i
      });
    }
  }
  getSubLayerPropsByTile(e) {
    return {
      highlightedObjectIndex: this.getHighlightedObjectIndex(e),
      highlightColor: this.state.highlightColor
    };
  }
  getHighlightedObjectIndex(e) {
    const { hoveredFeatureId: t } = this.state, n = e.content;
    return !Fge(t) || !Array.isArray(n) || // Quick check for whether id is within tile. data.findIndex is expensive
    !this._featureInTile(e, t) ? -1 : n.findIndex((s) => s.id === t);
  }
  _featureInTile(e, t) {
    const n = this.state.tileset, i = n.getTileZoom(e.index), s = e.index.q ? "q" : "i";
    let o = { [s]: t }, l = n.getTileZoom(o);
    for (; !(l <= i); )
      o = n.getParentIndex(o), l = n.getTileZoom(o);
    return o[s] === e.index[s];
  }
}
Sy.layerName = "SpatialIndexTileLayer";
Sy.defaultProps = Nge;
const Uge = (r) => {
  const { data: e } = r, { index: t } = r.tile;
  return !e || !e.length ? null : new pc(r, {
    getHexagon: (n) => n.id,
    centerHexagon: t,
    highPrecision: !0
  });
}, zge = {
  data: hh,
  tileSize: Vp
};
class Iy extends Ps {
  initializeState() {
    pc._checkH3Lib();
  }
  getLoadOptions() {
    const e = this.props.data;
    return jp(super.getLoadOptions(), {
      fetch: { headers: { Authorization: `Bearer ${e.accessToken}` } },
      cartoSpatialTile: { scheme: "h3" }
    });
  }
  renderLayers() {
    const e = this.props.data;
    if (!e)
      return null;
    const { tiles: t } = e;
    let { minresolution: n, maxresolution: i } = e;
    this.props.minZoom && (n = Math.max(n, I_({ zoom: this.props.minZoom, latitude: 0 }, this.props.tileSize))), this.props.maxZoom && (i = Math.min(i, I_({ zoom: this.props.maxZoom, latitude: 0 }, this.props.tileSize)));
    const s = this.getSubLayerClass("spatial-index-tile", Sy);
    return new s(this.props, {
      id: `h3-tile-layer-${this.props.id}`,
      data: t,
      // TODO: Tileset2D should be generic over TileIndex type
      TilesetClass: mT,
      renderSubLayers: Uge,
      // minZoom and maxZoom are H3 resolutions, however we must use this naming as that is what the Tileset2D class expects
      minZoom: n,
      maxZoom: i,
      loadOptions: this.getLoadOptions()
    });
  }
}
Iy.layerName = "H3TileLayer";
Iy.defaultProps = zge;
const Vge = (
  /* glsl */
  `uniform heatmapUniforms {
  vec2 colorDomain;
  vec2 delta;
  float intensity;
  float opacity;
  float radiusPixels;
} heatmap;

uniform sampler2D colorTexture;

vec3 colorGradient(float value) {
  return texture(colorTexture, vec2(value, 0.5)).rgb;
}

const vec3 SHIFT = vec3(1.0, 256.0, 256.0 * 256.0);
const float MAX_VAL = SHIFT.z * 255.0;
const float SCALE = MAX_VAL / 8.0;
vec4 pack(float value) {
  return vec4(mod(vec3(value, floor(value / SHIFT.yz)), 256.0), 255.0) / 255.0;
}
float unpack(vec3 color) {
  return 255.0 * dot(color, SHIFT);
}

vec4 heatmap_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {
  bool firstPass = (heatmap.delta.y < 0.5);
  float accumulator = 0.0;

  // Controls quality of heatmap, larger values increase quality at expense of performance
  float SUPPORT = clamp(heatmap.radiusPixels / 2.0, 8.0, 32.0);

  // Gaussian normalization parameters
  float sigma = SUPPORT / 3.0;
  float a = -0.5 / (sigma * sigma);
  float w0 = 0.3989422804014327 / sigma; // 1D normalization
  for (float t = -SUPPORT; t <= SUPPORT; t++) {
    vec2 percent = (t * heatmap.delta - 0.5) / SUPPORT;
    vec2 delta = percent * heatmap.radiusPixels / texSize;
    vec4 offsetColor = texture(source, texCoord + delta);

    // Unpack float
    float value = unpack(offsetColor.rgb);

    // Gaussian
    float weight = w0 * exp(a * t * t);
    
    accumulator += value * weight;
  }

  if (firstPass) {
    return pack(accumulator);
  }

  // Undo scaling to obtain normalized density
  float density = 10.0 * heatmap.intensity * accumulator / SCALE;
 
  // Domain also in normalized density units
  vec2 domain = heatmap.colorDomain;

  // Apply domain
  float f = (density - domain[0]) / (domain[1] - domain[0]);

  // sqrt/log scaling??
  // float f = (log(density) - log(domain[0] + 1.0)) / (log(domain[1] + 1.0) - log(domain[0] + 1.0));
  // f = sqrt(f);

  // Color map
  vec4 color = vec4(0.0);
  color.rgb = colorGradient(f);

  color.a = smoothstep(0.0, 0.1, f);
  color.a = pow(color.a, 1.0 / 2.2);
  color.a *= heatmap.opacity;

  // Use premultiplied alpha for compatibility with blending in ScreenPass
  color.rgb *= color.a;

  return color;
}
`
), SF = {
  name: "heatmap",
  uniformPropTypes: {
    colorDomain: { value: [0, 1] },
    delta: { value: [0, 1] },
    intensity: { value: 1, min: 0.1, max: 10 },
    opacity: { value: 1, min: 0, max: 1 },
    radiusPixels: { value: 20, min: 0, softMax: 100 }
  },
  uniformTypes: {
    colorDomain: "vec2<f32>",
    delta: "vec2<f32>",
    intensity: "f32",
    opacity: "f32",
    radiusPixels: "f32"
  },
  // @ts-ignore TODO v9.1
  getUniforms: (r) => {
    if (!r)
      return {};
    const { colorDomain: e = [0, 1], colorTexture: t, delta: n = [1, 0], intensity: i = 1, opacity: s = 1, radiusPixels: o = 20 } = r;
    return {
      colorDomain: e,
      colorTexture: t,
      delta: n,
      intensity: i,
      opacity: s,
      radiusPixels: o
    };
  },
  fs: Vge,
  passes: [
    // @ts-expect-error Seems typing in luma.gl should be Partial<>
    { sampler: !0, uniforms: { delta: [1, 0] } },
    // @ts-expect-error Seems typing in luma.gl should be Partial<>
    { sampler: !0, uniforms: { delta: [0, 1] } }
  ]
}, jge = {
  format: "rgba8unorm",
  width: 1,
  height: 1,
  sampler: {
    minFilter: "linear",
    magFilter: "linear",
    addressModeU: "clamp-to-edge",
    addressModeV: "clamp-to-edge"
  }
};
function H2(r) {
  for (; r.parent && !r.applyPostProcess; )
    r = r.parent;
  return r;
}
class IF extends Is {
  initializeState() {
    this.id = `draw-callback-${H2(this).props.id}`;
  }
  _drawLayer() {
    H2(this).applyPostProcess();
  }
}
IF.layerName = "DrawCallbackLayer";
function PF(r) {
  var e;
  return e = class extends r {
    draw(n) {
      const { shaderModuleProps: i } = n, { picking: s } = i, o = H2(this);
      s.isActive || o.enableRTT(n), super.draw(n), s.isActive || o.disableRTT();
    }
  }, // @ts-expect-error typescript doesn't see static property
  e.layerName = `RTT-${r.layerName}`, e;
}
function ST(r, e) {
  var t;
  return t = class extends r {
    initializeState(i) {
      super.initializeState(i), this._createTextures(), this.internalState.postProcess = new jW(e, this.props), this.internalState.postProcess.setup(i);
    }
    updateState(i) {
      super.updateState(i), this.internalState.postProcess.setProps(this.props);
    }
    renderLayers() {
      let i = super.renderLayers();
      return i ? (i = Array.isArray(i) ? i : [i], [...i, new IF()]) : null;
    }
    _createTextures() {
      const { device: i } = this.context;
      this.internalState.renderBuffers = [0, 1].map((s) => i.createFramebuffer({
        id: `layer-fbo-${s}`,
        colorAttachments: [i.createTexture(jge)],
        depthStencilAttachment: "depth16unorm"
      }));
    }
    _resizeBuffers(i) {
      const { shaderModuleProps: s } = i, { viewport: o } = this.context, { devicePixelRatio: l } = s.project, u = l * o.width, m = l * o.height;
      this.internalState.renderBuffers.forEach((y) => y.resize({ width: u, height: m }));
    }
    enableRTT(i) {
      this._resizeBuffers(i), this.internalState.originalRenderPass = this.context.renderPass;
      const [s] = this.internalState.renderBuffers;
      this.internalState.internalRenderPass = this.context.device.beginRenderPass({
        framebuffer: s,
        parameters: { viewport: [0, 0, s.width, s.height] },
        // Only clear on first render
        clearColor: this.internalState.renderInProgress ? !1 : [0, 0, 0, 0]
      }), this.internalState.renderInProgress = !0, this.context.renderPass = this.internalState.internalRenderPass;
    }
    disableRTT() {
      this.internalState.internalRenderPass.end(), this.context.renderPass = this.internalState.originalRenderPass;
    }
    applyPostProcess() {
      if (!this.internalState.renderInProgress)
        return;
      const [i, s] = this.internalState.renderBuffers, { framebuffer: o } = this.context.renderPass.props;
      this.internalState.postProcess.postRender({
        inputBuffer: i,
        swapBuffer: s,
        target: o
      }), this.internalState.renderInProgress = !1;
    }
    _finalize() {
      this.internalState.renderBuffers.forEach((i) => {
        i.destroy();
      }), this.internalState.renderBuffers = null, this.internalState.postProcess.cleanup();
    }
  }, t.layerName = `PostProcess${r.layerName}`, t;
}
const Hge = (
  /* glsl */
  `vec4 copy_filterColor_ext(vec4 color, vec2 texSize, vec2 texCoord) {
  return color;
}
`
), Gge = {
  name: "copy",
  fs: Hge,
  getUniforms: () => ({}),
  passes: [{ filter: !0 }]
}, Wge = {
  getQuadbin: { type: "accessor", value: (r) => r.quadbin }
};
class IT extends su {
  indexToBounds() {
    const { data: e, extruded: t, getQuadbin: n } = this.props, i = t ? 0.99 : 1;
    return {
      data: e,
      _normalize: !1,
      positionFormat: "XY",
      getPolygon: (s, o) => vF(n(s, o), i),
      updateTriggers: { getPolygon: i }
    };
  }
}
IT.layerName = "QuadbinLayer";
IT.defaultProps = Wge;
const $ge = (r) => {
  const { data: e } = r;
  if (!e || !e.length)
    return null;
  const t = typeof e[0].id == "bigint";
  return new IT(r, {
    getQuadbin: t ? (n) => n.id : (n) => pge(n.id)
  });
}, qge = {
  data: hh,
  tileSize: Vp
};
class Py extends Ps {
  getLoadOptions() {
    const e = this.props.data;
    return jp(super.getLoadOptions(), {
      fetch: { headers: { Authorization: `Bearer ${e.accessToken}` } },
      cartoSpatialTile: { scheme: "quadbin" }
    });
  }
  renderLayers() {
    const e = this.props.data;
    if (!e)
      return null;
    const { tiles: t, maxresolution: n } = e, i = this.getSubLayerClass("spatial-index-tile", Sy);
    return new i(this.props, {
      id: `quadbin-tile-layer-${this.props.id}`,
      data: t,
      // TODO: Tileset2D should be generic over TileIndex type
      TilesetClass: Ty,
      renderSubLayers: $ge,
      maxZoom: n,
      loadOptions: this.getLoadOptions()
    });
  }
}
Py.layerName = "QuadbinTileLayer";
Py.defaultProps = qge;
const Xge = [
  [255, 255, 178],
  [254, 217, 118],
  [254, 178, 76],
  [253, 141, 60],
  [240, 59, 32],
  [189, 0, 38]
], Zge = {
  format: "rgba8unorm",
  dimension: "2d",
  width: 1,
  height: 1,
  sampler: {
    minFilter: "linear",
    magFilter: "linear",
    addressModeU: "clamp-to-edge",
    addressModeV: "clamp-to-edge"
  }
};
function MF(r) {
  const e = Number(AT(r));
  return Math.pow(4, e);
}
function RF(r) {
  const e = Number(lh(r));
  return wce(e);
}
function Yge(r) {
  const e = new Uint8Array(r.length * 4);
  let t = 0;
  for (let n = 0; n < r.length; n++) {
    const i = r[n];
    e[t++] = i[0], e[t++] = i[1], e[t++] = i[2], e[t++] = Number.isFinite(i[3]) ? i[3] : 255;
  }
  return e;
}
const Kge = `uniform densityUniforms {
  float factor;
} density;
`, Qge = {
  name: "density",
  vs: Kge,
  uniformTypes: {
    factor: "f32"
  }
};
class BF extends PF(sf) {
  getShaders(e) {
    const t = super.getShaders(e);
    return t.inject = {
      "vs:#main-end": `
      // Value from getWeight accessor
  float weight = elevations;

  // Keep "power" delivered to screen constant when tiles update
  // by outputting normalized density
  weight *= density.factor;

  // Pack float into 3 channels to pass to heatmap shader
  // SCALE value important, as we don't want to saturate
  // but also want enough definition to avoid banding
  const vec3 SHIFT = vec3(1.0, 256.0, 256.0 * 256.0);
  const float MAX_VAL = SHIFT.z * 255.0;
  const float SCALE = MAX_VAL / 8.0;
  weight *= SCALE;
  weight = clamp(weight, 0.0, MAX_VAL);
  vColor = vec4(mod(vec3(weight, floor(weight / SHIFT.yz)), 256.0), 255.0) / 255.0;
`
    }, t.modules = [...t.modules, Qge], t;
  }
  draw(e) {
    const t = this.props.data[0];
    if (t) {
      const n = this.props.elevationScale, { scheme: i } = this.parent.parent.parent.parent.parent.state, o = { factor: (i === "h3" ? RF(t.id) : MF(t.id)) / n };
      for (const l of this.state.models)
        l.shaderInputs.setProps({ density: o });
    }
    super.draw(e);
  }
}
BF.layerName = "RTTSolidPolygonLayer";
const Jge = ST(Py, SF), eme = ST(Iy, SF), tme = {
  data: hh,
  getWeight: { type: "accessor", value: 1 },
  onMaxDensityChange: { type: "function", optional: !0, value: null },
  colorDomain: { type: "array", value: [0, 1] },
  colorRange: Xge,
  intensity: { type: "number", value: 1 },
  radiusPixels: { type: "number", min: 0, max: 100, value: 20 }
};
class PT extends Ps {
  initializeState() {
    this.state = {
      isLoaded: !1,
      scheme: null,
      tiles: /* @__PURE__ */ new Set(),
      viewportChanged: !1
    };
  }
  shouldUpdateState({ changeFlags: e }) {
    const { viewportChanged: t } = e;
    return this.setState({ viewportChanged: t }), e.somethingChanged;
  }
  updateState(e) {
    const { props: t, oldProps: n } = e;
    super.updateState(e), Fi(t.colorRange, n.colorRange, 2) || this._updateColorTexture(e);
    const i = t.data && "scheme" in t.data ? t.data.scheme : null;
    this.state.scheme !== i && (this.setState({ scheme: i }), this.state.tiles.clear());
  }
  renderLayers() {
    const { data: e, getWeight: t, colorDomain: n, intensity: i, radiusPixels: s, _subLayerProps: o, updateTriggers: l, onMaxDensityChange: u, onViewportLoad: m, onTileLoad: y, onTileUnload: E, ...P } = this.props, L = this.state.scheme === "h3", U = L ? "hexagon-cell-hifi" : "cell", V = {
      ...o,
      [U]: {
        ...o?.[U],
        _subLayerProps: {
          ...o?.[U]?._subLayerProps,
          fill: {
            ...o?.[U]?._subLayerProps?.fill,
            type: BF
          }
        }
      }
    };
    let q = 0, j = 0;
    const K = [...this.state.tiles].filter((fe) => fe.content), Y = K.filter((fe) => fe.isVisible), de = Y.length ? Y : K;
    for (const fe of de) {
      const ve = fe.content[0], me = L ? RF(ve.id) : MF(ve.id);
      j = Math.max(fe.userData.maxWeight * me, j), q = Math.max(fe.zoom, q);
    }
    let ne, ae;
    L ? (ne = 2 / 3 * this.context.viewport.zoom - q - 2.25, ae = 2.2) : (ne = this.context.viewport.zoom - q, ae = 2), j = j * Math.pow(ae, ne), typeof u == "function" && u(j);
    const De = L ? eme : Jge, Ge = P;
    return new De(Ge, this.getSubLayerProps({
      id: "heatmap",
      data: e,
      // Re-use existing props to pass down values to sublayer
      // TODO replace with custom layer
      getFillColor: 0,
      getElevation: t,
      elevationScale: j,
      colorDomain: n,
      radiusPixels: s,
      intensity: i,
      _subLayerProps: V,
      refinementStrategy: "no-overlap",
      colorTexture: this.state.colorTexture,
      // Disable line rendering
      extruded: !1,
      stroked: !1,
      updateTriggers: {
        getElevation: l.getWeight
      },
      // Tile stats
      onViewportLoad: (fe) => {
        this.setState({ isLoaded: !0 }), typeof m == "function" && m(fe);
      },
      onTileLoad: (fe) => {
        let ve = -1 / 0;
        if (typeof t != "function")
          ve = t;
        else if (fe.content)
          for (const me of fe.content)
            ve = Math.max(t(me, {}), ve);
        fe.userData = { maxWeight: ve }, this.state.tiles.add(fe), typeof y == "function" && y(fe);
      },
      onTileUnload: (fe) => {
        this.state.tiles.delete(fe), typeof E == "function" && E(fe);
      },
      transitions: { elevationScale: { type: "spring", stiffness: 0.3, damping: 0.5 } }
    }));
  }
  _updateColorTexture(e) {
    const { colorRange: t } = e.props;
    let { colorTexture: n } = this.state;
    const i = Yge(t);
    n?.destroy(), n = this.context.device.createTexture({
      ...Zge,
      data: i,
      width: t.length,
      height: 1
    }), this.setState({ colorTexture: n });
  }
}
PT.layerName = "HeatmapTileLayer";
PT.defaultProps = tme;
const [R4, B4, O4, D4] = [0, 1, 2, 3];
class OF extends E0 {
  getShaders() {
    const e = super.getShaders();
    let t = e.vs;
    return t = t.replaceAll("textBackground.padding.", "_padding."), t = t.replace("void main(void) {", `void main(void) {
  vec4 _padding = textBackground.padding + instancePixelOffsets.xyxy * vec4(1.0, 1.0, -1.0, -1.0);`), { ...e, vs: t };
  }
}
OF.layerName = "EnhancedTextBackgroundLayer";
class DF extends yh {
  filterSubLayer({ layer: e, renderPass: t }) {
    const n = e.id.includes("primary-background");
    return t === "collision" ? n : !n;
  }
}
DF.layerName = "EnhancedTextLayer";
const rme = {
  ...yh.defaultProps,
  getRadius: { type: "accessor", value: 1 },
  radiusScale: { type: "number", min: 0, value: 1 }
};
class My extends Ps {
  calculatePixelOffset(e) {
    const { getTextAnchor: t, getAlignmentBaseline: n, getRadius: i, getSecondaryText: s, radiusScale: o, secondarySizeScale: l, sizeScale: u } = this.props, m = t === "middle" ? 0 : t === "start" ? 1 : -1, y = n === "center" ? 0 : n === "bottom" ? 1 : -1, E = u / 4, P = u * (1 + 1 / 4), L = 0.6 * (1 - y) * u;
    let U = e ? L : 0;
    t === "middle" && n === "top" && s && (U -= L, U -= l, U += u);
    const V = 1 + 1 / 4;
    return typeof i == "function" ? (q, j) => {
      const K = (j ? i(q, j) : 1) * o * V;
      return [m * (K + E), y * (K + P) + U];
    } : [
      m * (i * o * V + E),
      y * (i * o * V + P) + U
    ];
  }
  calculateBackgroundPadding() {
    const { getTextAnchor: e, getAlignmentBaseline: t, sizeScale: n } = this.props, i = 12 * n, s = 3 * n, o = [0, 0, 0, 0];
    return t === "top" ? o[B4] = s : t === "bottom" ? o[D4] = s : (o[B4] = 0.5 * s, o[D4] = 0.5 * s), e === "start" ? o[R4] = i : e === "end" ? o[O4] = i : (o[R4] = 0.5 * i, o[O4] = 0.5 * i), o;
  }
  renderTextLayer(e, { updateTriggers: t = {}, ...n }) {
    const { data: i, characterSet: s, fontFamily: o, fontSettings: l, fontWeight: u, outlineColor: m, outlineWidth: y, sizeScale: E, radiusScale: P, getAlignmentBaseline: L, getColor: U, getPosition: V, getTextAnchor: q, updateTriggers: j } = this.props;
    if (E < 2) {
      const K = this.parent?.props?.textSizeScale ? "textSizeScale" : "sizeScale";
      Jr.warn(`${K} has small value (${E}). Note getTextSize is not supported on PointLabelLayer`)();
    }
    return new DF(this.getSubLayerProps({
      id: e,
      data: i,
      characterSet: s,
      fontFamily: o,
      fontSettings: l,
      fontWeight: u,
      outlineColor: m,
      outlineWidth: y,
      sizeScale: E,
      getAlignmentBaseline: L,
      getColor: U,
      getPosition: V,
      getTextAnchor: q,
      updateTriggers: {
        ...j,
        ...t,
        getPixelOffset: [
          j.getRadius,
          j.getTextAnchor,
          j.getAlignmentBaseline,
          P,
          E
        ]
      }
    }), {
      getSize: 1,
      _subLayerProps: { background: { type: OF } }
    }, n);
  }
  renderLayers() {
    const { getText: e, getSecondaryColor: t, getSecondaryText: n, secondaryOutlineColor: i, secondarySizeScale: s, updateTriggers: o } = this.props, l = this.calculatePixelOffset(!1), u = this.calculateBackgroundPadding();
    return [
      // Text doesn't update via updateTrigger for some reason
      this.renderTextLayer(`${o.getText}-primary`, {
        backgroundPadding: u,
        getText: e,
        getPixelOffset: l,
        background: !0
        // Only use background for primary label for faster collisions
      }),
      !!n && this.renderTextLayer(`${o.getSecondaryText}-secondary`, {
        getText: n,
        getPixelOffset: this.calculatePixelOffset(!0),
        getAlignmentBaseline: "top",
        // updateTriggers: {getText: updateTriggers.getSecondaryText},
        // Optional overrides
        ...t && { getColor: t },
        ...s && { sizeScale: s },
        ...i && { outlineColor: i }
      })
    ];
  }
}
My.layerName = "PointLabelLayer";
My.defaultProps = rme;
const nme = `#version 300 es
#define SHADER_NAME raster-layer-vertex-shader
in vec3 positions;
in vec3 normals;
in float instanceElevations;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in vec3 instancePickingColors;
out vec4 vColor;
#ifdef FLAT_SHADING
out vec4 position_commonspace;
#endif
void main(void) {
vec2 tileOrigin = column.offset.xy;
float scale = column.widthScale;
int yIndex = - (gl_InstanceID / BLOCK_WIDTH);
int xIndex = gl_InstanceID + (yIndex * BLOCK_WIDTH);
vec2 cellCenter = scale * vec2(float(xIndex) + 0.5, float(yIndex) - 0.5);
vec4 color = column.isStroke ? instanceLineColors : instanceFillColors;
float shouldRender = float(color.a > 0.0 && instanceElevations >= 0.0);
float cellWidth = column.coverage * scale;
geometry.position = vec4(tileOrigin, 0.0, 1.0);
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
geometry.position.xyz -= project.commonOrigin;
}
geometry.position.xy += cellCenter;
float elevation = 0.0;
float strokeOffsetRatio = 1.0;
if (column.extruded) {
elevation = instanceElevations * (positions.z + 1.0) / 2.0 * column.elevationScale;
} else if (column.stroked) {
float halfOffset = project_pixel_size(column.widthScale) / cellWidth;
if (column.isStroke) {
strokeOffsetRatio -= sign(positions.z) * halfOffset;
} else {
strokeOffsetRatio -= halfOffset;
}
}
geometry.pickingColor = instancePickingColors;
vec2 base = positions.xy * scale * strokeOffsetRatio * column.coverage * shouldRender;
vec3 cell = vec3(base, project_size(elevation));
DECKGL_FILTER_SIZE(cell, geometry);
geometry.position.xyz += cell;
gl_Position = project_common_position_to_clipspace(geometry.position);
geometry.normal = project_normal(normals);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
if (column.extruded && !column.isStroke) {
#ifdef FLAT_SHADING
position_commonspace = geometry.position;
vColor = vec4(color.rgb, color.a * layer.opacity);
#else
vec3 lightColor = lighting_getLightColor(color.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, color.a * layer.opacity);
#endif
} else {
vColor = vec4(color.rgb, color.a * layer.opacity);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, ime = {
  ...dc.defaultProps,
  extruded: !1,
  diskResolution: 4,
  vertices: [
    [-0.5, -0.5],
    [0.5, -0.5],
    [0.5, 0.5],
    [-0.5, 0.5]
  ]
};
class LF extends PF(dc) {
  getShaders() {
    const e = super.getShaders(), t = this.props.data, n = t.data.blockSize ?? Math.sqrt(t.length);
    return { ...e, defines: { ...e.defines, BLOCK_WIDTH: n }, vs: nme };
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instanceElevations: {
        size: 1,
        transition: !0,
        accessor: "getElevation"
      },
      instanceFillColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: !0,
        accessor: "getFillColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: !0,
        accessor: "getLineColor",
        defaultValue: [255, 255, 255, 255]
      }
    });
  }
}
LF.layerName = "RasterColumnLayer";
function sme(r, e) {
  return r.data === e.data && r.length === e.length;
}
class MT extends Ps {
  renderLayers() {
    const { data: e, getElevation: t, getFillColor: n, getLineColor: i, getLineWidth: s, tileIndex: o, updateTriggers: l } = this.props;
    if (!e || !o)
      return null;
    const u = e.blockSize ?? 0, [m, y, E] = yF(o), P = [m, y], L = E / u, U = this.getSubLayerClass("column", LF), { highlightedObjectIndex: V, highlightColor: q } = this.state;
    return new U(this.props, this.getSubLayerProps({
      id: "cell",
      updateTriggers: l,
      getElevation: this.getSubLayerAccessor(t),
      getFillColor: this.getSubLayerAccessor(n),
      getLineColor: this.getSubLayerAccessor(i),
      getLineWidth: this.getSubLayerAccessor(s)
    }), {
      data: {
        data: e,
        // Pass through data for getSubLayerAccessor()
        length: u * u
      },
      dataComparator: sme,
      offset: P,
      lineWidthScale: L,
      // Re-use widthScale prop to pass cell scale,
      highlightedObjectIndex: V,
      highlightColor: q
    });
  }
  getSubLayerAccessor(e) {
    return typeof e != "function" ? super.getSubLayerAccessor(e) : (t, n) => {
      const { data: i, index: s } = n, o = i.data, l = gge(o.cells, s);
      return e({ properties: l }, n);
    };
  }
  getPickingInfo(e) {
    const t = super.getPickingInfo(e);
    return t.index !== -1 && (t.object = this.getSubLayerAccessor((n) => n)(void 0, {
      data: this.props,
      index: t.index
    })), t;
  }
  _updateAutoHighlight(e) {
    const { highlightedObjectIndex: t } = this.state;
    let n = -1;
    if (e.index !== -1 && (n = e.index), t !== n) {
      let { highlightColor: i } = this.props;
      typeof i == "function" && (i = i(e)), this.setState({
        highlightColor: i,
        highlightedObjectIndex: n
      });
    }
  }
}
MT.layerName = "RasterLayer";
MT.defaultProps = ime;
const ome = {
  uint8: Uint8Array,
  uint16: Uint16Array,
  uint32: Uint32Array,
  uint64: BigUint64Array,
  int8: Int8Array,
  int16: Int16Array,
  int32: Int32Array,
  int64: BigInt64Array,
  float32: Float32Array,
  float64: Float64Array
};
class RT {
  static read(e, t) {
    return e.readFields(RT._readField, { name: "", type: "", data: null }, t);
  }
  static _readField(e, t, n) {
    if (e === 1)
      t.name = n.readString();
    else if (e === 2)
      t.type = n.readString();
    else if (e === 3) {
      const i = ome[t.type];
      if (!i)
        throw Error(`Invalid data type: ${t.type}`);
      t.data = {};
      const { compression: s } = G2;
      Ey(i, n, t.data, { compression: s });
    }
  }
}
let G2 = class kF {
  static read(e, t) {
    return e.readFields(kF._readField, { blockSize: 0, bands: [] }, t);
  }
  static _readField(e, t, n) {
    e === 1 ? t.blockSize = n.readVarint() : e === 2 && t.bands.push(RT.read(n, n.readVarint() + n.pos));
  }
};
const FF = "9.2.2", NF = "cartoRasterTile", ame = {
  cartoRasterTile: {
    metadata: null,
    workerUrl: wy(NF, FF)
  }
}, lme = {
  name: "CARTO Raster Tile",
  version: FF,
  id: NF,
  module: "carto",
  extensions: ["pbf"],
  mimeTypes: ["application/vnd.carto-raster-tile"],
  category: "geometry",
  parse: async (r, e) => L4(r, e),
  parseSync: L4,
  worker: !0,
  options: ame
};
function L4(r, e) {
  const t = e?.cartoRasterTile?.metadata;
  if (!r || !t)
    return null;
  G2.compression = t.compression;
  const n = Cy(r, G2), { bands: i, blockSize: s } = n, o = {};
  for (let l = 0; l < i.length; l++) {
    const { name: u, data: m } = i[l];
    o[u] = m;
  }
  return { blockSize: s, cells: { numericProps: o, properties: [] } };
}
Op([lme]);
const cme = (r) => {
  const e = r.tile?.index?.q;
  return e ? new MT(r, { tileIndex: e }) : null;
}, ume = {
  data: hh,
  refinementStrategy: "no-overlap",
  tileSize: Vp
};
class fme extends ST(ou, Gge) {
  filterSubLayer(e) {
    const { tile: t } = e.layer.props;
    return t ? super.filterSubLayer(e) : !0;
  }
}
class BT extends Ps {
  getLoadOptions() {
    const e = this.props.data;
    return jp(super.getLoadOptions(), {
      fetch: { headers: { Authorization: `Bearer ${e.accessToken}` } }
    });
  }
  renderLayers() {
    const e = this.props.data;
    if (!e)
      return null;
    const { tiles: t, minzoom: n, maxzoom: i, raster_metadata: s } = e, o = this.getSubLayerClass("tile", fme), l = this.getLoadOptions();
    return new o(this.props, {
      id: `raster-tile-layer-${this.props.id}`,
      data: t,
      // TODO: Tileset2D should be generic over TileIndex type
      TilesetClass: Ty,
      renderSubLayers: cme,
      minZoom: n,
      maxZoom: i,
      loadOptions: {
        ...l,
        cartoRasterTile: { ...l?.cartoRasterTile, metadata: s }
      }
    });
  }
}
BT.layerName = "RasterTileLayer";
BT.defaultProps = ume;
class OT {
  static read(e, t) {
    return e.readFields(OT._readField, { properties: [], numericProps: {} }, t);
  }
  static _readField(e, t, n) {
    if (e === 1)
      t.properties.push(bh.read(n, n.readVarint() + n.pos));
    else if (e === 2) {
      const i = xh.read(n, n.readVarint() + n.pos);
      t.numericProps[i.key] = i.value;
    }
  }
}
const UF = "9.2.2", zF = "cartoPropertiesTile", hme = {
  cartoPropertiesTile: {
    workerUrl: wy(zF, UF)
  }
}, dme = {
  name: "CARTO Properties Tile",
  version: UF,
  id: zF,
  module: "carto",
  extensions: ["pbf"],
  mimeTypes: ["application/vnd.carto-properties-tile"],
  category: "geometry",
  worker: !0,
  parse: async (r, e) => k4(r),
  parseSync: k4,
  options: hme
};
function k4(r, e) {
  return r ? Cy(r, OT) : null;
}
const VF = "9.2.2", jF = "cartoVectorTile", pme = {
  cartoVectorTile: {
    workerUrl: wy(jF, VF)
  }
}, Ame = {
  name: "CARTO Vector Tile",
  version: VF,
  id: jF,
  module: "carto",
  extensions: ["pbf"],
  mimeTypes: ["application/vnd.carto-vector-tile"],
  category: "geometry",
  parse: async (r, e) => F4(r),
  parseSync: F4,
  worker: !0,
  options: pme
};
function gme(r, e, { startPosition: t, endPosition: n, indices: i }) {
  const s = r.positions.size, o = t * s, l = n * s, u = r.positions.value.subarray(o, l), m = i.slice(1).map((E) => E - t), y = FD(u, m, s);
  for (let E = 0, P = y.length; E < P; ++E)
    e.push(t + y[E]);
}
function mme(r) {
  const { polygonIndices: e, primitivePolygonIndices: t } = r, n = [];
  let i = 0;
  for (let s = 0; s < e.value.length - 1; s++) {
    const o = e.value[s], l = e.value[s + 1], u = t.value.indexOf(l), m = t.value.subarray(i, u);
    i = u, gme(r, n, { startPosition: o, endPosition: l, indices: m });
  }
  r.triangles = { value: new Uint32Array(n), size: 1 };
}
function F4(r, e) {
  if (!r)
    return null;
  const t = Cy(r, Bge);
  return t.polygons && !t.polygons.triangles && mme(t.polygons), t;
}
function _me(r, e) {
  const t = e ? e in r.numericProps : !1, n = /* @__PURE__ */ new Map();
  for (let y = 0; y < r.pathIndices.value.length - 1; y++) {
    const E = r.pathIndices.value[y], P = r.featureIds.value[E];
    let L;
    e === void 0 ? L = P : t ? L = r.numericProps[e].value[E] : r.properties[P] && e in r.properties[P] ? L = r.properties[P][e] : L = void 0;
    const U = Eme(r, y);
    (!n.has(L) || U > n.get(L).length) && n.set(L, { index: y, length: U });
  }
  const i = [], s = [], o = [], l = [], u = AF(n.size, r.numericProps);
  let m = 0;
  for (const [y, { index: E }] of n) {
    const P = Cme(r, E);
    i.push(...P);
    const L = r.pathIndices.value[E], U = r.featureIds.value[L];
    o.push(m), s.push(r.properties[U]), l.push(r.globalFeatureIds.value[L]), gF(r.numericProps, u, L, m), m++;
  }
  return gT(i, o, l, u, s);
}
function yme(r, e, t) {
  const { west: n, south: i, east: s, north: o } = e, u = (s - n) * (o - i) * 1e-4, m = [], y = [], E = [], P = [], L = AF(r.polygonIndices.value.length - 1, r.numericProps);
  let U = 0, V = 0;
  const { extruded: q } = t;
  for (let j = 0; j < r.polygonIndices.value.length - 1; j++) {
    const K = r.polygonIndices.value[j], Y = r.polygonIndices.value[j + 1];
    if (vme(r, j) < u)
      continue;
    const de = wme(r, j);
    let ne = -1, ae = [0, 0], De = !1;
    for (; V < r.triangles.value.length; ) {
      const fe = r.triangles.value[V];
      if (fe >= Y)
        break;
      if (De) {
        V += 3;
        continue;
      }
      const ve = r.triangles.value[V + 1], me = r.triangles.value[V + 2], X = r.positions.value.subarray(fe * r.positions.size, fe * r.positions.size + r.positions.size), re = r.positions.value.subarray(ve * r.positions.size, ve * r.positions.size + r.positions.size), Me = r.positions.value.subarray(me * r.positions.size, me * r.positions.size + r.positions.size);
      if (xme(de, X, re, Me))
        De = !0;
      else {
        const ot = HF(X, re, Me);
        ot > ne && (ne = ot, ae = [(X[0] + re[0] + Me[0]) / 3, (X[1] + re[1] + Me[1]) / 3]);
      }
      V += 3;
    }
    const Ge = De ? de : ae;
    if (bme(Ge, e)) {
      m.push(...Ge);
      const fe = r.featureIds.value[K];
      if (q) {
        const ve = t.getElevation(void 0, {
          data: r,
          index: fe
        });
        m.push(ve * t.elevationScale);
      }
      y.push(r.properties[fe]), E.push(U), P.push(r.globalFeatureIds.value[K]), gF(r.numericProps, L, K, U), U++;
    }
  }
  return r.numericProps && Object.keys(L).forEach((j) => {
    L[j].value = L[j].value.slice(0, U);
  }), gT(m, E, P, L, y, q ? 3 : 2);
}
function vme(r, e) {
  const { positions: { value: t, size: n }, polygonIndices: { value: i }, triangles: { value: s } } = r, o = i[e], l = i[e + 1];
  let u = 0, m = 0;
  for (; m < s.length && !(s[m] >= o); )
    m += 3;
  for (; m < s.length; ) {
    const y = s[m];
    if (y >= l)
      break;
    const E = s[m + 1], P = s[m + 2], L = t.subarray(y * n, y * n + n), U = t.subarray(E * n, E * n + n), V = t.subarray(P * n, P * n + n);
    u += HF(L, U, V), m += 3;
  }
  return u;
}
function bme([r, e], { west: t, east: n, south: i, north: s }) {
  return r >= t && r < n && e >= i && e < s;
}
function xme(r, e, t, n) {
  const i = Math.abs((t[0] - e[0]) * (n[1] - e[1]) - (n[0] - e[0]) * (t[1] - e[1])) / 2, s = Math.abs((e[0] - r[0]) * (t[1] - r[1]) - (t[0] - r[0]) * (e[1] - r[1])) / 2, o = Math.abs((t[0] - r[0]) * (n[1] - r[1]) - (n[0] - r[0]) * (t[1] - r[1])) / 2, l = Math.abs((n[0] - r[0]) * (e[1] - r[1]) - (e[0] - r[0]) * (n[1] - r[1])) / 2;
  return Math.abs(i - (s + o + l)) < 1e-10;
}
function HF([r, e], [t, n], [i, s]) {
  return Math.abs((r * (n - s) + t * (s - e) + i * (e - n)) / 2);
}
function wme(r, e) {
  const { positions: { value: t, size: n } } = r, i = n * r.polygonIndices.value[e], s = n * r.polygonIndices.value[e + 1];
  let o = 1 / 0, l = 1 / 0, u = -1 / 0, m = -1 / 0;
  for (let y = i; y < s; y += n) {
    const [E, P] = t.subarray(y, y + 2);
    o = Math.min(o, E), l = Math.min(l, P), u = Math.max(u, E), m = Math.max(m, P);
  }
  return [(o + u) / 2, (l + m) / 2];
}
function Tme(r, e) {
  const { positions: { value: t } } = r, [n, i, s, o] = t.subarray(e, e + 4);
  return Math.sqrt(Math.pow(s - n, 2) + Math.pow(o - i, 2));
}
function Eme(r, e) {
  const { positions: { size: t } } = r, n = t * r.pathIndices.value[e], i = t * r.pathIndices.value[e + 1];
  let s = 0;
  for (let o = n; o < i; o += t)
    s += Tme(r, o);
  return s;
}
function Cme(r, e) {
  const { positions: { value: t }, pathIndices: { value: n } } = r, i = n[e] * 2, o = (n[e + 1] * 2 - i) / 2;
  if (o === 2) {
    const [u, m, y, E] = t.subarray(i, i + 4);
    return [(u + y) / 2, (m + E) / 2];
  }
  const l = i + Math.floor(o / 2) * 2;
  return [t[l], t[l + 1]];
}
Op([dme, Ame]);
const Sme = {
  ...Np.defaultProps,
  autoLabels: !1,
  data: hh,
  dataComparator: hh.equal,
  tileSize: Vp
};
class DT extends Np {
  constructor(...e) {
    super(...e);
  }
  initializeState() {
    super.initializeState(), this.setState({ binary: !0 });
  }
  updateState(e) {
    const { props: t } = e;
    if (t.data) {
      super.updateState(e);
      const i = new URL(t.data.tiles[0]).searchParams.get("formatTiles") === "mvt";
      this.setState({ mvt: i });
    }
  }
  getLoadOptions() {
    const e = this.props.data;
    return jp(super.getLoadOptions(), {
      fetch: { headers: { Authorization: `Bearer ${e.accessToken}` } },
      gis: { format: "binary" }
      // Use binary for MVT loading
    });
  }
  /* eslint-disable camelcase */
  async getTileData(e) {
    const t = this.props.data, { tiles: n, properties_tiles: i } = t, s = ch(n, e);
    if (!s)
      return Promise.reject("Invalid URL");
    const o = this.getLoadOptions(), { fetch: l } = this.props, { signal: u } = e, m = l(s, { propName: "data", layer: this, loadOptions: o, signal: u });
    if (!i)
      return await m;
    const y = ch(i, e);
    if (!y)
      return Promise.reject("Invalid properties URL");
    const E = l(y, {
      propName: "data",
      layer: this,
      loadOptions: o,
      signal: u
    }), [P, L] = await Promise.all([m, E]);
    return P ? L ? kge(P, L) : P : null;
  }
  /* eslint-enable camelcase */
  renderSubLayers(e) {
    if (e.data === null)
      return null;
    const t = e.tile.bbox, n = [], i = {
      "points-text": {
        type: My,
        ...e?._subLayerProps?.["points-text"],
        extensions: [
          new sT(),
          ...e.extensions || [],
          ...e?._subLayerProps?.["points-text"]?.extensions || []
        ]
      }
    };
    if (this.state.mvt)
      n.push(super.renderSubLayers(e));
    else {
      const { west: s, south: o, east: l, north: u } = t, m = [new _y(), ...e.extensions || []], y = {
        clipBounds: [s, o, l, u]
      }, E = (L) => ({
        [L]: {
          ...y,
          ...e?._subLayerProps?.[L],
          extensions: [...m, ...e?._subLayerProps?.[L]?.extensions || []]
        }
      }), P = {
        ...e,
        data: { ...e.data, tileBbox: t },
        autoHighlight: !1,
        // Do not perform clipping on points (#9059)
        _subLayerProps: {
          ...e._subLayerProps,
          ...i,
          ...E("polygons-fill"),
          ...E("polygons-stroke"),
          ...E("linestrings")
        }
      };
      n.push(new iu(P));
    }
    if (n[0] && e.autoLabels) {
      const s = pF();
      e.data.lines && e.data.lines.positions.value.length > 0 && (s.points = _me(e.data.lines, typeof e.autoLabels == "object" ? e.autoLabels.uniqueIdProperty : void 0)), e.data.polygons && e.data.polygons.positions.value.length > 0 && (s.points = yme(e.data.polygons, t, e)), n.push(n[0].clone({
        id: `${e.id}-labels`,
        data: s,
        pickable: !1,
        autoHighlight: !1
      }));
    }
    return n;
  }
  renderLayers() {
    const e = super.renderLayers();
    if (!this.props.autoLabels)
      return e;
    const t = e.flat().filter(Boolean);
    return t.sort((n, i) => {
      const s = n.id.includes("labels"), o = i.id.includes("labels");
      return s && !o ? 1 : !s && o ? -1 : 0;
    }), t.map((n) => n.id.includes("labels") ? n.clone({ highlightedObjectIndex: -1 }) : n);
  }
  _isWGS84() {
    return this.state.mvt ? super._isWGS84() : !0;
  }
}
DT.layerName = "VectorTileLayer";
DT.defaultProps = Sme;
var kn = {
  YlGn: {
    3: ["#f7fcb9", "#addd8e", "#31a354"],
    4: ["#ffffcc", "#c2e699", "#78c679", "#238443"],
    5: ["#ffffcc", "#c2e699", "#78c679", "#31a354", "#006837"],
    6: ["#ffffcc", "#d9f0a3", "#addd8e", "#78c679", "#31a354", "#006837"],
    7: ["#ffffcc", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#005a32"],
    8: ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#005a32"],
    9: ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#006837", "#004529"]
  },
  YlGnBu: {
    3: ["#edf8b1", "#7fcdbb", "#2c7fb8"],
    4: ["#ffffcc", "#a1dab4", "#41b6c4", "#225ea8"],
    5: ["#ffffcc", "#a1dab4", "#41b6c4", "#2c7fb8", "#253494"],
    6: ["#ffffcc", "#c7e9b4", "#7fcdbb", "#41b6c4", "#2c7fb8", "#253494"],
    7: ["#ffffcc", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#0c2c84"],
    8: ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#0c2c84"],
    9: ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#253494", "#081d58"]
  },
  GnBu: {
    3: ["#e0f3db", "#a8ddb5", "#43a2ca"],
    4: ["#f0f9e8", "#bae4bc", "#7bccc4", "#2b8cbe"],
    5: ["#f0f9e8", "#bae4bc", "#7bccc4", "#43a2ca", "#0868ac"],
    6: ["#f0f9e8", "#ccebc5", "#a8ddb5", "#7bccc4", "#43a2ca", "#0868ac"],
    7: ["#f0f9e8", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#08589e"],
    8: ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#08589e"],
    9: ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#0868ac", "#084081"]
  },
  BuGn: {
    3: ["#e5f5f9", "#99d8c9", "#2ca25f"],
    4: ["#edf8fb", "#b2e2e2", "#66c2a4", "#238b45"],
    5: ["#edf8fb", "#b2e2e2", "#66c2a4", "#2ca25f", "#006d2c"],
    6: ["#edf8fb", "#ccece6", "#99d8c9", "#66c2a4", "#2ca25f", "#006d2c"],
    7: ["#edf8fb", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#005824"],
    8: ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#005824"],
    9: ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#006d2c", "#00441b"]
  },
  PuBuGn: {
    3: ["#ece2f0", "#a6bddb", "#1c9099"],
    4: ["#f6eff7", "#bdc9e1", "#67a9cf", "#02818a"],
    5: ["#f6eff7", "#bdc9e1", "#67a9cf", "#1c9099", "#016c59"],
    6: ["#f6eff7", "#d0d1e6", "#a6bddb", "#67a9cf", "#1c9099", "#016c59"],
    7: ["#f6eff7", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016450"],
    8: ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016450"],
    9: ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016c59", "#014636"]
  },
  PuBu: {
    3: ["#ece7f2", "#a6bddb", "#2b8cbe"],
    4: ["#f1eef6", "#bdc9e1", "#74a9cf", "#0570b0"],
    5: ["#f1eef6", "#bdc9e1", "#74a9cf", "#2b8cbe", "#045a8d"],
    6: ["#f1eef6", "#d0d1e6", "#a6bddb", "#74a9cf", "#2b8cbe", "#045a8d"],
    7: ["#f1eef6", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#034e7b"],
    8: ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#034e7b"],
    9: ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#045a8d", "#023858"]
  },
  BuPu: {
    3: ["#e0ecf4", "#9ebcda", "#8856a7"],
    4: ["#edf8fb", "#b3cde3", "#8c96c6", "#88419d"],
    5: ["#edf8fb", "#b3cde3", "#8c96c6", "#8856a7", "#810f7c"],
    6: ["#edf8fb", "#bfd3e6", "#9ebcda", "#8c96c6", "#8856a7", "#810f7c"],
    7: ["#edf8fb", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#6e016b"],
    8: ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#6e016b"],
    9: ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#810f7c", "#4d004b"]
  },
  RdPu: {
    3: ["#fde0dd", "#fa9fb5", "#c51b8a"],
    4: ["#feebe2", "#fbb4b9", "#f768a1", "#ae017e"],
    5: ["#feebe2", "#fbb4b9", "#f768a1", "#c51b8a", "#7a0177"],
    6: ["#feebe2", "#fcc5c0", "#fa9fb5", "#f768a1", "#c51b8a", "#7a0177"],
    7: ["#feebe2", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177"],
    8: ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177"],
    9: ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177", "#49006a"]
  },
  PuRd: {
    3: ["#e7e1ef", "#c994c7", "#dd1c77"],
    4: ["#f1eef6", "#d7b5d8", "#df65b0", "#ce1256"],
    5: ["#f1eef6", "#d7b5d8", "#df65b0", "#dd1c77", "#980043"],
    6: ["#f1eef6", "#d4b9da", "#c994c7", "#df65b0", "#dd1c77", "#980043"],
    7: ["#f1eef6", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#91003f"],
    8: ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#91003f"],
    9: ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#980043", "#67001f"]
  },
  OrRd: {
    3: ["#fee8c8", "#fdbb84", "#e34a33"],
    4: ["#fef0d9", "#fdcc8a", "#fc8d59", "#d7301f"],
    5: ["#fef0d9", "#fdcc8a", "#fc8d59", "#e34a33", "#b30000"],
    6: ["#fef0d9", "#fdd49e", "#fdbb84", "#fc8d59", "#e34a33", "#b30000"],
    7: ["#fef0d9", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#990000"],
    8: ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#990000"],
    9: ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#b30000", "#7f0000"]
  },
  YlOrRd: {
    3: ["#ffeda0", "#feb24c", "#f03b20"],
    4: ["#ffffb2", "#fecc5c", "#fd8d3c", "#e31a1c"],
    5: ["#ffffb2", "#fecc5c", "#fd8d3c", "#f03b20", "#bd0026"],
    6: ["#ffffb2", "#fed976", "#feb24c", "#fd8d3c", "#f03b20", "#bd0026"],
    7: ["#ffffb2", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#b10026"],
    8: ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#b10026"],
    9: ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#bd0026", "#800026"]
  },
  YlOrBr: {
    3: ["#fff7bc", "#fec44f", "#d95f0e"],
    4: ["#ffffd4", "#fed98e", "#fe9929", "#cc4c02"],
    5: ["#ffffd4", "#fed98e", "#fe9929", "#d95f0e", "#993404"],
    6: ["#ffffd4", "#fee391", "#fec44f", "#fe9929", "#d95f0e", "#993404"],
    7: ["#ffffd4", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#8c2d04"],
    8: ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#8c2d04"],
    9: ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#993404", "#662506"]
  },
  Purples: {
    3: ["#efedf5", "#bcbddc", "#756bb1"],
    4: ["#f2f0f7", "#cbc9e2", "#9e9ac8", "#6a51a3"],
    5: ["#f2f0f7", "#cbc9e2", "#9e9ac8", "#756bb1", "#54278f"],
    6: ["#f2f0f7", "#dadaeb", "#bcbddc", "#9e9ac8", "#756bb1", "#54278f"],
    7: ["#f2f0f7", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#4a1486"],
    8: ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#4a1486"],
    9: ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#54278f", "#3f007d"]
  },
  Blues: {
    3: ["#deebf7", "#9ecae1", "#3182bd"],
    4: ["#eff3ff", "#bdd7e7", "#6baed6", "#2171b5"],
    5: ["#eff3ff", "#bdd7e7", "#6baed6", "#3182bd", "#08519c"],
    6: ["#eff3ff", "#c6dbef", "#9ecae1", "#6baed6", "#3182bd", "#08519c"],
    7: ["#eff3ff", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#084594"],
    8: ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#084594"],
    9: ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#08519c", "#08306b"]
  },
  Greens: {
    3: ["#e5f5e0", "#a1d99b", "#31a354"],
    4: ["#edf8e9", "#bae4b3", "#74c476", "#238b45"],
    5: ["#edf8e9", "#bae4b3", "#74c476", "#31a354", "#006d2c"],
    6: ["#edf8e9", "#c7e9c0", "#a1d99b", "#74c476", "#31a354", "#006d2c"],
    7: ["#edf8e9", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#005a32"],
    8: ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#005a32"],
    9: ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#006d2c", "#00441b"]
  },
  Oranges: {
    3: ["#fee6ce", "#fdae6b", "#e6550d"],
    4: ["#feedde", "#fdbe85", "#fd8d3c", "#d94701"],
    5: ["#feedde", "#fdbe85", "#fd8d3c", "#e6550d", "#a63603"],
    6: ["#feedde", "#fdd0a2", "#fdae6b", "#fd8d3c", "#e6550d", "#a63603"],
    7: ["#feedde", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#8c2d04"],
    8: ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#8c2d04"],
    9: ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#a63603", "#7f2704"]
  },
  Reds: {
    3: ["#fee0d2", "#fc9272", "#de2d26"],
    4: ["#fee5d9", "#fcae91", "#fb6a4a", "#cb181d"],
    5: ["#fee5d9", "#fcae91", "#fb6a4a", "#de2d26", "#a50f15"],
    6: ["#fee5d9", "#fcbba1", "#fc9272", "#fb6a4a", "#de2d26", "#a50f15"],
    7: ["#fee5d9", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#99000d"],
    8: ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#99000d"],
    9: ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#a50f15", "#67000d"]
  },
  Greys: {
    3: ["#f0f0f0", "#bdbdbd", "#636363"],
    4: ["#f7f7f7", "#cccccc", "#969696", "#525252"],
    5: ["#f7f7f7", "#cccccc", "#969696", "#636363", "#252525"],
    6: ["#f7f7f7", "#d9d9d9", "#bdbdbd", "#969696", "#636363", "#252525"],
    7: ["#f7f7f7", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525"],
    8: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525"],
    9: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525", "#000000"]
  },
  PuOr: {
    3: ["#f1a340", "#f7f7f7", "#998ec3"],
    4: ["#e66101", "#fdb863", "#b2abd2", "#5e3c99"],
    5: ["#e66101", "#fdb863", "#f7f7f7", "#b2abd2", "#5e3c99"],
    6: ["#b35806", "#f1a340", "#fee0b6", "#d8daeb", "#998ec3", "#542788"],
    7: ["#b35806", "#f1a340", "#fee0b6", "#f7f7f7", "#d8daeb", "#998ec3", "#542788"],
    8: ["#b35806", "#e08214", "#fdb863", "#fee0b6", "#d8daeb", "#b2abd2", "#8073ac", "#542788"],
    9: ["#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788"],
    10: ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"],
    11: ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"]
  },
  BrBG: {
    3: ["#d8b365", "#f5f5f5", "#5ab4ac"],
    4: ["#a6611a", "#dfc27d", "#80cdc1", "#018571"],
    5: ["#a6611a", "#dfc27d", "#f5f5f5", "#80cdc1", "#018571"],
    6: ["#8c510a", "#d8b365", "#f6e8c3", "#c7eae5", "#5ab4ac", "#01665e"],
    7: ["#8c510a", "#d8b365", "#f6e8c3", "#f5f5f5", "#c7eae5", "#5ab4ac", "#01665e"],
    8: ["#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#c7eae5", "#80cdc1", "#35978f", "#01665e"],
    9: ["#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e"],
    10: ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"],
    11: ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"]
  },
  PRGn: {
    3: ["#af8dc3", "#f7f7f7", "#7fbf7b"],
    4: ["#7b3294", "#c2a5cf", "#a6dba0", "#008837"],
    5: ["#7b3294", "#c2a5cf", "#f7f7f7", "#a6dba0", "#008837"],
    6: ["#762a83", "#af8dc3", "#e7d4e8", "#d9f0d3", "#7fbf7b", "#1b7837"],
    7: ["#762a83", "#af8dc3", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#7fbf7b", "#1b7837"],
    8: ["#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837"],
    9: ["#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837"],
    10: ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"],
    11: ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"]
  },
  PiYG: {
    3: ["#e9a3c9", "#f7f7f7", "#a1d76a"],
    4: ["#d01c8b", "#f1b6da", "#b8e186", "#4dac26"],
    5: ["#d01c8b", "#f1b6da", "#f7f7f7", "#b8e186", "#4dac26"],
    6: ["#c51b7d", "#e9a3c9", "#fde0ef", "#e6f5d0", "#a1d76a", "#4d9221"],
    7: ["#c51b7d", "#e9a3c9", "#fde0ef", "#f7f7f7", "#e6f5d0", "#a1d76a", "#4d9221"],
    8: ["#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221"],
    9: ["#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221"],
    10: ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"],
    11: ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"]
  },
  RdBu: {
    3: ["#ef8a62", "#f7f7f7", "#67a9cf"],
    4: ["#ca0020", "#f4a582", "#92c5de", "#0571b0"],
    5: ["#ca0020", "#f4a582", "#f7f7f7", "#92c5de", "#0571b0"],
    6: ["#b2182b", "#ef8a62", "#fddbc7", "#d1e5f0", "#67a9cf", "#2166ac"],
    7: ["#b2182b", "#ef8a62", "#fddbc7", "#f7f7f7", "#d1e5f0", "#67a9cf", "#2166ac"],
    8: ["#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac"],
    9: ["#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac"],
    10: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"],
    11: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"]
  },
  RdGy: {
    3: ["#ef8a62", "#ffffff", "#999999"],
    4: ["#ca0020", "#f4a582", "#bababa", "#404040"],
    5: ["#ca0020", "#f4a582", "#ffffff", "#bababa", "#404040"],
    6: ["#b2182b", "#ef8a62", "#fddbc7", "#e0e0e0", "#999999", "#4d4d4d"],
    7: ["#b2182b", "#ef8a62", "#fddbc7", "#ffffff", "#e0e0e0", "#999999", "#4d4d4d"],
    8: ["#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#e0e0e0", "#bababa", "#878787", "#4d4d4d"],
    9: ["#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d"],
    10: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"],
    11: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"]
  },
  RdYlBu: {
    3: ["#fc8d59", "#ffffbf", "#91bfdb"],
    4: ["#d7191c", "#fdae61", "#abd9e9", "#2c7bb6"],
    5: ["#d7191c", "#fdae61", "#ffffbf", "#abd9e9", "#2c7bb6"],
    6: ["#d73027", "#fc8d59", "#fee090", "#e0f3f8", "#91bfdb", "#4575b4"],
    7: ["#d73027", "#fc8d59", "#fee090", "#ffffbf", "#e0f3f8", "#91bfdb", "#4575b4"],
    8: ["#d73027", "#f46d43", "#fdae61", "#fee090", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4"],
    9: ["#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4"],
    10: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"],
    11: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"]
  },
  Spectral: {
    3: ["#fc8d59", "#ffffbf", "#99d594"],
    4: ["#d7191c", "#fdae61", "#abdda4", "#2b83ba"],
    5: ["#d7191c", "#fdae61", "#ffffbf", "#abdda4", "#2b83ba"],
    6: ["#d53e4f", "#fc8d59", "#fee08b", "#e6f598", "#99d594", "#3288bd"],
    7: ["#d53e4f", "#fc8d59", "#fee08b", "#ffffbf", "#e6f598", "#99d594", "#3288bd"],
    8: ["#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#e6f598", "#abdda4", "#66c2a5", "#3288bd"],
    9: ["#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd"],
    10: ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"],
    11: ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"]
  },
  RdYlGn: {
    3: ["#fc8d59", "#ffffbf", "#91cf60"],
    4: ["#d7191c", "#fdae61", "#a6d96a", "#1a9641"],
    5: ["#d7191c", "#fdae61", "#ffffbf", "#a6d96a", "#1a9641"],
    6: ["#d73027", "#fc8d59", "#fee08b", "#d9ef8b", "#91cf60", "#1a9850"],
    7: ["#d73027", "#fc8d59", "#fee08b", "#ffffbf", "#d9ef8b", "#91cf60", "#1a9850"],
    8: ["#d73027", "#f46d43", "#fdae61", "#fee08b", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850"],
    9: ["#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850"],
    10: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"],
    11: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"]
  },
  Accent: {
    3: ["#7fc97f", "#beaed4", "#fdc086"],
    4: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99"],
    5: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0"],
    6: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f"],
    7: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17"],
    8: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17", "#666666"]
  },
  Dark2: {
    3: ["#1b9e77", "#d95f02", "#7570b3"],
    4: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a"],
    5: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e"],
    6: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02"],
    7: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d"],
    8: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d", "#666666"]
  },
  Paired: {
    3: ["#a6cee3", "#1f78b4", "#b2df8a"],
    4: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c"],
    5: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99"],
    6: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c"],
    7: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f"],
    8: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00"],
    9: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6"],
    10: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a"],
    11: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99"],
    12: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99", "#b15928"]
  },
  Pastel1: {
    3: ["#fbb4ae", "#b3cde3", "#ccebc5"],
    4: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4"],
    5: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6"],
    6: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc"],
    7: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd"],
    8: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec"],
    9: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec", "#f2f2f2"]
  },
  Pastel2: {
    3: ["#b3e2cd", "#fdcdac", "#cbd5e8"],
    4: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4"],
    5: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9"],
    6: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae"],
    7: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc"],
    8: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc", "#cccccc"]
  },
  Set1: {
    3: ["#e41a1c", "#377eb8", "#4daf4a"],
    4: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3"],
    5: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00"],
    6: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33"],
    7: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628"],
    8: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf"],
    9: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf", "#999999"]
  },
  Set2: {
    3: ["#66c2a5", "#fc8d62", "#8da0cb"],
    4: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3"],
    5: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854"],
    6: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f"],
    7: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494"],
    8: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494", "#b3b3b3"]
  },
  Set3: {
    3: ["#8dd3c7", "#ffffb3", "#bebada"],
    4: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072"],
    5: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3"],
    6: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462"],
    7: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69"],
    8: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5"],
    9: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9"],
    10: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd"],
    11: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5"],
    12: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f"]
  }
}, Ime = {
  2: ["#ffc6c4", "#672044"],
  3: ["#ffc6c4", "#cc607d", "#672044"],
  4: ["#ffc6c4", "#e38191", "#ad466c", "#672044"],
  5: ["#ffc6c4", "#ee919b", "#cc607d", "#9e3963", "#672044"],
  6: ["#ffc6c4", "#f29ca3", "#da7489", "#b95073", "#93345d", "#672044"],
  7: [
    "#ffc6c4",
    "#f4a3a8",
    "#e38191",
    "#cc607d",
    "#ad466c",
    "#8b3058",
    "#672044"
  ],
  tags: ["quantitative"]
}, Pme = {
  2: ["#fbe6c5", "#70284a"],
  3: ["#fbe6c5", "#dc7176", "#70284a"],
  4: ["#fbe6c5", "#ee8a82", "#c8586c", "#70284a"],
  5: ["#fbe6c5", "#f2a28a", "#dc7176", "#b24b65", "#70284a"],
  6: ["#fbe6c5", "#f4b191", "#e7807d", "#d06270", "#a44360", "#70284a"],
  7: [
    "#fbe6c5",
    "#f5ba98",
    "#ee8a82",
    "#dc7176",
    "#c8586c",
    "#9c3f5d",
    "#70284a"
  ],
  tags: ["quantitative"]
}, Mme = {
  2: ["#f6d2a9", "#b13f64"],
  3: ["#f6d2a9", "#ea8171", "#b13f64"],
  4: ["#f6d2a9", "#f19c7c", "#dd686c", "#b13f64"],
  5: ["#f6d2a9", "#f3aa84", "#ea8171", "#d55d6a", "#b13f64"],
  6: ["#f6d2a9", "#f4b28a", "#ef9177", "#e3726d", "#cf5669", "#b13f64"],
  7: [
    "#f6d2a9",
    "#f5b78e",
    "#f19c7c",
    "#ea8171",
    "#dd686c",
    "#ca5268",
    "#b13f64"
  ],
  tags: ["quantitative"]
}, Rme = {
  2: ["#ecda9a", "#ee4d5a"],
  3: ["#ecda9a", "#f7945d", "#ee4d5a"],
  4: ["#ecda9a", "#f3ad6a", "#f97b57", "#ee4d5a"],
  5: ["#ecda9a", "#f1b973", "#f7945d", "#f86f56", "#ee4d5a"],
  6: ["#ecda9a", "#f0c079", "#f5a363", "#f98558", "#f76856", "#ee4d5a"],
  7: [
    "#ecda9a",
    "#efc47e",
    "#f3ad6a",
    "#f7945d",
    "#f97b57",
    "#f66356",
    "#ee4d5a"
  ],
  tags: ["quantitative"]
}, Bme = {
  2: ["#fde0c5", "#eb4a40"],
  3: ["#fde0c5", "#f59e72", "#eb4a40"],
  4: ["#fde0c5", "#f8b58b", "#f2855d", "#eb4a40"],
  5: ["#fde0c5", "#f9c098", "#f59e72", "#f17854", "#eb4a40"],
  6: ["#fde0c5", "#fac7a1", "#f7ac80", "#f38f65", "#f0704f", "#eb4a40"],
  7: [
    "#fde0c5",
    "#facba6",
    "#f8b58b",
    "#f59e72",
    "#f2855d",
    "#ef6a4c",
    "#eb4a40"
  ],
  tags: ["quantitative"]
}, Ome = {
  2: ["#fef6b5", "#e15383"],
  3: ["#fef6b5", "#ffa679", "#e15383"],
  4: ["#fef6b5", "#ffc285", "#fa8a76", "#e15383"],
  5: ["#fef6b5", "#ffd08e", "#ffa679", "#f67b77", "#e15383"],
  6: ["#fef6b5", "#ffd795", "#ffb77f", "#fd9576", "#f37378", "#e15383"],
  7: [
    "#fef6b5",
    "#ffdd9a",
    "#ffc285",
    "#ffa679",
    "#fa8a76",
    "#f16d7a",
    "#e15383"
  ],
  tags: ["quantitative"]
}, Dme = {
  2: ["#e4f1e1", "#0d585f"],
  3: ["#e4f1e1", "#63a6a0", "#0d585f"],
  4: ["#e4f1e1", "#89c0b6", "#448c8a", "#0d585f"],
  5: ["#E4F1E1", "#9CCDC1", "#63A6A0", "#337F7F", "#0D585F"],
  6: ["#e4f1e1", "#abd4c7", "#7ab5ad", "#509693", "#2c7778", "#0d585f"],
  7: [
    "#e4f1e1",
    "#b4d9cc",
    "#89c0b6",
    "#63a6a0",
    "#448c8a",
    "#287274",
    "#0d585f"
  ],
  tags: ["quantitative"]
}, Lme = {
  2: ["#c4e6c3", "#1d4f60"],
  3: ["#c4e6c3", "#4da284", "#1d4f60"],
  4: ["#c4e6c3", "#6dbc90", "#36877a", "#1d4f60"],
  5: ["#c4e6c3", "#80c799", "#4da284", "#2d7974", "#1d4f60"],
  6: ["#c4e6c3", "#8dce9f", "#5fb28b", "#3e927e", "#297071", "#1d4f60"],
  7: [
    "#c4e6c3",
    "#96d2a4",
    "#6dbc90",
    "#4da284",
    "#36877a",
    "#266b6e",
    "#1d4f60"
  ],
  tags: ["quantitative"]
}, kme = {
  2: ["#d2fbd4", "#123f5a"],
  3: ["#d2fbd4", "#559c9e", "#123f5a"],
  4: ["#d2fbd4", "#7bbcb0", "#3a7c89", "#123f5a"],
  5: ["#d2fbd4", "#8eccb9", "#559c9e", "#2b6c7f", "#123f5a"],
  6: ["#d2fbd4", "#9cd5be", "#6cafa9", "#458892", "#266377", "#123f5a"],
  7: [
    "#d2fbd4",
    "#a5dbc2",
    "#7bbcb0",
    "#559c9e",
    "#3a7c89",
    "#235d72",
    "#123f5a"
  ],
  tags: ["quantitative"]
}, Fme = {
  2: ["#d3f2a3", "#074050"],
  3: ["#d3f2a3", "#4c9b82", "#074050"],
  4: ["#d3f2a3", "#6cc08b", "#217a79", "#074050"],
  5: ["#d3f2a3", "#82d091", "#4c9b82", "#19696f", "#074050"],
  6: ["#d3f2a3", "#8fda94", "#60b187", "#35877d", "#145f69", "#074050"],
  7: [
    "#d3f2a3",
    "#97e196",
    "#6cc08b",
    "#4c9b82",
    "#217a79",
    "#105965",
    "#074050"
  ],
  tags: ["quantitative"]
}, Nme = {
  2: ["#245668", "#EDEF5D"],
  3: ["#245668", "#39AB7E", "#EDEF5D"],
  4: ["#245668", "#0D8F81", "#6EC574", "#EDEF5D"],
  5: ["#245668", "#04817E", "#39AB7E", "#8BD16D", "#EDEF5D"],
  6: ["#245668", "#09787C", "#1D9A81", "#58BB79", "#9DD869", "#EDEF5D"],
  7: [
    "#245668",
    "#0F7279",
    "#0D8F81",
    "#39AB7E",
    "#6EC574",
    "#A9DC67",
    "#EDEF5D"
  ],
  tags: ["aggregation"]
}, Ume = {
  2: ["#f7feae", "#045275"],
  3: ["#f7feae", "#46aea0", "#045275"],
  4: ["#f7feae", "#7ccba2", "#089099", "#045275"],
  5: ["#f7feae", "#9bd8a4", "#46aea0", "#058092", "#045275"],
  6: ["#f7feae", "#ace1a4", "#68bfa1", "#2a9c9c", "#02778e", "#045275"],
  7: [
    "#f7feae",
    "#b7e6a5",
    "#7ccba2",
    "#46aea0",
    "#089099",
    "#00718b",
    "#045275"
  ],
  tags: ["quantitative"]
}, zme = {
  2: ["#d1eeea", "#2a5674"],
  3: ["#d1eeea", "#68abb8", "#2a5674"],
  4: ["#d1eeea", "#85c4c9", "#4f90a6", "#2a5674"],
  5: ["#d1eeea", "#96d0d1", "#68abb8", "#45829b", "#2a5674"],
  6: ["#d1eeea", "#a1d7d6", "#79bbc3", "#599bae", "#3f7994", "#2a5674"],
  7: [
    "#d1eeea",
    "#a8dbd9",
    "#85c4c9",
    "#68abb8",
    "#4f90a6",
    "#3b738f",
    "#2a5674"
  ],
  tags: ["quantitative"]
}, Vme = {
  2: ["#b0f2bc", "#257d98"],
  3: ["#b0f2bc", "#4cc8a3", "#257d98"],
  4: ["#b0f2bc", "#67dba5", "#38b2a3", "#257d98"],
  5: ["#b0f2bc", "#77e2a8", "#4cc8a3", "#31a6a2", "#257d98"],
  6: ["#b0f2bc", "#82e6aa", "#5bd4a4", "#3fbba3", "#2e9ea1", "#257d98"],
  7: [
    "#b0f2bc",
    "#89e8ac",
    "#67dba5",
    "#4cc8a3",
    "#38b2a3",
    "#2c98a0",
    "#257d98"
  ],
  tags: ["quantitative"]
}, jme = {
  2: ["#f3e0f7", "#63589f"],
  3: ["#f3e0f7", "#b998dd", "#63589f"],
  4: ["#f3e0f7", "#d1afe8", "#9f82ce", "#63589f"],
  5: ["#f3e0f7", "#dbbaed", "#b998dd", "#9178c4", "#63589f"],
  6: ["#f3e0f7", "#e0c2ef", "#c8a5e4", "#aa8bd4", "#8871be", "#63589f"],
  7: [
    "#f3e0f7",
    "#e4c7f1",
    "#d1afe8",
    "#b998dd",
    "#9f82ce",
    "#826dba",
    "#63589f"
  ],
  tags: ["quantitative"]
}, Hme = {
  2: ["#f9ddda", "#573b88"],
  3: ["#f9ddda", "#ce78b3", "#573b88"],
  4: ["#f9ddda", "#e597b9", "#ad5fad", "#573b88"],
  5: ["#f9ddda", "#eda8bd", "#ce78b3", "#9955a8", "#573b88"],
  6: ["#f9ddda", "#f0b2c1", "#dd8ab6", "#bb69b0", "#8c4fa4", "#573b88"],
  7: [
    "#f9ddda",
    "#f2b9c4",
    "#e597b9",
    "#ce78b3",
    "#ad5fad",
    "#834ba0",
    "#573b88"
  ],
  tags: ["quantitative"]
}, Gme = {
  2: ["#f3e79b", "#5c53a5"],
  3: ["#f3e79b", "#eb7f86", "#5c53a5"],
  4: ["#f3e79b", "#f8a07e", "#ce6693", "#5c53a5"],
  5: ["#f3e79b", "#fab27f", "#eb7f86", "#b95e9a", "#5c53a5"],
  6: ["#f3e79b", "#fabc82", "#f59280", "#dc6f8e", "#ab5b9e", "#5c53a5"],
  7: [
    "#f3e79b",
    "#fac484",
    "#f8a07e",
    "#eb7f86",
    "#ce6693",
    "#a059a0",
    "#5c53a5"
  ],
  tags: ["quantitative"]
}, Wme = {
  2: ["#f3cbd3", "#6c2167"],
  3: ["#f3cbd3", "#ca699d", "#6c2167"],
  4: ["#f3cbd3", "#dd88ac", "#b14d8e", "#6c2167"],
  5: ["#f3cbd3", "#e498b4", "#ca699d", "#a24186", "#6c2167"],
  6: ["#f3cbd3", "#e7a2b9", "#d67ba5", "#bc5894", "#983a81", "#6c2167"],
  7: [
    "#f3cbd3",
    "#eaa9bd",
    "#dd88ac",
    "#ca699d",
    "#b14d8e",
    "#91357d",
    "#6c2167"
  ],
  tags: ["quantitative"]
}, $me = {
  2: ["#fcde9c", "#7c1d6f"],
  3: ["#fcde9c", "#e34f6f", "#7c1d6f"],
  4: ["#fcde9c", "#f0746e", "#dc3977", "#7c1d6f"],
  5: ["#fcde9c", "#f58670", "#e34f6f", "#d72d7c", "#7c1d6f"],
  6: ["#fcde9c", "#f89872", "#ec666d", "#df4273", "#c5287b", "#7c1d6f"],
  7: [
    "#fcde9c",
    "#faa476",
    "#f0746e",
    "#e34f6f",
    "#dc3977",
    "#b9257a",
    "#7c1d6f"
  ],
  tags: ["quantitative"]
}, qme = {
  2: ["#4b2991", "#edd9a3"],
  3: ["#4b2991", "#ea4f88", "#edd9a3"],
  4: ["#4b2991", "#c0369d", "#fa7876", "#edd9a3"],
  5: ["#4b2991", "#a52fa2", "#ea4f88", "#fa9074", "#edd9a3"],
  6: ["#4b2991", "#932da3", "#d43f96", "#f7667c", "#f89f77", "#edd9a3"],
  7: [
    "#4b2991",
    "#872ca2",
    "#c0369d",
    "#ea4f88",
    "#fa7876",
    "#f6a97a",
    "#edd9a3"
  ],
  tags: ["aggregation"]
}, Xme = {
  2: ["#ede5cf", "#541f3f"],
  3: ["#ede5cf", "#c1766f", "#541f3f"],
  4: ["#ede5cf", "#d39c83", "#a65461", "#541f3f"],
  5: ["#ede5cf", "#daaf91", "#c1766f", "#95455a", "#541f3f"],
  6: ["#ede5cf", "#ddba9b", "#cd8c7a", "#b26166", "#8a3c56", "#541f3f"],
  7: [
    "#ede5cf",
    "#e0c2a2",
    "#d39c83",
    "#c1766f",
    "#a65461",
    "#813753",
    "#541f3f"
  ],
  tags: ["quantitative"]
}, Zme = {
  2: ["#929b4f", "#db8195"],
  3: ["#a3ad62", "#fdfbe4", "#df91a3"],
  4: ["#929b4f", "#d9dbaf", "#f3d1ca", "#db8195"],
  5: ["#879043", "#c1c68c", "#fdfbe4", "#ebb4b8", "#d8758b"],
  6: ["#7f883b", "#b0b874", "#e3e4be", "#f6ddd1", "#e4a0ac", "#d66d85"],
  7: [
    "#798234",
    "#a3ad62",
    "#d0d3a2",
    "#fdfbe4",
    "#f0c6c3",
    "#df91a3",
    "#d46780"
  ],
  tags: ["diverging"]
}, Yme = {
  2: ["#3d5941", "#ca562c"],
  3: ["#3d5941", "#f6edbd", "#ca562c"],
  4: ["#3d5941", "#b5b991", "#edbb8a", "#ca562c"],
  5: ["#3d5941", "#96a07c", "#f6edbd", "#e6a272", "#ca562c"],
  6: ["#3d5941", "#839170", "#cecea2", "#f1cf9e", "#e19464", "#ca562c"],
  7: [
    "#3d5941",
    "#778868",
    "#b5b991",
    "#f6edbd",
    "#edbb8a",
    "#de8a5a",
    "#ca562c"
  ],
  tags: ["diverging"]
}, Kme = {
  2: ["#008080", "#ca562c"],
  3: ["#008080", "#f6edbd", "#ca562c"],
  4: ["#008080", "#b4c8a8", "#edbb8a", "#ca562c"],
  5: ["#008080", "#92b69e", "#f6edbd", "#e6a272", "#ca562c"],
  6: ["#008080", "#7eab98", "#ced7b1", "#f1cf9e", "#e19464", "#ca562c"],
  7: [
    "#008080",
    "#70a494",
    "#b4c8a8",
    "#f6edbd",
    "#edbb8a",
    "#de8a5a",
    "#ca562c"
  ],
  tags: ["diverging"]
}, Qme = {
  2: ["#009392", "#cf597e"],
  3: ["#009392", "#e9e29c", "#cf597e"],
  4: ["#009392", "#9ccb86", "#eeb479", "#cf597e"],
  5: ["#009392", "#71be83", "#e9e29c", "#ed9c72", "#cf597e"],
  6: ["#009392", "#52b684", "#bcd48c", "#edc783", "#eb8d71", "#cf597e"],
  7: [
    "#009392",
    "#39b185",
    "#9ccb86",
    "#e9e29c",
    "#eeb479",
    "#e88471",
    "#cf597e"
  ],
  tags: ["diverging"]
}, Jme = {
  2: ["#009392", "#d0587e"],
  3: ["#009392", "#f1eac8", "#d0587e"],
  4: ["#009392", "#91b8aa", "#f1eac8", "#dfa0a0", "#d0587e"],
  5: ["#009392", "#91b8aa", "#f1eac8", "#dfa0a0", "#d0587e"],
  6: ["#009392", "#72aaa1", "#b1c7b3", "#e5b9ad", "#d98994", "#d0587e"],
  7: [
    "#009392",
    "#72aaa1",
    "#b1c7b3",
    "#f1eac8",
    "#e5b9ad",
    "#d98994",
    "#d0587e"
  ],
  tags: ["diverging"]
}, e_e = {
  2: ["#009B9E", "#C75DAB"],
  3: ["#009B9E", "#F1F1F1", "#C75DAB"],
  4: ["#009B9E", "#A7D3D4", "#E4C1D9", "#C75DAB"],
  5: ["#009B9E", "#7CC5C6", "#F1F1F1", "#DDA9CD", "#C75DAB"],
  6: ["#009B9E", "#5DBCBE", "#C6DFDF", "#E9D4E2", "#D99BC6", "#C75DAB"],
  7: [
    "#009B9E",
    "#42B7B9",
    "#A7D3D4",
    "#F1F1F1",
    "#E4C1D9",
    "#D691C1",
    "#C75DAB"
  ],
  tags: ["diverging"]
}, t_e = {
  2: ["#A16928", "#2887a1"],
  3: ["#A16928", "#edeac2", "#2887a1"],
  4: ["#A16928", "#d6bd8d", "#b5c8b8", "#2887a1"],
  5: ["#A16928", "#caa873", "#edeac2", "#98b7b2", "#2887a1"],
  6: ["#A16928", "#c29b64", "#e0cfa2", "#cbd5bc", "#85adaf", "#2887a1"],
  7: [
    "#A16928",
    "#bd925a",
    "#d6bd8d",
    "#edeac2",
    "#b5c8b8",
    "#79a7ac",
    "#2887a1"
  ],
  tags: ["diverging"]
}, r_e = {
  2: ["#855C75", "#D9AF6B", "#7C7C7C"],
  3: ["#855C75", "#D9AF6B", "#AF6458", "#7C7C7C"],
  4: ["#855C75", "#D9AF6B", "#AF6458", "#736F4C", "#7C7C7C"],
  5: ["#855C75", "#D9AF6B", "#AF6458", "#736F4C", "#526A83", "#7C7C7C"],
  6: [
    "#855C75",
    "#D9AF6B",
    "#AF6458",
    "#736F4C",
    "#526A83",
    "#625377",
    "#7C7C7C"
  ],
  7: [
    "#855C75",
    "#D9AF6B",
    "#AF6458",
    "#736F4C",
    "#526A83",
    "#625377",
    "#68855C",
    "#7C7C7C"
  ],
  8: [
    "#855C75",
    "#D9AF6B",
    "#AF6458",
    "#736F4C",
    "#526A83",
    "#625377",
    "#68855C",
    "#9C9C5E",
    "#7C7C7C"
  ],
  9: [
    "#855C75",
    "#D9AF6B",
    "#AF6458",
    "#736F4C",
    "#526A83",
    "#625377",
    "#68855C",
    "#9C9C5E",
    "#A06177",
    "#7C7C7C"
  ],
  10: [
    "#855C75",
    "#D9AF6B",
    "#AF6458",
    "#736F4C",
    "#526A83",
    "#625377",
    "#68855C",
    "#9C9C5E",
    "#A06177",
    "#8C785D",
    "#7C7C7C"
  ],
  11: [
    "#855C75",
    "#D9AF6B",
    "#AF6458",
    "#736F4C",
    "#526A83",
    "#625377",
    "#68855C",
    "#9C9C5E",
    "#A06177",
    "#8C785D",
    "#467378",
    "#7C7C7C"
  ],
  tags: ["qualitative"]
}, n_e = {
  2: ["#7F3C8D", "#11A579", "#A5AA99"],
  3: ["#7F3C8D", "#11A579", "#3969AC", "#A5AA99"],
  4: ["#7F3C8D", "#11A579", "#3969AC", "#F2B701", "#A5AA99"],
  5: ["#7F3C8D", "#11A579", "#3969AC", "#F2B701", "#E73F74", "#A5AA99"],
  6: [
    "#7F3C8D",
    "#11A579",
    "#3969AC",
    "#F2B701",
    "#E73F74",
    "#80BA5A",
    "#A5AA99"
  ],
  7: [
    "#7F3C8D",
    "#11A579",
    "#3969AC",
    "#F2B701",
    "#E73F74",
    "#80BA5A",
    "#E68310",
    "#A5AA99"
  ],
  8: [
    "#7F3C8D",
    "#11A579",
    "#3969AC",
    "#F2B701",
    "#E73F74",
    "#80BA5A",
    "#E68310",
    "#008695",
    "#A5AA99"
  ],
  9: [
    "#7F3C8D",
    "#11A579",
    "#3969AC",
    "#F2B701",
    "#E73F74",
    "#80BA5A",
    "#E68310",
    "#008695",
    "#CF1C90",
    "#A5AA99"
  ],
  10: [
    "#7F3C8D",
    "#11A579",
    "#3969AC",
    "#F2B701",
    "#E73F74",
    "#80BA5A",
    "#E68310",
    "#008695",
    "#CF1C90",
    "#f97b72",
    "#A5AA99"
  ],
  11: [
    "#7F3C8D",
    "#11A579",
    "#3969AC",
    "#F2B701",
    "#E73F74",
    "#80BA5A",
    "#E68310",
    "#008695",
    "#CF1C90",
    "#f97b72",
    "#4b4b8f",
    "#A5AA99"
  ],
  tags: ["qualitative"]
}, i_e = {
  2: ["#66C5CC", "#F6CF71", "#B3B3B3"],
  3: ["#66C5CC", "#F6CF71", "#F89C74", "#B3B3B3"],
  4: ["#66C5CC", "#F6CF71", "#F89C74", "#DCB0F2", "#B3B3B3"],
  5: ["#66C5CC", "#F6CF71", "#F89C74", "#DCB0F2", "#87C55F", "#B3B3B3"],
  6: [
    "#66C5CC",
    "#F6CF71",
    "#F89C74",
    "#DCB0F2",
    "#87C55F",
    "#9EB9F3",
    "#B3B3B3"
  ],
  7: [
    "#66C5CC",
    "#F6CF71",
    "#F89C74",
    "#DCB0F2",
    "#87C55F",
    "#9EB9F3",
    "#FE88B1",
    "#B3B3B3"
  ],
  8: [
    "#66C5CC",
    "#F6CF71",
    "#F89C74",
    "#DCB0F2",
    "#87C55F",
    "#9EB9F3",
    "#FE88B1",
    "#C9DB74",
    "#B3B3B3"
  ],
  9: [
    "#66C5CC",
    "#F6CF71",
    "#F89C74",
    "#DCB0F2",
    "#87C55F",
    "#9EB9F3",
    "#FE88B1",
    "#C9DB74",
    "#8BE0A4",
    "#B3B3B3"
  ],
  10: [
    "#66C5CC",
    "#F6CF71",
    "#F89C74",
    "#DCB0F2",
    "#87C55F",
    "#9EB9F3",
    "#FE88B1",
    "#C9DB74",
    "#8BE0A4",
    "#B497E7",
    "#B3B3B3"
  ],
  11: [
    "#66C5CC",
    "#F6CF71",
    "#F89C74",
    "#DCB0F2",
    "#87C55F",
    "#9EB9F3",
    "#FE88B1",
    "#C9DB74",
    "#8BE0A4",
    "#B497E7",
    "#D3B484",
    "#B3B3B3"
  ],
  tags: ["qualitative"]
}, s_e = {
  2: ["#5F4690", "#1D6996", "#666666"],
  3: ["#5F4690", "#1D6996", "#38A6A5", "#666666"],
  4: ["#5F4690", "#1D6996", "#38A6A5", "#0F8554", "#666666"],
  5: ["#5F4690", "#1D6996", "#38A6A5", "#0F8554", "#73AF48", "#666666"],
  6: [
    "#5F4690",
    "#1D6996",
    "#38A6A5",
    "#0F8554",
    "#73AF48",
    "#EDAD08",
    "#666666"
  ],
  7: [
    "#5F4690",
    "#1D6996",
    "#38A6A5",
    "#0F8554",
    "#73AF48",
    "#EDAD08",
    "#E17C05",
    "#666666"
  ],
  8: [
    "#5F4690",
    "#1D6996",
    "#38A6A5",
    "#0F8554",
    "#73AF48",
    "#EDAD08",
    "#E17C05",
    "#CC503E",
    "#666666"
  ],
  9: [
    "#5F4690",
    "#1D6996",
    "#38A6A5",
    "#0F8554",
    "#73AF48",
    "#EDAD08",
    "#E17C05",
    "#CC503E",
    "#94346E",
    "#666666"
  ],
  10: [
    "#5F4690",
    "#1D6996",
    "#38A6A5",
    "#0F8554",
    "#73AF48",
    "#EDAD08",
    "#E17C05",
    "#CC503E",
    "#94346E",
    "#6F4070",
    "#666666"
  ],
  11: [
    "#5F4690",
    "#1D6996",
    "#38A6A5",
    "#0F8554",
    "#73AF48",
    "#EDAD08",
    "#E17C05",
    "#CC503E",
    "#94346E",
    "#6F4070",
    "#994E95",
    "#666666"
  ],
  tags: ["qualitative"]
}, o_e = {
  2: ["#88CCEE", "#CC6677", "#888888"],
  3: ["#88CCEE", "#CC6677", "#DDCC77", "#888888"],
  4: ["#88CCEE", "#CC6677", "#DDCC77", "#117733", "#888888"],
  5: ["#88CCEE", "#CC6677", "#DDCC77", "#117733", "#332288", "#888888"],
  6: [
    "#88CCEE",
    "#CC6677",
    "#DDCC77",
    "#117733",
    "#332288",
    "#AA4499",
    "#888888"
  ],
  7: [
    "#88CCEE",
    "#CC6677",
    "#DDCC77",
    "#117733",
    "#332288",
    "#AA4499",
    "#44AA99",
    "#888888"
  ],
  8: [
    "#88CCEE",
    "#CC6677",
    "#DDCC77",
    "#117733",
    "#332288",
    "#AA4499",
    "#44AA99",
    "#999933",
    "#888888"
  ],
  9: [
    "#88CCEE",
    "#CC6677",
    "#DDCC77",
    "#117733",
    "#332288",
    "#AA4499",
    "#44AA99",
    "#999933",
    "#882255",
    "#888888"
  ],
  10: [
    "#88CCEE",
    "#CC6677",
    "#DDCC77",
    "#117733",
    "#332288",
    "#AA4499",
    "#44AA99",
    "#999933",
    "#882255",
    "#661100",
    "#888888"
  ],
  11: [
    "#88CCEE",
    "#CC6677",
    "#DDCC77",
    "#117733",
    "#332288",
    "#AA4499",
    "#44AA99",
    "#999933",
    "#882255",
    "#661100",
    "#6699CC",
    "#888888"
  ],
  tags: ["qualitative", "colorblind"]
}, a_e = {
  2: ["#E58606", "#5D69B1", "#A5AA99"],
  3: ["#E58606", "#5D69B1", "#52BCA3", "#A5AA99"],
  4: ["#E58606", "#5D69B1", "#52BCA3", "#99C945", "#A5AA99"],
  5: ["#E58606", "#5D69B1", "#52BCA3", "#99C945", "#CC61B0", "#A5AA99"],
  6: [
    "#E58606",
    "#5D69B1",
    "#52BCA3",
    "#99C945",
    "#CC61B0",
    "#24796C",
    "#A5AA99"
  ],
  7: [
    "#E58606",
    "#5D69B1",
    "#52BCA3",
    "#99C945",
    "#CC61B0",
    "#24796C",
    "#DAA51B",
    "#A5AA99"
  ],
  8: [
    "#E58606",
    "#5D69B1",
    "#52BCA3",
    "#99C945",
    "#CC61B0",
    "#24796C",
    "#DAA51B",
    "#2F8AC4",
    "#A5AA99"
  ],
  9: [
    "#E58606",
    "#5D69B1",
    "#52BCA3",
    "#99C945",
    "#CC61B0",
    "#24796C",
    "#DAA51B",
    "#2F8AC4",
    "#764E9F",
    "#A5AA99"
  ],
  10: [
    "#E58606",
    "#5D69B1",
    "#52BCA3",
    "#99C945",
    "#CC61B0",
    "#24796C",
    "#DAA51B",
    "#2F8AC4",
    "#764E9F",
    "#ED645A",
    "#A5AA99"
  ],
  11: [
    "#E58606",
    "#5D69B1",
    "#52BCA3",
    "#99C945",
    "#CC61B0",
    "#24796C",
    "#DAA51B",
    "#2F8AC4",
    "#764E9F",
    "#ED645A",
    "#CC3A8E",
    "#A5AA99"
  ],
  tags: ["qualitative"]
}, l_e = { ...kn.BuGn, tags: ["quantitative"] }, c_e = { ...kn.BuPu, tags: ["quantitative"] }, u_e = { ...kn.GnBu, tags: ["quantitative"] }, f_e = { ...kn.OrRd, tags: ["quantitative"] }, h_e = { ...kn.PuBu, tags: ["quantitative"] }, d_e = { ...kn.PuBuGn, tags: ["quantitative"] }, p_e = { ...kn.PuRd, tags: ["quantitative"] }, A_e = { ...kn.RdPu, tags: ["quantitative"] }, g_e = { ...kn.YlGn, tags: ["quantitative"] }, m_e = { ...kn.YlGnBu, tags: ["quantitative"] }, __e = { ...kn.YlOrBr, tags: ["quantitative"] }, y_e = { ...kn.YlOrRd, tags: ["quantitative"] }, v_e = { ...kn.Accent, tags: ["qualitative"] }, b_e = { ...kn.Dark2, tags: ["qualitative"] }, x_e = { ...kn.Paired, tags: ["qualitative"] }, w_e = { ...kn.Pastel1, tags: ["qualitative"] }, T_e = { ...kn.Pastel2, tags: ["qualitative"] }, E_e = { ...kn.Set1, tags: ["qualitative"] }, C_e = { ...kn.Set2, tags: ["qualitative"] }, S_e = { ...kn.Set3, tags: ["qualitative"] }, I_e = { ...kn.Blues, tags: ["quantitative"] }, P_e = { ...kn.Greens, tags: ["quantitative"] }, M_e = { ...kn.Greys, tags: ["quantitative"] }, R_e = { ...kn.Oranges, tags: ["quantitative"] }, B_e = { ...kn.Purples, tags: ["quantitative"] }, O_e = { ...kn.Reds, tags: ["quantitative"] }, D_e = { ...kn.BrBG, tags: ["diverging"] }, L_e = { ...kn.PiYG, tags: ["diverging"] }, k_e = { ...kn.PRGn, tags: ["diverging"] }, F_e = { ...kn.PuOr, tags: ["diverging"] }, N_e = { ...kn.RdBu, tags: ["diverging"] }, U_e = { ...kn.RdGy, tags: ["diverging"] }, z_e = { ...kn.RdYlBu, tags: ["diverging"] }, V_e = { ...kn.RdYlGn, tags: ["diverging"] }, j_e = { ...kn.Spectral, tags: ["diverging"] };
const H_e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Antique: r_e,
  ArmyRose: Zme,
  BluGrn: Lme,
  BluYl: Ume,
  Bold: n_e,
  BrwnYl: Xme,
  Burg: Ime,
  BurgYl: Pme,
  DarkMint: kme,
  Earth: t_e,
  Emrld: Fme,
  Fall: Yme,
  Geyser: Kme,
  Magenta: Wme,
  Mint: Dme,
  OrYel: Rme,
  Pastel: i_e,
  Peach: Bme,
  PinkYl: Ome,
  Prism: s_e,
  Purp: jme,
  PurpOr: Hme,
  RedOr: Mme,
  Safe: o_e,
  Sunset: Gme,
  SunsetDark: $me,
  Teal: zme,
  TealGrn: Vme,
  TealRose: Jme,
  Temps: Qme,
  Tropic: e_e,
  Vivid: a_e,
  ag_GrnYl: Nme,
  ag_Sunset: qme,
  cb_Accent: v_e,
  cb_Blues: I_e,
  cb_BrBG: D_e,
  cb_BuGn: l_e,
  cb_BuPu: c_e,
  cb_Dark2: b_e,
  cb_GnBu: u_e,
  cb_Greens: P_e,
  cb_Greys: M_e,
  cb_OrRd: f_e,
  cb_Oranges: R_e,
  cb_PRGn: k_e,
  cb_Paired: x_e,
  cb_Pastel1: w_e,
  cb_Pastel2: T_e,
  cb_PiYG: L_e,
  cb_PuBu: h_e,
  cb_PuBuGn: d_e,
  cb_PuOr: F_e,
  cb_PuRd: p_e,
  cb_Purples: B_e,
  cb_RdBu: N_e,
  cb_RdGy: U_e,
  cb_RdPu: A_e,
  cb_RdYlBu: z_e,
  cb_RdYlGn: V_e,
  cb_Reds: O_e,
  cb_Set1: E_e,
  cb_Set2: C_e,
  cb_Set3: S_e,
  cb_Spectral: j_e,
  cb_YlGn: g_e,
  cb_YlGnBu: m_e,
  cb_YlOrBr: __e,
  cb_YlOrRd: y_e
}, Symbol.toStringTag, { value: "Module" })), LT = "PurpOr", kT = [204, 204, 204], G_e = [119, 119, 119];
function FT(r, e) {
  const t = H_e[r];
  let n = e;
  fh(t, `Palette "${r}" not found. Expected a CARTOColors string`);
  const i = Object.keys(t).filter((u) => u !== "tags").map(Number), s = Math.max(...i), o = Math.min(...i);
  !Number.isInteger(e) || e > s ? n = s : e < o && (n = o);
  let l = t[n];
  return t.tags && t.tags.includes("qualitative") && (l = l.slice(0, -1)), l.map((u) => W_e(u));
}
function W_e(r) {
  let e = /^#?([a-f\d]{1})([a-f\d]{1})([a-f\d]{1})$/i.exec(r);
  return e ? [
    parseInt(e[1] + e[1], 16),
    parseInt(e[2] + e[2], 16),
    parseInt(e[3] + e[3], 16),
    255
  ] : (e = /^#?([a-f\d]{1})([a-f\d]{1})([a-f\d]{1})([a-f\d]{1})$/i.exec(r), e ? [
    parseInt(e[1] + e[1], 16),
    parseInt(e[2] + e[2], 16),
    parseInt(e[3] + e[3], 16),
    parseInt(e[4] + e[4], 16)
  ] : (e = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(r), e ? [parseInt(e[1], 16), parseInt(e[2], 16), parseInt(e[3], 16), 255] : (e = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(r), fh(e, `Hexadecimal color "${r}" was not parsed correctly`), [
    parseInt(e[1], 16),
    parseInt(e[2], 16),
    parseInt(e[3], 16),
    parseInt(e[4], 16)
  ])));
}
const $_e = Object.freeze(["function", "string"]);
function NT(r, e, t) {
  return fh(typeof e == "object", 'Expected "data" to be an object'), fh($_e.includes(typeof r), 'Expected "attr" to be a function or string'), typeof r == "function" ? r(e, t) : e?.properties?.[r];
}
function q_e({ attr: r, domain: e, colors: t = LT, nullColor: n = kT }) {
  fh(Array.isArray(e), 'Expected "domain" to be an array of numbers');
  const i = typeof t == "string" ? FT(t, e.length + 1) : t, s = IN().domain(e).range(i);
  return (o, l) => {
    const u = NT(r, o, l);
    return typeof u == "number" && Number.isFinite(u) ? s(u) : n;
  };
}
function X_e({ attr: r, domain: e, colors: t = LT, nullColor: n = kT, othersColor: i = G_e }) {
  fh(Array.isArray(e), 'Expected "domain" to be an array of numbers or strings');
  const s = {}, o = typeof t == "string" ? FT(t, e.length) : t;
  for (const [l, u] of e.entries())
    s[u] = o[l];
  return (l, u) => {
    const m = NT(r, l, u);
    return typeof m == "number" && Number.isFinite(m) || typeof m == "string" ? s[m] || i : n;
  };
}
function Z_e({ attr: r, domain: e, colors: t = LT, nullColor: n = kT }) {
  fh(Array.isArray(e), 'Expected "domain" to be an array of numbers');
  const i = typeof t == "string" ? FT(t, e.length) : t, s = PN().domain(e).range(i);
  return (o, l) => {
    const u = NT(r, o, l);
    return typeof u == "number" && Number.isFinite(u) ? s(u) : n;
  };
}
const Y_e = {
  ClusterTileLayer: CT,
  H3TileLayer: Iy,
  HeatmapTileLayer: PT,
  PointLabelLayer: My,
  QuadbinTileLayer: Py,
  RasterTileLayer: BT,
  VectorTileLayer: DT
};
function W2(r, e = "") {
  if (!r)
    throw new Error(`JSON conversion error ${e}`);
}
function K_e(r, e) {
  const t = J_e(e);
  let n = r;
  for (const i of t)
    n = Q_e(n) ? n[i] : void 0;
  return n;
}
function Q_e(r) {
  return r !== null && typeof r == "object";
}
const N4 = {};
function J_e(r) {
  if (typeof r == "string") {
    let e = N4[r];
    return e || (e = r.split("."), N4[r] = e), e;
  }
  return Array.isArray(r) ? r : [r];
}
var Am = { exports: {} }, U4;
function eye() {
  return U4 || (U4 = 1, (function(r, e) {
    (function(t) {
      var n = "Compound", i = "Identifier", s = "MemberExpression", o = "Literal", l = "ThisExpression", u = "CallExpression", m = "UnaryExpression", y = "BinaryExpression", E = "LogicalExpression", P = "ConditionalExpression", L = "ArrayExpression", U = 46, V = 44, q = 39, j = 34, K = 40, Y = 41, de = 91, ne = 93, ae = 63, De = 59, Ge = 58, fe = function(Ot, dt) {
        var _r = new Error(Ot + " at character " + dt);
        throw _r.index = dt, _r.description = Ot, _r;
      }, ve = !0, me = { "-": ve, "!": ve, "~": ve, "+": ve }, X = {
        "||": 1,
        "&&": 2,
        "|": 3,
        "^": 4,
        "&": 5,
        "==": 6,
        "!=": 6,
        "===": 6,
        "!==": 6,
        "<": 7,
        ">": 7,
        "<=": 7,
        ">=": 7,
        "<<": 8,
        ">>": 8,
        ">>>": 8,
        "+": 9,
        "-": 9,
        "*": 10,
        "/": 10,
        "%": 10
      }, re = function(Ot) {
        var dt = 0, _r;
        for (var sr in Ot)
          (_r = sr.length) > dt && Ot.hasOwnProperty(sr) && (dt = _r);
        return dt;
      }, Me = re(me), ot = re(X), be = {
        true: !0,
        false: !1,
        null: null
      }, Ue = "this", Xe = function(Ot) {
        return X[Ot] || 0;
      }, lt = function(Ot, dt, _r) {
        var sr = Ot === "||" || Ot === "&&" ? E : y;
        return {
          type: sr,
          operator: Ot,
          left: dt,
          right: _r
        };
      }, at = function(Ot) {
        return Ot >= 48 && Ot <= 57;
      }, ct = function(Ot) {
        return Ot === 36 || Ot === 95 || // `$` and `_`
        Ot >= 65 && Ot <= 90 || // A...Z
        Ot >= 97 && Ot <= 122 || // a...z
        Ot >= 128 && !X[String.fromCharCode(Ot)];
      }, gt = function(Ot) {
        return Ot === 36 || Ot === 95 || // `$` and `_`
        Ot >= 65 && Ot <= 90 || // A...Z
        Ot >= 97 && Ot <= 122 || // a...z
        Ot >= 48 && Ot <= 57 || // 0...9
        Ot >= 128 && !X[String.fromCharCode(Ot)];
      }, St = function(Ot) {
        for (var dt = 0, _r = Ot.charAt, sr = Ot.charCodeAt, tr = function(Zt) {
          return _r.call(Ot, Zt);
        }, Wt = function(Zt) {
          return sr.call(Ot, Zt);
        }, yr = Ot.length, An = function() {
          for (var Zt = Wt(dt); Zt === 32 || Zt === 9 || Zt === 10 || Zt === 13; )
            Zt = Wt(++dt);
        }, Fr = function() {
          var Zt = $n(), br, Nr;
          if (An(), Wt(dt) === ae) {
            if (dt++, br = Fr(), br || fe("Expected expression", dt), An(), Wt(dt) === Ge)
              return dt++, Nr = Fr(), Nr || fe("Expected expression", dt), {
                type: P,
                test: Zt,
                consequent: br,
                alternate: Nr
              };
            fe("Expected :", dt);
          } else
            return Zt;
        }, Pr = function() {
          An();
          for (var Zt = Ot.substr(dt, ot), br = Zt.length; br > 0; ) {
            if (X.hasOwnProperty(Zt) && (!ct(Wt(dt)) || dt + Zt.length < Ot.length && !gt(Wt(dt + Zt.length))))
              return dt += br, Zt;
            Zt = Zt.substr(0, --br);
          }
          return !1;
        }, $n = function() {
          var Zt, br, Nr, on, pi, Le, Gt, Jt, pr;
          if (Le = xr(), br = Pr(), !br)
            return Le;
          for (pi = { value: br, prec: Xe(br) }, Gt = xr(), Gt || fe("Expected expression after " + br, dt), on = [Le, pi, Gt]; (br = Pr()) && (Nr = Xe(br), Nr !== 0); ) {
            for (pi = { value: br, prec: Nr }, pr = br; on.length > 2 && Nr <= on[on.length - 2].prec; )
              Gt = on.pop(), br = on.pop().value, Le = on.pop(), Zt = lt(br, Le, Gt), on.push(Zt);
            Zt = xr(), Zt || fe("Expected expression after " + pr, dt), on.push(pi, Zt);
          }
          for (Jt = on.length - 1, Zt = on[Jt]; Jt > 1; )
            Zt = lt(on[Jt - 1].value, on[Jt - 2], Zt), Jt -= 2;
          return Zt;
        }, xr = function() {
          var Zt, br, Nr;
          if (An(), Zt = Wt(dt), at(Zt) || Zt === U)
            return wr();
          if (Zt === q || Zt === j)
            return gn();
          if (Zt === de)
            return ii();
          for (br = Ot.substr(dt, Me), Nr = br.length; Nr > 0; ) {
            if (me.hasOwnProperty(br) && (!ct(Wt(dt)) || dt + br.length < Ot.length && !gt(Wt(dt + br.length))))
              return dt += Nr, {
                type: m,
                operator: br,
                argument: xr(),
                prefix: !0
              };
            br = br.substr(0, --Nr);
          }
          return ct(Zt) || Zt === K ? Jn() : !1;
        }, wr = function() {
          for (var Zt = "", br, Nr; at(Wt(dt)); )
            Zt += tr(dt++);
          if (Wt(dt) === U)
            for (Zt += tr(dt++); at(Wt(dt)); )
              Zt += tr(dt++);
          if (br = tr(dt), br === "e" || br === "E") {
            for (Zt += tr(dt++), br = tr(dt), (br === "+" || br === "-") && (Zt += tr(dt++)); at(Wt(dt)); )
              Zt += tr(dt++);
            at(Wt(dt - 1)) || fe("Expected exponent (" + Zt + tr(dt) + ")", dt);
          }
          return Nr = Wt(dt), ct(Nr) ? fe("Variable names cannot start with a number (" + Zt + tr(dt) + ")", dt) : Nr === U && fe("Unexpected period", dt), {
            type: o,
            value: parseFloat(Zt),
            raw: Zt
          };
        }, gn = function() {
          for (var Zt = "", br = tr(dt++), Nr = !1, on; dt < yr; )
            if (on = tr(dt++), on === br) {
              Nr = !0;
              break;
            } else if (on === "\\")
              switch (on = tr(dt++), on) {
                case "n":
                  Zt += `
`;
                  break;
                case "r":
                  Zt += "\r";
                  break;
                case "t":
                  Zt += "	";
                  break;
                case "b":
                  Zt += "\b";
                  break;
                case "f":
                  Zt += "\f";
                  break;
                case "v":
                  Zt += "\v";
                  break;
                default:
                  Zt += on;
              }
            else
              Zt += on;
          return Nr || fe('Unclosed quote after "' + Zt + '"', dt), {
            type: o,
            value: Zt,
            raw: br + Zt + br
          };
        }, zr = function() {
          var Zt = Wt(dt), br = dt, Nr;
          for (ct(Zt) ? dt++ : fe("Unexpected " + tr(dt), dt); dt < yr && (Zt = Wt(dt), gt(Zt)); )
            dt++;
          return Nr = Ot.slice(br, dt), be.hasOwnProperty(Nr) ? {
            type: o,
            value: be[Nr],
            raw: Nr
          } : Nr === Ue ? { type: l } : {
            type: i,
            name: Nr
          };
        }, ci = function(Zt) {
          for (var br, Nr = [], on, pi = !1, Le = 0; dt < yr; )
            if (An(), br = Wt(dt), br === Zt) {
              pi = !0, dt++, Zt === Y && Le && Le >= Nr.length && fe("Unexpected token " + String.fromCharCode(Zt), dt);
              break;
            } else if (br === V) {
              if (dt++, Le++, Le !== Nr.length) {
                if (Zt === Y)
                  fe("Unexpected token ,", dt);
                else if (Zt === ne)
                  for (var Gt = Nr.length; Gt < Le; Gt++)
                    Nr.push(null);
              }
            } else
              on = Fr(), (!on || on.type === n) && fe("Expected comma", dt), Nr.push(on);
          return pi || fe("Expected " + String.fromCharCode(Zt), dt), Nr;
        }, Jn = function() {
          var Zt, br;
          for (Zt = Wt(dt), Zt === K ? br = wn() : br = zr(), An(), Zt = Wt(dt); Zt === U || Zt === de || Zt === K; )
            dt++, Zt === U ? (An(), br = {
              type: s,
              computed: !1,
              object: br,
              property: zr()
            }) : Zt === de ? (br = {
              type: s,
              computed: !0,
              object: br,
              property: Fr()
            }, An(), Zt = Wt(dt), Zt !== ne && fe("Unclosed [", dt), dt++) : Zt === K && (br = {
              type: u,
              arguments: ci(Y),
              callee: br
            }), An(), Zt = Wt(dt);
          return br;
        }, wn = function() {
          dt++;
          var Zt = Fr();
          if (An(), Wt(dt) === Y)
            return dt++, Zt;
          fe("Unclosed (", dt);
        }, ii = function() {
          return dt++, {
            type: L,
            elements: ci(ne)
          };
        }, qn = [], Rn, ei; dt < yr; )
          Rn = Wt(dt), Rn === De || Rn === V ? dt++ : (ei = Fr()) ? qn.push(ei) : dt < yr && fe('Unexpected "' + tr(dt) + '"', dt);
        return qn.length === 1 ? qn[0] : {
          type: n,
          body: qn
        };
      };
      St.version = "0.3.5", St.toString = function() {
        return "JavaScript Expression Parser (JSEP) v" + St.version;
      }, St.addUnaryOp = function(Ot) {
        return Me = Math.max(Ot.length, Me), me[Ot] = ve, this;
      }, St.addBinaryOp = function(Ot, dt) {
        return ot = Math.max(Ot.length, ot), X[Ot] = dt, this;
      }, St.addLiteral = function(Ot, dt) {
        return be[Ot] = dt, this;
      }, St.removeUnaryOp = function(Ot) {
        return delete me[Ot], Ot.length === Me && (Me = re(me)), this;
      }, St.removeAllUnaryOps = function() {
        return me = {}, Me = 0, this;
      }, St.removeBinaryOp = function(Ot) {
        return delete X[Ot], Ot.length === ot && (ot = re(X)), this;
      }, St.removeAllBinaryOps = function() {
        return X = {}, ot = 0, this;
      }, St.removeLiteral = function(Ot) {
        return delete be[Ot], this;
      }, St.removeAllLiterals = function() {
        return be = {}, this;
      }, r.exports ? e = r.exports = St : e.parse = St;
    })();
  })(Am, Am.exports)), Am.exports;
}
var tye = eye();
const rye = /* @__PURE__ */ dh(tye), z4 = {
  "||": (r, e) => r || e,
  "&&": (r, e) => r && e,
  "|": (r, e) => r | e,
  "^": (r, e) => r ^ e,
  "&": (r, e) => r & e,
  "==": (r, e) => r == e,
  "!=": (r, e) => r != e,
  "===": (r, e) => r === e,
  "!==": (r, e) => r !== e,
  "<": (r, e) => r < e,
  ">": (r, e) => r > e,
  "<=": (r, e) => r <= e,
  ">=": (r, e) => r >= e,
  "<<": (r, e) => r << e,
  ">>": (r, e) => r >> e,
  ">>>": (r, e) => r >>> e,
  "+": (r, e) => r + e,
  "-": (r, e) => r - e,
  "*": (r, e) => r * e,
  "/": (r, e) => r / e,
  "%": (r, e) => r % e
}, nye = {
  "-": (r) => -r,
  "+": (r) => +r,
  "~": (r) => ~r,
  "!": (r) => !r
};
function V4(r, e) {
  return r.map(function(t) {
    return eo(t, e);
  });
}
function j4(r, e) {
  const t = eo(r.object, e);
  let n;
  if (r.computed ? n = eo(r.property, e) : n = r.property.name, /^__proto__|prototype|constructor$/.test(n))
    throw Error(`Access to member "${n}" disallowed.`);
  return [t, t[n]];
}
function eo(r, e) {
  const t = r;
  switch (t.type) {
    case "ArrayExpression":
      return V4(t.elements, e);
    case "BinaryExpression":
      return z4[t.operator](eo(t.left, e), eo(t.right, e));
    case "CallExpression":
      let n, i, s;
      return t.callee.type === "MemberExpression" ? (s = j4(t.callee, e), n = s[0], i = s[1]) : i = eo(t.callee, e), typeof i != "function" ? void 0 : i.apply(n, V4(t.arguments, e));
    case "ConditionalExpression":
      return eo(t.test, e) ? eo(t.consequent, e) : eo(t.alternate, e);
    case "Identifier":
      return e[t.name];
    case "Literal":
      return t.value;
    case "LogicalExpression":
      return t.operator === "||" ? eo(t.left, e) || eo(t.right, e) : t.operator === "&&" ? eo(t.left, e) && eo(t.right, e) : z4[t.operator](eo(t.left, e), eo(t.right, e));
    case "MemberExpression":
      return j4(t, e)[1];
    case "ThisExpression":
      return e;
    case "UnaryExpression":
      return nye[t.operator](eo(t.argument, e));
    default:
      return;
  }
}
const Ab = {
  "-": (r) => r
};
function GF(r, e) {
  if (r in Ab)
    return Ab[r];
  let t;
  const n = rye(r);
  return n.type === "Identifier" ? t = (i) => K_e(i, r) : ($2(n, (i) => {
    if (i.type === "CallExpression")
      throw new Error("Function calls not allowed in JSON expressions");
  }), t = (i) => eo(n, i)), Ab[r] = t, t;
}
function $2(r, e) {
  if (Array.isArray(r))
    r.forEach((t) => $2(t, e));
  else if (r && typeof r == "object") {
    r.type && e(r);
    for (const t in r)
      $2(r[t], e);
  }
}
const P_ = "@@=", H4 = "@@#", iye = "@@type", WF = "@@function", G4 = (r) => r && typeof r == "object";
class q2 {
  constructor(...e) {
    this.typeKey = iye, this.functionKey = WF, this.log = console, this.classes = {}, this.reactComponents = {}, this.enumerations = {}, this.constants = {}, this.functions = {}, this.React = null, this.convertFunction = GF, this.preProcessClassProps = (t, n) => n, this.postProcessConvertedJson = (t) => t;
    for (const t of e)
      this.merge(t);
  }
  merge(e) {
    for (const t in e)
      switch (t) {
        // DEPRECATED = For backwards compatibility, add views and layers to classes;
        case "layers":
        case "views":
          Object.assign(this.classes, e[t]);
          break;
        default:
          if (t in this) {
            const n = e[t];
            this[t] = G4(this[t]) ? Object.assign(this[t], n) : n;
          }
      }
  }
  validate(e) {
    return W2(!this.typeKey || typeof this.typeKey == "string"), W2(G4(this.classes)), !0;
  }
}
function sye(r) {
  return typeof r == "string" && r.startsWith(P_);
}
function oye(r) {
  return r.replace(P_, "");
}
function $F(r, e) {
  const t = {};
  for (const n in r) {
    let i = r[n];
    sye(i) && (i = oye(i), i = GF(i)), t[n] = i;
  }
  return t;
}
function aye(r, e, t) {
  const n = t.classes[r], i = t.reactComponents[r];
  if (!n && !i) {
    const { log: s } = t;
    if (s) {
      const o = JSON.stringify(e, null, 0).slice(0, 40);
      s.warn(`JSON converter: No registered class of type ${r}(${o}...)  `);
    }
    return null;
  }
  return n ? lye(n, e, t) : cye(i, e, t);
}
function lye(r, e, t) {
  return t.preProcessClassProps && (e = t.preProcessClassProps(r, e, t)), e = $F(e), new r(e);
}
function cye(r, e, t) {
  const { React: n } = t, { children: i = [] } = e;
  return delete e.children, t.preProcessClassProps && (e = t.preProcessClassProps(r, e, t)), e = $F(e), n.createElement(r, e, i);
}
function uye(r, e, t) {
  const n = t.functions[r];
  if (!n) {
    const { log: i } = t;
    if (i) {
      const s = JSON.stringify(e, null, 0).slice(0, 40);
      i.warn(`JSON converter: No registered function ${r}(${s}...)  `);
    }
    return null;
  }
  return n(e);
}
function fye(r) {
  return typeof r == "string" ? JSON.parse(r) : r;
}
const UT = (r) => r && typeof r == "object";
class hye {
  constructor(e) {
    this.log = console, this.onJSONChange = () => {
    }, this.json = null, this.convertedJson = null, this.setProps(e);
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  finalize() {
  }
  setProps(e) {
    "configuration" in e && (this.configuration = e.configuration instanceof q2 ? e.configuration : new q2(e.configuration)), "onJSONChange" in e && (this.onJSONChange = e.onJSONChange);
  }
  mergeConfiguration(e) {
    this.configuration.merge(e);
  }
  convert(e) {
    if (!e || e === this.json)
      return this.convertedJson;
    this.json = e;
    const t = fye(e);
    let n = dye(t, this.configuration);
    return n = this.configuration.postProcessConvertedJson(n), this.convertedJson = n, n;
  }
  // DEPRECATED: Backwards compatibility
  convertJson(e) {
    return this.convert(e);
  }
}
function dye(r, e) {
  return e = new q2(e), zT(r, "", e);
}
function zT(r, e, t) {
  return Array.isArray(r) ? r.map((n, i) => zT(n, String(i), t)) : pye(r, t) ? Aye(r, t) : UT(r) ? WF in r ? gye(r, t) : VT(r, t) : typeof r == "string" ? mye(r, e, t) : r;
}
function pye(r, e) {
  const { typeKey: t } = e;
  return UT(r) && !!r[t];
}
function Aye(r, e) {
  const { typeKey: t } = e, n = r[t];
  let i = { ...r };
  return delete i[t], i = VT(i, e), aye(n, i, e);
}
function gye(r, e) {
  const { functionKey: t } = e, n = r[t];
  let i = { ...r };
  return delete i[t], i = VT(i, e), uye(n, i, e);
}
function VT(r, e) {
  W2(UT(r));
  const t = {};
  for (const n in r) {
    const i = r[n];
    t[n] = zT(i, n, e);
  }
  return t;
}
function mye(r, e, t) {
  if (r.startsWith(P_) && t.convertFunction)
    return r = r.replace(P_, ""), t.convertFunction(r, t);
  if (r.startsWith(H4)) {
    if (r = r.replace(H4, ""), t.constants[r])
      return t.constants[r];
    const [n, i] = r.split(".");
    return t.enumerations[n][i];
  }
  return r;
}
const _ye = {
  classes: {
    ...lse,
    ...dge,
    ...VAe,
    ...ghe,
    ...Y_e
  },
  functions: {
    colorBins: q_e,
    colorCategories: X_e,
    colorContinuous: Z_e
  }
}, qF = new hye({
  configuration: _ye
}), yye = {
  [yy.layerName]: ["getFillColor"],
  [py.layerName]: ["getFillColor"],
  [pc.layerName]: ["getFillColor"],
  [Np.layerName]: ["getFillColor"],
  [uy.layerName]: ["getFillColor"],
  [cy.layerName]: ["getFillColor"],
  [dy.layerName]: ["getColor"],
  [x0.layerName]: ["getTargetColor", "getSourceColor"],
  [dc.layerName]: ["getFillColor"],
  [iu.layerName]: ["getFillColor"],
  [Fp.layerName]: ["getColor"],
  [Q_.layerName]: ["getColor"],
  [nf.layerName]: ["getColor"],
  [w0.layerName]: ["getColor"],
  [of.layerName]: ["getFillColor"],
  [T0.layerName]: ["getFillColor", "getColor", "getLineColor"],
  [sf.layerName]: ["getFillColor"],
  [yh.layerName]: ["getColor"],
  [P0.layerName]: ["getColor"],
  [uh.layerName]: ["getColor"]
}, vye = ({
  object: r,
  objectInfo: e,
  originalFillFunction: t
}) => {
  const n = typeof t == "function" ? t(r, e) : t;
  if (Array.isArray(n))
    return [n[0] || 0, n[1] || 0, n[2] || 0, n[3] || 255];
  if (typeof n == "string" && n.startsWith("@@=")) {
    const i = qF.convert({
      originalColor: n
    }).originalColor(r);
    return [i[0] || 0, i[1] || 0, i[2] || 0, i[3] || 255];
  }
  return null;
}, W4 = ({
  isSelected: r,
  object: e,
  objectInfo: t,
  opacity: n,
  originalFillFunction: i
}) => {
  const s = vye({
    object: e,
    objectInfo: t,
    originalFillFunction: i
  });
  if (!s)
    return null;
  let o = 0;
  return r ? o = Math.max(typeof s[3] == "number" ? s[3] : n, n) : o = Math.min(typeof s[3] == "number" ? s[3] : n, n), [s[0] || 0, s[1] || 0, s[2] || 0, o];
}, bye = ({
  isSelected: r,
  object: e,
  objectInfo: t,
  originalFillFunction: n,
  selectedColor: i,
  selectedOpacity: s = 255,
  unselectedColor: o,
  unselectedOpacity: l = Math.floor(255 * 0.4)
}) => r ? W4({
  opacity: s,
  isSelected: !0,
  object: e,
  objectInfo: t,
  originalFillFunction: n
}) || i : W4({
  opacity: l,
  isSelected: !1,
  object: e,
  objectInfo: t,
  originalFillFunction: n
}) || o, A0 = {
  selection: {
    indices: {},
    objects: {}
  }
}, $4 = (r, e) => {
  const t = e.match(/{(.*?)}/g);
  return t && t.forEach((n) => {
    const i = n.substring(1, n.length - 1);
    Object.hasOwn(r.object, i) ? e = e.replace(n, r.object[i]) : Object.hasOwn(r.object, "properties") && Object.hasOwn(r.object.properties, i) && (e = e.replace(n, r.object.properties[i]));
  }), e;
};
function xye(r, e) {
  return e.id ? r.getElementState(e.id, "selection") ?? A0 : A0;
}
function wye(r, e) {
  if (!e.id)
    return A0;
  const t = r.getStringValue(e);
  return (t ? mb.parse(t) : null) ?? A0;
}
function Tye(r, e, t, n) {
  r.id && e.setStringValue(r, JSON.stringify(t.value), {
    fromUi: t.fromUi
  }, n);
}
const Eye = (r) => {
  const {
    height: e,
    width: t,
    expanded: n
  } = Y4(K4), {
    element: i,
    fragmentId: s,
    isLightTheme: o,
    theme: l,
    widgetMgr: u
  } = r, {
    selectionMode: m,
    tooltip: y,
    useContainerWidth: E
  } = i, P = n ?? !1, [L, U] = NN({
    element: i,
    getDefaultState: xye,
    getStateFromWidgetMgr: wye,
    updateWidgetMgrState: Tye,
    widgetMgr: u,
    fragmentId: s
  }), [V, q] = Dt.useState(null), {
    height: j,
    width: K
  } = $re({
    element: i,
    isFullScreen: P,
    shouldUseContainerWidth: E,
    container: {
      height: e,
      width: t
    },
    heightFallback: V?.initialViewState?.height || l.sizes.defaultMapHeight
  }), [Y, de] = Dt.useState(null), ne = m[0], ae = ne !== void 0, De = ae && Object.keys(L.selection.indices).length > 0, Ge = Dt.useMemo(() => Object.freeze(mb.parse(i.json)), [P, o, i.json]), fe = Dt.useMemo(() => {
    const X = {
      ...Ge
    };
    if (X.mapStyle || (X.mapStyle = o ? "https://basemaps.cartocdn.com/gl/positron-gl-style/style.json" : "https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json"), (X?.mapProvider == "carto" || X?.mapStyle && X.mapStyle?.indexOf("cartocdn") >= 0) && !X.cartoKey && (X.cartoKey = "x7g2plm9yq8vfrc"), X.layers) {
      const Me = Object.values(L.selection.indices).some((be) => be?.length), ot = X.layers.some((be) => Object.hasOwn(be, "pickable"));
      X.layers = X.layers.map((be) => {
        if (!be || Array.isArray(be) || // If selection mode is not activated, do not make any additional changes to each layer
        !ae)
          return be;
        ot || (be.pickable = !0);
        const Ue = `${be.id || null}`, Xe = L?.selection?.indices?.[Ue] || [], lt = yye[be["@@type"]];
        if (!lt)
          return be;
        const at = {
          ...be
        };
        return lt.forEach((ct) => {
          at.updateTriggers = {
            // Tell Deck.gl to recompute the fill color when the selection changes.
            // Without this, objects in layers will have stale colors when selection changes.
            // @see https://deck.gl/docs/api-reference/core/layer#updatetriggers
            [ct]: [...at.updateTriggers?.[ct] || [], Xe, Me]
          };
          const gt = !Me, St = be[ct];
          if (gt || !St)
            return at;
          const Ot = 255, dt = Math.floor(255 * 0.4), _r = lE(l.colors.primary), sr = [_r[0], _r[1], _r[2], Ot], tr = lE(l.colors.gray20), Wt = [tr[0], tr[1], tr[2], dt], yr = (An, Fr) => bye({
            isSelected: Xe.includes(Fr.index),
            object: An,
            objectInfo: Fr,
            originalFillFunction: St,
            selectedColor: sr,
            unselectedColor: Wt,
            selectedOpacity: Ot,
            unselectedOpacity: dt
          });
          at[ct] = yr;
        }), at;
      });
    }
    return delete X?.views, qF.convert(X);
  }, [L.selection.indices, o, ae, Ge, l.colors.gray20, l.colors.primary]);
  Dt.useEffect(() => {
    if (!MN(fe.initialViewState, Y)) {
      const X = Object.keys(fe.initialViewState).reduce(
        // eslint-disable-next-line @typescript-eslint/no-explicit-any -- TODO: Replace 'any' with a more specific type.
        (re, Me) => fe.initialViewState[Me] === Y?.[Me] ? re : {
          ...re,
          // @ts-expect-error
          [Me]: fe.initialViewState[Me]
        },
        {}
      );
      q((re) => ({
        ...re,
        ...X
      })), de(fe.initialViewState);
    }
  }, [fe.initialViewState, Y, V]);
  const ve = Dt.useCallback((X) => {
    if (!X?.object || !y)
      return null;
    const re = mb.parse(y);
    return re.html ? re.html = $4(X, re.html) : re.text = $4(X, re.text), re;
  }, [y]), me = Dt.useCallback(({
    viewState: X
  }) => {
    q(X);
  }, [q]);
  return {
    createTooltip: ve,
    data: L,
    deck: fe,
    hasActiveSelection: De,
    height: j,
    isSelectionModeActivated: ae,
    onViewStateChange: me,
    selectionMode: ne,
    setSelection: U,
    viewState: V,
    width: K
  };
};
Op([rw, Tp]);
const gb = A0.selection, Cye = [], Sye = (r) => {
  const {
    disabled: e,
    disableFullscreenMode: t,
    element: n,
    fragmentId: i,
    widgetMgr: s
  } = r, {
    libConfig: o
  } = Dt.useContext(RN), l = BN(), {
    expanded: u,
    expand: m,
    collapse: y
  } = Y4(K4), {
    createTooltip: E,
    data: P,
    deck: L,
    hasActiveSelection: U,
    height: V,
    isSelectionModeActivated: q,
    onViewStateChange: j,
    selectionMode: K,
    setSelection: Y,
    viewState: de,
    width: ne
  } = Eye({
    element: n,
    fragmentId: i,
    isLightTheme: Z4(l),
    theme: l,
    widgetMgr: s
  }), ae = n.mapboxToken || o.mapboxToken, De = L.mapProvider == "mapbox" || L?.mapStyle && L.mapStyle?.indexOf("mapbox") >= 0, [Ge, fe] = Dt.useState(!1);
  Dt.useEffect(() => {
    fe(!0);
  }, []);
  const ve = Dt.useCallback((X) => {
    if (K === void 0)
      return;
    const {
      index: re,
      object: Me
    } = X, ot = `${X.layer?.id || null}`, be = P, Ue = re === -1, lt = (() => {
      if (Ue)
        return gb;
      switch (K) {
        case cE.SelectionMode.SINGLE_OBJECT:
          return be.selection.indices[ot]?.[0] === re ? gb : {
            indices: {
              [`${ot}`]: [re]
            },
            objects: {
              [`${ot}`]: [Me]
            }
          };
        case cE.SelectionMode.MULTI_OBJECT: {
          const at = new Map((be?.selection?.indices?.[ot] || []).map((gt, St) => [gt, be.selection?.objects?.[ot]?.[St]]));
          if (at.has(re) ? at.delete(re) : at.set(re, Me), at.size === 0) {
            const {
              [ot]: ct,
              ...gt
            } = be.selection.indices, {
              [ot]: St,
              ...Ot
            } = be.selection.objects;
            return {
              indices: gt,
              objects: Ot
            };
          }
          return {
            indices: {
              ...be.selection.indices,
              [`${ot}`]: Array.from(at.keys())
            },
            objects: {
              ...be.selection.objects,
              [`${ot}`]: Array.from(at.values())
            }
          };
        }
        default:
          throw ON(K), new Error("Invalid selection mode");
      }
    })();
    JSON.stringify(lt) !== JSON.stringify(be.selection) && Y({
      fromUi: !0,
      value: {
        selection: lt
      }
    });
  }, [K, P, Y]), me = Dt.useCallback(() => {
    Y({
      value: {
        selection: gb
      },
      fromUi: !0
    });
  }, [Y]);
  return /* @__PURE__ */ Jl.jsxs(NI, { className: "stDeckGlJsonChart", "data-testid": "stDeckGlJsonChart", height: V, children: [
    De ? /* @__PURE__ */ Jl.jsx(Gre, {}) : null,
    /* @__PURE__ */ Jl.jsx(kN, { isFullScreen: u, disableFullscreenMode: t, onExpand: m, onCollapse: y, target: NI, locked: U && !e ? !0 : void 0, children: U && !e && /* @__PURE__ */ Jl.jsx(FN, { label: "Clear selection", onClick: me, icon: DN }) }),
    de && /* @__PURE__ */ Jl.jsxs(
      iY,
      {
        viewState: de,
        onViewStateChange: j,
        height: V,
        width: ne,
        layers: Ge ? L.layers : Cye,
        getTooltip: E,
        ContextProvider: _h.Provider,
        controller: !0,
        onClick: q && !e ? ve : void 0,
        children: [
          /* @__PURE__ */ Jl.jsx(nu, { height: V, width: ne, mapStyle: L.mapStyle && (typeof L.mapStyle == "string" ? L.mapStyle : L.mapStyle[0]), mapboxApiAccessToken: ae }),
          /* @__PURE__ */ Jl.jsx(Wre, { children: /* @__PURE__ */ Jl.jsx(zre, { "data-testid": "stDeckGlJsonChartZoomButton", showCompass: !1 }) })
        ]
      }
    )
  ] });
}, Iye = LN(Sye), pve = Dt.memo(Iye);
export {
  pve as default
};
//# sourceMappingURL=index-Cgr30ms_.js.map
